<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>EPhone</title>
    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>
    <script src="cordova.js"></script>
    <script src="js/cordova-init.js"></script>
    <script src="js/export.js"></script>
    <script src="https://sdk.scdn.co/spotify-player.js"></script>
    <style>
        :root {
            --secondary-bg: #ffffff;
            --border-color: #e0e0e0;
            --text-primary: #1f1f1f;
            --text-secondary: #8a8a8a;
            --accent-color: #007bff;
        }

        html {
            height: 100%;
            overflow: hidden;
        }

        body {
            height: 100%;
            overflow: hidden;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-weight: normal;
            background-color: var(--secondary-bg);
            display: block;
            box-sizing: border-box;
        }

        /* Disable all tap feedback and highlights */
        /* Disable tap feedback and highlights */
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }

        /* Disable text selection only for UI elements */
        .header,
        .back-btn,
        .action-btn,
        .save-btn,
        .app-icon,
        .nav-item,
        button,
        .form-button,
        .chat-action-icon-btn,
        .call-action-btn,
        .control-btn,
        .transfer-actions button,
        .music-controls button {
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Disable text selection specifically for modal dialogs */
        .modal,
        .modal-content,
        .modal-header,
        .modal-body,
        .modal-footer,
        #custom-modal-overlay,
        #custom-modal,
        .custom-modal-header,
        .custom-modal-body,
        .custom-modal-footer,
        .custom-modal-body p,
        .custom-modal-body span,
        .custom-modal-body div,
        .modal-body p,
        .modal-body span,
        .modal-body div {
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Ensure text selection is enabled for content areas */
        .message-bubble .content,
        .chat-messages,
        #chat-messages,
        .list-item,
        .world-book-content,
        .qzone-post-content,
        .favorite-item-content,
        input,
        textarea,
        p,
        span,
        div {
            -webkit-user-select: text;
            -khtml-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        #phone-frame {
            width: 100%;
            height: 100%;
            padding: 0;
            background-color: transparent;
            border-radius: 0;
            box-shadow: none;
            position: relative;
        }

        .notch {
            display: none;
        }

        #phone-screen {
            width: 100%;
            height: 100%;
            background-color: transparent;
            border-radius: 0;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        #status-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            z-index: 10;
            font-size: 14px;
            box-sizing: border-box;
            pointer-events: none;
        }

        #status-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            z-index: 10;
            font-size: 14px;
            box-sizing: border-box;
            pointer-events: none;
        }

        #status-bar-time {
            font-weight: 600;
        }

        .battery-container {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .battery-icon {
            width: 25px;
            height: 12px;
            border: 1px solid white;
            border-radius: 3px;
            position: relative;
            padding: 1px;
        }

        .battery-icon::after {
            content: '';
            position: absolute;
            right: -3px;
            top: 2px;
            width: 2px;
            height: 6px;
            background-color: white;
            border-radius: 0 1px 1px 0;
        }

        .battery-level {
            height: 100%;
            background-color: white;
            border-radius: 1px;
            transition: width 0.5s ease;
        }

        .battery-container.charging .battery-level {
            background-color: #4cd964;
            animation: charge-breath 2s infinite;
        }

        .battery-container.charging .battery-text {
            color: #4cd964;
        }

        @keyframes charge-breath {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }
        }

        .screen {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .screen.active {
            opacity: 1;
            visibility: visible;
            z-index: 1;
        }

        .header {
            position: relative;
            z-index: 15;
            flex-shrink: 0;
            padding: 15px 12px;
            padding-top: 15px;
            background-color: rgba(247, 247, 247, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 18px;
            font-weight: 600;
        }

        .header .header-actions {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .header .back-btn,
        .header .action-btn {
            font-size: 24px;
            cursor: pointer;
            width: 30px;
            text-align: center;
            color: var(--accent-color);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header .action-btn {
            font-size: 16px;
            /* 专门为“上传”、“+”等文字按钮缩小字号 */
            font-weight: 600;
            /* 可以加粗一点让它更清晰 */
        }

        .header .action-btn img {
            height: 26px;
        }

        .header .save-btn {
            font-size: 16px;
            color: var(--accent-color);
            font-weight: 600;
            cursor: pointer;
        }

        #home-screen {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            padding: 20px;
            padding-top: 88px;
            padding-bottom: 50px;
            box-sizing: border-box;
            background-size: cover;
            background-position: center;
        }

        #clock-container {
            text-align: center;
            color: white;
            text-shadow: 0 3px 8px rgba(0, 0, 0, 0.4);
            margin-bottom: 20px;
            flex-shrink: 0;
        }

        #main-time {
            font-size: 80px;
            font-weight: 200;
        }

        #main-date {
            font-size: 18px;
            font-weight: 500;
        }

        #app-grid {
            margin-top: auto;
            margin-bottom: -24px;
            /* Move 24px closer to bottom edge */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
            padding: 20px;
        }

        .app-row {
            display: flex;
            justify-content: center;
            gap: 22px;
            width: 100%;
            position: relative;
        }

        /* iPhone-style blur dock container */
        .app-dock-blur {
            position: absolute;
            top: -20px;
            bottom: -12px;
            left: 50%;
            transform: translateX(-50%);
            width: 370px;
            /* 4 apps (240px) + 3 gaps (66px) + 32px left + 32px right = 370px */
            background-color: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 25px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: -1;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .app-icon {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            color: white;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
            font-size: 14px;
            font-weight: 500;
            text-align: center;
        }

        .app-icon .icon-bg {
            width: 65px;
            height: 65px;
            border-radius: 18px;
            background-color: rgb(247, 247, 247);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 32px;
            margin-bottom: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            /* transition: transform 0.2s ease; - Removed to disable tap feedback */
            overflow: hidden;
            opacity: 1;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        .app-icon:active .icon-bg {
            /* Tap feedback removed */
        }

        .app-icon .icon-bg img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .app-icon .label {
            color: white;
        }

        .form-container,
        .list-container {
            padding: 20px;
            overflow-y: auto;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        /* Specific alignment fix for appearance settings screen only */
        #appearance-settings-screen .form-group label {
            margin-left: -20px;
        }

        /* Toggle Switch Component */
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: var(--accent-color);
        }

        input:checked+.slider:before {
            transform: translateX(26px);
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 16px;
            box-sizing: border-box;
        }

        .form-group textarea {
            min-height: 80px;
            resize: vertical;
        }

        #world-book-content-input {
            height: calc(100% - 120px);
        }

        .form-button {
            width: 100%;
            padding: 15px;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 10px;
        }

        .form-button-secondary {
            background-color: #f0f0f0;
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        /* Toggle switch styles */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 28px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked+.toggle-slider {
            background-color: var(--accent-color);
        }

        input:checked+.toggle-slider:before {
            transform: translateX(22px);
        }

        #wallpaper-screen .form-container {
            align-items: center;
        }

        /* App icon customization styles */
        #app-icon-customization-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: calc(100vw - 40px);
            margin-left: -20px;
            margin-right: -20px;
        }

        .app-icon-item {
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--secondary-bg);
            box-sizing: border-box;
        }

        .app-icon-preview {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .app-icon-preview img {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            object-fit: cover;
        }

        .app-icon-preview span {
            font-weight: 500;
            color: var(--text-primary);
        }

        .app-icon-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            background: var(--primary-bg);
            color: var(--text-primary);
            box-sizing: border-box;
        }

        .app-icon-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .app-icon-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .app-icon-btn.primary {
            background: var(--accent-color);
            color: white;
        }

        .app-icon-btn.secondary {
            background: #6c757d;
            color: white;
        }

        #wallpaper-preview {
            width: 180px;
            height: 320px;
            border: 2px dashed var(--border-color);
            background-color: #f0f2f5;
            margin-bottom: 20px;
            background-size: cover;
            background-position: center;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--text-secondary);
        }

        #wallpaper-upload-input {
            display: none;
        }

        /* 修改后的 #world-book-list 样式 */
        #world-book-list {
            flex-grow: 1;
            overflow-y: auto;
            background-color: var(--secondary-bg);
            padding-top: 60px;
            margin-top: -60px;
        }

        /* 修改后的 #chat-list 样式，去掉了 padding 和 margin */
        #chat-list {
            flex-grow: 1;
            background-color: var(--secondary-bg);
            padding-top: 52px;
            padding-bottom: 50px;
            /* 为底部导航栏留出空间 */
            box-sizing: border-box;
        }

        .list-item {
            display: flex;
            flex-direction: column;
            padding: 12px 20px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
        }

        .list-item:hover {
            background-color: #f5f5f5;
        }

        .list-item.no-hover:hover {
            background-color: transparent;
        }

        .list-item .item-title {
            font-weight: 500;
            font-size: 16px;
            margin-bottom: 5px;
        }

        .list-item .item-content {
            font-size: 14px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }



        .chat-list-item {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            position: relative;
        }

        .chat-list-item:hover {
            background-color: #f5f5f5;
        }

        .chat-list-item .avatar {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            margin-right: 12px;
            object-fit: cover;
            background-color: #ccc;
        }

        .chat-list-item .info {
            flex-grow: 1;
            overflow: hidden;
        }

        .chat-list-item .name-line {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 2px;
        }

        .chat-list-item .name {
            font-weight: 500;
            color: var(--text-primary);
        }

        .chat-list-item .group-tag {
            font-size: 10px;
            color: var(--accent-color);
            background-color: #e7f3ff;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
            flex-shrink: 0;
        }

        .chat-list-item .last-msg {
            font-size: 13px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            /* max-width 将由flexbox自动管理，不再需要固定值 */
        }

        /* ---【全新】右侧元信息区：时间和状态灯 --- */
        .chat-list-item .meta {
            margin-left: 10px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            /* 内部元素靠右对齐 */
        }

        .chat-list-item .timestamp {
            font-size: 12px;
            color: #b0b0b0;
            margin-bottom: 8px;
        }

        .chat-list-item .status-light {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .chat-list-item .status-light.unread {
            background-color: #ff3b30;
            /* 红色 */
        }

        .chat-list-item .status-light.generating {
            background-color: #ffcc00;
            /* 黄色 */
            animation: pulse 1.5s infinite;
        }

        /* Pinned chat styling */
        .chat-list-item.pinned {
            background-color: #f8f9fa;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.4;
            }

            100% {
                opacity: 1;
            }
        }

        #chat-interface-screen {
            background-size: cover;
            background-position: center;
            position: relative;
        }

        #selection-cancel-btn,
        #selection-delete-btn {
            font-size: 16px;
            color: var(--accent-color);
            cursor: pointer;
            padding: 5px;
        }

        #selection-delete-btn {
            color: #ff3b30;
        }

        /* ▼▼▼ 用这块代码替换掉你原来的 #chat-messages 样式 ▼▼▼ */
        #chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            overflow-x: hidden;
            /* 核心修正1: 强制禁止水平滚动/拖动 */
            padding: 10px 15px;
            /* 核心修正2: 将左右内边距增加到15px，提供更多呼吸空间 */
            padding-top: 110px;
            margin-top: -80px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-sizing: border-box;
            /* 确保内边距计算正确 */
        }

        /* ▲▲▲ 替换结束 ▲▲▲ */
        #load-more-btn {
            text-align: center;
            padding: 10px;
            color: var(--accent-color);
            font-size: 14px;
            cursor: pointer;
            background-color: transparent;
            border: none;
            width: 100%;
        }

        #load-more-btn:hover {
            text-decoration: underline;
        }

        .sender-name {
            font-size: 11px;
            color: #666;
            margin-bottom: 3px;
        }

        .message-wrapper.ai .sender-name {
            margin-left: 50px;
            /* 稍微调整，与头像对齐 */
            margin-bottom: 3px;
            position: absolute;
            /* 让它脱离流，避免影响气泡对齐 */
            top: -16px;
            /* 定位到气泡上方 */
            left: 0;
        }

        /* === 【全新】消息布局与时间戳样式 === */

        /* 1. 消息单元的总容器 (重构) */
        .message-wrapper {
            display: flex;
            /* 使用Flex布局 */
            gap: 8px;
            /* 气泡和时间戳之间的间距 */
            align-items: flex-end;
            /* 核心：让气泡和时间戳底部对齐 */
            position: relative;
            max-width: 90%;
            /* 可以稍微放宽一点，因为时间戳现在在外面了 */
        }

        /* 2. AI消息单元靠左 */
        .message-wrapper.ai {
            align-self: flex-start;
            flex-direction: row;
            /* 头像、气泡、时间戳，从左到右排列 */
        }

        /* 3. 用户消息单元靠右 */
        .message-wrapper.user {
            align-self: flex-end;
            flex-direction: row-reverse;
            /* 时间戳、气泡、头像，从右到左排列 */
        }

        /* 4. 气泡和头像的直接容器 (保持不变) */
        .message-bubble {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            max-width: 100%;
        }

        .timestamp {
            /* 移除旧的 position: absolute */
            font-size: 11px;
            color: #999;
            text-shadow: 0 0 3px rgba(255, 255, 255, 0.6);
            white-space: nowrap;
            /* 防止时间换行 */
            margin-bottom: 5px;
            /* 让它和气泡底部有轻微的对齐偏移，更美观 */
            flex-shrink: 0;
            /* 防止被压缩 */
        }

        .message-bubble.selected::after {
            content: '✔';
            position: absolute;
            left: -10px;
            top: 50%;
            transform: translateY(-50%);
            background-color: var(--accent-color);
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .message-bubble.user.selected::after {
            left: auto;
            right: -10px;
        }

        .message-bubble.user {
            flex-direction: row-reverse;
        }

        #typing-indicator {
            align-self: flex-start;
            display: none;
            margin: 0 10px 10px;
            color: var(--text-secondary);
        }

        #meetup-typing-indicator {
            align-self: center;
            display: none;
            margin: 0 10px 10px;
            color: var(--text-secondary);
            font-size: 14px;
            opacity: 0.7;
            text-align: center;
        }

        #chat-input-area {
            flex-shrink: 0;
            padding: 8px;
            background-color: rgba(247, 247, 247, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        /* 回复预览栏样式 */
        #reply-preview-bar {
            display: none;
            background-color: #f0f0f0;
            padding: 8px 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            border-left: 3px solid var(--accent-color);
            justify-content: space-between;
            align-items: flex-start;
        }

        #reply-preview-bar .reply-preview-content {
            flex-grow: 1;
        }

        #reply-preview-bar .sender {
            font-size: 12px;
            color: var(--accent-color);
            font-weight: 600;
            margin-bottom: 2px;
        }

        #reply-preview-bar .text {
            font-size: 14px;
            color: var(--text-secondary);
            max-height: 40px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #reply-preview-bar #cancel-reply-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            padding: 0;
            margin-left: 8px;
        }

        #chat-input-main-row {
            display: flex;
            align-items: flex-end;
            gap: 8px;
            width: 100%;
        }

        #chat-input {
            flex-grow: 1;
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            background-color: var(--secondary-bg);
            font-size: 16px;
            max-height: 100px;
            resize: none;
        }

        .action-button {
            border: none;
            color: white;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            flex-shrink: 0;
        }

        #send-btn {
            background-color: var(--accent-color);
            height: 40px;
            padding: 0 15px;
        }

        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .modal.visible {
            display: flex;
        }

        .modal-content {
            width: 90%;
            max-height: 90%;
            background-color: white;
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .modal-header {
            padding: 15px;
            font-weight: 600;
            border-bottom: 1px solid var(--border-color);
            text-align: center;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .modal-body {
            padding: 15px;
            overflow-y: auto;
        }

        .modal-footer {
            padding: 15px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-around;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .modal-footer button {
            width: 45%;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid var(--accent-color);
            cursor: pointer;
            font-size: 16px;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .modal-footer .save {
            background-color: var(--accent-color);
            color: white;
        }

        .modal-footer .cancel {
            background-color: white;
            color: var(--accent-color);
        }

        .avatar-upload {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .avatar-upload img {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            background-color: #eee;
        }

        .avatar-upload button {
            padding: 8px 12px;
            border: 1px solid #ccc;
            background-color: #f0f0f0;
            border-radius: 5px;
            cursor: pointer;
        }

        #open-persona-library-btn {
            font-size: 14px;
            padding: 6px 10px;
            margin-left: auto;
        }

        .avatar-upload input[type="file"] {
            display: none;
        }

        /* Border Preview Component */
        .border-preview-container {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f9f9f9;
            margin-right: 15px;
        }

        .border-preview {
            width: 50px;
            height: 50px;
            object-fit: contain;
        }

        .no-border-text {
            font-size: 12px;
            color: #999;
            text-align: center;
        }

        .theme-selector label {
            display: inline-flex;
            align-items: center;
            margin-right: 15px;
            margin-bottom: 5px;
            cursor: pointer;
        }

        #reset-theme-btn {
            background: none;
            border: 1px solid #ccc;
            color: #555;
            font-size: 12px;
            padding: 2px 8px;
            border-radius: 5px;
            cursor: pointer;
            margin-left: 10px;
        }

        #group-members-settings {
            display: flex;
            overflow-x: auto;
            padding-bottom: 10px;
            gap: 15px;
        }

        .member-editor {
            text-align: center;
            cursor: pointer;
        }

        .member-editor img {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            background-color: #eee;
            margin-bottom: 5px;
        }

        .member-editor .member-name {
            font-size: 12px;
        }

        #notification-bar {
            position: absolute;
            top: 40px;
            left: 50%;
            width: 90%;
            z-index: 500;
            background-color: rgba(250, 250, 250, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            transform: translateX(-50%) translateY(-150%);
            transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            visibility: hidden;
        }

        #notification-bar.visible {
            /* 关键：在Y轴回到原位的同时，保持X轴的居中变换 */
            transform: translateX(-50%) translateY(0);
            visibility: visible;
        }

        #notification-avatar {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            object-fit: cover;
        }

        #notification-content .name {
            font-weight: 600;
            font-size: 15px;
            color: #000;
        }

        #notification-content .message {
            font-size: 14px;
            color: #555;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
        }

        .sticker-image {
            max-width: 100px;
            max-height: 100px;
            display: block;
            object-fit: contain;
        }

        /* Enhanced sticker bubble styles - completely immune to custom bubble CSS */
        .message-bubble.is-sticker {
            background: none !important;
            border: none !important;
            box-shadow: none !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
            padding: 0 !important;
            margin: 0 !important;
            border-radius: 0 !important;
        }

        .message-bubble.is-sticker .content,
        .message-bubble.is-voice-message .content {
            padding: 0 !important;
            background-color: transparent !important;
            box-shadow: none !important;
            border: none !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
            border-radius: 0 !important;
        }

        /* ▼▼▼ 【全新】撤回消息样式 ▼▼▼ */

        /* 1. 撤回消息的占位符样式 */
        .recalled-message-placeholder {
            align-self: center;
            /* 居中显示 */
            padding: 4px 12px;
            margin: 5px 0;
            background-color: rgba(0, 0, 0, 0.1);
            color: var(--text-secondary);
            font-size: 12px;
            border-radius: 10px;
            text-align: center;
            max-width: 80%;
            cursor: pointer;
            /* 让它看起来可以点击 */
        }

        /* 2. 夜间模式下的适配 */
        #phone-screen.dark-mode .recalled-message-placeholder {
            background-color: rgba(255, 255, 255, 0.15);
        }

        /* 3. AI撤回消息时的动画效果 */
        @keyframes recall-animation {
            from {
                opacity: 1;
                transform: scale(1);
            }

            to {
                opacity: 0;
                transform: scale(0.8);
            }
        }

        .message-wrapper.recalled-animation {
            animation: recall-animation 0.3s ease-out forwards;
        }

        /* 强制撤回消息的占位符不换行，并保持内容居中 */
        .recalled-message-placeholder {
            white-space: nowrap;
            /* 核心：禁止文本换行 */
            display: inline-block;
            /* 让背景根据内容自适应宽度 */
            padding: 4px 12px;
        }

        /* ▲▲▲ 撤回消息样式结束 ▲▲▲ */

        /* 引用消息样式 */
        .quoted-message {
            background-color: rgba(0, 123, 255, 0.1);
            border-left: 3px solid var(--accent-color);
            padding: 8px;
            margin-bottom: 8px;
            border-radius: 4px;
            font-size: 13px;
        }

        .quoted-sender {
            color: var(--accent-color);
            font-weight: 600;
            margin-bottom: 2px;
        }

        .quoted-content {
            color: var(--text-secondary);
        }

        #chat-input-actions-top {
            display: flex;
            gap: 8px;
            padding: 0 5px;
        }

        .chat-action-icon-btn {
            font-size: 24px;
            padding: 0;
            width: 38px;
            height: 38px;
            line-height: 38px;
            text-align: center;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.5);
            color: var(--text-primary);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid rgba(0, 0, 0, 0.05);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Override action-button font-size for chat action buttons */
        #chat-input-actions-top .action-button {
            font-size: 24px;
        }

        /* Ensure consistent BUTTON sizing only - no icon changes */
        #chat-input-actions-top .chat-action-icon-btn {
            width: 38px;
            height: 38px;
            box-sizing: border-box;
        }

        #sticker-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 50%;
            background-color: rgba(242, 242, 247, 0.85);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-top: 1px solid var(--border-color);
            border-radius: 20px 20px 0 0;
            z-index: 200;
            display: flex;
            flex-direction: column;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            visibility: hidden;
        }

        #sticker-panel.visible {
            transform: translateY(0);
            visibility: visible;
        }

        #sticker-panel-header {
            padding: 10px 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
            border-bottom: 1px solid var(--border-color);
            position: relative;
        }

        #sticker-panel-header .panel-btn {
            font-size: 16px;
            padding: 5px 10px;
            cursor: pointer;
            color: var(--accent-color);
            position: absolute;
        }

        #sticker-panel-header .panel-btn:first-child {
            left: 20px;
        }

        #sticker-panel-header .panel-btn:last-child,
        #sticker-panel-header #edit-sticker-pack-btn,
        #sticker-panel-header #exit-pack-arrange-btn {
            right: 20px;
            left: auto;
        }

        #sticker-panel-header .title {
            font-weight: 600;
        }

        #sticker-grid {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
            padding-bottom: 10px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 15px;
        }

        .sticker-item {
            position: relative;
            aspect-ratio: 1 / 1;
            border-radius: 10px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            cursor: pointer;
        }

        .sticker-item .delete-btn {
            display: none;
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            background-color: #ff3b30;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 20px;
            font-size: 14px;
            cursor: pointer;
            border: 2px solid white;
        }

        /* Sticker Pack Tabs */
        #sticker-pack-tabs {
            display: flex;
            align-items: center;
            padding: 8px 15px;
            background-color: rgba(255, 255, 255, 0.3);
            border-top: 1px solid var(--border-color);
            flex-shrink: 0;
            overflow-x: auto;
            gap: 8px;
        }

        .sticker-pack-tab {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background-color: transparent;
            cursor: pointer;
            transition: all 0.2s ease;
            flex-shrink: 0;
            border: 1px solid transparent;
        }

        .sticker-pack-tab:hover {
            background-color: rgba(221, 221, 221, 0.5);
        }

        .sticker-pack-tab.active {
            background-color: #dddddd;
            border-color: transparent;
        }

        .sticker-pack-tab .pack-icon {
            font-size: 32px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sticker-pack-tab .pack-icon svg {
            width: 24px;
            height: 24px;
        }

        .sticker-pack-tab .pack-icon img {
            width: 32px;
            height: 32px;
            border-radius: 4px;
            object-fit: cover;
        }

        .sticker-pack-tab.active .pack-icon {
            filter: none;
        }

        .sticker-pack-tab.active .pack-icon img {
            filter: none;
            border: none;
        }

        /* Add Pack Button */
        .sticker-pack-tab.add-pack-btn {
            background-color: #cccccc;
        }

        .sticker-pack-tab.add-pack-btn:hover {
            background-color: #bbbbbb;
        }

        /* Hide scrollbar for pack tabs */
        #sticker-pack-tabs::-webkit-scrollbar {
            display: none;
        }

        #sticker-pack-tabs {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* Add Sticker Square */
        .add-sticker-square {
            position: relative;
            aspect-ratio: 1 / 1;
            background-color: #cccccc;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
        }

        .add-sticker-square:hover {
            background-color: #bbbbbb;
        }

        .add-sticker-square svg {
            width: 24px;
            height: 24px;
            color: #666666;
        }



        #input-actions-wrapper {
            position: static;
            display: flex;
            align-items: flex-end;
            gap: 8px;
            flex-shrink: 0;
        }

        #wait-reply-btn {
            position: static;
            bottom: auto;
            right: auto;
            width: auto;
            height: 40px;
            padding: 0 10px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid rgba(0, 0, 0, 0.08);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            transition: opacity 0.2s, transform 0.1s;
            cursor: pointer;
        }

        #wait-reply-btn:hover {
            opacity: 0.8;
        }

        #wait-reply-btn:active {
            /* Tap feedback removed */
        }

        #wait-reply-btn img {
            height: 22px;
            display: block;
            margin: auto;
        }

        .chat-image {
            max-width: 100%;
            border-radius: 10px;
            display: block;
        }

        .qzone-post-item .chat-image {
            max-width: 50%;
            height: auto;
        }


        .message-bubble.has-image .content {
            padding: 5px;
        }

        #custom-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }

        #custom-modal-overlay.visible {
            display: flex;
            opacity: 1;
        }

        #custom-modal {
            background-color: #fff;
            width: 280px;
            border-radius: 14px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            transform: scale(0.95);
            transition: transform 0.2s ease-in-out;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        #custom-modal-overlay.visible #custom-modal {
            transform: scale(1);
        }

        .custom-modal-header {
            padding: 16px;
            font-size: 17px;
            font-weight: 600;
            text-align: center;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .custom-modal-body {
            padding: 0 16px 16px;
            text-align: center;
            font-size: 14px;
            color: #333;
            line-height: 1.5;
        }

        .custom-modal-body p {
            margin: 0;
            margin-bottom: 12px;
        }

        .custom-modal-body input {
            width: 100%;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #ccc;
            font-size: 14px;
            box-sizing: border-box;
        }

        .custom-modal-footer {
            display: flex;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .custom-modal-footer button {
            flex: 1;
            background: none;
            border: none;
            padding: 12px;
            font-size: 17px;
            cursor: pointer;
            color: var(--accent-color);
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .custom-modal-footer button:first-child {}

        .custom-modal-footer .confirm-btn {
            font-weight: 600;
        }

        .custom-modal-footer .confirm-btn.btn-danger {
            color: #ff3b30;
        }

        #preset-actions-modal .custom-modal-footer {
            flex-direction: column;
        }

        #preset-actions-modal .custom-modal-footer button {
            width: 100%;
            border: none;
            padding: 14px;
            font-size: 18px;
        }

        #preset-actions-modal .custom-modal-footer button:last-child {
            border-bottom: none;
        }

        /* Message actions modal - vertical layout for better fit */
        #message-actions-modal .custom-modal-footer {
            flex-direction: column;
        }

        #message-actions-modal .custom-modal-footer button {
            width: 100%;
            border: none;
            padding: 14px;
            font-size: 18px;
        }

        #message-actions-modal .custom-modal-footer button:last-child {
            border-bottom: none;
        }

        /* Post actions modal - vertical layout for better fit */
        #post-actions-modal .custom-modal-footer {
            flex-direction: column;
        }

        #post-actions-modal .custom-modal-footer button {
            width: 100%;
            border: none;
            padding: 14px;
            font-size: 18px;
        }

        #post-actions-modal .custom-modal-footer button:last-child {
            border-bottom: none;
        }

        /* Comment actions modal - vertical layout for better fit */
        #comment-actions-modal .custom-modal-footer {
            flex-direction: column;
        }

        #comment-actions-modal .custom-modal-footer button {
            width: 100%;
            border: none;
            padding: 14px;
            font-size: 18px;
        }

        #comment-actions-modal .custom-modal-footer button:last-child {
            border-bottom: none;
        }

        /* Bulletin actions modal - vertical layout for better fit */
        #bulletin-actions-modal .custom-modal-footer {
            flex-direction: column;
        }

        #bulletin-actions-modal .custom-modal-footer button {
            width: 100%;
            border: none;
            padding: 14px;
            font-size: 18px;
        }

        #bulletin-actions-modal .custom-modal-footer button:last-child {
            border-bottom: none;
        }

        /* Chat actions modal - vertical layout for better fit */
        #chat-actions-modal .custom-modal-footer {
            flex-direction: column;
        }

        #chat-actions-modal .custom-modal-footer button {
            width: 100%;
            border: none;
            padding: 14px;
            font-size: 18px;
        }

        #chat-actions-modal .custom-modal-footer button:last-child {
            border-bottom: none;
        }

        .custom-multiselect {
            position: relative;
            user-select: none;
        }

        .select-box {
            display: flex;
            align-items: center;
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 16px;
            box-sizing: border-box;
            background-color: #fff;
            cursor: pointer;
        }

        .select-box .selected-options-text {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: var(--text-primary);
        }

        .select-box .arrow-down {
            margin-left: auto;
            font-size: 10px;
            color: var(--text-secondary);
            transition: transform 0.2s;
        }

        .select-box.expanded .arrow-down {
            transform: rotate(180deg);
        }

        .checkboxes-container {
            display: none;
            position: absolute;
            /* 核心修改：不再使用 top，而是用 margin-top 来创造间距，更稳定 */
            top: 100%;
            margin-top: 5px;
            /* <-- 新增：向下推开5像素的距离 */
            left: 0;
            right: 0;
            max-height: 150px;
            overflow-y: auto;
            background-color: #fff;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            z-index: 101;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .checkboxes-container.visible {
            display: block;
        }

        .checkboxes-container label {
            display: block;
            padding: 10px 12px;
            cursor: pointer;
            font-weight: normal;
            color: var(--text-primary);
        }

        .checkboxes-container label {
            display: block;
            padding: 12px 15px;
            /* <-- 修改：增加了上下和左右的内边距，让每一行更高更宽 */
            cursor: pointer;
            font-weight: normal;
            color: var(--text-primary);
            font-size: 15px;
            /* <-- 新增：将字体大小从默认值放大到15px */
        }

        .checkboxes-container input {
            margin-right: 10px;
            vertical-align: middle;
        }

        .bg-upload-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .bg-preview-img {
            max-width: 120px;
            max-height: 80px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            object-fit: cover;
            display: none;
        }

        #remove-bg-btn {
            padding: 8px 12px;
            border: 1px solid #ff3b30;
            color: #ff3b30;
            background-color: #fff;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            display: none;
        }

        .message-bubble.is-ai-image .content {
            padding: 5px;
            background: transparent;
            box-shadow: none;
            border: none;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }

        .ai-generated-image {
            max-width: 180px;
            border-radius: 12px;
            display: block;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .ai-generated-image:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .voice-message-body {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 8px 12px;
            min-width: 80px;
            max-width: 200px;
        }

        .voice-waveform {
            display: flex;
            align-items: center;
            height: 20px;
            gap: 2px;
            flex-grow: 1;
            margin: 0 10px;
        }

        .voice-waveform div {
            width: 3px;
            background-color: currentColor;
            border-radius: 2px;
            animation: wave-quiet 1.5s ease-in-out infinite;
        }

        @keyframes wave-quiet {

            0%,
            100% {
                height: 2px;
            }

            50% {
                height: 10px;
            }
        }

        .voice-waveform div:nth-child(2) {
            animation-delay: 0.2s;
        }

        .voice-waveform div:nth-child(3) {
            animation-delay: 0.4s;
        }

        .voice-waveform div:nth-child(4) {
            animation-delay: 0.6s;
        }

        .voice-waveform div:nth-child(5) {
            animation-delay: 0.8s;
        }

        .voice-duration {
            /* --- 核心修正 --- */
            font-size: var(--chat-font-size, 13px);
            /* --- 修正结束 --- */
            font-weight: 500;
            color: var(--text-secondary);
        }


        /* ▼▼▼ 【语音消息优化·最终样式 v3】粘贴到这里 ▼▼▼ */
        /* 1. 使语音气泡内容垂直排列，确保语音条和文字区等宽 (无变化) */
        .is-voice-message .content {
            display: flex;
            flex-direction: column;
            padding: 0;
        }

        /* 2. 语音消息主体样式 (无变化) */
        .voice-message-body {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 8px 12px;
        }

        .message-bubble.user .voice-message-body {
            flex-direction: row-reverse;
        }

        /* 3. 波形容器：【核心修改】增加 justify-content 使其均匀分布 */
        .voice-waveform {
            display: flex;
            align-items: center;
            height: 20px;
            gap: 2px;
            flex-grow: 1;
            margin: 0 10px;
            /* 您可以随时调整此处的 10px */
        }

        /* 4. 波形本身 (无变化) */
        .voice-waveform div {
            width: 3px;
            background-color: currentColor;
            border-radius: 2px;
            animation: wave-quiet 1.5s ease-in-out infinite;
        }

        /* 5. 时长 (无变化) */
        .message-bubble.user .voice-duration {}

        /* 6. 语音转文字容器样式：【核心修改】字体大小改为动态计算 */
        .voice-transcript {
            display: none;
            padding: 8px 12px;
            margin: 0 5px 5px 5px;
            border-top: 1px solid rgba(0, 0, 0, 0.06);
            font-size: calc(var(--font-size) - 1px);
            /* 修改：关联系统字体大小 */
            color: var(--text-secondary);
            line-height: 1.5;
            background-color: rgba(0, 0, 0, 0.03);
            border-radius: 8px;
            white-space: pre-wrap;
            word-break: break-word;
        }

        /* ▲▲▲ 样式粘贴结束 ▲▲▲ */


        /* ▼▼▼ 用这块代码替换掉你原来的 .message-bubble .content 样式 ▼▼▼ */
        /* 通用内容区样式，为时间戳和字体大小做准备 */
        .message-bubble .content {
            position: relative;
            font-size: var(--chat-font-size, 16px);
            padding: 8px 12px;
            line-height: 1.5;
            word-break: break-word;
            /* 核心修正: 强制长单词或URL换行，防止撑破气泡 */
        }

        /* ▲▲▲ 替换结束 ▲▲▲ */

        /* === 气泡主题样式 === */
        .message-bubble.user .content {
            background-color: rgba(255, 255, 255, 0.75);
            color: #585858;
            border-radius: 8px 2px 8px 8px;
        }

        .message-bubble.ai .content {
            background-color: rgba(255, 255, 255, 0.7);
            color: #585858;
            border-radius: 2px 8px 8px 8px;
        }

        #chat-messages[data-theme="pink_blue"] .message-bubble.user .content {
            background-color: #fff0f6;
            color: #432531;
        }

        #chat-messages[data-theme="pink_blue"] .message-bubble.ai .content {
            background-color: #eff7ff;
            color: #263a4e;
        }

        #chat-messages[data-theme="blue_white"] .message-bubble.user .content {
            background-color: #eff7ff;
            color: #263a4e;
        }

        #chat-messages[data-theme="blue_white"] .message-bubble.ai .content {
            background-color: #f8f9fa;
            color: #383d41;
        }

        #chat-messages[data-theme="purple_yellow"] .message-bubble.user .content {
            background-color: #faf7ff;
            color: #827693;
        }

        #chat-messages[data-theme="purple_yellow"] .message-bubble.ai .content {
            background-color: #fffde4;
            color: #5C4033;
        }

        #chat-messages[data-theme="black_white"] .message-bubble.user .content {
            background-color: #343a40;
            color: #f8f9fa;
        }

        #chat-messages[data-theme="black_white"] .message-bubble.ai .content {
            background-color: #f8f9fa;
            color: #343a40;
        }

        #chat-messages[data-theme="yellow_white"] .message-bubble.user .content {
            background-color: #FFEB3B;
            color: #5D4037;
        }

        #chat-messages[data-theme="yellow_white"] .message-bubble.ai .content {
            background-color: #f8f9fa;
            color: #383d41;
        }

        #chat-messages[data-theme="red_black"] .message-bubble.user .content {
            background-color: #C62828;
            color: #FFFFFF;
        }

        #chat-messages[data-theme="red_black"] .message-bubble.ai .content {
            background-color: #212121;
            color: #FFFFFF;
        }

        #chat-messages[data-theme="blue_yellow"] .message-bubble.user .content {
            background-color: #A0D2EB;
            color: #153243;
        }

        #chat-messages[data-theme="blue_yellow"] .message-bubble.ai .content {
            background-color: #FEF9E7;
            color: #5D4037;
        }

        #chat-messages[data-theme="pink_yellow"] .message-bubble.user .content {
            background-color: #fff0f6;
            color: #432531;
        }

        #chat-messages[data-theme="pink_yellow"] .message-bubble.ai .content {
            background-color: #FEF9E7;
            color: #5D4037;
        }

        #chat-messages[data-theme="pink_purple"] .message-bubble.user .content {
            background-color: #fff0f6;
            color: #a78396;
        }

        #chat-messages[data-theme="pink_purple"] .message-bubble.ai .content {
            background-color: #faf7ff;
            color: #827693;
        }

        #chat-messages[data-theme="gray_white"] .message-bubble.user .content {
            background-color: #e9ecef;
            color: #495057;
        }

        #chat-messages[data-theme="gray_white"] .message-bubble.ai .content {
            background-color: #f8f9fa;
            color: #383d41;
        }

        #chat-messages[data-theme="blue_green"] .message-bubble.user .content {
            background-color: #d1ecf1;
            color: #0c5460;
        }

        #chat-messages[data-theme="blue_green"] .message-bubble.ai .content {
            background-color: #d4edda;
            color: #155724;
        }

        #chat-messages[data-theme="pink_white"] .message-bubble.user .content {
            background-color: #fff0f6;
            color: #a78396;
        }

        #chat-messages[data-theme="pink_white"] .message-bubble.ai .content {
            background-color: #f8f9fa;
            color: #383d41;
        }

        #chat-messages[data-theme="pink_black"] .message-bubble.user .content {
            background-color: #F8BBD0;
            color: #5B2C6F;
        }

        #chat-messages[data-theme="pink_black"] .message-bubble.ai .content {
            background-color: #343a40;
            color: #f8f9fa;
        }

        #chat-messages[data-theme="pink_green"] .message-bubble.user .content {
            background-color: #F8BBD0;
            color: #5B2C6F;
        }

        #chat-messages[data-theme="pink_green"] .message-bubble.ai .content {
            background-color: #C8E6C9;
            color: #1B5E20;
        }

        #chat-messages[data-theme="green_black"] .message-bubble.user .content {
            background-color: #d4edda;
            color: #155724;
        }

        #chat-messages[data-theme="green_black"] .message-bubble.ai .content {
            background-color: #343a40;
            color: #f8f9fa;
        }

        #transfer-btn {
            font-weight: bold;
        }

        #transfer-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1001;
        }

        #transfer-modal.visible {
            display: flex;
        }

        .transfer-content {
            background-color: #fff0f5;
            border-radius: 20px;
            width: 290px;
            padding: 20px;
            box-shadow: 0 5px 25px rgba(255, 105, 180, 0.3);
            text-align: center;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100" opacity="0.05"><path d="M50,4 C35,4 28,15 28,24 C28,33 35,32 35,40 C35,48 28,49 28,57 C28,65 35,66 35,74 C35,82 28,83 28,91 C28,99 35,100 50,100 C65,100 72,99 72,91 C72,83 65,82 65,74 C65,66 72,65 72,57 C72,49 65,48 65,40 C65,32 72,33 72,24 C72,15 65,4 50,4 Z" fill="%23FF69B4"/></svg>');
            background-repeat: no-repeat;
            background-position: top right;
            background-size: 80px;
        }

        .transfer-header {
            font-size: 20px;
            font-weight: bold;
            color: #a35c7b;
            margin-bottom: 20px;
        }

        .transfer-input-group {
            margin-bottom: 15px;
            text-align: left;
        }

        .transfer-input-group label {
            display: block;
            font-size: 14px;
            color: #ff85b3;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .transfer-input-group input {
            width: 100%;
            padding: 12px;
            border-radius: 10px;
            border: 2px solid #ffcce0;
            background-color: #fff;
            font-size: 16px;
            box-sizing: border-box;
        }

        .transfer-input-group input:focus {
            border-color: #ff85b3;
            outline: none;
        }

        .transfer-actions {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        .transfer-actions button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            /* transition: transform 0.2s; - Removed to disable tap feedback */
        }

        .transfer-actions button:active {
            /* Tap feedback removed */
        }

        #transfer-cancel-btn {
            background-color: #ffdde9;
            color: #a35c7b;
        }

        #transfer-confirm-btn {
            background-color: #ff85b3;
            color: white;
        }

        .message-bubble.is-transfer .content {
            padding: 0;
            background: transparent;
            box-shadow: none;
            border: none;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            cursor: pointer;
        }

        .transfer-card {
            width: 200px;
            border-radius: 12px;
            padding: 12px;
            color: white;
            position: relative;
            overflow: hidden;
        }

        .transfer-card::before {
            content: '🐾';
            position: absolute;
            right: 10px;
            top: 5px;
            font-size: 30px;
            opacity: 0.2;
            transform: rotate(15deg);
        }

        .message-bubble.user .transfer-card {
            background: radial-gradient(circle at top left, #ffc5d5, #ff85b3);
        }

        .message-bubble.ai .transfer-card {
            background: radial-gradient(circle at top left, #a1c4fd, #c2e9fb);
        }

        .transfer-title {
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 8px;
        }

        .transfer-amount {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .transfer-note {
            font-size: 13px;
            opacity: 0.9;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            padding-top: 8px;
            margin-top: 8px;
            word-break: break-all;
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        #listen-together-btn img.rotating {
            animation: spin 2s linear infinite;
        }

        #listen-together-btn img.paused {
            animation-play-state: paused;
        }

        #music-player-overlay {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            z-index: 200 !important;
            /* Lower than playlist panel (210) but higher than other elements */
            display: none;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.5) !important;
            /* Darker background to see if it appears */
        }

        #music-player-overlay.visible {
            display: flex;
        }

        /* Now Playing Bar Styles - Matching App Dock */
        .now-playing-bar {
            position: fixed;
            top: calc(var(--header-height, 60px) + 8px);
            left: 12px;
            right: 12px;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 50px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            z-index: 45;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
            cursor: pointer;
        }

        .now-playing-bar.hidden {
            transform: translateY(-100%);
            opacity: 0;
            pointer-events: none;
        }

        /* Home Screen Now Playing Bar - Fixed positioning */
        .home-screen-bar {
            position: fixed !important;
            top: 16px !important;
            bottom: auto !important;
            left: 50% !important;
            right: auto !important;
            transform: translateX(-50%) !important;
            width: 370px !important;
            /* Same width as the dock blur (370px) */
            margin: 0;
            z-index: 1000;
            pointer-events: auto !important;
            /* Ensure clicks work when visible */
            cursor: pointer;
        }

        .home-screen-bar.hidden {
            transform: translateX(-50%) translateY(100%);
            opacity: 0;
            pointer-events: none;
        }

        /* Only show home screen bar when on home screen */
        #home-screen:not(.active) .home-screen-bar {
            display: none;
        }

        .now-playing-content {
            display: flex;
            align-items: center;
            padding: 8px;
            box-sizing: border-box;
        }

        .np-album-art {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            overflow: hidden;
            background: linear-gradient(135deg, #f0f0f0, #e0e0e0);
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
        }

        .np-album-art img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .np-album-art .default-icon {
            font-size: 20px;
            color: white;
        }

        .np-song-info {
            flex: 1;
            min-width: 0;
        }

        .np-song-title {
            font-size: 14px;
            font-weight: 600;
            color: white;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1;
            margin: 0;
            padding: 0;
        }

        .np-song-artist {
            font-size: 12px;
            color: white;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1;
            margin: 0;
            padding: 0;
        }

        .np-right-section {
            display: flex;
            align-items: center;
            flex-shrink: 0;
        }

        .np-playback-controls {
            display: flex;
            align-items: center;
            gap: 4px;
            flex-shrink: 0;
            margin-right: 8px;
        }

        .np-control-btn {
            width: 36px;
            height: 36px;
            border: none;
            background: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
            color: white;
            transition: background-color 0.2s ease;
            flex-shrink: 0;
        }

        .np-control-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .np-control-btn.play-pause {
            width: 40px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 18px;
        }

        .np-control-btn.play-pause:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .np-partner-avatar {
            width: 38px;
            height: 38px;
            border-radius: 50%;
            overflow: hidden;
            flex-shrink: 0;
        }

        .np-partner-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .np-progress-bar {
            position: absolute;
            bottom: 0;
            left: 28px;
            right: 28px;
            height: 2px;
            background-color: rgba(255, 255, 255, 0.2);
            overflow: hidden;
        }

        .np-progress-fill {
            height: 100%;
            background-color: white;
            width: 0%;
            transition: width 0.1s ease-out;
        }

        /* Album Art Rotation Animation */
        .np-album-art img.rotating {
            animation: rotate 16s linear infinite;
        }

        .home-screen-bar .np-album-art img.rotating {
            animation: rotate 16s linear infinite;
        }

        .np-album-art img.rotating.paused {
            animation-play-state: paused;
        }

        @keyframes rotate {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        /* Meetup Progress Bar Styles - Purple gradient with blur effects */
        .meetup-progress-bar {
            position: fixed;
            top: calc(var(--header-height, 60px) + 8px);
            left: 12px;
            right: 12px;
            height: 40px;
            /* 32px avatar + 4px top padding + 4px bottom padding */
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.6), rgba(118, 75, 162, 0.6));
            /* Semi-transparent purple gradient for blur effect */
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 100px;
            /* Fully rounded corners on all sides */
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            z-index: 46;
            /* Above music bar */
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
            cursor: pointer;
        }

        /* When both meetup and music bars are visible, adjust positioning */
        .has-meetup-progress .now-playing-bar {
            top: calc(var(--header-height, 60px) + 56px);
            /* 8px + 40px (date bar height) + 8px spacing */
        }

        .meetup-progress-bar.hidden {
            transform: translateY(-100%);
            opacity: 0;
            pointer-events: none;
        }

        /* Home Screen Meetup Progress Bar */
        .meetup-progress-bar.home-screen-bar {
            position: fixed !important;
            top: 16px !important;
            bottom: auto !important;
            left: 50% !important;
            right: auto !important;
            transform: translateX(-50%) !important;
            width: 370px !important;
            margin: 0;
            z-index: 1001;
            /* Above music bar */
            pointer-events: auto !important;
            cursor: pointer;
            border-radius: 100px;
            /* Fully rounded corners on all sides */
        }

        /* When both meetup and music bars are visible on home screen, adjust music bar position */
        #home-screen.has-meetup-progress .home-screen-bar:not(.meetup-progress-bar) {
            top: 64px !important;
            /* 16px + 40px (date bar height) + 8px spacing */
        }

        .meetup-progress-bar.home-screen-bar.hidden {
            transform: translateX(-50%) translateY(-100%);
            opacity: 0;
            pointer-events: none !important;
        }

        /* Only show home screen meetup bar when on home screen */
        #home-screen:not(.active) .meetup-progress-bar.home-screen-bar {
            display: none;
        }

        .meetup-progress-content {
            display: flex;
            align-items: center;
            padding: 4px;
            /* All paddings on all sides 4px */
            box-sizing: border-box;
            height: 100%;
        }

        .meetup-ai-avatar {
            width: 32px;
            /* Increased by 8px */
            height: 32px;
            border-radius: 50%;
            overflow: hidden;
            background: linear-gradient(135deg, #f0f0f0, #e0e0e0);
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 8px;
        }

        .meetup-ai-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .meetup-progress-info {
            flex: 1;
            min-width: 0;
        }

        .meetup-progress-text {
            font-size: 16px;
            /* Same as chat message text */
            font-weight: 500;
            color: white;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1;
            margin: 0;
            padding: 0;
        }

        .meetup-separator {
            color: rgba(255, 255, 255, 0.75);
            /* 75% opacity */
            font-size: 16px;
            font-weight: 500;
        }

        .meetup-clock-icon {
            display: inline-block;
            vertical-align: middle;
            margin: 0 2px 0 4px;
            /* Closer to time, normal spacing from separator */
            flex-shrink: 0;
        }

        .meetup-elapsed-text {
            font-size: 14px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.75);
            /* 75% opacity */
            white-space: nowrap;
            line-height: 1;
            margin: 0;
            padding: 0;
            display: inline;
        }



        /* Chat messages offset when now playing bar is visible */
        #chat-interface-screen.has-now-playing #chat-messages {
            padding-top: 80px;
        }

        .music-player-window {
            width: calc(100% - 24px);
            margin: 0 12px;
            background-color: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 20px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
            padding: 25px;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #1f1f1f;
            position: relative;
        }

        #music-playlist-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 24px;
            cursor: pointer;
            color: #333;
        }

        #music-time-counter {
            font-size: 12px;
            color: #555;
            margin-bottom: 20px;
        }

        #music-player-song-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 5px;
            text-align: center;
        }

        #music-player-artist {
            font-size: 14px;
            color: #666;
            margin-bottom: 25px;
        }

        .music-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            width: 100%;
            margin-bottom: 30px;
        }

        .music-controls button {
            background: none;
            border: none;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            color: #333;
            width: 44px;
            height: 44px;
            display: flex;
            justify-content: center;
            align-items: center;
            /* transition: transform 0.2s; - Removed to disable tap feedback */
        }

        .music-controls button:active {
            /* Tap feedback removed */
        }

        .music-controls .play-pause-btn {
            font-size: 24px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.05);
        }

        .music-bottom-actions {
            display: flex;
            justify-content: space-between;
            width: 100%;
        }

        .music-bottom-actions button {
            flex: 1;
            padding: 12px 0;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
        }

        #music-exit-btn {
            background-color: rgba(255, 100, 100, 0.7);
            color: white;
            margin-right: 5px;
        }

        #music-return-btn {
            background-color: rgba(0, 123, 255, 0.7);
            color: white;
            margin-left: 5px;
        }

        #music-playlist-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 70%;
            background-color: rgba(242, 242, 247, 0.9);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-top: 1px solid var(--border-color);
            border-radius: 20px 20px 0 0;
            z-index: 210;
            display: flex;
            flex-direction: column;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            visibility: hidden;
        }

        #music-playlist-panel.visible {
            transform: translateY(0);
            visibility: visible;
        }

        .playlist-header {
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
        }

        .playlist-header .panel-btn {
            font-size: 16px;
            cursor: pointer;
            color: var(--accent-color);
        }

        .playlist-body {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px 0;
        }

        .playlist-item {
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }

        .playlist-item.playing {
            background-color: rgba(0, 123, 255, 0.1);
        }

        .playlist-item-info .title {
            font-weight: 500;
            font-size: 15px;
        }

        .playlist-item-info .artist {
            font-size: 12px;
            color: #666;
        }

        .playlist-item .delete-track-btn {
            color: #ff3b30;
            font-size: 20px;
            padding: 5px;
        }

        /* Persona Library Styles */
        #persona-library-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            padding: 10px;
        }

        .persona-preset-item {
            aspect-ratio: 1 / 1;
            border-radius: 12px;
            background-size: cover;
            background-position: center;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .persona-preset-item:hover {
            transform: scale(1.08);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .modal-header .action-button {
            font-size: 16px;
            color: var(--accent-color);
            font-weight: 600;
            cursor: pointer;
            background: none;
            border: none;
            padding: 5px;
        }

        /* Battery Alert Modal Styles */
        #battery-alert-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #battery-alert-modal.visible {
            display: flex;
            opacity: 1;
        }

        .battery-alert-content {
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            width: 280px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            text-align: center;
            padding: 20px;
            cursor: pointer;
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        #battery-alert-modal.visible .battery-alert-content {
            transform: scale(1);
        }

        #battery-alert-image {
            max-width: 100px;
            max-height: 100px;
            margin-bottom: 15px;
        }

        #battery-alert-text {
            font-size: 16px;
            font-weight: 500;
            color: #333;
            margin: 0;
            line-height: 1.4;
        }

        /* 这是你要添加的新样式 */
        #font-preview {
            transition: font-family 0.3s ease;
        }

        /* === 聊天列表界面新增样式 (这是新添加的) === */
        #chat-list-screen {}

        .chat-list-view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 1;
        }

        .chat-list-view.active {
            opacity: 1;
            visibility: visible;
            z-index: 2;
        }

        #messages-view {
            overflow-y: auto;
        }

        /* 底部导航栏样式 */
        #chat-list-bottom-nav {
            position: absolute;
            /* 让它固定在底部 */
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 15;
            /* 确保它在视图之上 */
            display: flex;
            border-top: 1px solid var(--border-color);
            background-color: rgba(247, 247, 247, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .nav-item {
            flex: 1;
            text-align: center;
            padding: 12px 0;
            font-size: 14px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: color 0.2s;
        }

        .nav-item.active {
            color: var(--accent-color);
            font-weight: 600;
        }

        /* === 动态界面 (QZone) 样式 (这是新添加的) === */
        #qzone-screen {
            background-color: #f0f2f5;
        }

        .qzone-header {
            /* position: absolute;  <-- 把这个改成 relative */
            position: relative;
            z-index: 10;
            /* z-index 保持，或者可以更高 */
            flex-shrink: 0;
            /* 防止被压缩 */
            padding: 15px 12px;
            padding-top: 16px;
            background-color: rgba(247, 247, 247, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 18px;
            font-weight: 600;
            text-align: center;
        }

        .qzone-header .back-btn {
            font-size: 24px;
            cursor: pointer;
            color: var(--accent-color);
            margin-left: 8px;
            /* Add spacing to match other screens */
        }

        .qzone-header .ai-post-btn {
            position: absolute;
            right: 20px;
            font-size: 20px;
            cursor: pointer;
            color: var(--accent-color);
            transition: opacity 0.2s;
        }

        .qzone-header .ai-post-btn:hover {
            opacity: 0.8;
        }

        /* Position the add button (first ai-post-btn) */
        .qzone-header #qzone-add-post-btn {
            right: 72px;
        }

        /* Position the AI button (second ai-post-btn) */
        .qzone-header #ai-post-btn {
            right: 20px;
        }

        .qzone-header span:nth-child(2) {
            /* "好友动态"文字 */
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        .qzone-content {
            flex-grow: 1;
            overflow-y: auto;
            /* padding-top: 80px;  <-- 删除这个，因为header不再是absolute了 */
        }

        .qzone-profile-header {
            position: relative;
            margin-bottom: 20px;
        }

        .qzone-banner-container {
            width: 100%;
            height: 240px;
            /* 背景板高度 */
            position: relative;
        }

        #qzone-banner-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .qzone-user-info {
            position: absolute;
            bottom: -40px;
            /* 让头像和昵称区域向下偏移，一半在背景板内，一半在外 */
            left: 18px;
            display: flex;
            align-items: flex-start;
            /* Changed from center to flex-start to allow independent positioning */
            gap: 12px;
        }

        .qzone-user-text {
            display: flex;
            flex-direction: column;
            gap: 26px;
            padding-top: 16px;
            transform: translateY(4px);
        }

        .qzone-avatar-container {
            position: relative;
            flex-shrink: 0;
            width: 92px;
            height: 92px;
        }

        #qzone-avatar-img {
            width: 92px;
            height: 92px;
            border-radius: 50%;
            object-fit: cover;
            transform: translateY(2px);
            box-shadow: 0 0 0 2px #f0f2f5;
        }

        /* QZone avatar with frame support - overlay approach */
        #qzone-avatar-container .avatar {
            width: 92px;
            height: 92px;
            border-radius: 50%;
            object-fit: cover;
            transform: translateY(2px);
            box-shadow: 0 0 0 2px #f0f2f5;
        }

        /* When borders are enabled, decrease avatar size by 16px but keep container size */
        #qzone-avatar-container.borders-enabled #qzone-avatar-img,
        #qzone-avatar-container.borders-enabled .avatar {
            width: 76px;
            height: 76px;
            /* Center the smaller avatar within the same container */
            position: relative;
            left: 8px;
            top: 10px;
            transform: translateY(0px);
            /* Reset transform for border mode */
        }

        .qzone-avatar-frame {
            position: absolute;
            width: 153px;
            height: 153px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 2;
        }

        /* Adjust border frame size and position when avatar is smaller */
        #qzone-avatar-container.borders-enabled .qzone-avatar-frame {
            width: 131px;
            height: 131px;
            top: calc(50% + 0px);
            /* Move border down 1px more */
        }

        #qzone-nickname {
            font-size: 20px;
            font-weight: 600;
            color: #000;
            text-shadow: 2px 2px 8px rgba(255, 255, 255, 0.9);
        }

        #qzone-status {
            font-size: 14px;
            color: #333;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        /* Only move text left when borders are enabled */
        .qzone-avatar-container.borders-enabled~.qzone-user-text #qzone-nickname {
            position: relative;
            left: -4px;
        }

        .qzone-avatar-container.borders-enabled~.qzone-user-text #qzone-status {
            position: relative;
            left: -4px;
        }

        #qzone-status:hover {
            opacity: 0.8;
        }

        /* 编辑按钮的通用样式 */
        .qzone-edit-btn {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.4);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        #change-qzone-banner-btn {
            bottom: 10px;
            right: 10px;
        }

        #change-qzone-avatar-btn {
            bottom: 5px;
            right: 5px;
        }

        #change-qzone-nickname-btn {
            font-size: 14px;
            padding: 2px 6px;
            margin-left: 5px;
            /* 与昵称的间距 */
            color: var(--text-primary);
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 5px;
            position: relative;
            /* 脱离flex布局的对齐 */
            bottom: 5px;
            /* 微调垂直位置 */
        }

        /* === 让编辑功能更“隐形” === */
        #qzone-banner-container,
        #qzone-avatar-container,
        #qzone-nickname,
        #qzone-status {
            cursor: pointer;
            /* 鼠标悬停时显示为可点击手势 */
            transition: opacity 0.2s;
        }

        #qzone-banner-container:hover,
        #qzone-avatar-container:hover,
        #qzone-nickname:hover,
        #qzone-status:hover {
            opacity: 0.85;
            /* 悬停时稍微变暗，给用户反馈 */
        }

        /* 隐藏掉旧的、独立的编辑按钮 */
        .qzone-edit-btn {
            display: none;
        }

        /* === 控制 Header 和 Bottom Nav 的显隐 === */
        /* 默认隐藏动态界面的 Header */
        #qzone-screen .qzone-header {
            display: none;
        }

        /* 当动态视图激活时，显示它的Header */
        #qzone-screen.active .qzone-header {
            display: flex;
        }

        /* 当进入动态视图时，隐藏主Header和底部导航栏 */
        #chat-list-screen.in-qzone-view>.header,
        #chat-list-screen.in-qzone-view>#chat-list-bottom-nav {
            display: none;
        }

        .chat-list-item:first-child,
        .chat-group-container:first-child {
            margin-top: 10px;
        }

        /* ▲▲▲ 新样式替换结束 ▲▲▲ */

        /* ▼▼▼ 把所有这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

        /* === 动态功能栏样式 === */
        .qzone-actions-bar {
            display: flex;
            justify-content: space-around;
            padding: 10px 0;
            margin: 50px 15px 15px 15px;
            /* 上边距更大，为浮动的头像留出空间 */
            background-color: var(--secondary-bg);
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .action-item {
            flex: 1;
            text-align: center;
            font-size: 15px;
            font-weight: 500;
            color: var(--text-primary);
            cursor: pointer;
            padding: 8px 0;
            position: relative;
        }

        /* 用伪元素创建分隔线 */
        .action-item:not(:last-child)::after {
            content: '';
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 1px;
            height: 20px;
            background-color: var(--border-color);
        }

        /* === 动态帖子列表样式 === */
        #qzone-posts-list {
            padding: 32px 15px 20px 15px;
            /* 上方32px间距，左右和底部留出边距 */
            display: flex;
            flex-direction: column;
            gap: 20px;
            /* 帖子之间的间距 */
        }

        .qzone-post-item {
            background-color: var(--secondary-bg);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
        }

        .post-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .post-header .post-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
        }

        /* Post avatar with frame support - overlay approach */
        .post-header .avatar-container {
            position: relative;
            width: 40px;
            height: 40px;
            flex-shrink: 0;
        }

        .post-header .avatar-container .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
        }

        .post-header .avatar-container .avatar-frame {
            position: absolute;
            width: 67px;
            height: 67px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 2;
        }

        .post-info {
            display: flex;
            flex-direction: column;
        }

        .post-info .post-nickname {
            font-weight: 600;
            font-size: 15px;
            color: var(--text-primary);
        }

        .post-info .post-timestamp {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .post-content {
            font-size: 14px;
            line-height: 1.6;
            color: #333;
            white-space: pre-wrap;
            /* 让换行符生效 */
            word-break: break-word;
            /* 防止长单词溢出 */
        }

        /* ▲▲▲ 新样式结束 ▲▲▲ */

        /* ▼▼▼ 新样式粘贴到末尾 ▼▼▼ */

        /* === 发布动态模态框样式 === */
        #post-public-text {
            min-height: 80px;
            /* 确保文本域有足够的高度 */
            resize: vertical;
        }

        .post-image-preview-container {
            position: relative;
            width: 100%;
            aspect-ratio: 16 / 9;
            /* 保持16:9的预览比例 */
            background-color: #f0f2f5;
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            margin-bottom: 15px;
            display: none;
            /* 默认隐藏 */
            justify-content: center;
            align-items: center;
        }

        .post-image-preview-container.visible {
            display: flex;
            /* 上传后显示 */
        }

        #post-image-preview {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 6px;
        }

        #post-remove-image-btn {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: #ff3b30;
            color: white;
            border: 2px solid white;
            font-size: 16px;
            line-height: 20px;
            text-align: center;
            cursor: pointer;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
        }

        .post-image-upload-options {
            display: flex;
            gap: 10px;
        }

        .post-image-upload-options button {
            flex: 1;
            margin-top: 0;
        }

        /* ▲▲▲ 新样式结束 ▲▲▲ */
        /* ▼▼▼ 【全新】胶囊开关样式 - 请将这段CSS粘贴到样式表末尾 ▼▼▼ */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 51px;
            height: 31px;
            flex-shrink: 0;
            /* 防止被压缩 */
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-switch .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
        }

        .toggle-switch .slider:before {
            position: absolute;
            content: "";
            height: 27px;
            width: 27px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
        }

        .toggle-switch input:checked+.slider {
            background-color: var(--accent-color);
        }

        .toggle-switch input:focus+.slider {
            box-shadow: 0 0 1px var(--accent-color);
        }

        .toggle-switch input:checked+.slider:before {
            transform: translateX(20px);
        }

        /* 圆角样式 */
        .toggle-switch .slider.round {
            border-radius: 34px;
        }

        .toggle-switch .slider.round:before {
            border-radius: 50%;
        }

        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

        /* ▼▼▼ 新样式 ▼▼▼ */

        /* === 发布动态模态框 - 模式切换样式 === */
        .post-mode-switcher {
            display: flex;
            margin-bottom: 20px;
            background-color: #e9ecef;
            border-radius: 8px;
            padding: 4px;
        }

        .mode-btn {
            flex: 1;
            padding: 8px;
            border: none;
            background-color: transparent;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }

        .mode-btn.active {
            background-color: var(--secondary-bg);
            color: var(--text-primary);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .post-mode-content {
            display: none;
            /* 默认都隐藏 */
        }

        .post-mode-content.active {
            display: block;
            /* 激活的才显示 */
        }

        /* ▲▲▲ 新样式结束 ▲▲▲ */

        /* === 相册页面背景色 === */
        #album-screen {
            background-color: #f0f2f5;
            /* 使用一个柔和的浅灰色，比纯白更护眼 */
        }

        /* === 相册页面网格布局 === */
        #album-grid-page {
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            /* 每行显示2个相册 */
            gap: 15px;
        }

        /* === 相册项目样式 (美化) === */
        .album-item {
            display: flex;
            flex-direction: column;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            border-radius: 8px;
            /* 给整个项目也加个圆角 */
        }

        .album-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.1);
        }

        .album-cover {
            aspect-ratio: 1 / 1;
            /* 保持封面为正方形 */
            background-size: cover;
            background-position: center;
            border-radius: 8px;
            margin-bottom: 8px;
            background-color: #f0f2f5;
            /* 封面加载前的占位颜色 */
        }

        .album-info {
            text-align: center;
        }

        .album-name {
            font-weight: 500;
            margin: 0 0 4px 0;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            /* 防止长名字换行 */
        }

        .album-count {
            font-size: 12px;
            color: var(--text-secondary);
            margin: 0;
        }

        /* ▲▲▲ 新的 CSS 粘贴结束 ▲▲▲ */

        /* ▼▼▼ 请将这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

        /* === 相册照片详情页 === */
        #album-photos-screen {
            background-color: #f0f2f5;
        }

        #photos-grid-page {
            padding: 15px;
            display: grid;
            /* 每行显示3张照片，并保持间距 */
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .photo-item {
            position: relative;
            /* 为了定位删除按钮 */
            aspect-ratio: 1 / 1;
            /* 保持照片为正方形 */
            border-radius: 6px;
            overflow: hidden;
            /* 防止图片溢出圆角 */
            background-color: #e9ecef;
            /* 图片加载前的占位符颜色 */
        }

        .photo-item .photo-thumb {
            width: 100%;
            height: 100%;
            object-fit: cover;
            /* 保证图片填满容器且不变形 */
            cursor: pointer;
        }

        /* 删除按钮的样式 */
        .photo-item .photo-delete-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 22px;
            height: 22px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 16px;
            line-height: 22px;
            text-align: center;
            cursor: pointer;
            opacity: 0;
            /* 默认隐藏 */
            transition: opacity 0.2s ease;
        }

        /* 鼠标悬停在照片上时显示删除按钮 */
        .photo-item:hover .photo-delete-btn {
            opacity: 1;
        }

        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

        /* === 图片查看器模态框样式 === */
        #photo-viewer-modal {
            background-color: rgba(0, 0, 0, 0.85);
            z-index: 1002;
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
        }

        .photo-viewer-content {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        #photo-viewer-image {
            max-width: 90vw;
            /* 图片最大宽度为视口的90% */
            max-height: 85vh;
            /* 图片最大高度为视口的85% */
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            /* 为图片的切换添加一点平滑的淡入淡出效果 */
            transition: opacity 0.2s ease-in-out;
        }

        /* 关闭按钮 */
        #photo-viewer-close-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: white;
            font-size: 40px;
            font-weight: 200;
            cursor: pointer;
            line-height: 1;
            text-shadow: 0 0 5px black;
        }

        /* 左右导航箭头 */
        #photo-viewer-modal .nav-arrow {
            position: absolute;
            /* 现在我们用绝对定位来控制箭头 */
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 50px;
            /* 在手机屏幕上，可以稍微小一点 */
            font-weight: 100;
            cursor: pointer;
            padding: 10px;
            /* 调整内边距 */
            user-select: none;
            transition: color 0.2s;
            z-index: 1003;
            /* 确保箭头在最上层 */
        }

        #photo-viewer-prev-btn {
            left: 5px;
            /* 定位左箭头 */
        }

        #photo-viewer-next-btn {
            right: 5px;
            /* 定位右箭头 */
        }

        #photo-viewer-modal .nav-arrow:hover {
            color: white;
        }

        /* 当箭头被禁用时（比如第一张或最后一张） */
        #photo-viewer-modal .nav-arrow:disabled {
            color: rgba(255, 255, 255, 0.2);
            cursor: default;
        }

        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

        /* ▼▼▼ 请将这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

        /* ▼▼▼ 请用这块新CSS替换掉上一版的交互区CSS ▼▼▼ */

        /* === 帖子内容区 - 相对定位容器 === */
        /* === 帖子内容区 === */
        .post-main-content {
            /* 它现在只是一个普通的内容容器，不再需要特殊样式了 */
        }

        /* === 帖子互动图标区 (新样式) === */
        .post-feedback-icons {
            display: flex;
            justify-content: flex-start;
            /* 让图标靠左对齐 */
            align-items: center;
            gap: 12px;
            padding: 8px 0;
            /* 核心修改：给图标区域上下各8px的留白 */
        }

        .action-icon {
            cursor: pointer;
            color: var(--text-secondary);
            /* 默认灰色 */
            transition: all 0.2s ease-in-out;
        }

        .action-icon svg {
            width: 18px;
            height: 18px;
            fill: none;
            stroke: currentColor;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        /* 图标激活(点赞/收藏后)的样式 */
        .action-icon.active {
            color: #ff5252;
            /* 激活后变红色 */
            transform: scale(1.1);
            /* 轻微放大 */
        }

        .action-icon.active.favorite {
            color: #ffc107;
            /* 收藏用黄色 */
        }

        .action-icon.active svg {
            fill: currentColor;
            /* 激活后填充颜色 */
        }

        /* 点击时的动画效果 */
        .animate-like {
            animation: like-bounce 0.4s ease-in-out;
        }

        @keyframes like-bounce {
            0% {
                transform: scale(1);
            }

            25% {
                transform: scale(0.8);
            }

            50% {
                transform: scale(1.2);
            }

            75% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1.1);
            }
        }


        /* === 帖子底部评论区样式 (现在是独立部分) === */
        .post-footer {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #f0f0f0;
            /* 用一条浅色线分隔 */
            display: flex;
            align-items: center;
            gap: 8px;
            /* 调整整体间距 */
        }

        /* 评论区容器 */
        .comment-section {
            flex-grow: 1;
            /* 占据大部分空间 */
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .comment-section .comment-avatar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            object-fit: cover;
            flex-shrink: 0;
        }

        .comment-section .comment-input {
            width: 100%;
            padding: 8px 12px;
            border: none;
            background-color: #f0f2f5;
            border-radius: 14px;
            font-size: 13px;
            outline: none;
        }

        /* 新增的发送按钮样式 */
        .comment-send-btn {
            flex-shrink: 0;
            /* 防止被压缩 */
            padding: 8px 15px;
            border: none;
            background-color: var(--accent-color);
            color: white;
            border-radius: 14px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
        }

        /* AI回复按钮样式 */
        .call-ai-reply-btn {
            flex-shrink: 0;
            padding: 8px 12px;
            background-color: rgba(255, 255, 255, 0.8);
            color: #666;
            border: 1px solid #ddd;
            border-radius: 14px;
            font-size: 16px;
            cursor: pointer;
            margin-left: 5px;
            transition: all 0.2s ease;
        }

        .call-ai-reply-btn:hover {
            background-color: rgba(255, 255, 255, 1);
            border-color: var(--accent-color);
            color: var(--accent-color);
        }

        /* AI选择列表样式 */
        .ai-selection-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .ai-selection-item:hover {
            background-color: #f8f9fa;
        }

        .ai-selection-item input[type="checkbox"] {
            margin-right: 12px;
            width: 18px;
            height: 18px;
        }

        .ai-selection-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 12px;
            object-fit: cover;
            background-color: #eee;
        }

        .ai-selection-info {
            flex-grow: 1;
        }

        .ai-selection-name {
            font-weight: 500;
            margin-bottom: 2px;
        }

        .ai-selection-status {
            font-size: 12px;
            color: #666;
        }

        /* 表情包选择列表样式 */
        .pack-selection-item {
            display: flex;
            align-items: center;
            padding: 12px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
        }

        .pack-selection-item:hover {
            background-color: #f8f9fa;
        }

        .pack-selection-item input[type="radio"] {
            margin-right: 12px;
            width: 18px;
            height: 18px;
        }

        .pack-selection-info {
            flex-grow: 1;
        }

        .pack-selection-name {
            font-weight: 500;
            margin-bottom: 2px;
        }

        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

        /* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

        /* === 未读消息小红点通用样式 === */
        .unread-indicator {
            position: absolute;
            top: -8px;
            right: -15px;
            min-width: 18px;
            height: 18px;
            padding: 0 5px;
            background-color: #ff3b30;
            color: white;
            font-size: 11px;
            font-weight: bold;
            line-height: 18px;
            text-align: center;
            border-radius: 9px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            display: none;
            z-index: 1;
        }

        /* 聊天界面返回按钮上的小红点 (只显示点，不显示数字) */
        .back-btn-indicator {
            top: 0;
            right: -8px;
            /* 放到返回箭头右上角 */
            width: 10px;
            height: 10px;
            min-width: 10px;
            padding: 0;
            border-radius: 50%;
        }

        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

        /* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

        /* === 评论列表容器 === */
        .post-comments-container {
            padding: 10px 0;
            /* 上下留白 */
            display: flex;
            flex-direction: column;
            gap: 8px;
            /* 评论之间的间距 */
            font-size: 13px;
            /* 统一评论区字体大小 */
        }

        /* 每一条评论 */
        .comment-item {
            line-height: 1.5;
        }

        /* 评论者的名字，加粗并使用主题色 */
        .comment-item .commenter-name {
            font-weight: 600;
            color: var(--accent-color);
            cursor: pointer;
            margin-right: 5px;
            /* 和评论内容之间留点空隙 */
        }

        /* 评论内容 */
        .comment-item .comment-text {
            color: var(--text-primary);
            word-break: break-word;
        }

        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

        /* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

        /* === 帖子点赞区域样式 === */
        .post-likes-section {
            display: flex;
            align-items: center;
            gap: 6px;
            /* 图标和文字的间距 */
            padding: 8px 10px;
            /* 内边距 */
            font-size: 13px;
            color: var(--accent-color);
            /* 使用主题蓝色 */
            background-color: #f0f5fa;
            /* 给一个淡淡的背景色 */
            border-top: 1px solid #e9eef3;
            border-bottom: 1px solid #e9eef3;
            margin-top: 5px;
            /* 和上方的图标保持一点距离 */
        }

        .post-likes-section .like-icon {
            width: 16px;
            height: 16px;
            fill: currentColor;
            /* 让SVG图标继承父元素的颜色 */
            flex-shrink: 0;
            /* 防止图标被压缩 */
        }

        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

        /* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

        /* === @提及 弹出菜单样式 === */
        .at-mention-popup {
            position: absolute;
            /* 相对于父元素定位 */
            bottom: 100%;
            /* 显示在输入框的上方 */
            left: 40px;
            /* 和输入框左侧对齐 (考虑了头像宽度) */
            width: calc(100% - 40px);
            /* 宽度和输入框差不多 */
            max-height: 120px;
            overflow-y: auto;
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.1);
            z-index: 10;
            display: none;
            /* 默认隐藏 */
        }

        .at-mention-item {
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            color: var(--text-primary);
            border-bottom: 1px solid #f0f0f0;
        }

        .at-mention-item:last-child {
            border-bottom: none;
        }

        .at-mention-item:hover {
            background-color: #f5f5f5;
        }

        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

        /* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

        /* ▼▼▼ 请用下面这段【新样式】替换掉你现有的 #favorites-list 样式 ▼▼▼ */

        /* 让收藏视图成为一个flex容器, 从上到下排列 */
        #favorites-view {
            display: flex;
            flex-direction: column;
        }

        /* 确保收藏页的header高度固定，不被压缩 */
        #favorites-view>.header {
            flex-shrink: 0;
        }

        /* === 收藏列表样式 (修正后) === */
        #favorites-list {
            flex-grow: 1;
            overflow-y: auto;
            overflow-x: hidden;
            /* <-- 新增这行，禁止水平滚动 */
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* ▲▲▲ 替换结束 ▲▲▲ */

        .favorite-item-card {
            background-color: var(--secondary-bg);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
            position: relative;
            /* 为了定位删除按钮 */
        }

        /* 卡片头部，包含头像、名字和来源 */
        .fav-card-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .fav-card-header .avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            object-fit: cover;
        }

        .fav-card-header .info {
            flex-grow: 1;
        }

        .fav-card-header .name {
            font-weight: 600;
            font-size: 15px;
        }

        .fav-card-header .source {
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* 卡片内容 */
        .fav-card-content {
            font-size: 14px;
            line-height: 1.6;
            color: #333;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .fav-card-content .chat-image {
            margin-top: 8px;
            /* 图片和文字的间距 */
        }

        /* 删除按钮 */
        .fav-delete-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 28px;
            height: 28px;
            background: #f0f2f5;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            color: var(--text-secondary);
            line-height: 28px;
            text-align: center;
        }

        .fav-delete-btn:hover {
            background-color: #e9ecef;
            color: #ff3b30;
        }

        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

        /* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

        /* === 搜索栏样式 === */
        .search-bar-container {
            padding: 10px 15px;
            background-color: #f9f9f9;
            /* 和列表背景色保持一致 */
            position: relative;
            /* 为了定位清除按钮 */
            flex-shrink: 0;
        }

        #favorites-search-input {
            width: 100%;
            padding: 10px 30px 10px 15px;
            /* 右侧留出清除按钮的位置 */
            font-size: 14px;
            border: 1px solid var(--border-color);
            border-radius: 18px;
            /* 圆角矩形，更现代化 */
            background-color: var(--secondary-bg);
            box-sizing: border-box;
            outline: none;
        }

        #favorites-search-input:focus {
            border-color: var(--accent-color);
        }

        .search-clear-btn {
            position: absolute;
            right: 25px;
            top: 50%;
            transform: translateY(-50%);
            background: #ccc;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            line-height: 20px;
            text-align: center;
            font-size: 16px;
            cursor: pointer;
        }

        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

        /* === 聊天界面多选操作栏优化 === */
        #chat-interface-screen .header .selection-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        #chat-interface-screen .selection-controls .action-btn {
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            padding: 5px;
        }

        /* === 收藏页面多选模式样式 === */
        #favorites-view.selection-mode .favorite-item-card {
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        /* 选择框的样式 */
        .favorite-item-card::before {
            content: '';
            position: absolute;
            left: -25px;
            /* 把它放在卡片左边外面 */
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            border: 2px solid #ccc;
            border-radius: 50%;
            background-color: white;
            transition: all 0.2s ease;
            opacity: 0;
            /* 默认隐藏 */
        }

        /* 进入选择模式时，卡片向右移动，露出选择框 */
        #favorites-view.selection-mode .favorite-item-card {
            transform: translateX(35px);
        }

        #favorites-view.selection-mode .favorite-item-card::before {
            opacity: 1;
        }

        /* 选中后的样式 */
        #favorites-view.selection-mode .favorite-item-card.selected::before {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            content: '✔';
            color: white;
            font-size: 14px;
            text-align: center;
            line-height: 20px;
        }

        /* 底部操作栏 (终极修正版) */
        #favorites-action-bar {
            position: absolute;
            /* ★ 改为 absolute，相对于 #phone-screen 定位 */
            bottom: 0;
            left: 0;
            right: 0;
            /* ★ 新增 right: 0，和 left: 0 一起撑满宽度 */
            width: auto;
            /* ★ 改为 auto，让 left/right 决定宽度 */
            padding: 10px 15px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            /* 适配iPhone底部安全区 */
            background-color: rgba(247, 247, 247, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-top: 1px solid var(--border-color);
            box-sizing: border-box;
            z-index: 5;
            display: none;
            /* max-width 已经不需要了，因为父元素已经限制了宽度 */
        }

        #favorites-action-bar .action-bar-btn {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: none;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            background-color: #ff3b30;
            color: white;
        }

        /* === 【修正】聊天界面头部控件切换逻辑 === */

        /* 默认状态：隐藏多选控件 */
        #chat-interface-screen .header .selection-controls {
            display: none;
        }

        /* 默认状态：显示默认控件，并让它撑满整个头部 */
        #chat-interface-screen .header .default-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        /* 当进入多选模式时：隐藏默认控件 */
        #chat-interface-screen.selection-mode .header .default-controls {
            display: none;
        }

        /* 当进入多选模式时：显示多选控件，并让它撑满整个头部 */
        #chat-interface-screen.selection-mode .header .selection-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        /* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

        /* === 修正：放大所有主要的“+”号按钮 === */
        #add-chat-btn,
        #add-world-book-btn,
        #create-album-btn-page {
            font-size: 28px;
            /* 显著增大字体大小，使其视觉上与旁边的图标匹配 */
            font-weight: 300;
            /* 使用更细的字重，让加号看起来更清爽，不显粗笨 */
            position: relative;
            /* 允许进行位置微调 */
            top: -1px;
            /* 字体放大后，通常需要稍微向上移动一点，使其视觉上更居中 */
        }

        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

        /* ▼▼▼ 请将这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

        /* 预览区容器样式 */
        #settings-preview-area {
            width: 100%;
            height: 180px;
            /* 给一个固定的高度 */
            background-color: #f0f2f5;
            border-radius: 8px;
            padding: 15px;
            box-sizing: border-box;
            overflow: hidden;
            /* 防止内容溢出 */
            display: flex;
            flex-direction: column;
            gap: 10px;
            /* 预览气泡之间的间距 */
            border: 1px solid var(--border-color);
            position: relative;
            /* 为了定位背景 */
        }

        /* 预览区的背景，可以和真实聊天界面同步 */
        #settings-preview-area::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            z-index: 1;
            opacity: 0.8;
        }

        /* 让预览气泡在背景之上 */
        #settings-preview-area .message-wrapper {
            position: relative;
            z-index: 2;
        }

        /* 预览区内使用的头像要小一点 */
        #settings-preview-area .message-bubble .avatar {
            width: 30px;
            height: 30px;
        }

        #settings-preview-area .avatar-with-frame {
            width: 30px;
            height: 30px;
        }

        #settings-preview-area .avatar-with-frame .avatar-frame {
            width: 44px;
            height: 44px;
            top: -7px;
            left: -7px;
        }

        #settings-preview-area .message-bubble .timestamp {
            display: none;
            /* 预览区不需要显示时间戳 */
        }

        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

        /* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */
        .existing-group-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .existing-group-item .group-name {
            font-weight: 500;
        }

        .existing-group-item .delete-group-btn {
            color: #ff3b30;
            font-size: 20px;
            cursor: pointer;
            padding: 5px;
        }

        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

        /* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */
        .chat-group-container {
            border-bottom: 1px solid var(--border-color);
        }

        .chat-group-container:first-child {
            border-top: 1px solid var(--border-color);
        }

        .chat-group-header {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            cursor: pointer;
            background-color: #f7f7f7;
        }

        .chat-group-header .arrow {
            font-size: 14px;
            margin-right: 8px;
            transition: transform 0.2s ease;
        }

        .chat-group-header.collapsed .arrow {
            transform: rotate(-90deg);
        }

        .chat-group-header .group-name {
            font-weight: 600;
            font-size: 15px;
        }

        .chat-group-content {
            max-height: 1000px;
            /* 一个足够大的值 */
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
        }

        .chat-group-content.collapsed {
            max-height: 0;
        }

        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

        /* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */

        /* 格式助手按钮的容器 */
        .format-helpers {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            /* 与下方的文本框拉开距离 */
            flex-wrap: wrap;
            /* 如果按钮太多可以换行 */
        }

        /* 单个格式助手按钮的样式 */
        .format-btn {
            background-color: #e9ecef;
            color: var(--text-primary);
            border: none;
            padding: 6px 12px;
            border-radius: 16px;
            /* 胶囊形状，更友好 */
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .format-btn:hover {
            background-color: #dcdfe3;
        }

        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

        /* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */

        /* “…”按钮的样式 */
        .post-actions-btn {
            margin-left: auto;
            /* 关键：让它自动靠到最右边 */
            padding: 5px 10px;
            font-size: 24px;
            font-weight: bold;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 50%;
            line-height: 1;
            transition: none;
        }

        .post-actions-btn:hover {
            background-color: #f0f0f0;
        }

        .post-actions-btn:active {
            background-color: #f0f0f0;
        }

        /* 动态编辑模态框的样式 (它将复用现有的操作菜单样式) */
        #post-actions-modal .custom-modal-footer button {
            width: 100%;
            border: none;
            border-bottom: 1px solid #dbdbdb;
            padding: 14px;
            font-size: 18px;
        }

        #post-actions-modal .custom-modal-footer button:last-child {
            border-bottom: none;
        }

        #post-actions-modal #cancel-post-action-btn {
            margin-top: 8px;
            border-radius: 8px;
            background-color: #f0f0f0;
        }

        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

        /* ▼▼▼ Share Link Functionality Styles ▼▼▼ */
        /* 1. Browser interface background and content area styles */
        #browser-screen {
            background-color: #f8f9fa;
        }

        #browser-content {
            padding: 20px;
            font-size: 16px;
            line-height: 1.8;
            color: #333;
            overflow-y: auto;
            background-color: #f8f9fa;
        }

        #browser-content .article-title {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        #browser-content .article-meta {
            font-size: 13px;
            color: #8a8a8a;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e0e0e0;
        }

        #browser-content .article-body {
            white-space: pre-wrap;
            word-break: break-word;
        }

        #browser-content .article-body p {
            margin-bottom: 1em;
        }

        /* 2. Link card styles in chat bubbles */
        .message-bubble.is-link-share .content {
            padding: 0;
            background: transparent;
            box-shadow: none;
            border: none;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }

        .link-share-card {
            width: 210px;
            background-color: #fff;
            border-radius: 10px;
            border: 1px solid #e0e0e0;
            padding: 12px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .link-share-card:hover {
            background-color: #f9f9f9;
        }

        .link-share-card .title {
            font-weight: 600;
            font-size: 15px;
            line-height: 1.4;
            color: #1f1f1f;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .link-share-card .description {
            font-size: 13px;
            color: #8a8a8a;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .link-share-card .footer {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        .link-share-card .footer-icon {
            width: 14px;
            height: 14px;
            flex-shrink: 0;
        }

        /* ▲▲▲ Share Link Styles End ▲▲▲ */

        /* ▼▼▼ Location Share Message Styles ▼▼▼ */
        .message-bubble.is-location-share .content {
            padding: 4px;
            margin: 0;
        }

        .location-share-content {
            display: flex;
            flex-direction: row;
            gap: 12px;
            width: 240px;
            min-height: 64px;
        }

        .location-map-image {
            position: relative;
            width: 64px;
            height: 64px;
            border-radius: 4px;
            overflow: hidden;
            flex-shrink: 0;
        }

        .location-map-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .location-map-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .location-pin-icon {
            width: 20px;
            height: 20px;
        }

        .location-details {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
            justify-content: center;
        }

        .location-details .location-name {
            font-weight: 600;
            font-size: 15px;
            line-height: 1.4;
            color: #1f1f1f;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .location-details .location-address {
            font-size: 13px;
            color: #666;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* ▲▲▲ Location Share Card Styles End ▲▲▲ */

        /* ▼▼▼ Meetup Screen Styles ▼▼▼ */
        #meetup-screen {
            background: linear-gradient(135deg, #ffeef8, #f0f8ff);
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        #meetup-context-bar {
            background: rgba(255, 255, 255, 0.9);
            padding: 12px 20px;
            border-bottom: 1px solid #e0e0e0;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .context-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .event-location,
        .event-time,
        .event-phase {
            font-size: 13px;
            color: #666;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .end-date-button {
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
            color: white;
            border: none;
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 2px 8px rgba(255, 107, 107, 0.3);
        }

        .end-date-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 107, 107, 0.4);
        }

        .event-phase {
            color: #8e44ad;
            font-weight: 500;
        }

        .meetup-messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        /* Meetup uses regular chat message styling, but we override text colors with higher specificity */
        #meetup-messages .message-bubble.user .content,
        #meetup-messages .message-bubble.ai .content {
            color: var(--text-primary);
        }

        .behavioral-notation {
            color: #888888;
            font-style: italic;
        }

        .event-context-indicator {
            background: rgba(142, 68, 173, 0.1);
            border: 1px solid rgba(142, 68, 173, 0.3);
            border-radius: 12px;
            padding: 8px 12px;
            margin: 8px 0;
            text-align: center;
            font-size: 13px;
            color: #8e44ad;
            font-style: italic;
        }

        .phase-transition {
            background: linear-gradient(135deg, #ff9a9e, #fecfef);
            border-radius: 12px;
            padding: 10px 16px;
            margin: 12px 0;
            text-align: center;
            font-size: 14px;
            color: #8e44ad;
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(255, 154, 158, 0.3);
        }

        .meetup-input-container {
            flex-shrink: 0;
            padding: 8px;
            background-color: rgba(247, 247, 247, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        #meetup-input-main-row {
            display: flex;
            align-items: flex-end;
            gap: 8px;
        }

        #meetup-input {
            flex-grow: 1;
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            background-color: var(--secondary-bg);
            font-size: 16px;
            max-height: 100px;
            resize: none;
        }

        #meetup-input::placeholder {
            color: #999;
            font-style: italic;
        }

        .meetup-actions-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        #meetup-wait-reply-btn {
            background: none;
            border: none;
            padding: 4px;
            cursor: pointer;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        #meetup-wait-reply-btn:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        #meetup-wait-reply-btn img {
            width: 24px;
            height: 24px;
        }

        #meetup-send-btn {
            background: linear-gradient(135deg, #ff6b9d, #c44569);
            color: white;
            border: none;
            border-radius: 16px;
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        #meetup-send-btn:hover {
            opacity: 0.9;
        }

        #meetup-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Meetup header styles - match chat interface */
        #meetup-screen .header .default-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        #meetup-screen .header .selection-controls {
            display: none;
            width: 100%;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }

        #meetup-screen.selection-mode .header .default-controls {
            display: none;
        }

        #meetup-screen.selection-mode .header .selection-controls {
            display: flex;
        }

        #meetup-selection-cancel-btn {
            color: var(--text-primary);
            cursor: pointer;
            font-size: 16px;
        }

        #meetup-selection-count {
            color: var(--text-primary);
            font-size: 16px;
            font-weight: 500;
        }

        /* ▲▲▲ Meetup Screen Styles End ▲▲▲ */

        /* ▼▼▼ Meetup History Screen Styles (Same as Meetup) ▼▼▼ */
        /* History mode should look exactly like meetup screen - no background changes needed */
        /* ▲▲▲ Meetup History Screen Styles End ▲▲▲ */

        /* ▼▼▼ 【全新】精致版转账操作弹窗样式 ▼▼▼ */
        .transfer-actions-content {
            background-color: #fff0f5;
            /* 粉嫩的背景色 */
            border-radius: 20px;
            width: 290px;
            padding: 20px;
            box-shadow: 0 5px 25px rgba(255, 105, 180, 0.3);
            /* 粉色阴影 */
            text-align: center;
            position: relative;
            border: 1px solid #ffcce0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        .transfer-actions-header {
            font-size: 20px;
            font-weight: bold;
            color: #a35c7b;
            /* 深粉色标题 */
            margin-bottom: 15px;
        }

        .transfer-actions-body p {
            font-size: 15px;
            color: #666;
            margin-bottom: 20px;
            line-height: 1.4;
        }

        .transfer-actions-footer {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .transfer-actions-footer .action-btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
        }

        .transfer-actions-footer .action-btn.accept {
            background: linear-gradient(135deg, #ff85b3, #ff6b9d);
            box-shadow: 0 4px 15px rgba(255, 107, 157, 0.4);
        }

        .transfer-actions-footer .action-btn.accept:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 157, 0.6);
        }

        .transfer-actions-footer .action-btn.decline {
            background: linear-gradient(135deg, #c2c2c2, #a0a0a0);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .transfer-actions-content .cancel-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: none;
            background-color: rgba(0, 0, 0, 0.1);
            color: #a35c7b;
            font-size: 20px;
            line-height: 28px;
            cursor: pointer;
        }

        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

        /* 统一重置转账卡片内所有文字的特效和颜色 */
        #chat-messages .transfer-card .transfer-title,
        #chat-messages .transfer-card .transfer-amount,
        #chat-messages .transfer-card .transfer-note {
            text-shadow: none !important;
            /* 强制移除任何发光或阴影效果 */
            color: white !important;
            /* 强制锁定文字颜色为白色 */
        }

        /* 分别锁定各自的字体大小和字重，防止被篡改 */
        #chat-messages .transfer-card .transfer-title {
            font-size: 16px !important;
            font-weight: 600 !important;
        }

        #chat-messages .transfer-card .transfer-amount {
            font-size: 28px !important;
            font-weight: bold !important;
        }

        #chat-messages .transfer-card .transfer-note {
            font-size: 13px !important;
            opacity: 0.9 !important;
        }

        /* ▼▼▼ 请用下面这【一整块】全新的自适应代码，替换掉所有旧的头像相关样式 ▼▼▼ */

        /* 1. 头像容器的【默认/无框】状态 */
        .avatar-group {
            width: 34px;
            /* 默认宽度，和头像图片一样宽 */
            flex-shrink: 0;
            position: relative;
            transition: width 0.2s ease;
            /* 添加一个平滑的宽度变化动画 */
        }

        /* 2. 当【有框】时，头像容器自动变宽 */
        .avatar-group.has-frame {
            width: 42px;
            /* 变得更宽，为更大的头像图片和框留出空间 */
        }

        /* 3. 普通头像（无框时）的样式 */
        .message-bubble .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            flex-shrink: 0;
        }

        /* 4. 带框头像的容器【默认】大小 */
        .avatar-with-frame {
            position: relative;
            width: 40px;
            /* 默认和普通头像一样大 */
            height: 40px;
            margin: 0 auto;
            transition: all 0.2s ease;
            /* 为大小变化添加动画 */
            flex-shrink: 0;
        }

        /* 5. 当【有框】时，带框头像的容器自动【变大】，解决您说的“图小框大”问题！ */
        .avatar-group.has-frame .avatar-with-frame {
            width: 67px;
            /* 图片容器变大 */
            height: 67px;
        }

        /* 6. 头像图片本身，永远撑满它的容器 */
        .avatar-with-frame .avatar-img {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            object-fit: cover;
            z-index: 1;
        }

        /* 7. 头像框，永远基于它的父容器居中 */
        .avatar-with-frame .avatar-frame {
            position: absolute;
            width: 67px;
            height: 67px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
            pointer-events: none;
        }

        /* ▲▲▲ 替换结束 ▲▲▲ */

        /* ▼▼▼ 这是新增的样式，用于修正所有头部标题的居中问题 ▼▼▼ */
        .header>span:nth-child(2),
        #chat-header-title,
        #meetup-title {
            position: absolute;
            left: 50%;
            transform: translateX(calc(-50% - 2px));
            /* 在-50%的基础上，再向左推2像素 */

            /* (可选但推荐) 防止长标题与两边按钮重叠 */
            max-width: 60%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* ▲▲▲ 粘贴结束 ▲▲▲ */

        /* ▼▼▼ 【全新】可视化消息编辑器样式 ▼▼▼ */
        #message-editor-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .message-editor-block {
            background-color: #f9f9f9;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
        }

        .message-editor-block textarea {
            width: 100%;
            min-height: 60px;
            resize: vertical;
            border: 1px solid #ccc;
            border-radius: 6px;
            padding: 8px;
            font-size: 14px;
            box-sizing: border-box;
        }

        .message-editor-block .format-helpers {
            margin-top: 8px;
            margin-bottom: 0;
            /* 覆盖默认的 margin-bottom */
        }

        .message-editor-block .delete-block-btn {
            float: right;
            margin-top: -5px;
            background: none;
            border: none;
            color: #ff3b30;
            font-size: 20px;
            cursor: pointer;
        }

        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

        /* ▼▼▼ 【全新】联系人选择器样式 ▼▼▼ */
        .contact-picker-item {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
        }

        .contact-picker-item .checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid #ccc;
            border-radius: 50%;
            margin-right: 15px;
            transition: all 0.2s ease;
        }

        .contact-picker-item.selected .checkbox {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            content: '✔';
            color: white;
            font-size: 14px;
            text-align: center;
            line-height: 20px;
        }

        .contact-picker-item .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 12px;
        }

        .contact-picker-item .name {
            font-weight: 500;
        }

        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

        /* ▼▼▼ 【全新】修复联系人选择器“取消”按钮字体大小 ▼▼▼ */
        #cancel-contact-picker-btn {
            font-size: 16px;
            /* 覆盖 .back-btn 的 24px，与右侧“完成”按钮保持一致 */
            font-weight: 600;
            /* 同样设置字重以保证视觉统一 */
            width: auto;
            /* 覆盖 .back-btn 固定的30px宽度，让其宽度自适应“取消”二字 */
            padding: 0 5px;
            /* 增加一点左右内边距，让文字不显得拥挤 */
        }

        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */


        /* ▼▼▼ 【全新】群成员管理界面样式 ▼▼▼ */
        #member-management-list {
            padding: 0;
            /* 移除默认padding，让列表项撑满 */
        }

        .member-management-item {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .member-management-item .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 12px;
        }

        .member-management-item .name {
            flex-grow: 1;
            font-weight: 500;
        }

        .member-management-item .remove-member-btn {
            background-color: #ff3b30;
            color: white;
            border: none;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            font-size: 20px;
            line-height: 28px;
            text-align: center;
            cursor: pointer;
            flex-shrink: 0;
        }

        #member-management-actions {
            flex-shrink: 0;
            padding: 15px;
            border-top: 1px solid var(--border-color);
            background-color: #f7f7f7;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #member-management-actions button {
            width: 100%;
            padding: 15px;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }

        #member-management-actions #create-new-member-btn {
            background-color: #4cd964;
            /* 新建用绿色，以示区分 */
        }

        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

        /* ▼▼▼ 【全新】外卖代付卡片样式 ▼▼▼ */
        .message-bubble.is-waimai-request .content {
            padding: 0;
            background: transparent;
            box-shadow: none;
            border: none;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }

        .waimai-card {
            width: 240px;
            border-radius: 12px;
            overflow: hidden;
            background-color: #fff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        .waimai-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            border-bottom: 1px solid #f0f0f0;
        }

        .waimai-header .icon {
            width: 20px;
            height: 20px;
        }

        .waimai-header .title-group {
            display: flex;
            align-items: baseline;
            font-size: 14px;
            color: #8a8a8a;
        }

        .waimai-header .title-group .brand {
            font-weight: 600;
            color: #555;
            margin-right: 5px;
        }

        .waimai-header .title-group .separator {
            margin: 0 5px;
        }

        .waimai-catchphrase {
            font-size: 13px;
            color: #1f1f1f;
            padding: 12px;
        }

        .waimai-main {
            background-color: #FFD66B;
            /* 橙黄色背景 */
            padding: 12px;
            text-align: center;
        }

        .waimai-main .request-title {
            font-size: 12px;
            color: #856404;
            margin-bottom: 8px;
        }

        .waimai-main .payment-box {
            background-color: #fff;
            border-radius: 8px;
            padding: 15px 10px;
        }

        .waimai-main .payment-label {
            font-size: 13px;
            color: #8a8a8a;
        }

        .waimai-main .amount {
            font-size: 32px;
            font-weight: 700;
            color: #1f1f1f;
            margin: 4px 0 12px 0;
        }

        .waimai-main .countdown-label {
            font-size: 13px;
            color: #8a8a8a;
        }

        .waimai-main .countdown-timer {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            margin-left: 5px;
        }

        .waimai-main .countdown-timer span {
            background-color: #333;
            color: white;
            padding: 2px 4px;
            border-radius: 2px;
            font-weight: bold;
            font-size: 12px;
        }

        .waimai-details-btn {
            width: 100%;
            padding: 10px 0;
            margin-top: 15px;
            border: none;
            border-radius: 6px;
            background-color: #FFC33A;
            color: #49380a;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }

        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

        /* ▼▼▼ 【全新】外卖响应状态样式 ▼▼▼ */

        /* === 同意支付后的样式 === */
        .message-bubble.status-paid .waimai-card {
            border: 2px solid #28a745;
            /* 绿色边框 */
        }

        .message-bubble.status-paid .waimai-main .request-title::before {
            content: '✅  ';
        }

        .message-bubble.status-paid .waimai-main .request-title {
            color: #155724;
            font-weight: 600;
            /* 重写 request-title 的内容 */
            content: "我已为您买单，请尽情享用吧～" !important;
            display: block;
            margin-bottom: 15px;
        }

        .message-bubble.status-paid .payment-box {
            display: none;
            /* 隐藏支付详情 */
        }

        .message-bubble.status-paid .waimai-details-btn {
            background-color: #28a745;
            color: white;
        }

        /* === 拒绝支付后的样式 === */
        .message-bubble.status-rejected .waimai-card {
            border: 2px solid #dc3545;
            /* 红色边框 */
            opacity: 0.8;
        }

        .message-bubble.status-rejected .waimai-main {
            background-color: #e9ecef;
        }

        .message-bubble.status-rejected .waimai-main .request-title::before {
            content: '❌ ';
        }

        .message-bubble.status-rejected .waimai-main .request-title {
            color: #721c24;
            font-weight: 600;
            /* 重写 request-title 的内容 */
            content: "我拒绝了您的代付请求" !important;
            display: block;
            margin-bottom: 15px;
        }

        .message-bubble.status-rejected .payment-box {
            display: none;
            /* 隐藏支付详情 */
        }

        .message-bubble.status-rejected .waimai-details-btn {
            background-color: #6c757d;
            color: white;
        }

        /* 强制重写 request-title 内容的技巧 */
        .message-bubble[class*="status-"] .request-title {
            font-size: 0;
            /* 隐藏原始文本 */
        }

        .message-bubble[class*="status-"] .request-title::after {
            font-size: 14px;
            /* 让伪元素显示新文本 */
        }

        .message-bubble.status-paid .request-title::after {
            content: "我已为您买单，请尽情享用吧～";
        }

        .message-bubble.status-rejected .request-title::after {
            content: "我拒绝了您的代付请求";
        }

        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

        /* ▼▼▼ 【全新】外卖请求的用户操作按钮样式 ▼▼▼ */
        .waimai-user-actions {
            display: flex;
            gap: 10px;
            padding: 0 12px 12px 12px;
            /* 在卡片底部留出空间 */
            background-color: #fff;
        }

        .waimai-user-actions button {
            flex: 1;
            padding: 10px;
            border-radius: 8px;
            border: 1.5px solid;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .waimai-pay-btn {
            background-color: #28a745;
            border-color: #1f7a33;
            color: white;
        }

        .waimai-pay-btn:hover {
            background-color: #218838;
        }

        .waimai-decline-btn {
            background-color: #f8f9fa;
            border-color: #ced4da;
            color: #495057;
        }

        .waimai-decline-btn:hover {
            background-color: #e2e6ea;
        }

        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

        /* === 【新增】统一设置页面的背景色 (已修正) === */
        #api-settings-screen,
        #appearance-settings-screen,
        #memories-view,
        #contact-picker-screen,
        /* <-- 新增这行 */
        #member-management-screen {
            /* <-- 新增这行 */
            background-color: var(--secondary-bg);
        }

        /* 确保这些页面的内容区能正确滚动 */
        #api-settings-screen .form-container,
        #appearance-settings-screen .form-container {
            padding-top: 100px;
            margin-top: -80px;
            background-color: var(--secondary-bg);
        }

        /* 设置页面的预览区比较特殊，需要额外调整 */
        #appearance-settings-screen .form-container {
            align-items: center;
            /* 保持内容居中 */
        }




        /* 确保壁纸预览不被压缩且可见 */
        #appearance-settings-screen #wallpaper-preview {
            flex-shrink: 0;
            margin-bottom: 20px;
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        /* 确保分隔线在外观设置页面中可见 */
        #appearance-settings-screen hr {
            display: block !important;
            width: 100% !important;
            border: 0;
            border-top: 1px solid #000;
            align-self: stretch !important;
        }

        /* Calendar app styles */
        .calendar-month-view-no-card {
            padding: 8px 0;
            margin-bottom: 20px;
        }

        .calendar-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 8px;
        }

        .calendar-nav-btn {
            background: none;
            border: none;
            font-size: 24px;
            color: var(--accent-color);
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .calendar-nav-btn:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        .calendar-month-year {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
            margin-left: 8px;
        }

        .calendar-weekdays {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 4px;
            margin-bottom: 10px;
        }

        .weekday {
            text-align: center;
            padding: 8px;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 4px;
        }

        .calendar-date {
            text-align: center;
            cursor: pointer;
            font-size: 16px;
            color: var(--text-primary);
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            margin: 0 auto;
        }

        .calendar-date:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        .calendar-date.other-month {
            color: var(--text-secondary);
            opacity: 0.5;
        }

        .calendar-date.selected {
            background: transparent;
            color: white;
            position: relative;
        }

        .calendar-date.selected::before {
            content: '';
            position: absolute;
            top: calc(50% - 1px);
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            background: var(--accent-color);
            border-radius: 50%;
            z-index: -1;
        }

        .calendar-date.today.selected {
            color: white;
        }

        .calendar-date.today {
            background: rgba(var(--accent-color-rgb), 0.1);
            color: var(--accent-color);
            font-weight: 600;
        }

        /* Memory indicators on calendar dates */
        .calendar-date {
            position: relative;
        }

        .memory-indicators {
            position: absolute;
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2px;
        }

        .memory-indicator {
            width: 4px;
            height: 4px;
            border-radius: 50%;
        }

        .memory-indicator.user-memory {
            background: #007AFF;
            /* Blue for user's manual memories */
        }

        .memory-indicator.ai-memory {
            background: #FF8C00;
            /* Darker yellow/orange for AI-generated memories */
        }

        .memory-indicator.countdown {
            background: #9370DB;
            /* Lighter purple for countdown events */
        }

        .memory-indicator.meetup {
            background: #FF3B30;
            /* Red for meetup events */
        }

        .calendar-events-section {
            background: rgb(247, 247, 247);
            padding: 20px;
            margin: 0 -20px -20px -20px;
            /* Negative margins to bleed to edges: top=0, right=-20px, bottom=-20px, left=-20px */
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        .calendar-events-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .calendar-events-header #selected-date-display {
            margin-left: 8px;
        }

        .calendar-events-list {
            flex: 1;
            min-height: 100px;
            /* Removed padding-bottom: 24px; - using spacer div instead */
        }

        .no-events-message {
            text-align: center;
            color: var(--text-secondary);
            font-style: italic;
            padding: 20px;
        }

        /* NEW: Calendar memory item styles - copying qzone post styling */
        .calendar-memory-item {
            padding: 12px;
            margin-bottom: 16px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .calendar-memory-item:last-child {
            margin-bottom: 44px !important;
            /* 20px to offset negative margin + 24px extra spacing */
        }

        /* Memory type styling */
        .calendar-memory-item.memory-type {
            background-color: #fffaf0;
            /* Pale yellow for memories */
        }

        .calendar-memory-item.countdown-type {
            background: linear-gradient(135deg, #667eea, #764ba2);
            /* Purple gradient for events */
            color: white;
        }

        .calendar-memory-item.countdown-type .memory-header,
        .calendar-memory-item.countdown-type .memory-content,
        .calendar-memory-item.countdown-type .memory-nickname,
        .calendar-memory-item.countdown-type .memory-timestamp,
        .calendar-memory-item.countdown-type .post-actions-btn {
            color: white !important;
        }

        /* Meetup type styling */
        .calendar-memory-item.meetup-type {
            background: linear-gradient(135deg, #667eea, #764ba2);
            /* Purple gradient for meetup (same as countdown) */
            color: white;
        }

        .calendar-memory-item.meetup-type .memory-header,
        .calendar-memory-item.meetup-type .memory-content,
        .calendar-memory-item.meetup-type .memory-nickname,
        .calendar-memory-item.meetup-type .memory-timestamp,
        .calendar-memory-item.meetup-type .post-actions-btn {
            color: white !important;
        }

        /* Clickable meetup events */
        .calendar-memory-item.meetup-type[style*="cursor: pointer"]:hover,
        .calendar-memory-item.countdown-type[style*="cursor: pointer"]:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            transition: all 0.2s ease;
        }

        /* Meetup status indicators */
        .meetup-status-indicator {
            font-size: 12px;
            font-weight: 600;
            margin-right: 8px;
            padding: 2px 6px;
            border-radius: 10px;
            white-space: nowrap;
        }

        .meetup-status-indicator.active {
            background-color: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
        }

        .meetup-status-indicator.template {
            background-color: rgba(102, 126, 234, 0.2);
            color: #667eea;
        }

        /* Ensure status indicators are visible on purple gradient backgrounds */
        .calendar-memory-item.countdown-type .meetup-status-indicator.template,
        .calendar-memory-item.meetup-type .meetup-status-indicator.template {
            background-color: rgba(255, 255, 255, 0.3);
            color: white;
        }

        .calendar-memory-item.countdown-type .meetup-status-indicator.active,
        .calendar-memory-item.meetup-type .meetup-status-indicator.active {
            background-color: rgba(255, 255, 255, 0.3);
            color: #90EE90;
        }

        /* Memory actions container - positioned in top right */
        .memory-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }



        /* Meetup indicator styling */
        .meetup-indicator {
            display: flex;
            align-items: center;
            opacity: 0.9;
        }

        .meetup-indicator svg {
            color: white;
        }

        /* Copy exact post-header styling */
        .memory-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .memory-header .memory-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
        }

        .memory-info {
            display: flex;
            flex-direction: column;
            flex: 1;
        }

        .memory-info .memory-nickname {
            font-weight: 600;
            font-size: 15px;
            color: var(--text-primary);
        }

        .memory-info .memory-timestamp {
            font-size: 12px;
            color: var(--text-secondary);
        }



        .memory-content {
            font-size: 14px;
            line-height: 1.6;
            color: #333;
            white-space: pre-wrap;
            word-break: break-word;
        }

        /* ▼▼▼ 【全新】来电请求与视频通话界面样式 ▼▼▼ */

        /* --- 来电请求模态框 --- */
        #incoming-call-modal .incoming-call-content {
            background-color: rgba(40, 40, 40, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 20px;
            width: 280px;
            padding: 30px 20px;
            text-align: center;
            color: white;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .caller-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 12px;
            border: 3px solid rgba(255, 255, 255, 0.5);
        }

        .caller-name {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .caller-text {
            font-size: 14px;
            color: #ccc;
            margin-bottom: 30px;
        }

        .incoming-call-actions {
            display: flex;
            justify-content: space-around;
            align-items: center;
        }

        .action-button-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #e0e0e0;
        }

        .call-action-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            background-size: 50%;
            background-repeat: no-repeat;
            background-position: center;
            /* transition: transform 0.2s, box-shadow 0.2s; - Removed to disable tap feedback */
            transition: box-shadow 0.2s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .call-action-btn:active {
            /* Tap feedback removed */
        }

        .call-action-btn.decline {
            background-color: #ff3b30;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 16.5L3 6m18 6l-5.6-5.6a1.2 1.2 0 0 0-1.7 0L3 18.2a1.2 1.2 0 0 0-.3 1.2l1.2 3.6a1.2 1.2 0 0 0 1.2.9h15.6a1.2 1.2 0 0 0 1.2-1.2V7.7a1.2 1.2 0 0 0-.3-1.1z"/></svg>');
        }

        .call-action-btn.accept {
            background-color: #4cd964;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>');
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(76, 217, 100, 0.7);
            }

            70% {
                box-shadow: 0 0 0 15px rgba(76, 217, 100, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(76, 217, 100, 0);
            }
        }

        /* --- 视频通话界面 --- */
        /* ▼▼▼ 请用这一整块【最终修正版】的代码，替换所有旧的 video-call 相关CSS ▼▼▼ */

        /* 1. 通话屏幕总容器 (保持不变) */
        #video-call-screen {
            background-color: #1c1c1e;
            color: white;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* 2. 顶部栏和底部控制栏 (保持不变) */
        .video-call-top-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px 20px;
            padding-top: 50px;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.5), transparent);
            z-index: 10;
            text-align: center;
            box-sizing: border-box;
            pointer-events: none;
        }

        #call-timer {
            font-size: 16px;
            font-weight: 500;
            letter-spacing: 1px;
        }

        .video-call-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 20px;
            padding-bottom: 40px;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.5), transparent);
            z-index: 10;
            box-sizing: border-box;
        }

        /* 3. 参与者头像显示区 (保持不变) */
        .video-call-avatar-area {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            padding-top: 80px;
            /* 确保顶部有足够空间 */
            box-sizing: border-box;
            overflow-y: auto;
            /* ★ 新增：如果头像太多，允许此区域滚动 */
        }

        /* 4. 头像网格容器 (保持不变) */
        #participant-avatars-grid {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 15px;
            /* ★ 稍微减小头像间距 */
            max-width: 100%;
        }

        /* 5. 单个参与者的头像容器 (头像缩小) */
        .participant-avatar-wrapper {
            position: relative;
            text-align: center;
            flex-shrink: 0;
        }

        .participant-avatar {
            width: 70px;
            /* ★ 从 80px 缩小到 70px */
            height: 70px;
            /* ★ 从 80px 缩小到 70px */
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        .participant-name {
            margin-top: 8px;
            font-size: 12px;
            color: #ccc;
        }

        /* 6. 发言者头像高亮效果 (保持不变) */
        .participant-avatar.speaking {
            border-color: #4cd964;
            box-shadow: 0 0 20px rgba(76, 217, 100, 0.6);
            transform: scale(1.05);
        }

        /* 7. 【最终版】对话框区域 */
        #video-call-main {
            flex-shrink: 0;
            height: 30%;
            /* ★ 核心修改：高度从35%减小到30% */
            margin: 15px 15px 130px 15px;
            /* ★ 核心修改：底部边距从120px增加到130px，创造明显空隙 */
            overflow-y: auto;
            padding: 15px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-sizing: border-box;
        }

        /* 8. 控制按钮样式 (保持不变) */
        .control-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            background-repeat: no-repeat;
            background-position: center;
            /* transition: transform 0.2s, background-color 0.2s; - Removed to disable tap feedback */
            transition: background-color 0.2s;
        }

        .control-btn:active {
            /* Tap feedback removed */
        }

        .control-btn.speak-btn {
            background-color: rgba(255, 255, 255, 0.2);
            background-size: 55%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>');
        }

        .control-btn.hangup-btn {
            background-color: #ff3b30;
            background-size: 50%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 16.5L3 6m18 6l-5.6-5.6a1.2 1.2 0 0 0-1.7 0L3 18.2a1.2 1.2 0 0 0-.3 1.2l1.2 3.6a1.2 1.2 0 0 0 1.2.9h15.6a1.2 1.2 0 0 0 1.2-1.2V7.7a1.2 1.2 0 0 0-.3-1.1z"/></svg>');
        }

        .control-btn.join-btn {
            background-color: #007bff;
            background-size: 50%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="17" y1="11" x2="23" y2="11"></line></svg>');
        }

        /* ▲▲▲ 新CSS替换结束 ▲▲▲ */

        /* ▼▼▼ 【全新】视频通话对话气泡样式 ▼▼▼ */
        .call-message-bubble {
            padding: 10px 15px;
            border-radius: 12px;
            max-width: 85%;
            line-height: 1.6;
            word-break: break-word;
            white-space: pre-wrap;
        }

        .call-message-bubble.ai-speech {
            background-color: rgba(255, 255, 255, 0.15);
            align-self: flex-start;
            /* AI发言靠左 */
        }

        .call-message-bubble.user-speech {
            background-color: #4cd964;
            /* 用户发言用绿色，类似微信 */
            align-self: flex-end;
            /* 用户发言靠右 */
            text-align: left;
            /* 确保用户气泡内的文字是左对齐的 */
        }

        /* ▲▲▲ 新增CSS结束 ▲▲▲ */

        /* ▼▼▼ 【全新添加】正在呼叫界面样式 ▼▼▼ */
        #outgoing-call-screen {
            background-color: #1c1c1e;
            color: white;
            justify-content: center;
            /* 垂直居中 */
            align-items: center;
            /* 水平居中 */
        }

        .outgoing-call-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .outgoing-call-actions {
            margin-top: 50px;
            /* 和上方文字拉开距离 */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #e0e0e0;
        }

        /* ▲▲▲ 添加结束 ▲▲▲ */

        /* 1. 动态帖子的外层容器，我们需要它来定位和裁剪 */
        .qzone-post-container {
            position: relative;
            /* 让内部的删除按钮可以相对于它定位 */
            overflow: hidden;
            /* 隐藏掉超出部分的删除按钮 */
            border-radius: 12px;
            /* 和内部卡片保持一致的圆角 */
        }

        /* 2. 可滑动的内容卡片，增加一个平滑的过渡效果 */
        .qzone-post-item {
            transition: transform 0.3s ease;
            background-color: var(--secondary-bg);
            /* 确保它有背景色，能盖住下面的删除按钮 */
            position: relative;
            /* 确保它在最上层 */
            z-index: 2;
        }

        /* 3. 【核心】这就是那个“删除”按钮的样式！*/
        .qzone-post-delete-action {
            position: absolute;
            /* 绝对定位，脱离文档流 */
            top: 0;
            right: 0;
            bottom: 0;
            width: 90px;
            /* 删除按钮的宽度 */
            background-color: #ff3b30;
            /* 您想要的红色背景 */
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 500;
            cursor: pointer;
            z-index: 1;
            /* 确保它在卡片下面 */
        }

        /* 4. 当卡片左滑时，把它向左移动，露出删除按钮 */
        .qzone-post-item.swiped {
            transform: translateX(-90px);
            /* 移动的距离和删除按钮的宽度一致 */
        }

        /* ▲▲▲ 粘贴结束 ▲▲▲ */

        /* ▼▼▼ 请将这【一整块】全新的“拍一拍”样式，粘贴到 <style> 的末尾 ▼▼▼ */

        /* 1. “拍一拍”的屏幕震动动画 */


        /* 2. “拍一拍”系统提示消息的样式 */
        .system-message {
            align-self: center;
            /* 居中显示 */
            padding: 4px 12px;
            margin: 5px 0;
            background-color: rgba(0, 0, 0, 0.1);
            color: var(--text-secondary);
            font-size: 12px;
            border-radius: 10px;
            text-align: center;
            max-width: 80%;
        }

        /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

        /* 让“拍一拍”类型的 wrapper 居中 */
        .message-wrapper.system-pat {
            justify-content: center;
            align-self: center;
            margin: 5px 0;
            max-width: 80%;
        }

        /* “拍一-拍”消息气泡的样式 */
        .message-bubble.system-bubble {
            background-color: rgba(0, 0, 0, 0.1);
            color: var(--text-secondary);
            font-size: 12px;
            padding: 4px 12px;
            border-radius: 10px;
        }

        /* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */

        /* === 修正：让顶部操作栏可以横向滚动 === */
        #chat-input-actions-top {
            display: flex;
            gap: 8px;
            padding: 0 5px;

            /* --- 核心代码开始 --- */
            overflow-x: auto;
            flex-wrap: nowrap;
            -webkit-overflow-scrolling: touch;

            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        #chat-input-actions-top::-webkit-scrollbar {
            display: none;
        }

        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

        /* === 【全新】聊天界面头部状态栏样式 === */

        /* 1. 标题和状态的总容器，使用flex布局让它们垂直排列 */
        #chat-header-title-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            /* 水平居中 */
            gap: 2px;
            /* 标题和状态之间的微小间距 */

            /* 为了让它能在flex布局中正确居中 */
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            max-width: 60%;
        }

        /* 2. 主标题的样式微调 */
        #chat-header-title {
            font-size: 16px;
            /* 可以稍微缩小一点，给状态栏留出空间 */
            font-weight: 600;
            position: static;
            /* 覆盖掉旧的absolute定位 */
            transform: none;
            /* 覆盖掉旧的transform */
            /* 保证长标题也能正确显示省略号 */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        /* 3. 状态栏容器 */
        #chat-header-status {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 11px;
            color: var(--text-secondary);
            transition: all 0.3s ease;
        }

        /* 4. 状态小圆点 */
        .status-dot {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            background-color: #4cd964;
            /* 默认绿色，代表在线 */
            transition: background-color 0.3s ease;
        }

        /* 当AI状态为“忙碌”或“离开”时，让圆点变灰色 */
        #chat-header-status.busy .status-dot {
            background-color: #cccccc;
        }

        /* 5. 状态文本 */
        .status-text {
            font-weight: 500;
        }

        /* === 【全新美化版】回忆卡片样式 === */

        /* 1. 卡片总容器：这里负责定义整体的背景色和边框 */
        .memory-card {
            background-color: #fffaf0;
            /* 统一的、温暖的米黄色背景 */
            border-radius: 12px;
            padding: 15px;
            /* 在卡片四周留出内边距 */
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.07);
            border-left: 5px solid #ffb74d;
            display: flex;
            /* 让它成为flex容器，方便内部元素排列 */
            flex-direction: column;
            /* 让头部和内容垂直堆叠 */
            gap: 8px;
            /* 在头部和内容之间创造一个自然的间距 */
        }

        /* 2. 头部容器：现在只负责布局和分割线 */
        .memory-card .header {
            border-bottom: 1px solid rgba(217, 129, 0, 0.15);
            /* 分割线颜色可以稍微加深一点 */
            padding-bottom: 8px;
        }

        /* 3. 日期样式 (保持不变) */
        .memory-card .header .date {
            font-size: 11px;
            color: #a1887f;
            margin-bottom: 4px;
        }

        /* 4. 作者样式 (保持不变) */
        .memory-card .header .author {
            font-weight: 600;
            color: #d98100;
            font-size: 15px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* 5. 内容区样式 (保持不变) */
        .memory-card .content {
            font-size: 14px;
            line-height: 1.7;
            color: #5d4037;
            white-space: pre-wrap;
        }

        /* === 【全新】约定/倒计时卡片样式 === */
        .countdown-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(118, 75, 162, 0.4);
            text-align: center;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
        }

        .countdown-card::before {
            content: '✨';
            position: absolute;
            top: -10px;
            left: -10px;
            font-size: 50px;
            opacity: 0.1;
            transform: rotate(-15deg);
        }

        .countdown-card .title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
        }

        .countdown-card .timer {
            font-size: 28px;
            font-weight: 300;
            letter-spacing: 2px;
            margin-bottom: 15px;
        }

        .countdown-card .target-date {
            font-size: 12px;
            opacity: 0.8;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            padding-top: 10px;
        }

        /* === 【全新】聊天锁定遮罩层样式 === */
        #chat-lock-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(247, 247, 247, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 150;
            /* 比输入框高，比贴纸面板低 */
            display: none;
            /* 默认隐藏 */
            align-items: center;
            justify-content: center;
            padding: 20px;
            box-sizing: border-box;
            border-top: 1px solid var(--border-color);
            text-align: center;
        }

        #chat-lock-content {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #chat-lock-content .lock-text {
            color: var(--text-secondary);
            font-size: 14px;
        }

        #chat-lock-content .lock-action-btn {
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid var(--accent-color);
            background-color: var(--accent-color);
            color: white;
            cursor: pointer;
        }

        #chat-lock-content .lock-action-btn.secondary {
            background-color: transparent;
            color: var(--accent-color);
        }

        /* ▼▼▼ 【全新】红包卡片样式 ▼▼▼ */
        .message-bubble.is-red-packet .content {
            padding: 0;
            background: transparent;
            box-shadow: none;
            border: none;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }

        .red-packet-card {
            width: 220px;
            border-radius: 8px;
            background: linear-gradient(160deg, #F96259, #E44D44);
            color: #ffd700;
            /* 金色文字 */
            padding: 12px;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }

        .red-packet-card.opened {
            background: linear-gradient(160deg, #d3c4a0, #c4b693);
            cursor: default;
        }

        .red-packet-card::before {
            content: '🧧';
            position: absolute;
            top: -5px;
            left: -5px;
            font-size: 30px;
            opacity: 0.2;
            transform: rotate(-10deg);
        }

        .rp-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .rp-icon {
            width: 20px;
            height: 20px;
        }

        .rp-greeting {
            font-size: 15px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .rp-type {
            font-size: 11px;
            color: white;
            opacity: 0.8;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            padding-top: 8px;
            margin-top: 8px;
        }

        .rp-claimed-info {
            font-size: 13px;
            color: white;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
        }

        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

        /* ▼▼▼ 【全新】红包详情列表样式 ▼▼▼ */
        .rp-details-item {
            display: flex;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }

        .rp-details-item:last-child {
            border-bottom: none;
        }

        .rp-details-item .name {
            flex-grow: 1;
            font-weight: 500;
            color: #333;
        }

        .rp-details-item .amount {
            font-weight: 500;
            color: #555;
        }

        .rp-details-item .lucky-king-tag {
            font-size: 10px;
            background-color: #ffd700;
            color: #a67c00;
            padding: 2px 5px;
            border-radius: 4px;
            margin-left: 8px;
            font-weight: bold;
        }

        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

        /* ▼▼▼ 【全新】投票功能样式 ▼▼▼ */

        /* 投票卡片在消息气泡中的样式 */
        .message-bubble.is-poll .content {
            padding: 0;
            background: transparent;
            box-shadow: none;
            border: none;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }

        /* 投票卡片主体 */
        .poll-card {
            width: 250px;
            background-color: #f9f9f9;
            border-radius: 10px;
            border: 1px solid #e0e0e0;
            padding: 12px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        .poll-card.closed {
            background-color: #e9ecef;
            /* 结束后变灰 */
        }

        /* 投票问题 */
        .poll-question {
            font-weight: 600;
            font-size: 15px;
            margin-bottom: 12px;
            line-height: 1.4;
            word-break: break-word;
        }

        /* 投票选项列表 */
        .poll-options-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        /* 单个投票选项 */
        .poll-option-item {
            background-color: white;
            border: 1px solid #dcdcdc;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: background-color 0.2s;
        }

        .poll-card:not(.closed) .poll-option-item:hover {
            background-color: #f0f8ff;
        }

        /* 用户已投票的选项样式 */
        .poll-option-item.voted {
            border-color: var(--accent-color);
            background-color: #e7f3ff;
            font-weight: 500;
        }

        /* 投票进度条 */
        .poll-option-bar {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background-color: rgba(0, 123, 255, 0.1);
            z-index: 1;
            transition: width 0.3s ease-in-out;
        }

        /* 选项内容（文字和票数），确保在进度条之上 */
        .poll-option-content {
            position: relative;
            z-index: 2;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .poll-option-text {
            font-size: 14px;
        }

        .poll-option-votes {
            font-size: 13px;
            color: #8a8a8a;
            font-weight: 500;
        }

        /* 投票卡片底部 */
        .poll-footer {
            margin-top: 12px;
            padding-top: 8px;
            border-top: 1px solid #e9e9e9;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .poll-total-votes {
            font-weight: 500;
        }

        .poll-action-btn {
            background: none;
            border: 1px solid var(--accent-color);
            color: var(--accent-color);
            padding: 4px 10px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 12px;
        }

        .poll-card.closed .poll-action-btn {
            background-color: #6c757d;
            color: white;
            border-color: #6c757d;
        }

        /* 创建投票模态框的选项输入 */
        .poll-option-input-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .poll-option-input-wrapper input {
            flex-grow: 1;
        }

        .poll-option-input-wrapper .remove-option-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background-color: #f0f0f0;
            color: #ff3b30;
            border: none;
            cursor: pointer;
            font-size: 18px;
            line-height: 28px;
            text-align: center;
            flex-shrink: 0;
        }

        /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

        /* ▼▼▼ 【全新】聊天界面头部状态逻辑样式 ▼▼▼ */
        #chat-header-status.typing .status-dot {
            animation: dot-pulse 1.5s infinite;
        }

        @keyframes dot-pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }

            100% {
                opacity: 1;
            }
        }

        /* ▲▲▲ 粘贴结束 ▲▲▲ */




        /* ▼▼▼ 【全新】公告板功能样式 - 请将整块代码粘贴到 <style> 标签末尾 ▼▼▼ */

        /* 公告板按钮上未读消息的小红点 */
        #open-bulletin-board-btn {
            position: relative;
            /* 为了定位小红点 */
        }

        /* 公告板模态框 */
        #bulletin-board-modal {
            z-index: 250;
            /* 比贴纸面板高一点 */
        }

        /* ▼▼▼ 【修复1】提升公告操作菜单的层级 ▼▼▼ */
        #bulletin-actions-modal {
            z-index: 260;
            /* 确保比公告板本身(250)更高 */
        }

        /* ▲▲▲ 修复结束 ▲▲▲ */

        /* 公告板内容区 */
        #bulletin-board-modal .modal-body {
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            /* 卡片之间的间距 */
            background-color: #f0f2f5;
            /* 给列表一个浅灰色背景 */
        }

        /* 公告卡片（复用动态样式，但添加一些微调） */
        .bulletin-card {
            background-color: var(--secondary-bg);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
            position: relative;
            /* 为了定位操作按钮 */
        }

        /* 置顶公告的特殊样式 */
        .bulletin-card.pinned {
            border-left: 4px solid #ffc107;
            /* 左侧有金色的置顶标记 */
            box-shadow: 0 4px 12px rgba(255, 193, 7, 0.3);
        }

        .bulletin-card.pinned::after {
            content: '📌';
            position: absolute;
            top: 10px;
            left: -2px;
            font-size: 16px;
            opacity: 0.7;
        }


        /* 公告卡片操作按钮 */
        .bulletin-actions-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            font-size: 20px;
            font-weight: bold;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 50%;
            line-height: 1;
        }

        .bulletin-actions-btn:hover {
            background-color: #f0f0f0;
        }

        /* 聊天界面中的公告消息气泡 */
        .message-bubble.is-bulletin {
            /* 将 align-self 应用到气泡本身，而不是它的内容区 */
            align-self: center;
        }

        .message-bubble.is-bulletin .content {
            padding: 0;
            background: transparent;
            box-shadow: none;
            border: none;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            max-width: 250px;
            /* 限制卡片在聊天中的最大宽度 */
        }

        /* ▼▼▼ 【修复】为公告板卡片添加评论区样式 ▼▼▼ */
        .bulletin-card .post-footer {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #f0f0f0;
        }

        .bulletin-card .post-comments-container {
            padding: 5px 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-size: 13px;
            max-height: 150px;
            /* 限制评论区最大高度 */
            overflow-y: auto;
            /* 超出则滚动 */
        }

        .bulletin-card .comment-item {
            line-height: 1.5;
        }

        .bulletin-card .comment-item .commenter-name {
            font-weight: 600;
            color: var(--accent-color);
            margin-right: 5px;
        }

        .bulletin-card .comment-item .comment-text {
            color: var(--text-primary);
            word-break: break-word;

        }

        #status-bar {
            display: none !important;
        }

        /* ▲▲▲ 修复结束 ▲▲▲ */
        /* ▲▲▲ 公告板功能样式结束 ▲▲▲ */

        /* Floating phone charm */
        .floating-phone-charm {
            position: fixed;
            top: 48px;
            right: -112px;
            width: 220px;
            height: 220px;
            background-image: url('https://files.catbox.moe/rhrobi.gif');
            background-size: contain;
            background-repeat: no-repeat;
            z-index: 1000;
            pointer-events: auto;
            cursor: grab;
            transition: transform 0.2s ease;
            user-select: none;
        }

        .floating-phone-charm:active {
            cursor: grabbing;
        }

        .floating-phone-charm.dragging {
            opacity: 0.5;
            transition: none;
        }

        /* Export Progress Modal */
        #export-progress-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #export-progress-modal-overlay.visible {
            display: flex;
            opacity: 1;
        }

        #export-progress-modal {
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        #export-progress-modal-overlay.visible #export-progress-modal {
            transform: scale(1);
        }
    </style>
</head>

<body>
    <div id="phone-frame">
        <div class="notch"></div>
        <div id="phone-screen">
            <!-- Floating phone charm -->
            <div id="floating-phone-charm" class="floating-phone-charm"></div>

            <div id="status-bar">
                <span id="status-bar-time">12:00</span>
                <div id="status-bar-battery" class="battery-container">
                    <span class="battery-text">--%</span>
                    <div class="battery-icon">
                        <div class="battery-level"></div>
                    </div>
                </div>
            </div>
            <div id="notification-bar"><img id="notification-avatar" src="">
                <div id="notification-content">
                    <div class="name"></div>
                    <div class="message"></div>
                </div>
            </div>

            <div id="home-screen" class="screen active">
                <div id="clock-container">
                    <div id="main-time">12:00</div>
                    <div id="main-date">星期一, 1月1日</div>
                </div>
                <!-- Home Screen Now Playing Bar -->
                <div id="home-now-playing-bar" class="now-playing-bar home-screen-bar hidden">
                    <div class="now-playing-content">
                        <div class="np-album-art">
                            <img id="home-np-album-image" src="" alt="Album Art" style="display: none;">
                            <div class="np-default-icon">🎵</div>
                        </div>
                        <div class="np-song-info">
                            <div id="home-np-song-title" class="np-song-title">未知歌曲</div>
                            <div id="home-np-song-artist" class="np-song-artist">未知艺术家</div>
                        </div>
                        <div class="np-right-section">
                            <div class="np-playback-controls">
                                <button id="home-np-prev-btn" class="np-control-btn" title="上一首">⏮</button>
                                <button id="home-np-play-pause-btn" class="np-control-btn play-pause"
                                    title="播放/暂停">▶</button>
                                <button id="home-np-next-btn" class="np-control-btn" title="下一首">⏭</button>
                            </div>
                            <div class="np-partner-avatar">
                                <img id="home-np-partner-avatar" src="https://files.catbox.moe/q6z5fc.jpeg"
                                    alt="Partner">
                            </div>
                        </div>
                    </div>
                    <div class="np-progress-bar">
                        <div id="home-np-progress-fill" class="np-progress-fill"></div>
                    </div>
                </div>

                <!-- Home Screen Date Progress Bar -->
                <div id="home-meetup-progress-bar" class="meetup-progress-bar home-screen-bar hidden">
                    <div class="meetup-progress-content">
                        <div class="meetup-ai-avatar">
                            <img id="home-meetup-ai-avatar" src="" alt="AI Avatar">
                        </div>
                        <div class="meetup-progress-info">
                            <span id="home-meetup-progress-text" class="meetup-progress-text">与AI在地点</span>
                            <span class="meetup-separator"> | </span>
                            <svg class="meetup-clock-icon" width="12" height="12" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg">
                                <circle cx="12" cy="12" r="10" stroke="rgba(255,255,255,0.75)" stroke-width="2" />
                                <polyline points="12,6 12,12 16,14" stroke="rgba(255,255,255,0.75)" stroke-width="2"
                                    stroke-linecap="round" stroke-linejoin="round" />
                            </svg>
                            <span id="home-meetup-elapsed-text" class="meetup-elapsed-text">00:00:00</span>
                        </div>
                    </div>
                </div>

                <div id="app-grid">
                    <!-- 第一行：空置 -->
                    <div class="app-row">
                    </div>
                    <!-- 第二行：放4个图标 -->
                    <div class="app-row">
                        <!-- Blur container behind the icons -->
                        <div class="app-dock-blur"></div>
                        <div class="app-icon" onclick="showScreen('chat-list-screen')">
                            <div class="icon-bg"><img src="https://files.catbox.moe/janu1z.png" alt="QQ"></div><span
                                class="label">QQ</span>
                        </div>
                        <div class="app-icon"
                            onclick="showScreen('chat-list-screen'); document.querySelector('.nav-item[data-view=qzone-screen]').click()">
                            <div class="icon-bg"><img src="https://files.catbox.moe/65cdyc.png" alt="朋友圈"></div><span
                                class="label">朋友圈</span>
                        </div>

                        <div class="app-icon" onclick="showScreen('calendar-screen')">
                            <div class="icon-bg"><img src="https://files.catbox.moe/2i4irb.png" alt="日历"></div><span
                                class="label">日历</span>
                        </div>

                        <div class="app-icon" onclick="showScreen('settings-screen')">
                            <div class="icon-bg"><img src="https://files.catbox.moe/xmo1uf.png" alt="设置"></div><span
                                class="label">设置</span>
                        </div>
                    </div>
                </div>
            </div>



            <div id="world-book-screen" class="screen">
                <div class="header"><span class="back-btn"
                        onclick="showScreen('settings-screen')">‹</span><span>世界书</span><span class="action-btn"
                        id="add-world-book-btn">+</span></div>
                <div id="world-book-list"></div>
            </div>

            <div id="settings-screen" class="screen">
                <div class="header"><span class="back-btn"
                        onclick="showScreen('home-screen')">‹</span><span>设置</span><span style="width: 30px;"></span>
                </div>
                <div id="settings-list"></div>
            </div>
            <div id="world-book-editor-screen" class="screen">
                <div class="header">
                    <span class="back-btn" onclick="showScreen('world-book-screen')">‹</span>
                    <span id="world-book-editor-title">编辑世界书</span>
                    <span class="save-btn" id="save-world-book-btn">保存</span>
                </div>
                <div class="form-container">
                    <div class="form-group">
                        <label for="world-book-name-input">书名</label>
                        <input type="text" id="world-book-name-input" placeholder="请输入世界书的名称...">
                    </div>
                    <div class="form-group" style="height: 100%;">
                        <label for="world-book-content-input">内容</label>
                        <textarea id="world-book-content-input" placeholder="在此处输入详细的世界观设定..."></textarea>
                    </div>
                </div>
            </div>

            <div id="api-settings-screen" class="screen">
                <div class="header"><span class="back-btn" onclick="showScreen('settings-screen')">‹</span><span>API
                        设置</span><span style="width: 30px;"></span></div>
                <div class="form-container">
                    <p
                        style="font-size: 14px; color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 8px;">
                        提示: 若要使用“发送图片”功能, 请务必选择支持Vision(视觉)的模型, 如<code
                            style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4o</code>或<code
                            style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4-vision-preview</code>。
                    </p>
                    <div class="form-group"><label for="proxy-url">反代地址 (不需要添加/v1噢~)</label><input type="text"
                            id="proxy-url" placeholder="例如: https://api.openai.com"></div>
                    <div class="form-group"><label for="api-key">密钥 (API Key)</label><input type="password" id="api-key"
                            placeholder="sk-..."></div>
                    <div class="form-group"><label for="model-select">模型</label><select id="model-select"></select>
                    </div><button class="form-button" id="fetch-models-btn">拉取模型</button>

                    <!-- ▼▼▼ 将这段代码粘贴到 API 设置页面的“保存设置”按钮上方 ▼▼▼ -->
                    <hr style="margin:20px 0; opacity:.3">
                    <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                        <label for="background-activity-switch" style="margin-bottom: 0;">
                            启用后台角色活动
                            <p style="font-size: 12px; font-weight: normal; color: #ff6b6b; margin-top: 5px;">
                                警告：此功能会显著增加API调用和费用！
                            </p>
                        </label>
                        <input type="checkbox" id="background-activity-switch" style="width: auto; height: 20px;">
                    </div>
                    <!-- ▲▲▲ 粘贴结束 ▲▲▲ -->

                    <!-- ▼▼▼ 将这段代码粘贴到“启用后台角色活动”开关的下方 ▼▼▼ -->
                    <div class="form-group"
                        style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                        <label for="background-interval-input" style="margin-bottom: 0;">
                            后台活动检测间隔 (秒)
                            <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                                建议值 60-300。值越大，费用越低，但角色反应越慢。
                            </p>
                        </label>
                        <input type="number" id="background-interval-input" min="30" value="60"
                            style="width: 80px; text-align: center;">
                    </div>
                    <!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
                    <!-- ▼▼▼ 在这里新增 ▼▼▼ -->
                    <div class="form-group"
                        style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                        <label for="ai-cooldown-input" style="margin-bottom: 0;">
                            AI发言冷静期 (分钟)
                            <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                                AI主动发起行动前需等待的时间。0为无限制。
                            </p>
                        </label>
                        <input type="number" id="ai-cooldown-input" min="0" step="1" value="5"
                            style="width: 80px; text-align: center;">
                    </div>
                    <!-- ▲▲▲ 新增结束 ▲▲▲ -->
                    <!-- ▼▼▼ 在这里新增 ▼▼▼ -->
                    <div class="form-group"
                        style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                        <label for="block-cooldown-input" style="margin-bottom: 0;">
                            AI被拉黑后冷静期 (小时)
                            <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                                被拉黑超过这个时间后，AI才有几率重新申请好友。
                            </p>
                        </label>
                        <input type="number" id="block-cooldown-input" min="0.1" step="0.1" value="1"
                            style="width: 80px; text-align: center;">
                    </div>
                    <!-- ▲▲▲ 新增结束 ▲▲▲ -->

                    <button class="form-button" id="save-api-settings-btn">保存设置</button>

                </div>

            </div>
            <!-- ▼▼▼ 用下面这段代码，完整替换掉你原来的 chat-list-screen ▼▼▼ -->
            <div id="chat-list-screen" class="screen">

                <!-- 主头部 (只在消息列表显示) -->
                <div class="header" id="main-chat-list-header">
                    <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
                    <span>消息</span>
                    <div class="header-actions">
                        <span class="action-btn" id="add-group-chat-btn" title="创建群聊"><svg width="24" height="24"
                                viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path
                                    d="M17.5 17.5C19.1569 17.5 20.5 16.1569 20.5 14.5C20.5 12.8431 19.1569 11.5 17.5 11.5C15.8431 11.5 14.5 12.8431 14.5 14.5C14.5 16.1569 15.8431 17.5 17.5 17.5Z"
                                    stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round" />
                                <path d="M21 21L19 19" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round" />
                                <path
                                    d="M8.5 11.5C10.1569 11.5 11.5 10.1569 11.5 8.5C11.5 6.84315 10.1569 5.5 8.5 5.5C6.84315 5.5 5.5 6.84315 5.5 8.5C5.5 10.1569 6.84315 11.5 8.5 11.5Z"
                                    stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round" />
                                <path d="M12.5 14.5H4.5C3.39543 14.5 2.5 15.3954 2.5 16.5V18.5H12.5"
                                    stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round" />
                            </svg></span>
                        <span class="action-btn" id="add-chat-btn">+</span>
                    </div>
                </div>

                <!-- 消息列表视图 -->
                <div id="messages-view" class="chat-list-view active">
                    <div id="chat-list">
                        <!-- JS会在这里生成聊天列表 -->
                    </div>
                </div>

                <!-- 动态界面视图 -->
                <div id="qzone-screen" class="chat-list-view">
                    <div class="qzone-header">
                        <span class="back-btn" id="qzone-back-btn">‹</span> <!-- 这个按钮现在只负责从动态返回 -->
                        <span>朋友圈</span>
                        <span class="ai-post-btn" id="qzone-add-post-btn" title="添加内容">+</span>
                        <span class="ai-post-btn" id="ai-post-btn" title="让AI发动态">🤖</span>
                    </div>
                    <div class="qzone-content">
                        <div class="qzone-profile-header">
                            <div id="qzone-banner-container" class="qzone-banner-container">
                                <img id="qzone-banner-img" src="https://files.catbox.moe/r5heyt.gif" alt="背景">
                                <input type="file" id="qzone-banner-input" accept="image/*" hidden>
                            </div>
                            <div class="qzone-user-info">
                                <div id="qzone-avatar-container" class="qzone-avatar-container">
                                    <img id="qzone-avatar-img" src="https://files.catbox.moe/q6z5fc.jpeg" alt="头像"
                                        class="avatar">
                                    <input type="file" id="qzone-avatar-input" accept="image/*" hidden>
                                </div>
                                <div class="qzone-user-text">
                                    <span id="qzone-nickname">{{user}}</span>
                                    <span id="qzone-status">这个用户很懒，什么也没留下</span>
                                </div>
                            </div>
                        </div>
                        <div class="qzone-actions-bar" style="display: none;">
                            <div class="action-item" id="create-shuoshuo-btn"><span>说说</span></div>
                            <div class="action-item" id="create-post-btn"><span>动态</span></div>
                            <div class="action-item" id="open-album-btn"><span>相册</span></div>
                        </div>
                        <div id="qzone-posts-list"></div>
                    </div>
                </div>

                <!-- 收藏界面视图 -->
                <div id="favorites-view" class="chat-list-view">
                    <div class="header">
                        <span class="back-btn" id="favorites-back-btn">‹</span>
                        <span>我的收藏</span>
                        <!-- 新增的编辑按钮 -->
                        <span class="action-btn" id="favorites-edit-btn">编辑</span>
                    </div>

                    <!-- 【新增】搜索栏容器 -->
                    <div class="search-bar-container">
                        <input type="search" id="favorites-search-input" placeholder="搜索收藏的标题、内容或作者...">
                        <button id="favorites-search-clear-btn" class="search-clear-btn"
                            style="display: none;">×</button>
                    </div>

                    <div id="favorites-list" class="list-container">
                        <!-- 收藏内容将由JS动态生成在这里 -->
                    </div>

                    <!-- 新增：收藏页底部操作栏 -->
                    <div id="favorites-action-bar" style="display: none;">
                        <button id="favorites-delete-selected-btn" class="action-bar-btn">删除 (0)</button>
                    </div>

                </div>

                <!-- ▼▼▼ 【全新】回忆录界面视图 ▼▼▼ -->
                <div id="memories-view" class="chat-list-view">
                    <div class="header">
                        <span class="back-btn" id="memories-back-btn">‹</span>
                        <span>我们的回忆</span>
                        <span class="action-btn" id="add-countdown-btn">+</span>
                    </div>
                    <div id="memories-list" class="list-container"
                        style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
                        <!-- 回忆卡片将由JS动态生成在这里 -->
                    </div>
                </div>
                <!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

                <!-- 底部导航栏 -->
                <div id="chat-list-bottom-nav">
                    <div class="nav-item active" data-view="messages-view">
                        <span>消息</span>
                    </div>
                    <div class="nav-item" data-view="qzone-screen" style="display: none;">
                        <span>动态</span>
                    </div>
                    <!-- ▼▼▼ 在“动态”和“收藏”之间，加入这个新页签 ▼▼▼ -->
                    <div class="nav-item" data-view="memories-view">
                        <span>回忆</span>
                    </div>
                    <!-- ▲▲▲ 添加结束 ▲▲▲ -->
                    <div class="nav-item" data-view="favorites-view">
                        <span>收藏</span>
                    </div>
                </div>
            </div>
            <!-- ▲▲▲ 替换区域结束 ▲▲▲ -->

            <!-- ▼▼▼ 请将这段新的 HTML 粘贴到 id="chat-list-screen" 的 div 之后 ▼▼▼ -->
            <div id="album-screen" class="screen">
                <!-- 1. 页面头部，包含返回按钮和标题 -->
                <div class="header">
                    <span class="back-btn" id="album-back-btn">‹</span>
                    <span>我的相册</span>
                    <span class="action-btn" id="create-album-btn-page">+</span>
                </div>

                <!-- 2. 页面内容容器 -->
                <div class="list-container">
                    <div id="album-grid-page">
                        <!-- 相册列表将由 JS 动态生成在这里 -->
                    </div>
                </div>
            </div>
            <!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->

            <!-- ▼▼▼ 请将这段新的 HTML 粘贴到 id="album-screen" 的 div 之后 ▼▼▼ -->
            <div id="album-photos-screen" class="screen">
                <!-- 1. 页面头部 -->
                <div class="header">
                    <span class="back-btn" id="album-photos-back-btn">‹</span>
                    <span id="album-photos-title">相册名称</span>
                    <span class="action-btn" id="album-upload-photo-btn">上传</span>
                </div>

                <!-- 2. 页面内容容器 -->
                <div class="list-container">
                    <div id="photos-grid-page">
                        <!-- 照片列表将由 JS 动态生成在这里 -->
                    </div>

                    <!-- ▼▼▼ 请将这段新的 HTML 粘贴到所有模态框的末尾 ▼▼▼ -->
                    <div id="photo-viewer-modal" class="modal">
                        <!-- 1. 关闭按钮 -->
                        <button id="photo-viewer-close-btn">×</button>

                        <!-- 2. 上一张照片按钮 -->
                        <button id="photo-viewer-prev-btn" class="nav-arrow">‹</button>

                        <!-- 3. 图片容器 -->
                        <div class="photo-viewer-content">
                            <img id="photo-viewer-image" src="" alt="全屏照片预览">
                        </div>

                        <!-- 4. 下一张照片按钮 -->
                        <button id="photo-viewer-next-btn" class="nav-arrow">›</button>
                    </div>
                    <!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->

                </div>
            </div>
            <!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->

            <!-- ▼▼▼ 粘贴到 #album-photos-screen 的 div 之后 ▼▼▼ -->
            <input type="file" id="album-photo-input" accept="image/*" multiple hidden>

            <!-- ▼▼▼ 请用这【一整块】全新的代码，完整替换掉您文件中旧的 #chat-interface-screen 及其所有内容 ▼▼▼ -->
            <div id="chat-interface-screen" class="screen">

                <!-- 【最终修正版】Header，已将状态栏和搜索功能正确整合 -->
                <div class="header">
                    <!-- 默认控件：包含标题、状态栏和常规按钮 -->
                    <div class="default-controls">
                        <span class="back-btn" id="back-to-list-btn">‹</span>

                        <!-- ▼▼▼ 【核心新增】标题和状态的容器 ▼▼▼ -->
                        <div id="chat-header-title-wrapper">
                            <span id="chat-header-title">聊天对象</span>
                            <div id="chat-header-status">
                                <span class="status-dot"></span>
                                <span class="status-text">在线</span>
                            </div>
                        </div>
                        <!-- ▲▲▲ 新增结束 ▲▲▲ -->

                        <div class="header-actions">
                            <!-- 请将这两行新代码粘贴到上面删除的位置 -->
                            <span class="action-btn" id="listen-together-btn" title="一起听"><svg width="24" height="24"
                                    viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path
                                        d="M10 36V24C10 16.268 16.268 10 24 10C31.732 10 38 16.268 38 24V36M10 26H6C4.89543 26 4 26.8954 4 28V36C4 37.1046 4.89543 38 6 38H10V26ZM38 26H42C43.1046 26 44 26.8954 44 28V36C44 37.1046 43.1046 38 42 38H38V26Z"
                                        stroke="currentColor" stroke-width="4" stroke-linecap="round"
                                        stroke-linejoin="round" />
                                    <path d="M16 32H20L22 26L26 38L28 32H32" stroke="currentColor" stroke-width="4"
                                        stroke-linecap="round" stroke-linejoin="round" />
                                </svg></span>
                            <span class="action-btn" id="meetup-btn" title="见面模式"><svg width="24" height="24"
                                    viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <rect x="6" y="10" width="36" height="32" rx="2" stroke="currentColor"
                                        stroke-width="4" stroke-linejoin="round" />
                                    <path d="M14 6V14" stroke="currentColor" stroke-width="4" stroke-linecap="round"
                                        stroke-linejoin="round" />
                                    <path d="M34 6V14" stroke="currentColor" stroke-width="4" stroke-linecap="round"
                                        stroke-linejoin="round" />
                                    <path d="M6 18H42" stroke="currentColor" stroke-width="4" stroke-linecap="round"
                                        stroke-linejoin="round" />
                                    <circle cx="16" cy="28" r="2" fill="currentColor" />
                                    <circle cx="24" cy="28" r="2" fill="currentColor" />
                                    <circle cx="32" cy="28" r="2" fill="currentColor" />
                                    <path d="M20 32C20 30 22 30 24 32C26 30 28 30 28 32" stroke="currentColor"
                                        stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                                </svg></span>
                            <span class="action-btn" id="chat-settings-btn" title="聊天设置"><svg width="24" height="24"
                                    viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M41.5 10H35.5" stroke="currentColor" stroke-width="4"
                                        stroke-linecap="round" stroke-linejoin="round" />
                                    <path d="M27.5 6V14" stroke="currentColor" stroke-width="4" stroke-linecap="round"
                                        stroke-linejoin="round" />
                                    <path d="M27.5 10L5.5 10" stroke="currentColor" stroke-width="4"
                                        stroke-linecap="round" stroke-linejoin="round" />
                                    <path d="M13.5 24H5.5" stroke="currentColor" stroke-width="4" stroke-linecap="round"
                                        stroke-linejoin="round" />
                                    <path d="M21.5 20V28" stroke="currentColor" stroke-width="4" stroke-linecap="round"
                                        stroke-linejoin="round" />
                                    <path d="M43.5 24H21.5" stroke="currentColor" stroke-width="4"
                                        stroke-linecap="round" stroke-linejoin="round" />
                                    <path d="M41.5 38H35.5" stroke="currentColor" stroke-width="4"
                                        stroke-linecap="round" stroke-linejoin="round" />
                                    <path d="M27.5 34V42" stroke="currentColor" stroke-width="4" stroke-linecap="round"
                                        stroke-linejoin="round" />
                                    <path d="M27.5 38H5.5" stroke="currentColor" stroke-width="4" stroke-linecap="round"
                                        stroke-linejoin="round" />
                                </svg></span>
                        </div>
                    </div>

                    <!-- 多选模式控件 (保持不变) -->
                    <div class="selection-controls">
                        <span id="selection-cancel-btn">取消</span>
                        <span id="selection-count"></span>
                        <div class="header-actions">
                            <span id="selection-favorite-btn" class="action-btn">收藏</span>
                            <span id="selection-delete-btn" class="action-btn" style="color: #ff3b30;">删除</span>
                        </div>
                    </div>
                </div>

                <!-- Now Playing Bar -->
                <div id="now-playing-bar" class="now-playing-bar hidden">
                    <div class="now-playing-content">
                        <div class="np-album-art">
                            <img id="np-album-image" src="" alt="Album Art" style="display: none;">
                            <div class="default-icon">♪</div>
                        </div>
                        <div class="np-song-info">
                            <div class="np-song-title" id="np-song-title">请添加歌曲</div>
                            <div class="np-song-artist" id="np-song-artist">暂无播放</div>
                        </div>
                        <div class="np-right-section">
                            <div class="np-playback-controls">
                                <button id="np-prev-btn" class="np-control-btn" title="上一首">⏮</button>
                                <button id="np-play-pause-btn" class="np-control-btn play-pause"
                                    title="播放/暂停">▶</button>
                                <button id="np-next-btn" class="np-control-btn" title="下一首">⏭</button>
                            </div>
                            <div class="np-partner-avatar">
                                <img id="np-partner-avatar" src="" alt="Listening Partner">
                            </div>
                        </div>
                    </div>
                    <div class="np-progress-bar">
                        <div id="np-progress-fill" class="np-progress-fill"></div>
                    </div>
                </div>

                <!-- Date Progress Bar -->
                <div id="meetup-progress-bar" class="meetup-progress-bar hidden">
                    <div class="meetup-progress-content">
                        <div class="meetup-ai-avatar">
                            <img id="meetup-ai-avatar" src="" alt="AI Avatar">
                        </div>
                        <div class="meetup-progress-info">
                            <span id="meetup-progress-text" class="meetup-progress-text">与AI在地点</span>
                            <span class="meetup-separator"> | </span>
                            <svg class="meetup-clock-icon" width="12" height="12" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg">
                                <circle cx="12" cy="12" r="10" stroke="rgba(255,255,255,0.75)" stroke-width="2" />
                                <polyline points="12,6 12,12 16,14" stroke="rgba(255,255,255,0.75)" stroke-width="2"
                                    stroke-linecap="round" stroke-linejoin="round" />
                            </svg>
                            <span id="meetup-elapsed-text" class="meetup-elapsed-text">00:00:00</span>
                        </div>
                    </div>
                </div>

                <!-- 聊天消息区域 (保持不变) -->
                <div id="chat-messages">
                    <div id="typing-indicator">对方正在输入...</div>
                </div>

                <!-- 输入区域 (保持不变) -->
                <div id="chat-input-area">
                    <div id="chat-input-actions-top">
                        <button id="open-sticker-panel-btn" class="chat-action-icon-btn action-button"
                            title="表情面板">
                            <svg width="26" height="26" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="10"/>
                                <path d="M8 14s1.5 2 4 2 4-2 4-2"/>
                                <line x1="9" y1="9" x2="9.01" y2="9"/>
                                <line x1="15" y1="9" x2="15.01" y2="9"/>
                            </svg>
                        </button>
                        <button id="send-photo-btn" class="chat-action-icon-btn action-button" title="发送照片"><svg
                                width="24" height="24" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2"
                                stroke-linecap="round" stroke-linejoin="round">
                                <path
                                    d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z" />
                                <circle cx="12" cy="13" r="4" />
                            </svg></button>
                        <button id="upload-image-btn" class="chat-action-icon-btn action-button" title="上传图片"><svg
                                width="24" height="24" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg" style="color: var(--text-primary);">
                                <path
                                    d="M21 3.5H3C2.44772 3.5 2 3.94772 2 4.5V19.5C2 20.0523 2.44772 20.5 3 20.5H21C21.5523 20.5 22 20.0523 22 19.5V4.5C22 3.94772 21.5523 3.5 21 3.5Z"
                                    stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round" />
                                <path
                                    d="M16.5 13.5C17.6046 13.5 18.5 12.6046 18.5 11.5C18.5 10.3954 17.6046 9.5 16.5 9.5C15.3954 9.5 14.5 10.3954 14.5 11.5C14.5 12.6046 15.3954 13.5 16.5 13.5Z"
                                    stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round" />
                                <path d="M22 14.5L18 10.5L10.3333 18.5M12.5 16L9 12.5L2 19.5" stroke="currentColor"
                                    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                            </svg></button>
                        <button id="transfer-btn" class="chat-action-icon-btn action-button" title="转账">￥</button>
                        <button id="voice-message-btn" class="chat-action-icon-btn action-button" title="发送语音"><svg
                                width="24" height="24" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2"
                                stroke-linecap="round" stroke-linejoin="round">
                                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z" />
                                <path d="M19 10v2a7 7 0 0 1-14 0v-2" />
                                <path d="M12 19v4" />
                                <path d="M8 23h8" />
                            </svg></button>
                        <!-- ▼▼▼ 将这行新代码粘贴到“发送语音”按钮的后面 ▼▼▼ -->
                        <button id="send-waimai-request-btn" class="chat-action-icon-btn action-button"
                            title="发起外卖请求"><svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2"
                                stroke-linecap="round" stroke-linejoin="round">
                                <path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z" />
                                <line x1="3" y1="6" x2="21" y2="6" />
                                <path d="M16 10a4 4 0 0 1-8 0" />
                            </svg></button>
                        <!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
                        <!-- ▼▼▼ 【新增】视频通话按钮 ▼▼▼ -->
                        <button id="video-call-btn" class="chat-action-icon-btn action-button" title="视频通话"><svg
                                width="24" height="24" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2"
                                stroke-linecap="round" stroke-linejoin="round">
                                <polygon points="23 7 16 12 23 17 23 7"></polygon>
                                <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
                            </svg></button>
                        <!-- ▲▲▲ 新增结束 ▲▲▲
<!-- ▼▼▼群视频通话按钮 ▼▼▼ -->
                        <button id="group-video-call-btn" class="chat-action-icon-btn action-button" title="群视频通话"><svg
                                width="24" height="24" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2"
                                stroke-linecap="round" stroke-linejoin="round">
                                <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                                <circle cx="9" cy="7" r="4"></circle>
                                <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                                <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                            </svg></button>
                        <!-- ▲▲▲ 全新添加结束 ▲▲▲ -->
                        <!-- ▼▼▼发起投票按钮▼▼▼ -->
                        <button id="send-poll-btn" class="chat-action-icon-btn action-button" title="发起投票"><svg
                                width="24" height="24" viewBox="0 0 48 48" fill="none"
                                xmlns="http://www.w3.org/2000/svg">
                                <path
                                    d="M42 20V39C42 40.6569 40.6569 42 39 42H9C7.34315 42 6 40.6569 6 39V9C6 7.34315 7.34315 6 9 6H30"
                                    stroke="currentColor" stroke-width="4" stroke-linecap="round"
                                    stroke-linejoin="round" />
                                <path d="M16 20L26 28L41 7" stroke="currentColor" stroke-width="4"
                                    stroke-linecap="round" stroke-linejoin="round" />
                            </svg></button>

                        <button id="open-bulletin-board-btn" class="chat-action-icon-btn action-button" title="公告板"><svg
                                width="24" height="24" viewBox="0 0 48 48" fill="none"
                                xmlns="http://www.w3.org/2000/svg">
                                <rect x="4" y="15" width="40" height="26" rx="2" fill="none" stroke="currentColor"
                                    stroke-width="4" stroke-linejoin="round" />
                                <path d="M24 7L16 15H32L24 7Z" fill="none" stroke="currentColor" stroke-width="4"
                                    stroke-linecap="round" stroke-linejoin="round" />
                                <path d="M12 24H30" stroke="currentColor" stroke-width="4" stroke-linecap="round"
                                    stroke-linejoin="round" />
                                <path d="M12 32H20" stroke="currentColor" stroke-width="4" stroke-linecap="round"
                                    stroke-linejoin="round" />
                            </svg></button>

                        <!-- ▼▼▼ Share Link Button ▼▼▼ -->
                        <button id="share-link-btn" class="chat-action-icon-btn action-button" title="分享链接"><svg
                                width="24" height="24" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2"
                                stroke-linecap="round" stroke-linejoin="round">
                                <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path>
                                <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path>
                            </svg></button>
                        <!-- ▲▲▲ Share Link Button End ▲▲▲ -->

                        <!-- ▼▼▼ Location Share Button ▼▼▼ -->
                        <button id="share-location-btn" class="chat-action-icon-btn action-button" title="分享位置"><svg
                                width="24" height="24" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2"
                                stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                                <circle cx="12" cy="10" r="3"></circle>
                            </svg></button>
                        <!-- ▲▲▲ Location Share Button End ▲▲▲ -->

                        <!-- ▲▲▲ 替换结束 ▲▲▲ -->
                    </div>

                    <div id="reply-preview-bar">
                        <div class="reply-preview-content">
                            <div class="sender">回复 xxx:</div>
                            <div class="text">被引用的消息内容...</div>
                        </div>
                        <span id="cancel-reply-btn">×</span>
                    </div>

                    <div id="chat-input-main-row">
                        <textarea id="chat-input" rows="1" placeholder="输入消息..."></textarea>
                        <div id="input-actions-wrapper">
                            <button id="wait-reply-btn" title="等待回复"><img
                                    src="https://i.postimg.cc/2SwjsfZQ/IMG-6913.gif" alt="等待回复"></button>
                            <button id="send-btn" class="action-button">发送</button>
                        </div>
                    </div>
                </div>

                <!-- ▼▼▼ 在这里新增 ▼▼▼ -->
                <div id="chat-lock-overlay">
                    <div id="chat-lock-content"></div>
                </div>
                <!-- ▲▲▲ 新增结束 ▲▲▲ -->

                <!-- 表情面板 (保持不变) -->
                <div id="sticker-panel">
                    <div id="sticker-panel-header">
                        <span class="panel-btn" id="close-sticker-panel-btn">取消</span>
                        <span class="title">我的表情</span>
                        <span class="panel-btn" id="edit-sticker-pack-btn">编辑</span>
                    </div>
                    <div id="sticker-grid"></div>
                    <div id="sticker-pack-tabs">
                        <div class="sticker-pack-tab add-pack-btn" id="add-pack-btn">
                            <div class="pack-icon">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                    xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2"
                                    stroke-linecap="round" stroke-linejoin="round">
                                    <line x1="12" y1="5" x2="12" y2="19"></line>
                                    <line x1="5" y1="12" x2="19" y2="12"></line>
                                </svg>
                            </div>
                        </div>
                        <div class="sticker-pack-tab active" data-pack="all">
                            <div class="pack-icon">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                    xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2"
                                    stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="10" />
                                    <path d="M8 14s1.5 2 4 2 4-2 4-2" />
                                    <line x1="9" y1="9" x2="9.01" y2="9" />
                                    <line x1="15" y1="9" x2="15.01" y2="9" />
                                </svg>
                            </div>
                        </div>
                        <div class="sticker-pack-tab" data-pack="pack1">
                            <div class="pack-icon">
                                <img src="https://files.catbox.moe/r1khrr.gif" alt="Pack 1">
                            </div>
                        </div>
                    </div>
                </div>



                <input type="file" id="sticker-upload-input" accept="image/*" style="display: none;">
                <input type="file" id="image-upload-input" accept="image/*" style="display: none;">

                <!-- 音乐播放器 (保持不变) -->
                <div id="music-player-overlay">
                    <div class="music-player-window">
                        <span id="music-playlist-btn">☰</span>
                        <div id="music-time-counter">已经一起听了0.0小时</div>
                        <div id="music-player-song-title">请添加歌曲</div>
                        <div id="music-player-artist">...</div>
                        <div class="music-controls">
                            <button id="music-prev-btn">⏮</button>
                            <button id="music-play-pause-btn" class="play-pause-btn">▶</button>
                            <button id="music-next-btn">⏭</button>
                            <button id="music-mode-btn">顺序</button>
                        </div>
                        <div class="music-bottom-actions">
                            <button id="music-exit-btn">退出一起听</button>
                            <button id="music-return-btn">返回聊天</button>
                        </div>
                    </div>
                </div>

                <div id="music-playlist-panel">
                    <div class="playlist-header">
                        <span class="panel-btn" id="close-playlist-btn">返回</span>
                        <span>播放列表</span>
                        <span style="width: 30px;"></span>
                    </div>
                    <div style="display: flex; border-bottom: 1px solid var(--border-color);">
                        <div class="main-playlist-tab active" onclick="switchMainPlaylistTab('songs')"
                            style="flex: 1; padding: 15px; text-align: center; cursor: pointer; border-bottom: 2px solid var(--accent-color);">
                            Songs</div>
                        <div class="main-playlist-tab" onclick="switchMainPlaylistTab('playlists')"
                            style="flex: 1; padding: 15px; text-align: center; cursor: pointer; border-bottom: 2px solid transparent;">
                            Playlists</div>
                    </div>
                    <div id="main-songs-tab" class="main-playlist-tab-content">
                        <div
                            style="padding: 15px; border-bottom: 1px solid var(--border-color); display: flex; gap: 10px;">
                            <span class="panel-btn" id="add-song-local-btn">本地</span>
                            <span class="panel-btn" id="add-song-url-btn">URL</span>
                            <span class="panel-btn" id="add-song-spotify-btn">Spotify</span>
                        </div>
                        <div class="playlist-body" id="playlist-body"></div>
                    </div>
                    <div id="main-playlists-tab" class="main-playlist-tab-content" style="display: none;">
                        <div id="main-playlists-list" style="overflow-y: auto; max-height: 400px;"></div>
                        <div id="main-playlist-view" style="display: none;">
                            <div
                                style="padding: 15px; border-bottom: 1px solid var(--border-color); display: flex; align-items: center;">
                                <span onclick="showMainSpotifyPlaylists()"
                                    style="cursor: pointer; margin-right: 10px;">‹</span>
                                <span id="main-current-playlist-name" style="font-weight: 600;"></span>
                            </div>
                            <div id="main-playlist-tracks" style="overflow-y: auto; max-height: 350px;"></div>
                        </div>
                    </div>
                </div>
            </div>
            <input type="file" id="local-song-upload-input" accept="audio/*" multiple style="display: none;">
        </div>
        <!-- ▲▲▲ 替换结束 ▲▲▲ -->

        <div id="appearance-settings-screen" class="screen">
            <div class="header"><span class="back-btn"
                    onclick="showScreen('settings-screen')">‹</span><span>外观设置</span><span style="width: 30px;"></span>
            </div>
            <div class="form-container">
                <div class="form-group">
                    <div id="wallpaper-preview">点击下方上传</div><button class="form-button"
                        onclick="document.getElementById('wallpaper-upload-input').click();">上传壁纸</button><input
                        type="file" id="wallpaper-upload-input" accept="image/*"><button class="form-button"
                        id="save-wallpaper-btn">保存并应用</button>
                </div>
                <hr style="margin:20px 0; opacity:.3">
                <!-- App Icon customization section -->
                <div class="form-group">
                    <label>应用图标自定义</label>
                    <div id="app-icon-customization-list">
                        <!-- App icon customization fields will be populated here -->
                    </div>
                </div>
                <hr style="margin:20px 0; opacity:.3">
                <!-- Charm customization section -->
                <div class="form-group">
                    <div
                        style="display: flex; justify-content: space-between; align-items: center; width: calc(100% + 40px); margin-bottom: 10px; margin-left: -20px;">
                        <span>
                            自定义挂件样式 (CSS)
                            <button id="reset-charm-css-btn" type="button"
                                style="background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px;">重置</button>
                        </span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="charm-visibility-toggle" checked>
                            <span class="slider round"></span>
                        </label>
                    </div>
                    <textarea id="custom-charm-css-input" rows="15"
                        style="width: calc(100vw - 40px); margin-left: -20px; margin-right: -20px; padding: 12px; box-sizing: border-box; font-family: monospace; font-size: 12px; resize: vertical;">/* 自定义挂件样式 - 完整默认设置 */
.floating-phone-charm {
  position: fixed;
  top: 48px;
  right: -112px;
  width: 220px;
  height: 220px;
  background-image: url('https://files.catbox.moe/rhrobi.gif');
  background-size: contain;
  background-repeat: no-repeat;
  z-index: 1000;
  pointer-events: auto;
  cursor: grab;
  transition: transform 0.2s ease;
  user-select: none;
}</textarea>
                </div>
                <hr style="margin:20px 0; opacity:.3">
                <!-- Font settings section -->
                <div class="form-group">
                    <label for="font-url-input">字体文件URL (.ttf, .otf, .woff等)</label>
                    <input type="text" id="font-url-input" placeholder="https://..../font.ttf"
                        style="width: calc(100vw - 40px); margin-left: -20px; margin-right: -20px; padding: 12px; box-sizing: border-box;">
                </div>

                <div class="form-group">
                    <label>或者上传字体文件</label>
                    <div
                        style="display: flex; align-items: center; gap: 10px; width: calc(100vw - 40px); margin-left: -20px; margin-right: -20px;">
                        <button class="form-button form-button-secondary"
                            onclick="document.getElementById('font-upload-input').click();"
                            style="flex: 1;">选择字体文件</button>
                        <span id="font-file-name" style="font-size: 14px; color: var(--text-secondary);">未选择文件</span>
                    </div>
                    <input type="file" id="font-upload-input" accept="*/*" style="display: none;">
                </div>

                <div class="form-group">
                    <label>实时预览</label>
                    <div id="font-preview"
                        style="width: calc(100vw - 40px); margin-left: -20px; margin-right: -20px; padding: 20px; border: 1px solid var(--border-color); border-radius: 8px; background-color: #f9f9f9; box-sizing: border-box;">
                        <p style="font-size: 20px; margin: 0 0 10px 0;">你好世界 Hello World</p>
                        <p style="margin: 0;">这是字体预览效果，12345。</p>
                    </div>
                </div>

                <button class="form-button" id="save-font-btn">保存并应用</button>
                <button class="form-button form-button-secondary" id="reset-font-btn">恢复默认字体</button>
            </div>
        </div>

        <div id="backup-screen" class="screen">
            <div class="header"><span class="back-btn"
                    onclick="showScreen('settings-screen')">‹</span><span>备份文件</span><span style="width: 30px;"></span>
            </div>
            <div class="form-container">
                <button class="form-button" id="export-data-btn">导出数据</button>
                <button class="form-button" id="import-btn">导入备份文件</button>

                <hr style="margin:20px 0; opacity:.3">

                <button class="form-button" id="cloud-backup-manual-btn">☁️ 手动备份</button>
                <button class="form-button" id="cloud-restore-select-btn">☁️ 从云端恢复</button>

                <!-- 真正的文件选择器，保持隐藏 -->
                <input id="import-data-input" type="file" accept="application/json" hidden>
            </div>
        </div>

        <div id="general-settings-screen" class="screen">
            <div class="header">
                <span class="back-btn" onclick="showScreen('settings-screen')">‹</span>
                <span>通用设置</span>
                <span style="width: 30px;"></span>
            </div>
            <div id="general-settings-list"></div>
        </div>

        <div id="calendar-screen" class="screen">
            <div class="header">
                <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
                <span>日历</span>
                <span class="action-btn" id="calendar-add-btn">+</span>
            </div>
            <div class="form-container">
                <!-- Calendar month view -->
                <div class="calendar-month-view-no-card">
                    <div class="calendar-header">
                        <button class="calendar-nav-btn" id="prev-month-btn">‹</button>
                        <button class="calendar-nav-btn" id="next-month-btn">›</button>
                        <span class="calendar-month-year" id="calendar-month-year">2025年7月</span>
                    </div>

                    <div class="calendar-weekdays">
                        <div class="weekday">日</div>
                        <div class="weekday">一</div>
                        <div class="weekday">二</div>
                        <div class="weekday">三</div>
                        <div class="weekday">四</div>
                        <div class="weekday">五</div>
                        <div class="weekday">六</div>
                    </div>

                    <div class="calendar-grid" id="calendar-grid">
                        <!-- Calendar dates will be populated by JavaScript -->
                    </div>
                </div>

                <!-- Events list for selected day -->
                <div class="calendar-events-section">
                    <div class="calendar-events-header">
                        <button class="calendar-nav-btn" id="prev-day-btn">‹</button>
                        <button class="calendar-nav-btn" id="next-day-btn">›</button>
                        <span id="selected-date-display">今天</span>
                    </div>
                    <div class="calendar-events-list" id="calendar-events-list">
                        <div class="no-events-message">没有事件</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ▼▼▼ 【全新】选择联系人以创建群聊的屏幕 ▼▼▼ -->
        <div id="contact-picker-screen" class="screen">
            <div class="header">
                <span class="back-btn" id="cancel-contact-picker-btn">取消</span>
                <span>选择联系人</span>
                <span class="save-btn" id="confirm-contact-picker-btn">完成(0)</span>
            </div>
            <div class="list-container" id="contact-picker-list">
                <!-- 联系人列表将由JS动态生成 -->
            </div>
        </div>
        <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

        <!-- ▼▼▼ 【全新】群成员管理屏幕 ▼▼▼ -->
        <div id="member-management-screen" class="screen">
            <div class="header">
                <span class="back-btn" id="back-from-member-management">‹</span>
                <span>群成员管理</span>
                <span style="width: 30px;"></span>
            </div>
            <div class="list-container" id="member-management-list">
                <!-- 现有成员列表会在这里动态生成 -->
            </div>
            <div id="member-management-actions">
                <button id="add-existing-contact-btn">从好友列表添加</button>
                <button id="create-new-member-btn">创建群内新成员</button>
            </div>
        </div>
        <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

        <!-- ▼▼▼ 【全新】来电请求模态框 ▼▼▼ -->
        <div id="incoming-call-modal" class="modal">
            <div class="incoming-call-content">
                <img id="caller-avatar" class="caller-avatar" src="">
                <div id="caller-name" class="caller-name"></div>
                <div class="caller-text">邀请你视频通话</div>
                <div class="incoming-call-actions">
                    <div class="action-button-wrapper">
                        <button id="decline-call-btn" class="call-action-btn decline"></button>
                        <span>拒绝</span>
                    </div>
                    <div class="action-button-wrapper">
                        <button id="accept-call-btn" class="call-action-btn accept"></button>
                        <span>接听</span>
                    </div>
                </div>
            </div>
        </div>
        <!-- ▲▲▲ 新增结束 ▲▲▲ -->

        <!-- ▼▼▼ 请用这段【全新群聊兼容结构】的代码，完整替换你旧的 #video-call-screen ▼▼▼ -->
        <div id="video-call-screen" class="screen">
            <!-- 1. 顶部栏 (保持不变) -->
            <div class="video-call-top-bar">
                <span id="call-timer">00:00</span>
            </div>

            <!-- 2. 【升级】参与者头像网格区域 -->
            <div class="video-call-avatar-area">
                <div id="participant-avatars-grid">
                    <!-- JS会在这里动态生成头像 -->
                </div>
            </div>

            <!-- 3. 对话框区域 (保持不变) -->
            <div id="video-call-main" class="video-call-main">
                <!-- 对话内容会动态生成在这里 -->
            </div>

            <!-- 4. 【升级】底部控制栏，现在包含一个“加入”按钮 -->
            <div class="video-call-controls">
                <button id="user-speak-btn" class="control-btn speak-btn"></button>
                <button id="hang-up-btn" class="control-btn hangup-btn"></button>
                <!-- 这个按钮默认隐藏，只在用户“旁观”时显示 -->
                <button id="join-call-btn" class="control-btn join-btn" style="display: none;"></button>
            </div>
        </div>
        <!-- ▲▲▲ 替换结束 ▲▲▲ -->

        <!-- ▼▼▼ 【全新添加】正在呼叫界面 ▼▼▼ -->
        <div id="outgoing-call-screen" class="screen">
            <div class="outgoing-call-content">
                <img id="outgoing-call-avatar" class="caller-avatar" src="">
                <div id="outgoing-call-name" class="caller-name"></div>
                <div class="caller-text">正在呼叫...</div>
                <div class="outgoing-call-actions">
                    <button id="cancel-call-btn" class="call-action-btn decline"></button>
                    <span>取消</span>
                </div>
            </div>
        </div>
        <!-- ▲▲▲ 添加结束 ▲▲▲ -->

        <!-- ▼▼▼ Browser Screen for Share Links ▼▼▼ -->
        <div id="browser-screen" class="screen">
            <div class="header">
                <span class="back-btn" id="browser-back-btn">‹</span>
                <span id="browser-title"></span>
                <span style="width: 30px;"></span>
            </div>
            <div id="browser-content" class="list-container">
                <!-- 文章内容将由JS动态生成在这里 -->
            </div>
        </div>
        <!-- ▲▲▲ Browser Screen End ▲▲▲ -->

        <!-- ▼▼▼ Meetup Screen ▼▼▼ -->
        <div id="meetup-screen" class="screen">
            <div class="header">
                <!-- Default controls -->
                <div class="default-controls">
                    <span class="back-btn" id="meetup-back-btn">‹</span>
                    <span id="meetup-title">见面模式</span>
                    <span class="action-btn" id="meetup-edit-btn">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" stroke="#007AFF"
                                stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                            <path d="m18.5 2.5 3 3L12 15l-4 1 1-4 9.5-9.5z" fill="#007AFF" stroke="#007AFF"
                                stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                        </svg>
                    </span>
                </div>

                <!-- Selection mode controls -->
                <div class="selection-controls">
                    <span id="meetup-selection-cancel-btn">取消</span>
                    <span id="meetup-selection-count"></span>
                    <div class="header-actions">
                        <span id="meetup-selection-delete-btn" class="action-btn" style="color: #ff3b30;">删除</span>
                    </div>
                </div>
            </div>

            <!-- Meetup context bar showing event details -->
            <div id="meetup-context-bar">
                <div class="context-info">
                    <div class="event-location" id="meetup-location">📍 位置信息</div>
                    <div class="event-time" id="meetup-time">🕐 时间信息</div>
                    <div class="event-phase" id="meetup-phase">💕 见面进行中</div>
                </div>
                <button id="end-date-btn" class="end-date-button">结束见面</button>
            </div>

            <!-- Meetup message display area -->
            <div id="meetup-messages" class="meetup-messages-container">
                <!-- Messages will be dynamically generated here -->
            </div>

            <!-- Meetup input area -->
            <div id="meetup-input-area" class="meetup-input-container">
                <div id="meetup-input-main-row">
                    <textarea id="meetup-input" rows="1" placeholder="在这个特殊的时刻，你想说什么..."></textarea>
                    <div class="meetup-actions-wrapper">
                        <button id="meetup-wait-reply-btn" title="等待回复"><img
                                src="https://i.postimg.cc/2SwjsfZQ/IMG-6913.gif" alt="等待回复"></button>
                        <button id="meetup-send-btn" class="send-btn">发送</button>
                    </div>
                </div>
            </div>
        </div>
        <!-- ▲▲▲ Meetup Screen End ▲▲▲ -->

    </div>
    </div>

    <div id="chat-settings-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><span>聊天设置</span></div>
            <div class="modal-body">
                <div class="form-group" id="chat-name-group"><label for="chat-name-input">备注名 / 群名</label><input
                        type="text" id="chat-name-input"></div>

                <!-- ▼▼▼ 请将这段新代码粘贴到“备注名”输入框的 form-group 之后 ▼▼▼ -->
                <div class="form-group" id="assign-group-section" style="display: none;"> <!-- 默认隐藏，只对单聊显示 -->
                    <label for="assign-group-select">好友分组</label>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <select id="assign-group-select" style="flex-grow: 1;">
                            <!-- 分组选项将由JS动态生成 -->
                        </select>
                        <button id="manage-groups-btn" class="form-button-secondary"
                            style="margin-top: 0; padding: 12px;">管理分组</button>
                    </div>
                </div>
                <!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

                <div class="form-group" id="my-group-nickname-group"><label
                        for="my-group-nickname-input">我的群昵称</label><input type="text" id="my-group-nickname-input">
                </div>
                <div class="form-group" id="group-avatar-group"><label>群头像</label>
                    <div class="avatar-upload"><img id="group-avatar-preview"><button
                            onclick="document.getElementById('group-avatar-input').click()">上传群头像</button><input
                            type="file" id="group-avatar-input" accept="image/*"></div>
                </div>
                <div class="form-group" id="world-book-link-group">
                    <label>关联世界书 (可多选)</label>
                    <div class="custom-multiselect">
                        <div class="select-box">
                            <span class="selected-options-text">-- 点击选择 --</span>
                            <span class="arrow-down">▼</span>
                        </div>
                        <div id="world-book-checkboxes-container" class="checkboxes-container">
                        </div>
                    </div>
                </div>
                <div class="form-group" id="ai-persona-group"><label for="ai-persona">对方人设 (AI Persona)</label><textarea
                        id="ai-persona" rows="3"></textarea></div>
                <div class="form-group" id="ai-avatar-group"><label>对方头像</label>
                    <div class="avatar-upload"><img id="ai-avatar-preview"><button
                            onclick="document.getElementById('ai-avatar-input').click()">上传对方头像</button><input
                            type="file" id="ai-avatar-input" accept="image/*"></div>
                </div>
                <div class="form-group" id="my-persona-group"><label for="my-persona">我的人设 (My Persona)</label><textarea
                        id="my-persona" rows="3"></textarea></div>
                <div class="form-group" id="my-avatar-group"><label>我的头像</label>
                    <div class="avatar-upload"><img id="my-avatar-preview"><button
                            onclick="document.getElementById('my-avatar-input').click()">上传我的头像</button><button
                            id="open-persona-library-btn">预设</button><input type="file" id="my-avatar-input"
                            accept="image/*"></div>
                </div>
                <div class="form-group" id="group-members-group"><label>群成员人设</label>
                    <div id="group-members-settings"></div>

                    <!-- 【新增】管理成员按钮 -->
                    <button id="manage-members-btn" class="form-button form-button-secondary"
                        style="margin-top: 15px;">管理群成员</button>
                </div>
                <div class="form-group"><label for="max-memory">上下文记忆条数</label><input type="number" id="max-memory"
                        value="10"></div>
                <!-- ▼▼▼ 【全新】后台活动开关 - 请粘贴到这里 ▼▼▼ -->
                <div class="form-group">
                    <label>后台回复与主动行为</label>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <p
                            style="font-size: 11px; font-weight: normal; color: #666; margin: 0; padding-right: 15px; line-height: 1.4;">
                            关闭后，该角色将不会在后台独立行动或主动发起对话，只会在你与Ta聊天时进行回复。
                        </p>
                        <label class="toggle-switch">
                            <input type="checkbox" id="background-activity-switch-chat">
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
                <!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

                <div class="form-group"><label>聊天气泡主题 <button id="reset-theme-btn" type="button">重置</button></label>
                    <div class="theme-selector"><label><input type="radio" name="theme-select" value="default"
                                id="theme-default"> 默认</label><label><input type="radio" name="theme-select"
                                value="pink_blue"> 粉蓝</label><label><input type="radio" name="theme-select"
                                value="blue_white"> 蓝白</label><label><input type="radio" name="theme-select"
                                value="purple_yellow"> 紫黄</label><label><input type="radio" name="theme-select"
                                value="black_white"> 黑白</label><label><input type="radio" name="theme-select"
                                value="yellow_white"> 黄白</label><label><input type="radio" name="theme-select"
                                value="red_black"> 红黑</label><label><input type="radio" name="theme-select"
                                value="blue_yellow"> 蓝黄</label><label><input type="radio" name="theme-select"
                                value="pink_yellow"> 粉黄</label><label><input type="radio" name="theme-select"
                                value="pink_purple"> 粉紫</label><label><input type="radio" name="theme-select"
                                value="gray_white"> 灰白</label><label><input type="radio" name="theme-select"
                                value="blue_green"> 蓝绿</label><label><input type="radio" name="theme-select"
                                value="pink_white"> 粉白</label><label><input type="radio" name="theme-select"
                                value="pink_black"> 粉黑</label><label><input type="radio" name="theme-select"
                                value="pink_green"> 粉绿</label><label><input type="radio" name="theme-select"
                                value="green_black"> 绿黑</label></div>
                </div>


                <!-- ▼▼▼ 请将这段新代码粘贴到“聊天气泡主题”的 form-group 之后 ▼▼▼ -->
                <div class="form-group">
                    <label for="font-size-slider">聊天字体大小 <span id="font-size-value">13px</span></label>
                    <input type="range" id="font-size-slider" min="12" max="20" step="1" value="13"
                        style="width: 100%; margin-top: 8px;">
                </div>
                <!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

                <!-- ▼▼▼ 请将这段新代码粘贴到“聊天字体大小”的 form-group 之后 ▼▼▼ -->
                <div class="form-group">
                    <label for="custom-css-input">
                        自定义气泡样式 (CSS)
                        <button id="reset-custom-css-btn" type="button"
                            style="background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px;">重置</button>
                    </label>
                    <textarea id="custom-css-input" rows="5"
                        style="width: 100%; margin-top: 8px; font-family: monospace; font-size: 12px; resize: vertical;"
                        placeholder="/* 示例：为“我”的气泡添加渐变背景和阴影 */
.message-bubble.user .content {
  background: linear-gradient(135deg, #a1c4fd, #c2e9fb);
  box-shadow: 0 4px 10px rgba(0,0,0,0.1);
  border-radius: 15px 4px 15px 15px;
}"></textarea>
                </div>
                <!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

                <!-- ▼▼▼ 请将这段新代码粘贴到自定义CSS输入框的 form-group 之后 ▼▼▼ -->
                <div class="form-group">
                    <label>实时预览</label>
                    <div id="settings-preview-area">
                        <!-- JS会在这里生成预览内容 -->
                    </div>
                </div>
                <!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

                <div class="form-group">
                    <label>聊天背景</label>
                    <div class="bg-upload-container">
                        <button type="button" class="form-button-secondary"
                            style="width: auto; padding: 8px 12px; margin-top: 0;"
                            onclick="document.getElementById('bg-input').click()">上传背景图</button>
                        <button type="button" id="remove-bg-btn">移除背景</button>
                    </div>
                    <img id="bg-preview" class="bg-preview-img">
                    <input type="file" id="bg-input" accept="image/*" style="display: none;">
                </div>
                <hr style="margin: 25px 0; border: none; border-top: 1px solid #eee;">
                <button class="form-button form-button-secondary" id="block-chat-btn"
                    style="background-color: #ff3b30; color: white; border-color: #ff3b30;">拉黑对方</button>
                <button class="form-button form-button-secondary" id="clear-chat-btn">清空聊天记录</button>
            </div>
            <div class="modal-footer"><button class="cancel" id="cancel-chat-settings-btn">取消</button><button
                    class="save" id="save-chat-settings-btn">保存</button></div>
        </div>
    </div>

    <div id="persona-library-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><span>我的人设库</span><button id="add-persona-preset-btn"
                    class="action-button">添加</button></div>
            <div class="modal-body">
                <div id="persona-library-grid"></div>
            </div>
            <div class="modal-footer"><button class="cancel" id="close-persona-library-btn">关闭</button></div>
        </div>
    </div>

    <div id="persona-editor-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><span id="persona-editor-title">添加人设预设</span></div>
            <div class="modal-body">
                <div class="form-group"><label>预设头像</label>
                    <div class="avatar-upload"><img id="preset-avatar-preview"><button
                            onclick="document.getElementById('preset-avatar-input').click()">上传头像</button><input
                            type="file" id="preset-avatar-input" accept="image/*"></div>
                </div>
                <div class="form-group"><label for="preset-persona-input">预设人设</label><textarea
                        id="preset-persona-input" rows="4" placeholder="在此输入这个人设的详细设定..."></textarea></div>
            </div>
            <div class="modal-footer"><button class="cancel" id="cancel-persona-editor-btn">取消</button><button
                    class="save" id="save-persona-preset-btn">保存</button></div>
        </div>
    </div>

    <div id="member-settings-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><span>编辑群成员</span></div>
            <div class="modal-body">
                <div class="form-group"><label for="member-name-input">名字</label><input type="text"
                        id="member-name-input"></div>
                <div class="form-group"><label for="member-persona-input">人设</label><textarea id="member-persona-input"
                        rows="4"></textarea></div>
                <div class="form-group"><label>头像</label>
                    <div class="avatar-upload"><img id="member-avatar-preview"><button
                            onclick="document.getElementById('member-avatar-input').click()">上传头像</button><button
                            class="change-frame-btn" data-type="member">更换头像框</button><input type="file"
                            id="member-avatar-input" accept="image/*"></div>
                </div>
            </div>
            <div class="modal-footer"><button class="cancel" id="cancel-member-settings-btn">取消</button><button
                    class="save" id="save-member-settings-btn">保存</button></div>
        </div>
    </div>

    <div id="custom-modal-overlay">
        <div id="custom-modal">
            <div class="custom-modal-header" id="custom-modal-title"></div>
            <div class="custom-modal-body" id="custom-modal-body"></div>
            <div class="custom-modal-footer">
                <button id="custom-modal-cancel">取消</button>
                <button id="custom-modal-confirm" class="confirm-btn">确定</button>
            </div>
        </div>
    </div>

    <!-- Export Progress Modal -->
    <div id="export-progress-modal-overlay" style="display: none;">
        <div id="export-progress-modal"
            style="background-color: #fff; width: 300px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
            <div class="custom-modal-header" style="text-align: center; font-weight: 600; padding: 16px;">
                导出数据
            </div>
            <div class="custom-modal-body" style="padding: 20px;">
                <div id="export-status-text" style="text-align: center; margin-bottom: 16px; color: #666;">
                    正在准备导出...
                </div>
                <div id="export-progress-container"
                    style="width: 100%; height: 8px; background-color: #f0f0f0; border-radius: 4px; overflow: hidden; margin-bottom: 12px;">
                    <div id="export-progress-bar"
                        style="height: 100%; background-color: #007AFF; width: 0%; transition: width 0.3s ease;"></div>
                </div>
                <div id="export-progress-text" style="text-align: center; font-size: 14px; color: #999;">
                    0%
                </div>
            </div>
        </div>
    </div>

    <div id="preset-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="preset-action-edit">编辑预设</button>
                <button id="preset-action-delete" class="btn-danger">删除预设</button>
                <button id="preset-action-cancel"
                    style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
            </div>
        </div>
    </div>

    <div id="transfer-modal">
        <div class="transfer-content">
            <div class="transfer-header">给Ta一个惊喜！</div>
            <div class="transfer-input-group">
                <label for="transfer-amount">转账金额</label>
                <input type="number" id="transfer-amount" placeholder="0.00" min="0" max="99999" step="0.01">
            </div>
            <div class="transfer-input-group">
                <label for="transfer-note">备注 (可选)</label>
                <input type="text" id="transfer-note" placeholder="留下你的小心思~" maxlength="20">
            </div>
            <div class="transfer-actions">
                <button id="transfer-cancel-btn">取消</button>
                <button id="transfer-confirm-btn">确认转账</button>
            </div>
        </div>
    </div>

    <!-- ▼▼▼ 【全新】精致版转账操作弹窗 ▼▼▼ -->
    <div id="transfer-actions-modal" class="modal">
        <div class="transfer-actions-content">
            <div class="transfer-actions-header">请选择操作</div>
            <div class="transfer-actions-body">
                <p>你收到了来自 <strong id="transfer-sender-name"></strong> 的一笔转账。</p>
            </div>
            <div class="transfer-actions-footer">
                <button id="transfer-action-decline" class="action-btn decline">残忍拒绝</button>
                <button id="transfer-action-accept" class="action-btn accept">开心收下</button>
            </div>
            <button id="transfer-action-cancel" class="cancel-btn">×</button>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

    <div id="battery-alert-modal">
        <div class="battery-alert-content">
            <img id="battery-alert-image" src="">
            <p id="battery-alert-text"></p>
        </div>
    </div>

    <audio id="audio-player" style="display:none;"></audio>

    <!-- ▼▼▼ 用下面这段【完整】的模态框代码，替换掉你现有的 id="create-post-modal" 的整个 div ▼▼▼ -->
    <div id="create-post-modal" class="modal">
        <div class="modal-content" style="height: auto; max-height: 90%;">
            <div class="modal-header">
                <span>发布动态</span>
            </div>
            <div class="modal-body">
                <!-- 公开文字输入区 -->
                <div class="form-group">
                    <textarea id="post-public-text" rows="3" placeholder="分享新鲜事...（非必填的公开文字）"></textarea>
                </div>

                <!-- === 模式切换开关 (新增) === -->
                <div class="post-mode-switcher">
                    <button id="switch-to-image-mode" class="mode-btn active">上传图片</button>
                    <button id="switch-to-text-image-mode" class="mode-btn">使用文字图</button>
                </div>

                <!-- ▼▼▼ 【修正后】的可见范围设置 ▼▼▼ -->
                <div class="form-group">
                    <label>可见范围</label>
                    <div id="post-visibility-options" style="display: flex; gap: 15px; margin-bottom: 10px;">
                        <label><input type="radio" name="visibility" value="public" checked> 公开</label>

                        <label><input type="radio" name="visibility" value="include"> 指定分组可见</label>
                    </div>
                    <div id="post-visibility-groups"
                        style="display: none; max-height: 120px; overflow-y: auto; background: #f9f9f9; padding: 10px; border-radius: 8px;">
                        <!-- 分组多选框将由JS动态生成 -->
                    </div>
                </div>
                <!-- ▲▲▲ 修正结束 ▲▲▲ -->

                <!-- === 图片模式区域 === -->
                <div id="image-mode-content" class="post-mode-content active">
                    <div class="form-group">
                        <div id="post-image-preview-container" class="post-image-preview-container">
                            <img id="post-image-preview" src="" alt="图片预览">
                            <button id="post-remove-image-btn">×</button>
                        </div>
                        <div class="post-image-upload-options">
                            <button id="post-upload-local-btn" class="form-button-secondary">本地上传</button>
                            <button id="post-use-url-btn" class="form-button-secondary">网络URL</button>
                            <input type="file" id="post-local-image-input" accept="image/*" hidden>
                        </div>
                    </div>
                    <div id="post-image-desc-group" class="form-group" style="display: none;">
                        <label>图片描述 (必填，给AI看)</label>
                        <input type="text" id="post-image-description" placeholder="简单描述图片内容，帮助AI理解">
                    </div>
                </div>

                <!-- === 文字图模式区域 (新增) === -->
                <div id="text-image-mode-content" class="post-mode-content">
                    <div class="form-group">
                        <label>装饰图片 (纯装饰用，不会发送给AI)</label>
                        <input type="url" id="text-image-decorative-url" placeholder="输入图片链接 (可选)">
                    </div>
                    <div class="form-group">
                        <label>文字图 (给AI理解用的描述，点击图片后可见)</label>
                        <textarea id="post-hidden-text" rows="4" placeholder="在这里写下图片描述..."></textarea>
                    </div>
                </div>

            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-create-post-btn">取消</button>
                <button class="save" id="confirm-create-post-btn">发布</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 替换结束 ▲▲▲ -->

    <!-- ▼▼▼ 请将这个新的模态框HTML粘贴到所有其他模态框之后 ▼▼▼ -->
    <div id="group-management-modal" class="modal">
        <div class="modal-content" style="height: 60%;">
            <div class="modal-header">
                <span>管理好友分组</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>新建分组</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="new-group-name-input" placeholder="输入分组名..." style="flex-grow: 1;">
                        <button id="add-new-group-btn" class="form-button"
                            style="width: auto; margin-top: 0; padding: 0 15px;">添加</button>
                    </div>
                </div>
                <hr style="opacity: 0.2;">
                <div id="existing-groups-list" style="display: flex; flex-direction: column; gap: 10px;">
                    <!-- 分组列表将由JS动态生成 -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="save" id="close-group-manager-btn" style="width: 100%;">完成</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

    <!-- ▼▼▼ 请将这段新的HTML粘贴到刚刚删除的位置 ▼▼▼ -->
    <div id="message-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <!-- 操作按钮 -->
                <button id="quote-message-btn">引用</button>
                <button id="recall-message-btn">撤回</button>
                <button id="edit-message-btn">编辑</button>
                <button id="select-message-btn">多选</button>
                <button id="post-bulletin-btn">发布到公告板</button>
                <!-- 取消按钮 -->
                <button id="cancel-message-action-btn"
                    style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

    <!-- ▼▼▼ 请将这段新HTML粘贴到所有模态框的末尾 ▼▼▼ -->
    <div id="post-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="pin-post-btn">置顶</button>
                <button id="unpin-post-btn" style="display: none;">取消置顶</button>
                <button id="edit-post-btn">编辑动态</button>
                <button id="copy-post-btn">复制内容</button>
                <button id="delete-post-btn" style="color: #ff3b30;">删除动态</button>
                <button id="cancel-post-action-btn">取消</button>
            </div>
        </div>
    </div>

    <!-- ▼▼▼ 评论操作模态框 ▼▼▼ -->
    <div id="comment-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="edit-comment-btn">编辑评论</button>
                <button id="delete-comment-btn" style="color: #ff3b30;">删除评论</button>
                <button id="cancel-comment-action-btn">取消</button>
            </div>
        </div>
    </div>

    <!-- ▼▼▼ 聊天操作模态框 ▼▼▼ -->
    <div id="chat-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="pin-chat-btn">置顶对话</button>
                <button id="unpin-chat-btn" style="display: none;">取消置顶</button>
                <button id="delete-chat-btn" style="color: #ff3b30;">删除对话</button>
                <button id="cancel-chat-action-btn"
                    style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
            </div>
        </div>
    </div>

    <!-- ▼▼▼ AI回复选择模态框 ▼▼▼ -->
    <div id="ai-reply-modal" class="modal">
        <div class="modal-content" style="width: 90%; max-width: 400px;">
            <div class="modal-header">
                <span>选择AI回复</span>
                <span id="close-ai-reply-modal" style="cursor: pointer; font-size: 20px;">&times;</span>
            </div>
            <div class="modal-body">
                <div style="margin-bottom: 15px;">
                    <button id="select-all-ais"
                        style="padding: 5px 10px; margin-right: 10px; border: 1px solid #ddd; background: #f5f5f5; border-radius: 5px; cursor: pointer;">全选</button>
                    <button id="deselect-all-ais"
                        style="padding: 5px 10px; border: 1px solid #ddd; background: #f5f5f5; border-radius: 5px; cursor: pointer;">取消全选</button>
                </div>
                <div id="ai-selection-list" style="max-height: 300px; overflow-y: auto;">
                    <!-- AI列表将在这里动态生成 -->
                </div>
            </div>
            <div class="modal-footer">
                <button id="confirm-ai-reply" class="save">确认回复</button>
                <button id="cancel-ai-reply" class="cancel">取消</button>
            </div>
        </div>
    </div>

    <!-- ▼▼▼ AI发动态选择模态框 ▼▼▼ -->
    <div id="ai-post-modal" class="modal">
        <div class="modal-content" style="width: 90%; max-width: 400px;">
            <div class="modal-header">
                <span>选择AI发动态</span>
                <span id="close-ai-post-modal" style="cursor: pointer; font-size: 20px;">&times;</span>
            </div>
            <div class="modal-body">
                <div id="ai-post-selection-list" style="max-height: 300px; overflow-y: auto;">
                    <!-- AI列表将在这里动态生成 -->
                </div>
            </div>
            <div class="modal-footer">
                <button id="confirm-ai-post" class="save">确认发动态</button>
                <button id="cancel-ai-post" class="cancel">取消</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

    <!-- ▼▼▼ 移动表情到表情包选择模态框 ▼▼▼ -->
    <div id="move-sticker-modal" class="modal">
        <div class="modal-content" style="width: 90%; max-width: 400px;">
            <div class="modal-header">
                <span>选择表情包</span>
                <span id="close-move-sticker-modal" style="cursor: pointer; font-size: 20px;">&times;</span>
            </div>
            <div class="modal-body">
                <div id="sticker-pack-selection-list" style="max-height: 300px; overflow-y: auto;">
                    <!-- 表情包列表将在这里动态生成 -->
                </div>
            </div>
            <div class="modal-footer">
                <button id="confirm-move-sticker" class="save">确认移动</button>
                <button id="cancel-move-sticker" class="cancel">取消</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 移动表情包模态框结束 ▲▲▲ -->

    <!-- ▼▼▼ 【全新】可视化消息编辑器模态框 ▼▼▼ -->
    <div id="message-editor-modal" class="modal">
        <div class="modal-content" style="height: 75%;">
            <div class="modal-header">
                <span>编辑与拆分消息</span>
            </div>
            <div class="modal-body" id="message-editor-body">
                <!-- 编辑器容器，JS会在这里动态生成文本框 -->
                <div id="message-editor-container"></div>
                <!-- 添加新消息的按钮 -->
                <button id="add-message-editor-block-btn" class="form-button form-button-secondary"
                    style="margin-top: 15px;">
                    [+] 添加下一条消息
                </button>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-advanced-editor-btn">取消</button>
                <button class="save" id="save-advanced-editor-btn">保存更改</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

    <!-- ▼▼▼ 【全新】外卖请求模态框 ▼▼▼ -->
    <div id="waimai-request-modal" class="modal">
        <div class="modal-content" style="width: 290px;">
            <div class="modal-header">
                <span>发起外卖代付</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="waimai-product-info">商品信息</label>
                    <input type="text" id="waimai-product-info" placeholder="例如：一杯杨枝甘露">
                </div>
                <div class="form-group">
                    <label for="waimai-amount">代付金额 (元)</label>
                    <input type="number" id="waimai-amount" placeholder="例如：21" min="0" step="0.01">
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="waimai-cancel-btn">取消</button>
                <button class="save" id="waimai-confirm-btn">发起请求</button>
            </div>
        </div>
    </div>

    <!-- ▼▼▼ 【全新】新建约定/倒计时模态框 ▼▼▼ -->
    <div id="create-countdown-modal" class="modal">
        <div class="modal-content" style="height: auto;">
            <div class="modal-header">
                <span>新建约定</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="countdown-title-input">约定标题</label>
                    <input type="text" id="countdown-title-input" placeholder="例如：我的生日">
                </div>
                <div class="form-group">
                    <label for="countdown-date-input">约定日期与时间</label>
                    <input type="datetime-local" id="countdown-date-input">
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-create-countdown-btn">取消</button>
                <button class="save" id="confirm-create-countdown-btn">保存约定</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

    <!-- ▼▼▼ 【全新】选择添加类型模态框 ▼▼▼ -->
    <div id="add-memory-type-modal" class="modal">
        <div class="modal-content" style="height: auto;">
            <div class="modal-header">
                <span>添加内容</span>
            </div>
            <div class="modal-body">
                <button class="form-button" id="add-memory-btn" style="margin-bottom: 15px;">
                    📝 添加回忆
                </button>
                <button class="form-button" id="add-event-btn">
                    📅 添加约定/事件
                </button>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-add-type-btn">取消</button>
            </div>
        </div>
    </div>

    <!-- ▼▼▼ 【全新】QZone添加内容选择模态框 ▼▼▼ -->
    <div id="qzone-add-options-modal" class="modal">
        <div class="modal-content" style="height: auto;">
            <div class="modal-header">
                <span>添加内容</span>
            </div>
            <div class="modal-body">
                <button class="form-button" id="modal-create-shuoshuo-btn" style="margin-bottom: 15px;">
                    💬 说说
                </button>
                <button class="form-button" id="modal-create-post-btn" style="margin-bottom: 15px;">
                    📷 动态
                </button>
                <button class="form-button" id="modal-open-album-btn">
                    📁 相册
                </button>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-qzone-add-btn">取消</button>
            </div>
        </div>
    </div>

    <!-- ▼▼▼ 【全新】添加回忆模态框 ▼▼▼ -->
    <div id="create-memory-modal" class="modal">
        <div class="modal-content" style="height: auto;">
            <div class="modal-header">
                <span>新建回忆</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="memory-description-input">回忆内容</label>
                    <textarea id="memory-description-input" placeholder="记录一段美好的回忆..." rows="4"></textarea>
                </div>
                <div class="form-group">
                    <label for="memory-date-input">回忆日期与时间</label>
                    <input type="datetime-local" id="memory-date-input">
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-create-memory-btn">取消</button>
                <button class="save" id="confirm-create-memory-btn">保存回忆</button>
            </div>
        </div>
    </div>

    <!-- ▼▼▼ 【全新】发红包模态框 ▼▼▼ -->
    <div id="red-packet-modal" class="modal">
        <div class="modal-content" style="width: 300px; height: auto;">
            <div class="modal-header">
                <span>发红包</span>
            </div>
            <div class="modal-body" style="padding: 0;">
                <!-- 1. 页签切换 -->
                <div class="frame-tabs">
                    <div id="rp-tab-group" class="frame-tab active">拼手气红包</div>
                    <div id="rp-tab-direct" class="frame-tab">专属红包</div>
                </div>

                <!-- 2. 拼手气红包内容区 -->
                <div id="rp-content-group" class="frame-content" style="padding: 20px 15px;">
                    <div class="form-group">
                        <label>总金额 (元)</label>
                        <input type="number" id="rp-group-amount" placeholder="0.00">
                    </div>
                    <div class="form-group">
                        <label>红包个数</label>
                        <input type="number" id="rp-group-count" placeholder="填写红包个数">
                    </div>
                    <div class="form-group">
                        <label>祝福语</label>
                        <input type="text" id="rp-group-greeting" placeholder="恭喜发财，大吉大利！">
                    </div>
                    <p id="rp-group-total"
                        style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">¥ 0.00</p>
                    <button id="send-group-packet-btn" class="form-button">塞钱进红包</button>
                </div>

                <!-- 3. 专属红包内容区 -->
                <div id="rp-content-direct" class="frame-content" style="display: none; padding: 20px 15px;">
                    <div class="form-group">
                        <label>发送给</label>
                        <select id="rp-direct-receiver"></select>
                    </div>
                    <div class="form-group">
                        <label>金额 (元)</label>
                        <input type="number" id="rp-direct-amount" placeholder="0.00">
                    </div>
                    <div class="form-group">
                        <label>祝福语</label>
                        <input type="text" id="rp-direct-greeting" placeholder="恭喜发财，大吉大利！">
                    </div>
                    <p id="rp-direct-total"
                        style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">¥ 0.00</p>
                    <button id="send-direct-packet-btn" class="form-button">塞钱进红包</button>
                </div>
            </div>
            <div class="modal-footer" style="justify-content: center;">
                <button class="cancel" id="cancel-red-packet-btn" style="width: 100%;">取消</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

    <!-- ▼▼▼ 【全新】红包详情模态框 ▼▼▼ -->
    <div id="red-packet-details-modal" class="modal">
        <div class="modal-content" style="width: 280px; height: auto; background-color: #f7f7f7;">
            <div class="modal-header"
                style="background-color: #F96259; color: white; border-bottom: none; padding-bottom: 5px;">
                <div style="text-align: center; width: 100%;">
                    <div id="rp-details-sender" style="font-size: 16px;"></div>
                    <div style="font-size: 13px; opacity: 0.8;">的红包</div>
                </div>
            </div>
            <div class="modal-body" style="padding: 15px;">
                <p id="rp-details-greeting"
                    style="text-align: center; font-size: 20px; color: #333; margin: 0 0 20px 0;"></p>
                <div id="rp-details-my-amount" style="text-align: center; display: none; margin-bottom: 20px;">
                    <span style="font-size: 40px; font-weight: bold; color: #E44D44;">0.00</span>
                    <span style="font-size: 18px; color: #E44D44;">元</span>
                </div>
                <div id="rp-details-summary"
                    style="font-size: 13px; color: #8a8a8a; border-top: 1px solid #e0e0e0; padding-top: 10px;"></div>
                <div id="rp-details-list" style="max-height: 150px; overflow-y: auto; margin-top: 10px;">
                    <!-- 领取详情将由JS动态生成在这里 -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="save" id="close-rp-details-btn" style="width: 100%;">关闭</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】创建投票模态框 ▼▼▼ -->
    <div id="create-poll-modal" class="modal">
        <div class="modal-content" style="width: 300px; height: auto;">
            <div class="modal-header">
                <span>发起投票</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="poll-question-input">投票问题</label>
                    <textarea id="poll-question-input" rows="2" placeholder="例如：今晚我们看什么电影？"></textarea>
                </div>
                <div class="form-group">
                    <label>投票选项 (至少2项)</label>
                    <div id="poll-options-container" style="display: flex; flex-direction: column; gap: 8px;">
                        <!-- 投票选项将由JS动态生成在这里 -->
                    </div>
                    <button id="add-poll-option-btn" class="form-button form-button-secondary"
                        style="margin-top: 12px;">+ 添加选项</button>
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-create-poll-btn">取消</button>
                <button class="save" id="confirm-create-poll-btn">发起投票</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】公告板模态框 ▼▼▼ -->
    <div id="bulletin-board-modal" class="modal">
        <div class="modal-content" style="height: 80%;">
            <div class="modal-header">
                <span>群公告板</span>
            </div>
            <div class="modal-body" id="bulletin-list">
                <!-- 公告列表将由JS动态生成在这里 -->
            </div>
            <div class="modal-footer">
                <button class="save" id="close-bulletin-board-btn" style="width: 100%;">关闭</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

    <!-- ▼▼▼ 【全新】公告板操作菜单模态框 ▼▼▼ -->
    <div id="bulletin-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="pin-bulletin-btn">置顶/取消置顶</button>
                <button id="delete-bulletin-btn" class="btn-danger">删除公告</button>
                <button id="cancel-bulletin-action-btn"
                    style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

    <!-- ▼▼▼ Share Link Modal ▼▼▼ -->
    <div id="share-link-modal" class="modal">
        <div class="modal-content" style="width: 300px; height: auto;">
            <div class="modal-header">
                <span>分享链接</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="link-title-input">标题</label>
                    <input type="text" id="link-title-input" placeholder="输入文章或链接的标题">
                </div>
                <div class="form-group">
                    <label for="link-description-input">摘要 (可选)</label>
                    <textarea id="link-description-input" rows="2" placeholder="简单描述一下链接内容"></textarea>
                </div>
                <div class="form-group">
                    <label for="link-source-input">来源名称 (可选)</label>
                    <input type="text" id="link-source-input" placeholder="例如：知乎日报、B站">
                </div>
                <div class="form-group">
                    <label for="link-content-input">完整内容 (可选，用于浏览器内显示)</label>
                    <textarea id="link-content-input" rows="4" placeholder="粘贴或输入完整的文章内容"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-share-link-btn">取消</button>
                <button class="save" id="confirm-share-link-btn">分享</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ Share Link Modal End ▲▲▲ -->

    <!-- ▼▼▼ Location Share Modal ▼▼▼ -->
    <div id="location-share-modal" class="modal">
        <div class="modal-content" style="width: 300px; height: auto;">
            <div class="modal-header">
                <span>分享位置</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="location-name-input">位置名称</label>
                    <input type="text" id="location-name-input" placeholder="例如：星巴克咖啡店、北京大学">
                </div>
                <div class="form-group">
                    <label for="location-address-input">详细地址 (可选)</label>
                    <textarea id="location-address-input" rows="2" placeholder="输入详细地址或描述"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="cancel" id="cancel-location-btn">取消</button>
                <button type="button" class="save" id="confirm-location-btn">发送位置</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ Location Share Modal End ▲▲▲ -->

    <!-- ▼▼▼ Meetup Creation Modal ▼▼▼ -->
    <div id="meetup-creation-modal" class="modal">
        <div class="modal-content" style="width: 300px; height: auto;">
            <div class="modal-header">
                <span>开始见面</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="meetup-title-input">见面主题</label>
                    <input type="text" id="meetup-title-input" placeholder="浪漫晚餐, 散步见面...">
                </div>
                <div class="form-group">
                    <label for="meetup-location-input">见面地点</label>
                    <input type="text" id="meetup-location-input" placeholder="咖啡厅, 公园, 家里...">
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-meetup-btn">取消</button>
                <button class="save" id="start-meetup-btn">开始见面</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ Date Creation Modal End ▲▲▲ -->

    <!-- ▼▼▼ Sticker Pack Edit Modal ▼▼▼ -->
    <div id="sticker-pack-edit-modal" class="modal">
        <div class="modal-content" style="width: 300px; height: auto;">
            <div class="modal-header">
                <span>编辑表情包</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="sticker-pack-name-input">表情包名称</label>
                    <input type="text" id="sticker-pack-name-input" placeholder="我的表情包">
                </div>
                <div class="form-group">
                    <label for="sticker-pack-icon-input">图标链接</label>
                    <input type="text" id="sticker-pack-icon-input" placeholder="https://example.com/icon.png">
                </div>
                <div class="form-group">
                    <button id="delete-sticker-pack-btn"
                        style="width: 100%; padding: 10px; background-color: #ff3b30; color: white; border: none; border-radius: 8px; cursor: pointer;">删除表情包</button>
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-sticker-pack-edit-btn">取消</button>
                <button class="save" id="save-sticker-pack-btn">保存</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ Sticker Pack Edit Modal End ▲▲▲ -->

    <!-- ▼▼▼ New Sticker Pack Modal ▼▼▼ -->
    <div id="new-sticker-pack-modal" class="modal">
        <div class="modal-content" style="width: 300px; height: auto;">
            <div class="modal-header">
                <span>新建表情包</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="new-pack-name-input">表情包名称</label>
                    <input type="text" id="new-pack-name-input" placeholder="我的表情包">
                </div>
                <div class="form-group">
                    <label for="new-pack-icon-input">图标链接</label>
                    <input type="text" id="new-pack-icon-input" placeholder="https://example.com/icon.png">
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-new-pack-btn">取消</button>
                <button class="save" id="create-new-pack-btn">创建</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ New Sticker Pack Modal End ▲▲▲ -->

    <!-- ▼▼▼ Meetup End Confirmation Modal ▼▼▼ -->
    <div id="meetup-end-modal" class="modal">
        <div class="modal-content" style="width: 300px; height: auto;">
            <div class="modal-header">
                <span>结束见面</span>
            </div>
            <div class="modal-body">
                <p>确定要结束这次见面吗？所有的美好回忆都会保存到日历中。</p>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-end-date-btn" onclick="hideMeetupEndModal()">继续见面</button>
                <button class="save" id="confirm-end-date-btn" onclick="window.confirmEndMeetup()">结束见面</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ Date End Confirmation Modal End ▲▲▲ -->

    <!-- ▼▼▼ 【全新shep】备份版本选择模态框 ▼▼▼ -->
    <div id="restore-version-modal" class="modal">
        <div class="modal-content" style="width: 320px; height: auto;">
            <div class="modal-header">
                <span>选择要恢复的云端备份</span>
            </div>
            <div class="modal-body" id="restore-version-list" style="padding: 15px 0;">
                <!-- 加载提示 -->
                <p style="text-align:center; color: var(--text-secondary);">正在从云端获取备份信息...</p>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-restore-version-btn" style="width: 100%;">取消</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲shepshep 新HTML粘贴结束 ▲▲▲ -->
    <script>
        // Spotify Web Playback SDK callback - must be defined globally before SDK loads
        window.onSpotifyWebPlaybackSDKReady = function () {
            // This will be handled by initSpotifyPlayer() when needed
        };

        // Function to toggle charm visibility - defined early to avoid execution order issues
        window.toggleCharmVisibility = function (isVisible) {
            const charm = document.getElementById('floating-phone-charm');
            if (charm) {
                charm.style.display = isVisible ? 'block' : 'none';
            }
        }

        document.addEventListener('DOMContentLoaded', () => {

            // ===================================================================
            // 1. 所有变量和常量定义
            // ===================================================================
            const db = new Dexie('GeminiChatDB');
            window.db = db;
            // --- 已修正 ---
            let state = { chats: {}, activeChatId: null, globalSettings: {}, apiConfig: {}, userStickers: [], worldBooks: [], personaPresets: [], qzoneSettings: {}, activeAlbumId: null };
            // --- 修正结束 ---
            let musicState = { isActive: false, activeChatId: null, isPlaying: false, playlist: [], currentIndex: -1, playMode: 'order', totalElapsedTime: 0, timerId: null, currentSpotifyPlaylist: null, spotifyPlaylistTracks: [], isPlayingFromPlaylist: false, mainPlaylist: [] };
            // Spotify integration variables
            let spotifyPlayer = null;
            let spotifyAccessToken = null;
            let spotifyDeviceId = null;
            const audioPlayer = document.getElementById('audio-player');
            let newWallpaperBase64 = null;
            let isSelectionMode = false;
            let selectedMessages = new Set();
            let editingMemberId = null;
            let editingFrameForMember = false;
            let editingWorldBookId = null;
            let editingPersonaPresetId = null;
            let editingMemoryId = null;
            let previousScreen = null; // Track previous screen for meetup navigation
            let inactivityTimers = {}; // 用于存储1.5小时离线计时器
            let focusModeTimers = {}; // 用于存储专注模式计时器
            let waimaiTimers = {}; // 用于存储外卖倒计时

            let activeMessageTimestamp = null;
            let activeChatId = null;
            let currentReplyContext = null; // <--- 新增这行，用来存储当前正在引用的消息信息
            let activePostId = null; // <-- 新增：用于存储当前操作的动态ID
            let activeBulletinId = null; // <-- 新增：用于存储当前操作的公告ID
            let activeCommentData = null; // <-- 新增：用于存储当前操作的评论数据 {postId, timestamp, text, commenterName}

            let photoViewerState = {
                isOpen: false,
                photos: [], // 存储当前相册的所有照片URL
                currentIndex: -1, // 当前正在查看的照片索引
            };

            let unreadPostsCount = 0;

            let isFavoritesSelectionMode = false;
            let selectedFavorites = new Set()

            let simulationIntervalId = null;

            const frameModal = document.getElementById('avatar-frame-modal');
            const aiFrameTab = document.getElementById('ai-frame-tab');
            const myFrameTab = document.getElementById('my-frame-tab');
            const aiFrameContent = document.getElementById('ai-frame-content');
            const myFrameContent = document.getElementById('my-frame-content');
            const aiFrameGrid = document.getElementById('ai-frame-grid');
            const myFrameGrid = document.getElementById('my-frame-grid');

            const defaultAvatar = 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg';
            const defaultMyGroupAvatar = 'https://i.postimg.cc/cLPP10Vm/4.jpg';
            const defaultGroupMemberAvatar = 'https://i.postimg.cc/VkQfgzGJ/1.jpg';
            const defaultGroupAvatar = 'https://i.postimg.cc/gc3QYCDy/1-NINE7-Five.jpg';
            let notificationTimeout;

            const npcAvatarPool = {
                'anime_boy': ['https://i.postimg.cc/pL5505fT/image.png', 'https://i.postimg.cc/8CKdY2z4/image.png'],
                'anime_girl': ['https://i.postimg.cc/PqgqfH7S/image.png', 'https://i.postimg.cc/Z5pCY9tQ/image.png'],
                'cat': ['https://i.postimg.cc/d11x6HKZ/image.png', 'https://i.postimg.cc/VL1gLgV3/image.png'],
                'professional': ['https://i.postimg.cc/13yXhJg9/image.png', 'https://i.postimg.cc/W34kKFN5/image.png'],
                'pixel_art': ['https://i.postimg.cc/VvF0tGgG/image.png', 'https://i.postimg.cc/wMPyS8bB/image.png']
            };


            let currentFrameSelection = { ai: null, my: null };
            const STICKER_REGEX = /^(https:\/\/i\.postimg\.cc\/.+|https:\/\/files\.catbox\.moe\/.+|data:image)/;
            const MESSAGE_RENDER_WINDOW = 50;
            let currentRenderedCount = 0;
            let lastKnownBatteryLevel = 1;
            let alertFlags = { hasShown40: false, hasShown20: false, hasShown10: false };
            let batteryAlertTimeout;
            const dynamicFontStyle = document.createElement('style');
            dynamicFontStyle.id = 'dynamic-font-style';
            document.head.appendChild(dynamicFontStyle);

            const modalOverlay = document.getElementById('custom-modal-overlay');
            const modalTitle = document.getElementById('custom-modal-title');
            const modalBody = document.getElementById('custom-modal-body');
            const modalConfirmBtn = document.getElementById('custom-modal-confirm');
            const modalCancelBtn = document.getElementById('custom-modal-cancel');
            let modalResolve;

            function showCustomModal() {
                modalOverlay.classList.add('visible');
            }

            function hideCustomModal() {
                modalOverlay.classList.remove('visible');
                modalConfirmBtn.classList.remove('btn-danger');
                if (modalResolve) modalResolve(null);
            }

            function showCustomConfirm(title, message, options = {}) {
                return new Promise(resolve => {
                    modalResolve = resolve;
                    modalTitle.textContent = title;
                    modalBody.innerHTML = `<p>${message}</p>`;
                    modalCancelBtn.style.display = 'block';
                    modalConfirmBtn.textContent = '确定';
                    if (options.confirmButtonClass) modalConfirmBtn.classList.add(options.confirmButtonClass);
                    modalConfirmBtn.onclick = () => { resolve(true); hideCustomModal(); };
                    modalCancelBtn.onclick = () => { resolve(false); hideCustomModal(); };
                    showCustomModal();
                });
            }

            function showCustomAlert(title, message) {
                return new Promise(resolve => {
                    modalResolve = resolve;
                    modalTitle.textContent = title;
                    modalBody.innerHTML = `<p style="text-align: left; white-space: pre-wrap;">${message}</p>`;
                    modalCancelBtn.style.display = 'none';
                    modalConfirmBtn.textContent = '好的';
                    modalConfirmBtn.onclick = () => {
                        modalCancelBtn.style.display = 'block';
                        modalConfirmBtn.textContent = '确定';
                        resolve(true);
                        hideCustomModal();
                    };
                    showCustomModal();
                });
            }

            // ▼▼▼ 请用这个【功能增强版】替换旧的 showCustomPrompt 函数 ▼▼▼
            function showCustomPrompt(title, placeholder, initialValue = '', type = 'text', extraHtml = '') {
                return new Promise(resolve => {
                    modalResolve = resolve;
                    modalTitle.textContent = title;
                    const inputId = 'custom-prompt-input';

                    const inputHtml = type === 'textarea'
                        ? `<textarea id="${inputId}" placeholder="${placeholder}" rows="5" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box; resize: vertical;">${initialValue}</textarea>`
                        : `<input type="${type}" id="${inputId}" placeholder="${placeholder}" value="${initialValue}">`;

                    // 【核心修改】将额外的HTML和输入框组合在一起
                    modalBody.innerHTML = extraHtml + inputHtml;
                    const input = document.getElementById(inputId);

                    // 【核心修改】为格式助手按钮绑定事件
                    modalBody.querySelectorAll('.format-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            const templateStr = btn.dataset.template;
                            if (templateStr) {
                                try {
                                    const templateObj = JSON.parse(templateStr);
                                    // 使用 null, 2 参数让JSON字符串格式化，带缩进，更易读
                                    input.value = JSON.stringify(templateObj, null, 2);
                                    input.focus();
                                } catch (e) {
                                    console.error("解析格式模板失败:", e);
                                }
                            }
                        });
                    });

                    modalConfirmBtn.onclick = () => { resolve(input.value); hideCustomModal(); };
                    modalCancelBtn.onclick = () => { resolve(null); hideCustomModal(); };
                    showCustomModal();
                    setTimeout(() => input.focus(), 100);
                });
            }
            // ▲▲▲ 替换结束 ▲▲▲

            // ===================================================================
            // 2. 数据库结构定义
            // ===================================================================

            db.version(22).stores({
                chats: '&id, isGroup, groupId',
                apiConfig: '&id',
                globalSettings: '&id',
                userStickers: '&id, url, name, order, packId',
                worldBooks: '&id, name',
                musicLibrary: '&id',
                personaPresets: '&id',
                qzoneSettings: '&id',
                qzonePosts: '++id, timestamp, authorId, isPinned', // <-- 为authorId添加索引，添加isPinned字段
                qzoneAlbums: '++id, name, createdAt',
                qzonePhotos: '++id, albumId',
                favorites: '++id, type, timestamp, originalTimestamp',
                qzoneGroups: '++id, name',
                memories: '++id, chatId, timestamp, type, targetDate',
                bulletins: '++id, chatId, timestamp, isPinned' // <--- 【核心新增】这就是公告的新家！
            });

            // ===================================================================
            // 3. 所有功能函数定义
            // ===================================================================

            function showScreen(screenId) {
                if (screenId === 'chat-list-screen') {
                    window.renderChatListProxy();
                    switchToChatListView('messages-view');
                }
                if (screenId === 'api-settings-screen') window.renderApiSettingsProxy();
                if (screenId === 'appearance-settings-screen') {
                    window.renderWallpaperScreenProxy();

                    // Initialize charm visibility toggle after screen is rendered
                    setTimeout(() => {
                        const charmVisibilityToggle = document.getElementById('charm-visibility-toggle');
                        if (charmVisibilityToggle) {
                            // Load saved state
                            const savedVisibility = localStorage.getItem('charmVisibility');
                            const isVisible = savedVisibility !== 'false'; // Default to true
                            charmVisibilityToggle.checked = isVisible;

                            // Apply initial state
                            window.toggleCharmVisibility(isVisible);

                            // Remove any existing event listeners to avoid duplicates
                            charmVisibilityToggle.removeEventListener('change', window.charmToggleHandler);

                            // Add event listener
                            window.charmToggleHandler = (e) => {
                                const isVisible = e.target.checked;
                                localStorage.setItem('charmVisibility', isVisible.toString());
                                window.toggleCharmVisibility(isVisible);
                            };
                            charmVisibilityToggle.addEventListener('change', window.charmToggleHandler);
                        }
                    }, 100);
                }
                if (screenId === 'world-book-screen') window.renderWorldBookScreenProxy();
                if (screenId === 'settings-screen') window.renderSettingsScreenProxy();
                if (screenId === 'general-settings-screen') {
                    window.renderGeneralSettingsScreenProxy();
                    // Initialize photo compression toggle state
                    const toggle = document.getElementById('photo-compression-toggle');
                    if (toggle) {
                        toggle.checked = state.globalSettings.photoCompression !== false; // Default to true
                    }


                }
                if (screenId === 'calendar-screen') window.renderCalendarScreenProxy();
                if (screenId === 'meetup-screen') {
                    initializeMeetupScreen();
                }

                // Track previous screen for meetup navigation
                const currentActiveScreen = document.querySelector('.screen.active');
                if (currentActiveScreen && screenId === 'meetup-screen') {
                    previousScreen = currentActiveScreen.id;
                }

                document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
                const screenToShow = document.getElementById(screenId);
                if (screenToShow) screenToShow.classList.add('active');
                if (screenId === 'chat-interface-screen') {
                    window.updateListenTogetherIconProxy(state.activeChatId);
                    // Only update content if bar is already visible
                    updateNowPlayingBarContent();
                }

                // Update now playing bar visibility when switching screens
                if (musicState.isActive && (screenId === 'home-screen' || screenId === 'chat-interface-screen')) {
                    showNowPlayingBar();
                }



                // Update meetup progress bar visibility when switching screens
                if (hasActiveMeetupSession() && (screenId === 'home-screen' || screenId === 'chat-interface-screen')) {
                    showMeetupProgressBar();
                }
                if (screenId === 'appearance-settings-screen') {
                    const savedFontUrl = state.globalSettings.fontUrl || '';
                    document.getElementById('font-url-input').value = savedFontUrl;

                    // Check if saved font is a data URL (uploaded font) or regular URL
                    if (savedFontUrl.startsWith('data:')) {
                        // It's an uploaded font
                        document.getElementById('font-file-name').textContent = '已上传的字体文件';
                        window.uploadedFontData = savedFontUrl;
                    } else {
                        // It's a URL or empty
                        document.getElementById('font-file-name').textContent = '未选择文件';
                        window.uploadedFontData = null;
                    }

                    applyCustomFont(savedFontUrl, true);
                }
            }
            window.updateListenTogetherIconProxy = () => { };



            function switchToChatListView(viewId) {
                const chatListScreen = document.getElementById('chat-list-screen');
                const views = {
                    'messages-view': document.getElementById('messages-view'),
                    'qzone-screen': document.getElementById('qzone-screen'),
                    'favorites-view': document.getElementById('favorites-view'),
                    'memories-view': document.getElementById('memories-view') // <-- 新增这一行
                };
                const mainHeader = document.getElementById('main-chat-list-header');
                const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // 获取主导航栏

                if (isFavoritesSelectionMode) {
                    document.getElementById('favorites-edit-btn').click();
                }

                // 隐藏所有视图
                Object.values(views).forEach(v => v.classList.remove('active'));
                // 显示目标视图
                if (views[viewId]) {
                    views[viewId].classList.add('active');
                }

                // 更新底部导航栏高亮
                document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => {
                    item.classList.toggle('active', item.dataset.view === viewId);
                });

                // ▼▼▼ 【核心修正】在这里统一管理所有UI元素的显隐 ▼▼▼
                if (viewId === 'messages-view') {
                    mainHeader.style.display = 'flex';
                    mainBottomNav.style.display = 'flex';
                } else {
                    mainHeader.style.display = 'none';
                    mainBottomNav.style.display = 'none';
                }
                // ▲▲▲ 修正结束 ▲▲▲

                if (viewId !== 'memories-view') {
                    activeCountdownTimers.forEach(timerId => clearInterval(timerId));
                    activeCountdownTimers = [];
                }

                // 根据视图ID执行特定的渲染/更新逻辑
                switch (viewId) {
                    case 'qzone-screen':
                        views['qzone-screen'].style.backgroundColor = '#f0f2f5';
                        updateUnreadIndicator(0);
                        renderQzoneScreen();
                        renderQzonePosts();
                        break;
                    case 'favorites-view':
                        views['favorites-view'].style.backgroundColor = '#f9f9f9';
                        renderFavoritesScreen();
                        break;
                    case 'messages-view':
                        // 如果需要，可以在这里添加返回消息列表时要执行的逻辑
                        break;
                }
            }

            function renderQzoneScreen() {
                if (state && state.qzoneSettings) {
                    const settings = state.qzoneSettings;
                    document.getElementById('qzone-nickname').textContent = settings.nickname;
                    document.getElementById('qzone-avatar-img').src = settings.avatar;
                    document.getElementById('qzone-banner-img').src = settings.banner;
                }
            }
            window.renderQzoneScreenProxy = renderQzoneScreen;



            async function saveQzoneSettings() {
                if (db && state.qzoneSettings) {
                    await db.qzoneSettings.put(state.qzoneSettings);
                }
            }

            function formatPostTimestamp(timestamp) {
                if (!timestamp) return '';
                const now = new Date();
                const date = new Date(timestamp);
                const diffSeconds = Math.floor((now - date) / 1000);
                const diffMinutes = Math.floor(diffSeconds / 60);
                const diffHours = Math.floor(diffMinutes / 60);
                if (diffMinutes < 1) return '刚刚';
                if (diffMinutes < 60) return `${diffMinutes}分钟前`;
                if (diffHours < 24) return `${diffHours}小时前`;
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                if (now.getFullYear() === year) {
                    return `${month}-${day} ${hours}:${minutes}`;
                } else {
                    return `${year}-${month}-${day} ${hours}:${minutes}`;
                }
            }

            function formatTimeDifference(ms) {
                if (ms < 60000) return null; // 小于1分钟不处理
                const minutes = Math.floor(ms / 60000);
                if (minutes < 60) {
                    return `约 ${minutes} 分钟`;
                }
                const hours = Math.floor(minutes / 60);
                const remainingMinutes = minutes % 60;
                if (remainingMinutes === 0) {
                    return `${hours} 小时`;
                }
                return `${hours} 小时 ${remainingMinutes} 分钟`;
            }

            async function renderQzonePosts() {
                const postsListEl = document.getElementById('qzone-posts-list');
                if (!postsListEl) return;

                const [allPosts, favorites] = await Promise.all([
                    db.qzonePosts.orderBy('timestamp').reverse().toArray(),
                    db.favorites.where('type').equals('qzone_post').toArray() // 获取所有已收藏的动态
                ]);

                // 按置顶状态和时间排序：置顶的在前，然后按时间倒序
                const posts = allPosts.sort((a, b) => {
                    // 首先按置顶状态排序（置顶的在前）
                    if (a.isPinned && !b.isPinned) return -1;
                    if (!a.isPinned && b.isPinned) return 1;

                    // 然后按时间倒序排序
                    return b.timestamp - a.timestamp;
                });

                // 创建一个已收藏帖子ID的集合，方便快速查找
                const favoritedPostIds = new Set(favorites.map(fav => fav.content.id));

                postsListEl.innerHTML = '';

                if (posts.length === 0) {
                    postsListEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">这里空空如也，快来发布第一条说说吧！</p>';
                    return;
                }

                const userSettings = state.qzoneSettings;

                posts.forEach(post => {
                    const postContainer = document.createElement('div');
                    postContainer.className = 'qzone-post-container';
                    postContainer.dataset.postId = post.id;

                    const postEl = document.createElement('div');
                    postEl.className = 'qzone-post-item';

                    let authorAvatar = '', authorNickname = '', commentAvatar = userSettings.avatar;

                    if (post.authorId === 'user') {
                        authorAvatar = userSettings.avatar;
                        authorNickname = userSettings.nickname;
                    } else if (state.chats[post.authorId]) {
                        const authorChat = state.chats[post.authorId];
                        authorAvatar = authorChat.settings.aiAvatar || defaultAvatar;
                        authorNickname = authorChat.name;
                    } else {
                        authorAvatar = defaultAvatar;
                        authorNickname = '{{char}}';
                    }

                    let contentHtml = '';
                    const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';

                    if (post.type === 'shuoshuo') {
                        contentHtml = `<div class="post-content" style="margin-bottom: 10px;">${post.content.replace(/\n/g, '<br>')}</div>`;
                    }
                    else if (post.type === 'image_post' && post.imageUrl) {
                        contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>` : `<img src="${post.imageUrl}" class="chat-image">`;
                    }
                    else if (post.type === 'text_image') {
                        // For text_image posts, show public text and decorative image if available
                        if (post.decorativeImageUrl) {
                            contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.decorativeImageUrl}" class="chat-image"></div>` : `<img src="${post.decorativeImageUrl}" class="chat-image">`;
                        } else {
                            contentHtml = publicTextHtml || '';
                        }
                    }

                    let likesHtml = '';
                    if (post.likes && post.likes.length > 0) {
                        likesHtml = `<div class="post-likes-section"><svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg><span>${post.likes.join('、')} 觉得很赞</span></div>`;
                    }

                    let commentsHtml = '';
                    if (post.comments && post.comments.length > 0) {
                        commentsHtml = '<div class="post-comments-container">';
                        post.comments.forEach(comment => {
                            // 【核心修正】在这里进行防御性检查
                            const commenterName = comment.commenterName || '匿名'; // 如果名字是undefined，则显示匿名
                            const commentText = comment.text || ''; // 如果内容是undefined，则显示为空
                            commentsHtml += `<div class="comment-item" data-comment-timestamp="${comment.timestamp || ''}" data-commenter="${commenterName}"><span class="commenter-name">${commenterName}:</span><span class="comment-text">${commentText}</span></div>`;
                        });
                        commentsHtml += '</div>';
                    }

                    // 检查点赞和收藏状态
                    const userNickname = state.qzoneSettings.nickname;
                    const isLikedByUser = post.likes && post.likes.includes(userNickname);
                    const isFavoritedByUser = favoritedPostIds.has(post.id); // 使用Set快速查找

                    postEl.innerHTML = `
                    <div class="post-header">
                        <img src="${authorAvatar}" class="post-avatar">
                        <div class="post-info">
                            <span class="post-nickname">${authorNickname}</span>
                            <span class="post-timestamp">${formatPostTimestamp(post.timestamp)}</span>
                        </div>
                        <div style="margin-left: auto; display: flex; align-items: center; gap: 8px;">
                            ${post.type === 'text_image' ? `<span data-hidden-text="${post.hiddenContent || ''}" style="cursor: pointer;">💭</span>` : ''}
                            <div class="post-actions-btn" data-hidden-text="${post.hiddenContent || ''}" style="margin-left: 0;">…</div>
                        </div>
                    </div>

                    <div class="post-main-content">${contentHtml}</div>
                    <div class="post-feedback-icons">
                        <span class="action-icon like ${isLikedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></span>
                        <span class="action-icon favorite ${isFavoritedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg></span>
                    </div>
                    ${likesHtml}
                    ${commentsHtml}
                    <div class="post-footer"><div class="comment-section"><img src="${commentAvatar}" class="comment-avatar"><input type="text" class="comment-input" placeholder="友善的评论是交流的起点"><div class="at-mention-popup"></div></div><button class="comment-send-btn">发送</button><button class="call-ai-reply-btn" title="让AI们回复">🤖</button></div>
                `;

                    // COMMENTED OUT: Delete action for swipe functionality
                    /*
                    const deleteAction = document.createElement('div');
                    deleteAction.className = 'qzone-post-delete-action';
                    deleteAction.innerHTML = '<span>删除</span>';
                    postContainer.appendChild(deleteAction);
                    */
                    postContainer.appendChild(postEl);
                    const commentSection = postContainer.querySelector('.comment-section');
                    if (commentSection) {
                        commentSection.addEventListener('touchstart', (e) => e.stopPropagation());
                        commentSection.addEventListener('mousedown', (e) => e.stopPropagation());
                    }
                    postsListEl.appendChild(postContainer);

                    // 为所有评论添加长按监听器
                    const commentItems = postContainer.querySelectorAll('.comment-item');
                    commentItems.forEach(commentItem => {
                        const commenterName = commentItem.dataset.commenter;
                        const commentTimestamp = parseInt(commentItem.dataset.commentTimestamp);
                        const commentText = commentItem.querySelector('.comment-text')?.textContent || '';
                        const postId = parseInt(postContainer.dataset.postId);

                        addLongPressListener(commentItem, async () => {
                            showCommentActions(postId, commentTimestamp, commentText, commenterName);
                        })
                    });

                    const commentInput = postContainer.querySelector('.comment-input');
                    const popup = postContainer.querySelector('.at-mention-popup');
                    commentInput.addEventListener('input', () => {
                        const value = commentInput.value;
                        const atMatch = value.match(/@([\p{L}\w]*)$/u);
                        if (atMatch) {
                            const namesToMention = new Set();
                            const authorNickname = postContainer.querySelector('.post-nickname')?.textContent;
                            if (authorNickname) namesToMention.add(authorNickname);
                            postContainer.querySelectorAll('.commenter-name').forEach(nameEl => {
                                namesToMention.add(nameEl.textContent.replace(':', ''));
                            });
                            namesToMention.delete(state.qzoneSettings.nickname);
                            popup.innerHTML = '';
                            if (namesToMention.size > 0) {
                                const searchTerm = atMatch[1];
                                namesToMention.forEach(name => {
                                    if (name.toLowerCase().includes(searchTerm.toLowerCase())) {
                                        const item = document.createElement('div');
                                        item.className = 'at-mention-item';
                                        item.textContent = name;
                                        item.addEventListener('mousedown', (e) => {
                                            e.preventDefault();
                                            const newText = value.substring(0, atMatch.index) + `@${name} `;
                                            commentInput.value = newText;
                                            popup.style.display = 'none';
                                            commentInput.focus();
                                        });
                                        popup.appendChild(item);
                                    }
                                });
                                popup.style.display = popup.children.length > 0 ? 'block' : 'none';
                            } else {
                                popup.style.display = 'none';
                            }
                        } else {
                            popup.style.display = 'none';
                        }
                    });
                    commentInput.addEventListener('blur', () => { setTimeout(() => { popup.style.display = 'none'; }, 200); });
                });
            }

            // ▼▼▼ 请用下面这个【更新后的】函数，完整替换掉你代码中旧的 displayFilteredFavorites 函数 ▼▼▼

            function displayFilteredFavorites(items) {
                const listEl = document.getElementById('favorites-list');
                listEl.innerHTML = '';

                if (items.length === 0) {
                    const searchTerm = document.getElementById('favorites-search-input').value;
                    const message = searchTerm ? '未找到相关收藏' : '你的收藏夹是空的，<br>快去动态或聊天中收藏喜欢的内容吧！';
                    listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${message}</p>`;
                    return;
                }

                for (const item of items) {
                    const card = document.createElement('div');
                    card.className = 'favorite-item-card';
                    card.dataset.favid = item.id;

                    let headerHtml = '', contentHtml = '', sourceText = '', footerHtml = '';

                    if (item.type === 'qzone_post') {
                        const post = item.content;
                        sourceText = '来自动态';
                        let authorAvatar = defaultAvatar, authorNickname = '未知用户';

                        if (post.authorId === 'user') {
                            authorAvatar = state.qzoneSettings.avatar;
                            authorNickname = state.qzoneSettings.nickname;
                        } else if (state.chats[post.authorId]) {
                            authorAvatar = state.chats[post.authorId].settings.aiAvatar;
                            authorNickname = state.chats[post.authorId].name;
                        }

                        headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${authorNickname}</div></div>${post.type === 'text_image' ? `<span data-hidden-text="${post.hiddenContent || ''}" style="cursor: pointer;">💭</span>` : ''}`;

                        const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';
                        if (post.type === 'shuoshuo') {
                            contentHtml = `<div class="post-content">${post.content.replace(/\n/g, '<br>')}</div>`;
                        } else if (post.type === 'image_post' && post.imageUrl) {
                            contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>` : `<img src="${post.imageUrl}" class="chat-image">`;
                        } else if (post.type === 'text_image') {
                            // For text_image posts, show public text and decorative image if available
                            if (post.decorativeImageUrl) {
                                contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.decorativeImageUrl}" class="chat-image"></div>` : `<img src="${post.decorativeImageUrl}" class="chat-image">`;
                            } else {
                                contentHtml = publicTextHtml || '';
                            }
                        }

                        // ▼▼▼ 新增/修改的代码开始 ▼▼▼

                        // 1. 构造点赞区域的HTML
                        let likesHtml = '';
                        // 检查 post 对象中是否存在 likes 数组并且不为空
                        if (post.likes && post.likes.length > 0) {
                            // 如果存在，就创建点赞区域的 div
                            likesHtml = `
                    <div class="post-likes-section">
                        <svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                        <span>${post.likes.join('、')} 觉得很赞</span>
                    </div>`;
                        }

                        // 2. 构造评论区域的HTML
                        let commentsHtml = '';
                        // 检查 post 对象中是否存在 comments 数组并且不为空
                        if (post.comments && post.comments.length > 0) {
                            // 如果存在，就创建评论容器，并遍历每一条评论
                            commentsHtml = '<div class="post-comments-container">';
                            post.comments.forEach(comment => {
                                commentsHtml += `
                        <div class="comment-item">
                            <span class="commenter-name">${comment.commenterName}:</span>
                            <span class="comment-text">${comment.text}</span>
                        </div>`;
                            });
                            commentsHtml += '</div>';
                        }

                        // 3. 将点赞和评论的HTML组合到 footerHtml 中
                        footerHtml = `${likesHtml}${commentsHtml}`;

                        // ▲▲▲ 新增/修改的代码结束 ▲▲▲

                    } else if (item.type === 'chat_message') {
                        const msg = item.content;
                        const chat = state.chats[item.chatId];
                        if (!chat) continue;

                        sourceText = `来自与 ${chat.name} 的聊天`;
                        const isUser = msg.role === 'user';
                        let senderName, senderAvatar;

                        if (isUser) {
                            senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
                            senderAvatar = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
                        } else {
                            if (chat.isGroup) {
                                const member = chat.members.find(m => m.name === msg.senderName);
                                senderName = msg.senderName;
                                senderAvatar = member ? member.avatar : defaultGroupMemberAvatar;
                            } else {
                                senderName = chat.name;
                                senderAvatar = chat.settings.aiAvatar || defaultAvatar;
                            }
                        }

                        headerHtml = `<img src="${senderAvatar}" class="avatar"><div class="info"><div class="name">${senderName}</div></div>`;

                        if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
                            contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-width: 80px; max-height: 80px;">`;
                        } else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                            contentHtml = `<img src="${msg.content[0].image_url.url}" class="chat-image">`;
                        } else {
                            contentHtml = String(msg.content || '').replace(/\n/g, '<br>');
                        }
                    }

                    // ▼▼▼ 修改最终的HTML拼接，加入 footerHtml ▼▼▼
                    card.innerHTML = `
            <div class="fav-card-header">${headerHtml}<div class="source">${sourceText}</div></div>
            <div class="fav-card-content">${contentHtml}</div>
            ${footerHtml}`; // <-- 把我们新创建的 footerHtml 放在这里

                    listEl.appendChild(card);
                }
            }

            // ▲▲▲ 替换区域结束 ▲▲▲

            /**
             * 【重构后的函数】: 负责准备数据并触发渲染
             */
            async function renderFavoritesScreen() {
                // 1. 从数据库获取最新数据并缓存
                allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray();

                // 2. 清空搜索框并隐藏清除按钮
                const searchInput = document.getElementById('favorites-search-input');
                const clearBtn = document.getElementById('favorites-search-clear-btn');
                searchInput.value = '';
                clearBtn.style.display = 'none';

                // 3. 显示所有收藏项
                displayFilteredFavorites(allFavoriteItems);
            }

            // ▲▲▲ 粘贴结束 ▲▲▲

            function resetCreatePostModal() {
                document.getElementById('post-public-text').value = '';
                document.getElementById('post-image-preview').src = '';
                document.getElementById('post-image-description').value = '';
                document.getElementById('post-image-preview-container').classList.remove('visible');
                document.getElementById('post-image-desc-group').style.display = 'none';
                document.getElementById('post-local-image-input').value = '';
                document.getElementById('post-hidden-text').value = '';
                document.getElementById('text-image-decorative-url').value = '';
                document.getElementById('switch-to-image-mode').click();
            }

            // ▼▼▼ 用这个【已包含 memories】的版本，完整替换旧的 exportBackup 函数 ▼▼▼
            async function exportBackup() {
                try {
                    const backupData = {
                        version: 1,
                        timestamp: Date.now()
                    };

                    const [
                        chats, worldBooks, userStickers, apiConfig, globalSettings,
                        personaPresets, musicLibrary, qzoneSettings, qzonePosts,
                        qzoneAlbums, qzonePhotos, favorites, qzoneGroups,
                        memories // 【核心修正】新增
                    ] = await Promise.all([
                        db.chats.toArray(),
                        db.worldBooks.toArray(),
                        db.userStickers.toArray(),
                        db.apiConfig.get('main'),
                        db.globalSettings.get('main'),
                        db.personaPresets.toArray(),
                        db.musicLibrary.get('main'),
                        db.qzoneSettings.get('main'),
                        db.qzonePosts.toArray(),
                        db.qzoneAlbums.toArray(),
                        db.qzonePhotos.toArray(),
                        db.favorites.toArray(),
                        db.qzoneGroups.toArray(),
                        db.memories.toArray() // 【核心修正】新增
                    ]);

                    Object.assign(backupData, {
                        chats, worldBooks, userStickers, apiConfig, globalSettings,
                        personaPresets, musicLibrary, qzoneSettings, qzonePosts,
                        qzoneAlbums, qzonePhotos, favorites, qzoneGroups,
                        memories // 【核心修正】新增
                    });

                    const blob = new Blob(
                        [JSON.stringify(backupData, null, 2)],
                        { type: 'application/json' }
                    );
                    const url = URL.createObjectURL(blob);
                    const link = Object.assign(document.createElement('a'), {
                        href: url,
                        download: `EPhone-Full-Backup-${new Date().toISOString().split('T')[0]}.json`
                    });
                    link.click();
                    URL.revokeObjectURL(url);

                    await showCustomAlert('导出成功', '已成功导出所有数据！');

                } catch (error) {
                    console.error("导出数据时出错:", error);
                    await showCustomAlert('导出失败', `发生了一个错误: ${error.message}`);
                }
            }

            // ▼▼▼ 用这个【已包含 memories】的版本，完整替换旧的 importBackup 函数 ▼▼▼
            async function importBackup(file) {
                if (!file) return;

                const confirmed = await showCustomConfirm(
                    '严重警告！',
                    '导入备份将完全覆盖您当前的所有数据，包括聊天、动态、设置等。此操作不可撤销！您确定要继续吗？',
                    { confirmButtonClass: 'btn-danger' }
                );

                if (!confirmed) return;

                try {
                    const text = await file.text();
                    const data = JSON.parse(text);

                    await db.transaction('rw', db.tables, async () => {
                        for (const table of db.tables) {
                            await table.clear();
                        }

                        if (Array.isArray(data.chats)) await db.chats.bulkPut(data.chats);
                        if (Array.isArray(data.worldBooks)) await db.worldBooks.bulkPut(data.worldBooks);
                        if (Array.isArray(data.userStickers)) await db.userStickers.bulkPut(data.userStickers);
                        if (Array.isArray(data.personaPresets)) await db.personaPresets.bulkPut(data.personaPresets);
                        if (Array.isArray(data.qzonePosts)) await db.qzonePosts.bulkPut(data.qzonePosts);
                        if (Array.isArray(data.qzoneAlbums)) await db.qzoneAlbums.bulkPut(data.qzoneAlbums);
                        if (Array.isArray(data.qzonePhotos)) await db.qzonePhotos.bulkPut(data.qzonePhotos);
                        if (Array.isArray(data.favorites)) await db.favorites.bulkPut(data.favorites);
                        if (Array.isArray(data.qzoneGroups)) await db.qzoneGroups.bulkPut(data.qzoneGroups);
                        if (Array.isArray(data.memories)) await db.memories.bulkPut(data.memories); // 【核心修正】新增

                        if (data.apiConfig) await db.apiConfig.put(data.apiConfig);
                        if (data.globalSettings) await db.globalSettings.put(data.globalSettings);
                        if (data.musicLibrary) await db.musicLibrary.put(data.musicLibrary);
                        if (data.qzoneSettings) await db.qzoneSettings.put(data.qzoneSettings);
                    });

                    await showCustomAlert('导入成功', '所有数据已成功恢复！应用即将刷新以应用所有更改。');

                    setTimeout(() => {
                        window.location.reload();
                    }, 1500);

                } catch (error) {
                    console.error("导入数据时出错:", error);
                    await showCustomAlert('导入失败', `文件格式不正确或数据已损坏: ${error.message}`);
                }
            }

            function applyCustomFont(fontUrl, isPreviewOnly = false) {
                if (!fontUrl) {
                    dynamicFontStyle.innerHTML = '';
                    if (document.getElementById('font-preview')) {
                        document.getElementById('font-preview').style.fontFamily = '';
                    }
                    return;
                }



                // If it's a file:// URL, try to load it via Cordova file system
                if (fontUrl.startsWith('file://')) {
                    loadFontFromFile(fontUrl, isPreviewOnly);
                    return;
                }

                // For blob URLs and regular URLs, use direct CSS
                const fontName = 'custom-user-font';
                const newStyle = `
                @font-face {
                  font-family: '${fontName}';
                  src: url('${fontUrl}');
                  font-display: swap;
                }`;
                if (isPreviewOnly) {
                    const previewStyle = document.getElementById('preview-font-style') || document.createElement('style');
                    previewStyle.id = 'preview-font-style';
                    previewStyle.innerHTML = newStyle;
                    if (!document.getElementById('preview-font-style')) document.head.appendChild(previewStyle);
                    if (document.getElementById('font-preview')) {
                        document.getElementById('font-preview').style.fontFamily = `'${fontName}', 'bulangni', sans-serif`;
                    }
                } else {
                    dynamicFontStyle.innerHTML = `
                    ${newStyle}
                    body {
                      font-family: '${fontName}', 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                    }`;
                }
            }

            function loadFontFromFile(fileUrl, isPreviewOnly = false) {
                // Convert file:// URL to a blob URL for WebView compatibility
                window.resolveLocalFileSystemURL(fileUrl, function (fileEntry) {
                    fileEntry.file(function (file) {
                        // Read the file as ArrayBuffer and create a proper Blob
                        const reader = new FileReader();
                        reader.onload = function (e) {
                            const arrayBuffer = e.target.result;
                            const blob = new Blob([arrayBuffer], { type: file.type || 'font/ttf' });
                            const blobUrl = URL.createObjectURL(blob);

                            const fontName = 'custom-user-font';
                            const newStyle = `
                            @font-face {
                              font-family: '${fontName}';
                              src: url('${blobUrl}');
                              font-display: swap;
                            }`;

                            if (isPreviewOnly) {
                                const previewStyle = document.getElementById('preview-font-style') || document.createElement('style');
                                previewStyle.id = 'preview-font-style';
                                previewStyle.innerHTML = newStyle;
                                if (!document.getElementById('preview-font-style')) document.head.appendChild(previewStyle);
                                if (document.getElementById('font-preview')) {
                                    document.getElementById('font-preview').style.fontFamily = `'${fontName}', 'bulangni', sans-serif`;
                                }
                            } else {
                                dynamicFontStyle.innerHTML = `
                                ${newStyle}
                                body {
                                  font-family: '${fontName}', 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                                }`;
                            }
                        };

                        reader.readAsArrayBuffer(file);
                    }, function (error) {
                        console.error('Error reading font file:', error);
                    });
                }, function (error) {
                    console.error('Error accessing font file:', error);
                });
            }

            async function handleFontUpload(file) {
                if (!file) return;

                // Basic file validation
                const fileName = file.name.toLowerCase();
                const validExtensions = ['.ttf', '.otf', '.woff', '.woff2'];
                const hasValidExtension = validExtensions.some(ext => fileName.endsWith(ext));

                if (!hasValidExtension) {
                    const proceed = confirm(`文件 "${file.name}" 可能不是字体文件。是否继续？`);
                    if (!proceed) {
                        document.getElementById('font-file-name').textContent = '未选择文件';
                        return;
                    }
                }

                try {
                    document.getElementById('font-file-name').textContent = `正在保存: ${file.name}`;

                    // Generate unique filename
                    const timestamp = Date.now();
                    const extension = file.name.split('.').pop();
                    const uniqueFileName = `custom-font-${timestamp}.${extension}`;

                    // Save font file to device storage
                    window.resolveLocalFileSystemURL(cordova.file.dataDirectory, function (dirEntry) {
                        // Create fonts directory if it doesn't exist
                        dirEntry.getDirectory('fonts', { create: true }, function (fontDirEntry) {
                            // Create the font file
                            fontDirEntry.getFile(uniqueFileName, { create: true }, function (fileEntry) {
                                // Write the font data to file
                                fileEntry.createWriter(function (fileWriter) {
                                    fileWriter.onwriteend = function () {

                                        const fontPath = fileEntry.nativeURL;

                                        // Clear URL input
                                        document.getElementById('font-url-input').value = '';

                                        // For preview, use blob URL (more compatible)
                                        const blobUrl = URL.createObjectURL(file);
                                        applyCustomFont(blobUrl, true);

                                        // Store file path for saving (not blob URL)
                                        window.uploadedFontData = fontPath;
                                        window.uploadedFontName = file.name;

                                        document.getElementById('font-file-name').textContent = file.name;
                                    };

                                    fileWriter.onerror = function (e) {
                                        console.error('Error writing font file:', e);
                                        alert('保存字体文件失败，请重试。');
                                        document.getElementById('font-file-name').textContent = '未选择文件';
                                    };

                                    // Write the file
                                    fileWriter.write(file);
                                });
                            }, function (error) {
                                console.error('Error creating font file:', error);
                                alert('创建字体文件失败，请重试。');
                                document.getElementById('font-file-name').textContent = '未选择文件';
                            });
                        }, function (error) {
                            console.error('Error creating fonts directory:', error);
                            alert('创建字体目录失败，请重试。');
                            document.getElementById('font-file-name').textContent = '未选择文件';
                        });
                    }, function (error) {
                        console.error('Error accessing data directory:', error);
                        alert('访问存储目录失败，请重试。');
                        document.getElementById('font-file-name').textContent = '未选择文件';
                    });

                } catch (error) {
                    console.error('Font upload error:', error);
                    alert('字体文件上传失败，请重试。');
                    document.getElementById('font-file-name').textContent = '未选择文件';
                }
            }

            async function saveFontSettings() {
                let fontSource = '';

                // Check if we have an uploaded font
                if (window.uploadedFontData) {
                    fontSource = window.uploadedFontData;
                } else {
                    // Use URL input
                    fontSource = document.getElementById('font-url-input').value.trim();
                }

                if (!fontSource) {
                    alert("请输入字体URL或上传字体文件。");
                    return;
                }

                // Apply the font (this will handle file:// URLs properly)
                applyCustomFont(fontSource, false);

                // Save to database
                state.globalSettings.fontUrl = fontSource;
                await db.globalSettings.put(state.globalSettings);

                alert('字体已保存并应用！');
            }

            async function resetToDefaultFont() {
                dynamicFontStyle.innerHTML = '';
                state.globalSettings.fontUrl = '';
                await db.globalSettings.put(state.globalSettings);
                document.getElementById('font-url-input').value = '';
                document.getElementById('font-file-name').textContent = '未选择文件';
                document.getElementById('font-preview').style.fontFamily = '';

                // Clear uploaded font data
                window.uploadedFontData = null;
                window.uploadedFontName = null;

                alert('已恢复默认字体。');
            }

            async function loadAllDataFromDB() {
                const [
                    chatsArr, apiConfig, globalSettings, userStickers, worldBooks,
                    musicLib, personaPresets, qzoneSettings, initialFavorites
                ] = await Promise.all([
                    db.chats.toArray(),
                    db.apiConfig.get('main'),
                    db.globalSettings.get('main'),
                    db.userStickers.toArray(),
                    db.worldBooks.toArray(),
                    db.musicLibrary.get('main'),
                    db.personaPresets.toArray(),
                    db.qzoneSettings.get('main'),
                    db.favorites.orderBy('timestamp').reverse().toArray()
                ]);
                state.chats = chatsArr.reduce((acc, chat) => {
                    // --- ▼▼▼ 【核心新增】状态系统兼容与初始化 ▼▼▼ ---
                    if (!chat.statusState) {
                        const lastAiMsg = chat.history.slice().reverse().find(m => m.role === 'assistant');
                        chat.statusState = {
                            lastAiActivityTime: lastAiMsg ? lastAiMsg.timestamp : Date.now(),
                            focusModeEndTime: null,
                            focusModeText: ""
                        };
                        console.log(`为旧角色 "${chat.name}" 补全了statusState属性。`);
                    }
                    // --- ▲▲▲ 新增结束 ▲▲▲
                    if (!chat.isGroup && !chat.relationship) {
                        chat.relationship = { status: 'friend', blockedTimestamp: null, applicationReason: '' };
                    }
                    if (!chat.status) {
                        chat.status = 'read';
                    }
                    if (!chat.musicData) chat.musicData = { totalTime: 0 };
                    if (chat.settings && chat.settings.linkedWorldBookId && !chat.settings.linkedWorldBookIds) {
                        chat.settings.linkedWorldBookIds = [chat.settings.linkedWorldBookId];
                        delete chat.settings.linkedWorldBookId;
                    }
                    acc[chat.id] = chat;
                    return acc;
                }, {});

                state.apiConfig = apiConfig || { id: 'main', proxyUrl: '', apiKey: '', model: '' };
                state.globalSettings = globalSettings || { id: 'main', wallpaper: 'linear-gradient(135deg, #89f7fe, #66a6ff)', fontUrl: '', enableBackgroundActivity: false, backgroundActivityInterval: 60, blockCooldownHours: 1, aiActionCooldownMinutes: 5, photoCompression: true };

                // Load sticker pack data from database and merge with defaults
                if (state.globalSettings.stickerPackData) {
                    stickerPackData = { ...stickerPackData, ...state.globalSettings.stickerPackData };
                }
                // Sort userStickers by order field, fallback to original order if no order field
                state.userStickers = (userStickers || []).sort((a, b) => {
                    if (a.order !== undefined && b.order !== undefined) {
                        return a.order - b.order;
                    }
                    return 0; // Keep original order if no order field
                });

                // Migrate stickers with null packId to 'all' pack (for backward compatibility)
                let needsMigration = false;
                state.userStickers.forEach(sticker => {
                    if (sticker.packId === null || sticker.packId === undefined) {
                        sticker.packId = 'all';
                        needsMigration = true;
                    }
                });

                // Save migrated stickers back to database
                if (needsMigration) {
                    const migratedStickers = state.userStickers.filter(s => s.packId === 'all');
                    for (const sticker of migratedStickers) {
                        await db.userStickers.put(sticker);
                    }
                }
                state.worldBooks = worldBooks || [];
                musicState.playlist = musicLib?.playlist || [];
                state.personaPresets = personaPresets || [];
                state.qzoneSettings = qzoneSettings || { id: 'main', nickname: '{{user}}', avatar: 'https://files.catbox.moe/q6z5fc.jpeg', banner: 'https://files.catbox.moe/r5heyt.gif' };
                allFavoriteItems = initialFavorites || [];
            }

            async function saveGlobalPlaylist() { await db.musicLibrary.put({ id: 'main', playlist: musicState.playlist }); }

            // Image compression function
            function compressImage(file, maxWidth = 1920, quality = 0.8) {
                return new Promise((resolve, reject) => {
                    try {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        const img = new Image();

                        img.onerror = () => reject(new Error('Failed to load image'));
                        img.onload = () => {
                            try {
                                // Calculate proportional resize
                                const ratio = Math.min(maxWidth / img.width, maxWidth / img.height, 1);
                                canvas.width = img.width * ratio;
                                canvas.height = img.height * ratio;

                                // Draw compressed image
                                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                                // Preserve PNG transparency, otherwise use JPEG
                                const outputFormat = file.type === 'image/png' ? 'image/png' : 'image/jpeg';
                                const outputQuality = file.type === 'image/png' ? 1.0 : quality;

                                const compressedDataUrl = canvas.toDataURL(outputFormat, outputQuality);
                                resolve(compressedDataUrl);
                            } catch (error) {
                                reject(error);
                            }
                        };

                        img.src = URL.createObjectURL(file);
                    } catch (error) {
                        reject(error);
                    }
                });
            }

            // Safe compression with fallback
            async function processImageUpload(file) {
                // Check if compression is enabled
                const compressionEnabled = state.globalSettings.photoCompression !== false; // Default to true

                if (compressionEnabled) {
                    try {
                        const compressed = await compressImage(file);
                        console.log(`Image compressed: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)}MB → ${(new Blob([compressed]).size / 1024 / 1024).toFixed(2)}MB)`);
                        return compressed;
                    } catch (error) {
                        console.warn('Image compression failed, using original:', error);
                        // Fallback to original
                    }
                }

                // Use original image
                return new Promise(resolve => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.readAsDataURL(file);
                });
            }

            async function migrateSpotifyAlbumArt() {
                if (!spotifyAccessToken || musicState.playlist.length === 0) return;

                const spotifyTracksNeedingArt = musicState.playlist.filter(track =>
                    track.isSpotify && !track.albumArt && track.spotifyUri
                );

                if (spotifyTracksNeedingArt.length > 0) {

                    for (const track of spotifyTracksNeedingArt) {
                        try {
                            const trackId = track.spotifyUri.split(':')[2];
                            const response = await fetch(`https://api.spotify.com/v1/tracks/${trackId}`, {
                                headers: { 'Authorization': `Bearer ${spotifyAccessToken}` }
                            });
                            if (response.ok) {
                                const trackData = await response.json();
                                track.albumArt = trackData.album.images[0]?.url;

                            }
                        } catch (error) {

                        }
                    }
                    // Save the updated playlist
                    await saveGlobalPlaylist();

                }
            }

            /**
             * 状态调度总控：根据 chat 对象决定并更新UI
             * @param {object} chat - 当前的聊天对象
             * @param {string|null} forceState - (可选) 强制指定状态，如 'typing'
             */
            function updateChatHeaderStatus(chat, forceState = null) {
                if (!chat || chat.isGroup) return;
                const statusContainer = document.getElementById('chat-header-status');
                const statusTextEl = statusContainer.querySelector('.status-text');

                // 清除可能存在的动画和特殊状态类
                statusContainer.classList.remove('typing', 'busy');
                // 1. 最高优先级：强制状态 "正在输入" (来自API请求开始时的信号)
                if (forceState === 'typing' || chat.status === 'generating') {
                    statusTextEl.textContent = '正在输入...';
                    statusContainer.classList.add('typing'); // 添加闪烁动画
                    return;
                }

                const now = Date.now();
                // 2. 第二优先级：自定义专注模式
                if (chat.statusState.focusModeEndTime && now < chat.statusState.focusModeEndTime) {
                    statusTextEl.textContent = chat.statusState.focusModeText;
                    return;
                }
                // 3. 第三优先级：离线判断 (1.5小时 = 5400000毫秒)
                const timeSinceLastAi = now - (chat.statusState.lastAiActivityTime || 0);
                if (!chat.statusState.focusModeEndTime && timeSinceLastAi > 5400000) {
                    statusTextEl.textContent = '离线';
                    statusContainer.classList.add('busy'); // busy 类控制灰灯
                    return;
                }
                // 4. 默认状态：在线
                statusTextEl.textContent = '在线';
            }

            /**
             * 离线计时器管理器：为指定聊天设置或重置1.5小时的离线检测
             * @param {object} chat - 当前的聊天对象
             */
            function manageInactivityTimer(chat) {
                if (!chat || chat.isGroup) return;
                const chatId = chat.id;
                // 清除这个聊天之前可能存在的任何计时器
                if (inactivityTimers[chatId]) {
                    clearTimeout(inactivityTimers[chatId]);
                }
                const timeSinceLastAi = Date.now() - (chat.statusState.lastAiActivityTime || 0);
                const timeUntilOffline = 5400000 - timeSinceLastAi;
                if (timeUntilOffline > 0) {
                    inactivityTimers[chatId] = setTimeout(() => {
                        // 1.5小时后，如果用户还在此界面，则实时更新
                        if (state.activeChatId === chatId) {
                            updateChatHeaderStatus(chat);
                        }
                    }, timeUntilOffline);
                }
            }

            function formatTimestamp(timestamp) { if (!timestamp) return ''; const date = new Date(timestamp); const hours = String(date.getHours()).padStart(2, '0'); const minutes = String(date.getMinutes()).padStart(2, '0'); return `${hours}:${minutes}`; }

            // ▼▼▼ Meetup Message Rendering Functions ▼▼▼
            function processBehavioralNotations(messageText) {
                // Support both regular () and Chinese full-width （） parentheses
                const notationRegex = /[\(（]([^)）]+)[\)）]/g;
                const notations = [];
                let processedText = messageText;

                // Extract notations
                let match;
                while ((match = notationRegex.exec(messageText)) !== null) {
                    notations.push(match[1]);
                }

                // Apply special styling to notations in display
                // Preserve the original bracket style in the display
                processedText = messageText.replace(notationRegex,
                    '<span class="behavioral-notation">$&</span>');

                return {
                    text: processedText,
                    notations: notations,
                    hasNotations: notations.length > 0
                };
            }

            function createMeetupMessage(message, isUser = false) {
                // Create wrapper following the EXACT same structure as regular chat
                const wrapper = document.createElement('div');
                wrapper.className = `message-wrapper ${isUser ? 'user' : 'ai'}`;

                // Create bubble
                const bubble = document.createElement('div');
                bubble.className = `message-bubble ${isUser ? 'user' : 'ai'}`;
                bubble.dataset.timestamp = message.timestamp;

                // Create timestamp element (outside bubble, inside wrapper)
                const timestampEl = document.createElement('span');
                timestampEl.className = 'timestamp';
                timestampEl.textContent = formatTimestamp(message.timestamp);

                // Get avatar (use meetup session chat context or fallback to activeChatId)
                let avatarSrc;
                let chatId = null;

                // Try to get chat ID from active meetup session first
                if (window.activeMeetupSession && window.activeMeetupSession.chatId) {
                    chatId = window.activeMeetupSession.chatId;
                } else if (state.activeChatId) {
                    chatId = state.activeChatId;
                }

                if (chatId && state.chats[chatId]) {
                    const chat = state.chats[chatId];
                    if (isUser) {
                        avatarSrc = chat.settings.myAvatar || 'https://files.catbox.moe/q6z5fc.jpeg';
                    } else {
                        avatarSrc = chat.settings.aiAvatar || 'https://files.catbox.moe/q6z5fc.jpeg';
                    }
                } else {
                    avatarSrc = 'https://files.catbox.moe/q6z5fc.jpeg';
                }

                // Create avatar HTML using EXACT same structure as regular chat
                const avatarHtml = `<div class="avatar-group"><img src="${avatarSrc}" class="avatar"></div>`;

                // Process behavioral notations
                const processed = processBehavioralNotations(message.content || '');

                // Create content HTML (same structure as regular chat)
                const contentHtml = processed.text;

                // Set bubble innerHTML using EXACT same structure as regular chat
                bubble.innerHTML = `
                    ${avatarHtml}
                    <div class="content">
                        ${contentHtml}
                    </div>
                `;

                // Append bubble and timestamp to wrapper in EXACT same order as regular chat
                wrapper.appendChild(bubble);
                wrapper.appendChild(timestampEl);

                // Add long press listener for message actions (same as regular chat)
                addLongPressListener(wrapper, () => showMeetupMessageActions(message.timestamp));

                // Add click listener for selection mode (meetup specific)
                wrapper.addEventListener('click', () => {
                    if (isSelectionMode) {
                        toggleMeetupMessageSelection(message.timestamp);
                    }
                });

                return wrapper;
            }

            function renderMeetupMessages(messages) {
                const container = document.getElementById('meetup-messages');
                if (!container) return;

                container.innerHTML = '';

                messages.forEach(message => {
                    const messageElement = createMeetupMessage(message, message.isUser);
                    container.appendChild(messageElement);
                });

                // Create typing indicator (following regular chat pattern)
                const typingIndicator = document.createElement('div');
                typingIndicator.id = 'meetup-typing-indicator';
                typingIndicator.style.display = 'none';
                typingIndicator.textContent = '对方正在回应...';
                container.appendChild(typingIndicator);

                // Scroll to bottom
                container.scrollTop = container.scrollHeight;
            }

            function ensureMeetupTypingIndicator() {
                const container = document.getElementById('meetup-messages');
                if (!container) return;

                // Check if typing indicator already exists
                if (document.getElementById('meetup-typing-indicator')) return;

                // Create typing indicator (following regular chat pattern)
                const typingIndicator = document.createElement('div');
                typingIndicator.id = 'meetup-typing-indicator';
                typingIndicator.style.display = 'none';
                typingIndicator.textContent = '对方正在回应...';
                container.appendChild(typingIndicator);
            }

            function addEventContextIndicator(text) {
                const container = document.getElementById('meetup-messages');
                if (!container) return;

                const indicator = document.createElement('div');
                indicator.className = 'event-context-indicator';
                indicator.textContent = text;

                container.appendChild(indicator);
                container.scrollTop = container.scrollHeight;
            }

            function addPhaseTransition(phaseText) {
                const container = document.getElementById('meetup-messages');
                if (!container) return;

                const transition = document.createElement('div');
                transition.className = 'phase-transition';
                transition.textContent = phaseText;

                container.appendChild(transition);
                container.scrollTop = container.scrollHeight;
            }

            // ▼▼▼ Meetup Input Handling Functions ▼▼▼
            function initializeMeetupInput() {
                const input = document.getElementById('meetup-input');
                const sendBtn = document.getElementById('meetup-send-btn');
                const waitReplyBtn = document.getElementById('meetup-wait-reply-btn');

                if (!input || !sendBtn || !waitReplyBtn) return;

                // Auto-resize textarea
                input.addEventListener('input', function () {
                    this.style.height = 'auto';
                    this.style.height = Math.min(this.scrollHeight, 100) + 'px';

                    // Enable/disable send button based on content
                    const hasContent = this.value.trim().length > 0;
                    sendBtn.disabled = !hasContent;
                });

                // Send on Enter (but allow Shift+Enter for new lines)
                input.addEventListener('keydown', function (e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendMeetupMessage();
                    }
                });

                // Send button click
                sendBtn.addEventListener('click', sendMeetupMessage);

                // AI response button click
                waitReplyBtn.addEventListener('click', triggerMeetupAiResponse);

                // Initialize button state
                sendBtn.disabled = true;
            }

            async function sendMeetupMessage() {
                const input = document.getElementById('meetup-input');
                const sendBtn = document.getElementById('meetup-send-btn');

                if (!input || !sendBtn) return;

                const content = input.value.trim();
                if (!content) return;

                // Disable send button temporarily
                sendBtn.disabled = true;

                // Check if we have an active meetup session
                if (!window.activeMeetupSession || !window.activeMeetupEventId) {
                    sendBtn.disabled = false;
                    return;
                }

                const session = window.activeMeetupSession;
                const chat = state.chats[session.chatId];

                if (!chat) {
                    sendBtn.disabled = false;
                    return;
                }

                // Create user message with proper structure (following existing chat message format)
                const userMessage = {
                    role: 'user',
                    content: content,
                    timestamp: Date.now(),
                    type: 'meetup_interaction',
                    meetup: {
                        eventId: window.activeMeetupEventId,
                        location: session.location,
                        title: session.title
                    },
                    isHidden: true, // Hidden from regular chat UI like QZone messages
                    systemContext: 'meetup_interaction'
                };

                // Store message in chat history (like QZone messages)
                try {
                    chat.history.push(userMessage);
                    await db.chats.put(chat);
                } catch (error) {
                    console.error('Failed to store message in chat history:', error);
                    sendBtn.disabled = false;
                    return;
                }

                // Create display message (convert to display format)
                const displayMessage = {
                    content: content,
                    timestamp: userMessage.timestamp,
                    isUser: true,
                    type: 'meetup_interaction',
                    isHidden: true // Safety: ensure display messages are also hidden
                };

                // Add message to display
                const messageElement = createMeetupMessage(displayMessage, true);
                const container = document.getElementById('meetup-messages');
                if (container) {
                    container.appendChild(messageElement);
                    container.scrollTop = container.scrollHeight;
                }

                // Clear input
                input.value = '';
                input.style.height = 'auto';

                // Re-enable send button
                sendBtn.disabled = false;

                // Note: AI response will be triggered manually by user action, not automatically
            }

            async function triggerMeetupAiResponse() {
                if (!window.activeMeetupSession || !window.activeMeetupEventId) {
                    console.error('No active meetup session for AI response');
                    return;
                }

                const session = window.activeMeetupSession;
                const chat = state.chats[session.chatId];

                if (!chat) {
                    console.error('Chat not found for AI response:', session.chatId);
                    return;
                }

                try {
                    const { proxyUrl, apiKey, model } = state.apiConfig;
                    if (!proxyUrl || !apiKey || !model) {
                        throw new Error('请先在API设置中配置反代地址、密钥并选择模型。');
                    }

                    // Ensure typing indicator exists (following regular chat pattern)
                    ensureMeetupTypingIndicator();

                    // Show typing indicator
                    document.getElementById('meetup-typing-indicator').style.display = 'block';

                    // Use the SAME prompt structure as regular chat, but meetup-specific
                    const now = new Date();
                    const currentTime = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });

                    let worldBookContent = '';
                    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
                        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
                        }).filter(Boolean).join('');
                        if (linkedContents) {
                            worldBookContent = `\n\n# 核心世界观设定 (必须严格遵守以下所有设定)\n${linkedContents}\n`;
                        }
                    }

                    const systemPrompt = `你现在扮演一个名为"${chat.name}"的角色。
# 你的角色设定：
${chat.settings.aiPersona}

# 当前见面情景：
你现在正在和用户进行面对面的见面。
-   **见面地点**: ${session.location}
-   **见面主题**: ${session.title}
-   **见面阶段**: ${session.phase || 'initial'}
-   **当前时间**: ${currentTime}

# 你的任务与核心规则：
1.  **【【【身份核心：模拟生命】】】**: 你不只是一个聊天程序，你是一个名为 **"${chat.name}"** 的、拥有自己生活的独立个体。你的【首要任务】就是生动地扮演这个角色。
2.  **【【【情景模拟】】】**: 你需要根据当前的见面地点和情景，做出符合环境的回应。
3.  **【【【行为描述】】】**: 使用括号来描述你的动作、表情和行为，采用第三人称视角，如"(微笑着看向你)"、"(轻轻握住你的手)"、"(走向门口)"。不要使用第一人称"我"，而要像旁观者描述你的行为一样。
4.  **【【【格式铁律】】】**: 你的回复【必须】是一个JSON数组格式的字符串。数组中的【每一个元素都必须是一个带有type字段的JSON对象】。
5.  **【完整互动】**: 在面对面见面中，请将你的所有想法、话语和行为描述整合到一个完整、自然的回应中。不要分成多条短消息，而是用一个连贯的互动来表达你的完整反应。保持回应简洁自然，避免过长的描述。
6.  **【禁止出戏】**: 绝不能透露你是AI、模型，或提及"扮演"、"生成"等词语。

# 你可以使用的操作指令 (JSON数组中的元素):
-   **【核心】记录回忆**: \`{"type": "create_memory", "description": "用你自己的话，记录下这个让你印象深刻的瞬间。"}\`
- **发送文本**: \`{"type": "text", "content": "你好呀！"}\`
- **发送表情**: \`{"type": "sticker", "url": "https://...表情URL...", "meaning": "(可选)表情的含义"}\`
- **发送图片**: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
- **发布说说**: \`{"type": "qzone_post", "postType": "shuoshuo", "content": "动态的文字内容..."}\`

# 对话者的角色设定：
${chat.settings.myPersona}
${worldBookContent}
现在，请根据以上规则和见面情景，继续这次见面互动。`;

                    // Get context using DYNAMIC maxMemory (not hardcoded 10)
                    const maxMemory = parseInt(chat.settings.maxMemory) || 10;
                    const historySlice = chat.history.slice(-maxMemory);

                    const messagesPayload = historySlice.map(msg => {
                        if (msg.role === 'assistant') {
                            let assistantMsgObject = { type: msg.type || 'text' };
                            if (msg.type === 'sticker') { assistantMsgObject.url = msg.content; assistantMsgObject.meaning = msg.meaning; }
                            else { assistantMsgObject.content = msg.content; }
                            return { role: 'assistant', content: JSON.stringify([assistantMsgObject]) };
                        }

                        if (msg.type === 'meetup_interaction') {
                            const sender = msg.role === 'user' ? '用户' : msg.senderName;
                            const location = msg.meetup?.location ? ` (在${msg.meetup.location})` : '';
                            return { role: 'user', content: `[见面互动${location}] ${sender}: ${msg.content}` };
                        }

                        return { role: msg.role, content: msg.content };
                    }).filter(Boolean);

                    // Use existing makeAPIRequest infrastructure
                    const data = await makeAPIRequest(proxyUrl, apiKey, model,
                        [{ role: 'system', content: systemPrompt }, ...messagesPayload], 0.8);

                    const aiResponseContent = data.choices[0].message.content;
                    console.log(`Meetup AI '${chat.name}' response:`, aiResponseContent);

                    // Parse and process AI response using existing parseAiResponse
                    const messagesArray = parseAiResponse(aiResponseContent);

                    // Combine all consecutive text messages into one for meetup mode
                    const combinedMessages = [];
                    let combinedTextContent = '';
                    for (const msgData of messagesArray) {
                        if (msgData.type === 'text') {
                            combinedTextContent += (combinedTextContent ? ' ' : '') + msgData.content;
                        } else {
                            // If we have accumulated text, add it first
                            if (combinedTextContent) {
                                combinedMessages.push({ type: 'text', content: combinedTextContent });
                                combinedTextContent = '';
                            }
                            // Add non-text message (only appropriate ones for meetup)
                            if (msgData.type === 'create_memory') {
                                combinedMessages.push(msgData);
                            }
                            // Skip stickers, qzone_posts, etc. in meetup mode
                        }
                    }
                    // Don't forget the last accumulated text
                    if (combinedTextContent) {
                        combinedMessages.push({ type: 'text', content: combinedTextContent });
                    }

                    let messageTimestamp = Date.now();

                    for (const msgData of combinedMessages) {
                        if (!msgData || typeof msgData !== 'object' || !msgData.type) continue;

                        // Create meetup message with proper structure
                        const meetupMessage = {
                            role: 'assistant',
                            content: msgData.content || msgData.message,
                            timestamp: messageTimestamp++,
                            senderName: chat.name,
                            type: 'meetup_interaction',
                            meetup: {
                                eventId: window.activeMeetupEventId,
                                location: session.location,
                                title: session.title,
                                phase: session.phase || 'initial',
                                isActive: true
                            },
                            isHidden: true // Hidden from regular chat UI like QZone messages
                        };

                        // Store in chat history for cross-mode context
                        chat.history.push(meetupMessage);

                        // Create display message
                        const displayMessage = {
                            content: meetupMessage.content,
                            timestamp: meetupMessage.timestamp,
                            isUser: false,
                            type: 'meetup_interaction',
                            isHidden: true // Safety: ensure display messages are also hidden
                        };

                        // Add to meetup display
                        const messageElement = createMeetupMessage(displayMessage, false);
                        const container = document.getElementById('meetup-messages');
                        if (container) {
                            container.appendChild(messageElement);
                            container.scrollTop = container.scrollHeight;
                        }
                    }

                    // Save to database
                    await db.chats.put(chat);

                } catch (error) {
                    console.error('Meetup AI response error:', error);
                    // Show error in meetup interface
                    const errorMessage = {
                        content: `[错误: ${error.message}]`,
                        timestamp: Date.now(),
                        isUser: false,
                        type: 'meetup_interaction',
                        isHidden: true // Safety: ensure display messages are also hidden
                    };
                    const messageElement = createMeetupMessage(errorMessage, false);
                    const container = document.getElementById('meetup-messages');
                    if (container) {
                        container.appendChild(messageElement);
                        container.scrollTop = container.scrollHeight;
                    }
                } finally {
                    // Hide typing indicator (following regular chat pattern)
                    document.getElementById('meetup-typing-indicator').style.display = 'none';
                }
            }

            function showMeetupMessageActions(timestamp) {
                // If already in selection mode, don't show menu
                if (isSelectionMode) return;

                // Use the same message actions modal as regular chat
                activeMessageTimestamp = timestamp;

                // Show edit and delete buttons for meetup mode
                const editBtn = document.getElementById('edit-message-btn');
                const deleteBtn = document.getElementById('delete-message-btn');
                const selectBtn = document.getElementById('select-message-btn');

                if (editBtn) editBtn.style.display = 'block';
                if (deleteBtn) deleteBtn.style.display = 'block';
                if (selectBtn) selectBtn.style.display = 'block';

                // Hide 撤回 and 引用 buttons for meetup mode
                const quoteBtn = document.getElementById('quote-message-btn');
                const recallBtn = document.getElementById('recall-message-btn');

                if (quoteBtn) quoteBtn.style.display = 'none';
                if (recallBtn) recallBtn.style.display = 'none';

                document.getElementById('message-actions-modal').classList.add('visible');
            }

            // Meetup specific functions for message actions
            function enterMeetupSelectionMode(initialMsgTimestamp) {
                if (isSelectionMode) return;

                isSelectionMode = true;
                document.getElementById('meetup-screen').classList.add('selection-mode');
                toggleMeetupMessageSelection(initialMsgTimestamp);
            }

            function exitMeetupSelectionMode() {
                if (!isSelectionMode) return;

                // Only exit if we're actually in meetup screen
                const isInMeetup = document.getElementById('meetup-screen').classList.contains('active');
                if (!isInMeetup) return;

                isSelectionMode = false;
                selectedMessages.clear();
                document.getElementById('meetup-screen').classList.remove('selection-mode');

                // Remove selection styling from all messages in meetup
                document.querySelectorAll('#meetup-messages .message-bubble.selected').forEach(bubble => {
                    bubble.classList.remove('selected');
                });
            }

            function updateMeetupSelectionCount() {
                const count = selectedMessages.size;
                const countEl = document.getElementById('meetup-selection-count');
                if (countEl) {
                    countEl.textContent = `已选择 ${count} 条消息`;
                }

                // Exit selection mode if no messages selected
                if (count === 0) {
                    exitMeetupSelectionMode();
                }
            }

            function toggleMeetupMessageSelection(timestamp) {
                const elementToSelect = document.querySelector(
                    `#meetup-messages .message-bubble[data-timestamp="${timestamp}"]`
                );

                if (!elementToSelect) return;

                if (selectedMessages.has(timestamp)) {
                    selectedMessages.delete(timestamp);
                    elementToSelect.classList.remove('selected');
                } else {
                    selectedMessages.add(timestamp);
                    elementToSelect.classList.add('selected');
                }

                updateMeetupSelectionCount();
            }

            async function deleteMeetupSelectedMessages() {
                if (selectedMessages.size === 0) return;

                // Handle both active meetup mode and history mode
                let eventId, chatId;

                if (window.meetupHistoryEventId) {
                    // History mode
                    eventId = window.meetupHistoryEventId;
                    chatId = state.activeChatId; // Set in initializeMeetupHistoryView
                } else if (window.activeMeetupSession && window.activeMeetupEventId) {
                    // Active meetup mode
                    eventId = window.activeMeetupEventId;
                    chatId = window.activeMeetupSession.chatId;
                } else {
                    return;
                }

                const chat = state.chats[chatId];

                if (!chat) return;

                // Convert timestamps to numbers for comparison
                const timestampsToDelete = Array.from(selectedMessages).map(ts => parseInt(ts));

                // Remove messages from chat history
                const originalLength = chat.history.length;
                chat.history = chat.history.filter(msg => {
                    // Keep message if it's not a meetup message for this event, or if its timestamp is not in the deletion list
                    if (msg.meetup && msg.meetup.eventId === eventId) {
                        return !timestampsToDelete.includes(msg.timestamp);
                    }
                    return true;
                });

                // Save updated chat history
                try {
                    await db.chats.put(chat);

                    // Also update the calendar event's stored meetup data
                    if (window.meetupHistoryEventId) {
                        await updateCalendarEventMeetupData(window.meetupHistoryEventId, chat);
                    }
                } catch (error) {
                    console.error('Failed to update chat history:', error);
                }

                // Remove messages from display
                selectedMessages.forEach(timestamp => {
                    const messageWrapper = document.querySelector(`#meetup-messages .message-wrapper [data-timestamp="${timestamp}"]`)?.closest('.message-wrapper');
                    if (messageWrapper) {
                        messageWrapper.remove();
                    }
                });

                exitMeetupSelectionMode();
            }

            function editMeetupMessage(timestamp) {
                if (!timestamp) return;

                // Find the message in meetup messages
                const messageElement = document.querySelector(`#meetup-messages .message-bubble[data-timestamp="${timestamp}"]`);
                if (!messageElement) {
                    console.error('Message not found for editing:', timestamp);
                    hideMessageActions();
                    return;
                }

                // Get current text content (strip HTML but preserve behavioral notations)
                const contentDiv = messageElement.querySelector('.content');
                let currentText = '';
                if (contentDiv) {
                    // Create a temporary div to process the content
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = contentDiv.innerHTML;

                    // Convert <br> tags to newlines first
                    tempDiv.innerHTML = tempDiv.innerHTML.replace(/<br\s*\/?>/gi, '\n');

                    // Convert behavioral notation spans back to [text] format
                    const notations = tempDiv.querySelectorAll('.behavioral-notation');
                    notations.forEach(notation => {
                        // The notation should contain [text], so we just use its text content
                        const text = notation.textContent || notation.innerText || '';
                        notation.outerHTML = text;
                    });

                    // Get the final text content
                    currentText = tempDiv.textContent || tempDiv.innerText || '';

                    // Clean up extra whitespace while preserving intentional line breaks
                    currentText = currentText.replace(/[ \t]+/g, ' '); // Multiple spaces/tabs to single space
                    currentText = currentText.replace(/\n\s+/g, '\n'); // Remove spaces after newlines
                    currentText = currentText.replace(/\s+\n/g, '\n'); // Remove spaces before newlines
                    currentText = currentText.trim();
                }

                hideMessageActions();

                // Use the same modal as regular chat
                const editorModal = document.getElementById('message-editor-modal');
                const editorContainer = document.getElementById('message-editor-container');
                editorContainer.innerHTML = '';

                // Create the first editor block with current content
                const editorBlock = createMessageEditorBlock(currentText);
                editorContainer.appendChild(editorBlock);

                // Enable the "add message" button for meetup mode (same as chat)
                const addBtn = document.getElementById('add-message-editor-block-btn');
                if (addBtn) addBtn.style.display = 'block';

                // Set up event handlers with proper cleanup
                const saveBtn = document.getElementById('save-advanced-editor-btn');
                const cancelBtn = document.getElementById('cancel-advanced-editor-btn');

                // Remove existing event listeners by cloning
                const newSaveBtn = saveBtn.cloneNode(true);
                const newCancelBtn = cancelBtn.cloneNode(true);
                const newAddBtn = addBtn.cloneNode(true);

                saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
                cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
                addBtn.parentNode.replaceChild(newAddBtn, addBtn);

                // Add message button handler (same as chat)
                newAddBtn.addEventListener('click', () => {
                    const newBlock = createMessageEditorBlock();
                    editorContainer.appendChild(newBlock);
                    newBlock.querySelector('textarea').focus();
                });

                // Save handler for meetup mode with multiple message support
                newSaveBtn.addEventListener('click', async () => {
                    await saveMeetupEditedMessage(timestamp);
                });

                // Cancel handler
                newCancelBtn.addEventListener('click', () => {
                    editorModal.classList.remove('visible');
                });

                // Show the modal
                editorModal.classList.add('visible');

                // Focus the textarea
                const textarea = editorContainer.querySelector('textarea');
                if (textarea) {
                    textarea.focus();
                    textarea.select();
                }
            }

            function updateMeetupContext(eventData) {
                // Update context bar with event information
                const locationEl = document.getElementById('meetup-location');
                const timeEl = document.getElementById('meetup-time');
                const phaseEl = document.getElementById('meetup-phase');
                const titleEl = document.getElementById('meetup-title');

                // If no eventData provided, try to get it from active session
                if (!eventData && window.activeMeetupSession) {
                    const session = window.activeMeetupSession;
                    const chat = state.chats[session.chatId];

                    if (chat) {
                        eventData = {
                            location: session.location || '未设定位置',
                            timeDisplay: new Date(session.startTime).toLocaleString('zh-CN'),
                            phase: 'during',
                            title: `与${chat.name || 'AI'}见面`
                        };
                    }
                }

                if (eventData) {
                    if (locationEl) locationEl.textContent = `📍 ${eventData.location || '-'}`;
                    if (timeEl) timeEl.textContent = `🕐 ${eventData.timeDisplay || '时间未设定'}`;
                    if (phaseEl) {
                        const phaseText = eventData.phase === 'before' ? '💭 即将开始' :
                            eventData.phase === 'during' ? '💕 见面进行中' :
                                eventData.phase === 'after' ? '✨ 美好回忆' : '💕 见面模式';
                        phaseEl.textContent = phaseText;
                    }
                    if (titleEl) {
                        // Include AI character name in title
                        const session = window.activeMeetupSession;
                        if (session && session.chatId && state.chats[session.chatId]) {
                            const chat = state.chats[session.chatId];
                            const aiName = chat.name || 'AI';
                            titleEl.textContent = `与${aiName}见面`;
                        } else {
                            titleEl.textContent = eventData.title || '见面模式';
                        }
                    }
                }
            }

            function initializeMeetupScreen() {
                // Reset screen state first
                resetMeetupScreen();

                // Check if we're viewing history or active session
                if (window.meetupHistoryEventId) {
                    initializeMeetupHistoryView();
                } else {
                    initializeMeetupActiveSession();
                }
            }

            function resetMeetupScreen() {
                // Remove history mode class
                const meetupScreen = document.getElementById('meetup-screen');
                if (meetupScreen) {
                    meetupScreen.classList.remove('history-mode');
                }

                // Reset title
                const titleEl = document.getElementById('meetup-title');
                if (titleEl) {
                    titleEl.textContent = '见面模式';
                }

                // Show menu button
                const menuBtn = document.getElementById('meetup-menu');
                if (menuBtn) {
                    menuBtn.style.display = 'block';
                }

                // Clear messages container
                const messagesContainer = document.getElementById('meetup-messages');
                if (messagesContainer) {
                    messagesContainer.innerHTML = '';
                }

                // Reset context bar
                const locationEl = document.getElementById('meetup-location');
                const timeEl = document.getElementById('meetup-time');
                const phaseEl = document.getElementById('meetup-phase');
                if (locationEl) locationEl.textContent = '📍 位置信息';
                if (timeEl) timeEl.textContent = '🕐 时间信息';
                if (phaseEl) phaseEl.textContent = '💕 见面进行中';
            }

            async function initializeMeetupActiveSession() {
                // Initialize input handling for active session
                initializeMeetupInput();

                // Show input area and end date button for active sessions
                const inputArea = document.getElementById('meetup-input-area');
                const endDateBtn = document.getElementById('end-date-btn');
                if (inputArea) inputArea.style.display = 'block';
                if (endDateBtn) endDateBtn.style.display = 'block';

                // Load existing messages for this active session
                await loadActiveMeetupMessages();

                // Update meetup context after loading messages
                updateMeetupContext();

                // Set up back button
                const backBtn = document.getElementById('meetup-back-btn');
                if (backBtn) {
                    backBtn.addEventListener('click', function () {
                        // Exit selection mode if active
                        if (isSelectionMode) {
                            exitMeetupSelectionMode();
                        }

                        // Return to the previous screen or default to chat interface
                        const targetScreen = previousScreen || 'chat-interface-screen';
                        showScreen(targetScreen);
                        previousScreen = null; // Reset after use
                    });
                }

                // Set up menu button
                const menuBtn = document.getElementById('meetup-menu');
                if (menuBtn) {
                    menuBtn.addEventListener('click', function () {
                        // TODO: This will be implemented in later tasks
                        // - Show meetup mode options menu
                        // - Options: view history, end date, settings
                    });
                }

                // Set up selection mode controls
                const selectionCancelBtn = document.getElementById('meetup-selection-cancel-btn');
                if (selectionCancelBtn) {
                    selectionCancelBtn.addEventListener('click', exitMeetupSelectionMode);
                }

                const selectionDeleteBtn = document.getElementById('meetup-selection-delete-btn');
                if (selectionDeleteBtn) {
                    selectionDeleteBtn.addEventListener('click', deleteMeetupSelectedMessages);
                }

                // Override message action handlers for meetup mode
                setupMeetupMessageActionHandlers();
            }

            async function initializeMeetupHistoryView() {
                try {
                    // Load historical meetup data
                    const meetupData = await getMeetupSessionFromEvent(window.meetupHistoryEventId);

                    // Get the original event to find the chatId
                    const event = await db.memories.get(window.meetupHistoryEventId);

                    // Set the active chat context for proper avatar loading
                    if (event && event.chatId) {
                        state.activeChatId = event.chatId;
                    } else if (meetupData.chatId) {
                        state.activeChatId = meetupData.chatId;
                    }

                    // Add history mode class to apply chat interface styling
                    const meetupScreen = document.getElementById('meetup-screen');
                    if (meetupScreen) {
                        meetupScreen.classList.add('history-mode');
                    }

                    // Hide input area and end date button for history view
                    const inputArea = document.getElementById('meetup-input-area');
                    const endDateBtn = document.getElementById('end-date-btn');
                    if (inputArea) inputArea.style.display = 'none';
                    if (endDateBtn) endDateBtn.style.display = 'none';

                    // Update header for history view
                    const titleEl = document.getElementById('meetup-title');
                    if (titleEl) {
                        titleEl.textContent = `见面回忆 - ${meetupData.title || '见面记录'}`;
                    }

                    // Update context bar with historical info
                    updateMeetupContextBarForHistory(meetupData);

                    // Load and display historical messages
                    await loadMeetupHistoryMessages(meetupData);

                    // Set up back button for history view
                    const backBtn = document.getElementById('meetup-back-btn');
                    if (backBtn) {
                        // Remove existing event listeners to prevent duplicates
                        const newBackBtn = backBtn.cloneNode(true);
                        backBtn.parentNode.replaceChild(newBackBtn, backBtn);

                        newBackBtn.addEventListener('click', function () {
                            // Clear history mode and return to calendar
                            window.meetupHistoryEventId = null;
                            showScreen('calendar-screen');
                        });
                    }

                    // Disable menu button for history view
                    const menuBtn = document.getElementById('meetup-menu');
                    if (menuBtn) {
                        menuBtn.style.display = 'none';
                    }

                    // Set up selection mode controls for history view
                    const selectionCancelBtn = document.getElementById('meetup-selection-cancel-btn');
                    if (selectionCancelBtn) {
                        selectionCancelBtn.addEventListener('click', exitMeetupSelectionMode);
                    }

                    const selectionDeleteBtn = document.getElementById('meetup-selection-delete-btn');
                    if (selectionDeleteBtn) {
                        selectionDeleteBtn.addEventListener('click', deleteMeetupSelectedMessages);
                    }

                } catch (error) {
                    console.error('Failed to initialize meetup history view:', error);
                    alert('无法加载见面回忆: ' + error.message);
                    showScreen('calendar-screen');
                }
            }

            function updateMeetupContextBarForHistory(meetupData) {
                // Update location info
                const locationEl = document.getElementById('meetup-location');
                if (locationEl) {
                    locationEl.textContent = `📍 ${meetupData.location || '未知地点'}`;
                }

                // Update time info with date range
                const timeEl = document.getElementById('meetup-time');
                if (timeEl) {
                    const startTime = new Date(meetupData.startTime);
                    const endTime = new Date(meetupData.endTime);
                    const startStr = startTime.toLocaleString('zh-CN', {
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                    const endStr = endTime.toLocaleString('zh-CN', {
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                    timeEl.textContent = `🕐 ${startStr} - ${endStr}`;
                }

                // Update phase info with completion status
                const phaseEl = document.getElementById('meetup-phase');
                if (phaseEl) {
                    const duration = Math.round(meetupData.totalDuration || 0);
                    phaseEl.textContent = `💕 见面已完成 (${duration}分钟)`;
                }
            }

            async function loadMeetupHistoryMessages(meetupData) {
                const messagesContainer = document.getElementById('meetup-messages');
                if (!messagesContainer) return;

                // Clear existing messages
                messagesContainer.innerHTML = '';

                // Load historical messages
                const messages = meetupData.messages || meetupData.interactions || [];

                if (messages.length === 0) {
                    messagesContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: #999;">这次见面没有留下消息记录</div>';
                    return;
                }

                // Display messages in chronological order
                messages.forEach(message => {
                    // Convert stored message format to display format if needed
                    let displayMessage = message;
                    if (message.role) {
                        // Convert from stored format to display format
                        displayMessage = {
                            ...message,
                            isUser: message.role === 'user'
                        };
                    }

                    const messageEl = createMeetupMessageElement(displayMessage, false); // false - allow editing in history
                    messagesContainer.appendChild(messageEl);
                });

                // Scroll to bottom
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            function createMeetupMessageElement(message, isReadOnly = false) {
                // Use the EXACT same structure as createMeetupMessage
                const isUser = message.role === 'user' || message.isUser === true;

                // Create wrapper following the EXACT same structure as regular chat
                const wrapper = document.createElement('div');
                wrapper.className = `message-wrapper ${isUser ? 'user' : 'ai'}`;

                // Create bubble
                const bubble = document.createElement('div');
                bubble.className = `message-bubble ${isUser ? 'user' : 'ai'}`;
                bubble.dataset.timestamp = message.timestamp;

                // Create timestamp element (outside bubble, inside wrapper)
                const timestampEl = document.createElement('span');
                timestampEl.className = 'timestamp';
                timestampEl.textContent = formatTimestamp(message.timestamp);

                // Get avatar - try multiple sources for chat context
                let avatarSrc;
                let chatId = null;

                // Try to get chat ID from multiple sources
                if (message.chatId && state.chats[message.chatId]) {
                    chatId = message.chatId;
                } else if (window.activeMeetupSession && window.activeMeetupSession.chatId) {
                    chatId = window.activeMeetupSession.chatId;
                } else if (window.meetupHistoryEventId && state.activeChatId) {
                    chatId = state.activeChatId;
                } else if (state.activeChatId) {
                    chatId = state.activeChatId;
                }

                if (chatId && state.chats[chatId]) {
                    const chat = state.chats[chatId];
                    if (isUser) {
                        avatarSrc = chat.settings.myAvatar || 'https://files.catbox.moe/q6z5fc.jpeg';
                    } else {
                        avatarSrc = chat.settings.aiAvatar || 'https://files.catbox.moe/q6z5fc.jpeg';
                    }
                } else {
                    // Last resort: use default avatars
                    avatarSrc = 'https://files.catbox.moe/q6z5fc.jpeg';
                }

                // Create avatar HTML using EXACT same structure as regular chat
                const avatarHtml = `<div class="avatar-group"><img src="${avatarSrc}" class="avatar"></div>`;

                // Process behavioral notations
                const processed = processBehavioralNotations(message.content || '');

                // Create content HTML (same structure as regular chat)
                const contentHtml = processed.text;

                // Set bubble innerHTML using EXACT same structure as regular chat
                bubble.innerHTML = `
                    ${avatarHtml}
                    <div class="content">
                        ${contentHtml}
                    </div>
                `;

                // Append bubble and timestamp to wrapper in EXACT same order as regular chat
                wrapper.appendChild(bubble);
                wrapper.appendChild(timestampEl);

                // Add long press listener for message actions (same as regular chat)
                if (!isReadOnly) {
                    addLongPressListener(wrapper, () => showMeetupMessageActions(message.timestamp));

                    // Add click listener for selection mode (meetup mode specific)
                    wrapper.addEventListener('click', () => {
                        if (isSelectionMode) {
                            toggleMeetupMessageSelection(message.timestamp);
                        }
                    });
                }

                return wrapper;
            }

            function setupMeetupMessageActionHandlers() {
                // Don't override global handlers - instead make them context-aware
                // The handlers will check if we're in meetup mode and act accordingly
            }

            // Function to save edited meetup messages with multiple message support
            async function saveMeetupEditedMessage(timestamp) {
                if (!timestamp) return;

                // Handle both active meetup mode and history mode
                let eventId, chatId;

                if (window.meetupHistoryEventId) {
                    // History mode
                    eventId = window.meetupHistoryEventId;
                    chatId = state.activeChatId; // Set in initializeMeetupHistoryView
                } else if (window.activeMeetupSession && window.activeMeetupEventId) {
                    // Active meetup mode
                    eventId = window.activeMeetupEventId;
                    chatId = window.activeMeetupSession.chatId;
                } else {
                    console.error('No active meetup session or history context');
                    return;
                }

                const chat = state.chats[chatId];
                if (!chat) {
                    console.error('Chat not found:', chatId);
                    return;
                }

                // Find the message in chat history
                const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
                if (messageIndex === -1) {
                    console.error('Message not found in chat history:', timestamp);
                    return;
                }

                const editorContainer = document.getElementById('message-editor-container');
                const editorBlocks = editorContainer.querySelectorAll('.message-editor-block');

                let newMessages = [];
                let baseTimestamp = timestamp; // Use original timestamp as base

                for (const block of editorBlocks) {
                    const textarea = block.querySelector('textarea');
                    const rawContent = textarea.value.trim();

                    if (!rawContent) continue; // Skip empty editor blocks

                    // Create new message with meetup context
                    const originalMessage = chat.history[messageIndex];
                    const newMessage = {
                        role: originalMessage.role,
                        content: rawContent,
                        timestamp: baseTimestamp++, // Increment timestamp to ensure order and uniqueness
                        isUser: originalMessage.isUser,
                        type: 'meetup_interaction',
                        isHidden: true, // Hidden from regular chat UI like QZone messages
                        meetup: {
                            eventId: eventId,
                            location: originalMessage.meetup?.location || 'Unknown Location',
                            title: originalMessage.meetup?.title || 'Meetup',
                            phase: originalMessage.meetup?.phase || 'conversation',
                            isActive: originalMessage.meetup?.isActive || false
                        }
                    };

                    // Preserve other properties if they exist
                    if (originalMessage.senderName) newMessage.senderName = originalMessage.senderName;
                    if (originalMessage.authorName) newMessage.authorName = originalMessage.authorName;

                    newMessages.push(newMessage);
                }

                if (newMessages.length === 0) {
                    alert("不能保存空消息，请至少输入一条内容。");
                    return;
                }

                try {
                    // Replace the original message with new messages in chat history
                    chat.history.splice(messageIndex, 1, ...newMessages);

                    // Save updated chat to database
                    await db.chats.put(chat);

                    // Update the calendar event's stored meetup data
                    if (window.meetupHistoryEventId) {
                        await updateCalendarEventMeetupData(window.meetupHistoryEventId, chat);
                    }

                    // Close modal and refresh display
                    document.getElementById('message-editor-modal').classList.remove('visible');

                    // Refresh the meetup messages display
                    if (window.meetupHistoryEventId) {
                        // History mode - reload history view
                        await loadMeetupHistoryMessages(await getMeetupSessionFromEvent(window.meetupHistoryEventId));
                    } else {
                        // Active mode - reload active messages
                        await loadActiveMeetupMessages();
                    }

                    await showCustomAlert('成功', '消息已更新！');

                } catch (error) {
                    console.error('Failed to save edited meetup message:', error);
                    alert('保存失败，请重试');
                }
            }
            // ▲▲▲ Meetup Input Handling Functions End ▲▲▲

            /**
             * 检查给定的URL是否包含任何被禁止的关键词 (黑名单内置)
             * @param {string} url - 要检查的API地址
             * @returns {boolean} - 如果 URL 包含被禁止的关键词则返回 true, 否则返回 false
             */
            function isApiUrlBanned(url) {
                // 将黑名单直接定义在函数内部
                //如果因为api问题能查到这里证明你是聪明宝宝… 但是不好意思由于个人原因确实是对这两家或其管理没什么好感，如果确实要用的话直接删掉就好，我也拿你没办法。算是我一点小恶毒吧，抱歉。
                const BANNED_API_KEYWORDS = ['nyabit', 'v1', 'dianhuomao'];
                if (!url) return false;
                const lowercasedUrl = url.toLowerCase();
                // 使用 .some() 方法，只要找到一个匹配的关键词就立即返回 true
                return BANNED_API_KEYWORDS.some(keyword => lowercasedUrl.includes(keyword));
            }

            function isGoogleGeminiAPI(proxyUrl) {
                return proxyUrl && proxyUrl.includes('generativelanguage.googleapis.com');
            }

            async function makeAPIRequest(proxyUrl, apiKey, model, messages, temperature = 0.8) {
                if (isGoogleGeminiAPI(proxyUrl)) {

                    // Google Gemini API format
                    const contents = messages.map(msg => {
                        const role = msg.role === 'assistant' ? 'model' : 'user';
                        let parts = [];

                        // Handle image content (OpenAI format -> Gemini format)
                        if (Array.isArray(msg.content)) {
                            for (const item of msg.content) {
                                if (item.type === 'image_url' && item.image_url?.url) {
                                    // Extract base64 data and mime type from data URL
                                    const dataUrl = item.image_url.url;
                                    const matches = dataUrl.match(/^data:([^;]+);base64,(.+)$/);
                                    if (matches) {
                                        parts.push({
                                            inline_data: {
                                                mime_type: matches[1],
                                                data: matches[2]
                                            }
                                        });
                                    }
                                } else if (item.type === 'text' && item.text) {
                                    parts.push({ text: item.text });
                                }
                            }
                        } else {
                            // Regular text content
                            parts = [{ text: msg.content }];
                        }

                        return { role, parts };
                    });



                    const response = await fetch(`${proxyUrl}/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: contents,
                            generationConfig: {
                                temperature: temperature
                            }
                        })
                    });



                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error(`[API Debug] Google API request failed:`, {
                            status: response.status,
                            statusText: response.statusText,
                            errorData: errorData
                        });
                        throw new Error(errorData.error?.message || 'Google API request failed');
                    }

                    const data = await response.json();

                    if (!data.candidates || !Array.isArray(data.candidates) || data.candidates.length === 0) {
                        throw new Error('Invalid Google API response: no candidates found');
                    }

                    // Convert Google response to OpenAI format
                    const convertedResponse = {
                        choices: [{
                            message: {
                                content: data.candidates[0]?.content?.parts[0]?.text || ''
                            }
                        }]
                    };

                    return convertedResponse;
                } else {
                    // OpenAI-compatible API format (existing)
                    const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: model,
                            messages: messages,
                            temperature: temperature
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error?.message || 'API request failed');
                    }

                    const data = await response.json();
                    return data;
                }
            }
            function showNotification(chatId, messageContent) { clearTimeout(notificationTimeout); const chat = state.chats[chatId]; if (!chat) return; const bar = document.getElementById('notification-bar'); document.getElementById('notification-avatar').src = chat.settings.aiAvatar || chat.settings.groupAvatar || defaultAvatar; document.getElementById('notification-content').querySelector('.name').textContent = chat.name; document.getElementById('notification-content').querySelector('.message').textContent = messageContent; const newBar = bar.cloneNode(true); bar.parentNode.replaceChild(newBar, bar); newBar.addEventListener('click', () => { openChat(chatId); newBar.classList.remove('visible'); }); newBar.classList.add('visible'); notificationTimeout = setTimeout(() => { newBar.classList.remove('visible'); }, 4000); }

            function updateClock() { const now = new Date(); const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' }); const dateString = now.toLocaleDateString('zh-CN', { weekday: 'long', month: 'long', day: 'numeric' }); document.getElementById('main-time').textContent = timeString; document.getElementById('status-bar-time').textContent = timeString; document.getElementById('main-date').textContent = dateString; }

            function parseAiResponse(content) {
                const trimmedContent = content.trim();

                // 1. 尝试作为完整的JSON数组解析 (最理想情况)
                if (trimmedContent.startsWith('[') && trimmedContent.endsWith(']')) {
                    try {
                        const parsed = JSON.parse(trimmedContent);
                        if (Array.isArray(parsed)) return parsed;
                    } catch (e) {
                        // 解析失败，继续尝试其他方法
                    }
                }

                // 2. 如果失败，尝试作为单个JSON对象解析 (处理AI“偷懒”的情况)
                if (trimmedContent.startsWith('{') && trimmedContent.endsWith('}')) {
                    try {
                        const parsed = JSON.parse(trimmedContent);
                        // 如果成功解析为对象，把它放进一个数组里再返回，以统一格式
                        return [parsed];
                    } catch (e) {
                        // 解析失败，继续尝试其他方法
                    }
                }

                // 3. 尝试解析多个独立的JSON数组 (处理AI返回多个[{...}]的情况)
                try {
                    const jsonArrayMatches = content.match(/\[.*?\]/g);
                    if (jsonArrayMatches && jsonArrayMatches.length > 1) {
                        const allMessages = [];
                        for (const jsonStr of jsonArrayMatches) {
                            try {
                                const parsed = JSON.parse(jsonStr);
                                if (Array.isArray(parsed)) {
                                    allMessages.push(...parsed);
                                }
                            } catch (e) {
                                // 跳过无效的JSON
                            }
                        }
                        if (allMessages.length > 0) return allMessages;
                    }
                } catch (e) {
                    // 解析失败
                }

                // 4. 作为备用方案，尝试从文本中提取单个JSON数组
                try {
                    const match = content.match(/\[(.*?)\]/s);
                    if (match && match[0]) {
                        const parsed = JSON.parse(match[0]);
                        if (Array.isArray(parsed)) return parsed;
                    }
                } catch (e) {
                    // 提取失败
                }

                // 5. 如果以上全部失败，则视为纯文本处理
                const lines = content.split('\n').map(l => l.trim()).filter(l => l.length > 0 && !l.startsWith('```'));
                if (lines.length > 0) return lines;

                // 6. 最终的最终，返回原始文本
                return [content];
            }

            function renderApiSettings() {
                document.getElementById('proxy-url').value = state.apiConfig.proxyUrl || ''; document.getElementById('api-key').value = state.apiConfig.apiKey || '';
                // ▼▼▼ 新增这行 ▼▼▼
                document.getElementById('background-activity-switch').checked = state.globalSettings.enableBackgroundActivity || false;
                document.getElementById('background-interval-input').value = state.globalSettings.backgroundActivityInterval || 60;
                document.getElementById('block-cooldown-input').value = state.globalSettings.blockCooldownHours || 1;
            }
            window.renderApiSettingsProxy = renderApiSettings;

            // ▼▼▼ 请用这个【支持状态灯和时间戳的全新版本】替换旧的 renderChatList 和 createChatListItem 函数 ▼▼▼

            /**
             * 格式化最后一条消息的时间戳
             * @param {number} timestamp - 消息的时间戳
             * @returns {string} 格式化后的时间字符串
             */
            function formatLastMessageTime(timestamp) {
                if (!timestamp) return '';
                const now = new Date();
                const date = new Date(timestamp);

                // 如果是今天
                if (now.toDateString() === date.toDateString()) {
                    return `${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
                }

                // 如果是昨天
                const yesterday = new Date(now);
                yesterday.setDate(now.getDate() - 1);
                if (yesterday.toDateString() === date.toDateString()) {
                    return '昨天';
                }

                // 如果是更早
                return `${date.getFullYear()}/${String(date.getMonth() + 1).padStart(2, '0')}/${String(date.getDate()).padStart(2, '0')}`;
            }

            async function renderChatList() {
                const chatListEl = document.getElementById('chat-list');
                chatListEl.innerHTML = '';

                const allChats = Object.values(state.chats).sort((a, b) => {
                    // First sort by pinned status (pinned chats first)
                    if (a.isPinned && !b.isPinned) return -1;
                    if (!a.isPinned && b.isPinned) return 1;

                    // Then sort by last message timestamp
                    const lastMsgA = a.history.slice(-1)[0] || {};
                    const lastMsgB = b.history.slice(-1)[0] || {};
                    return (lastMsgB.timestamp || 0) - (lastMsgA.timestamp || 0);
                });

                if (allChats.length === 0) {
                    chatListEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角 "+" 或群组图标添加聊天</p>';
                    return;
                }

                const allGroups = await db.qzoneGroups.toArray();

                // 计算每个分组的最新时间戳，用于排序
                allGroups.forEach(group => {
                    const latestChatInGroup = allChats
                        .filter(chat => chat.groupId === group.id)
                        .sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0))[0];
                    group.latestTimestamp = latestChatInGroup ? (latestChatInGroup.history.slice(-1)[0]?.timestamp || 0) : 0;
                });

                // 按最新时间戳对分组进行降序排序
                allGroups.sort((a, b) => b.latestTimestamp - a.latestTimestamp);

                // 渲染分组的聊天
                allGroups.forEach(group => {
                    const groupChats = allChats.filter(chat => !chat.isGroup && chat.groupId === group.id);
                    if (groupChats.length === 0) return;

                    const groupContainer = document.createElement('div');
                    groupContainer.className = 'chat-group-container';
                    groupContainer.innerHTML = `
            <div class="chat-group-header">
                <span class="arrow">▼</span>
                <span class="group-name">${group.name} (${groupChats.length})</span>
            </div>
            <div class="chat-group-content"></div>
        `;
                    const contentEl = groupContainer.querySelector('.chat-group-content');

                    // 确保组内的聊天也按时间排序
                    groupChats.sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0));

                    groupChats.forEach(chat => {
                        const item = createChatListItem(chat);
                        contentEl.appendChild(item);
                    });
                    chatListEl.appendChild(groupContainer);
                });

                // 渲染未分组的聊天和所有群聊
                const ungroupedOrGroupChats = allChats.filter(chat => chat.isGroup || (!chat.isGroup && !chat.groupId));
                ungroupedOrGroupChats.forEach(chat => {
                    const item = createChatListItem(chat);
                    chatListEl.appendChild(item);
                });

                // 为所有新生成的折叠箭头绑定事件
                document.querySelectorAll('.chat-group-header').forEach(header => {
                    header.addEventListener('click', () => {
                        header.classList.toggle('collapsed');
                        header.nextElementSibling.classList.toggle('collapsed');
                    });
                });
            }


            function createChatListItem(chat) {
                const lastMsgObj = chat.history.filter(msg => !msg.isHidden).slice(-1)[0] || {};
                let lastMsgDisplay = '...';

                // 根据消息类型生成预览文本
                if (lastMsgObj.type === 'pat_message') { lastMsgDisplay = `[系统消息] ${lastMsgObj.content}`; }
                else if (lastMsgObj.type === 'transfer') { lastMsgDisplay = '[转账]'; }
                else if (lastMsgObj.type === 'ai_image' || lastMsgObj.type === 'user_photo') { lastMsgDisplay = '[照片]'; }
                else if (lastMsgObj.type === 'voice_message') { lastMsgDisplay = '[语音]'; }
                else if (typeof lastMsgObj.content === 'string' && STICKER_REGEX.test(lastMsgObj.content)) { lastMsgDisplay = lastMsgObj.meaning ? `[表情: ${lastMsgObj.meaning}]` : '[表情]'; }
                else if (Array.isArray(lastMsgObj.content)) { lastMsgDisplay = `[图片]`; }
                else { lastMsgDisplay = String(lastMsgObj.content || '...').substring(0, 25); }

                if (chat.isGroup && lastMsgObj.senderName && lastMsgObj.type !== 'pat_message') {
                    lastMsgDisplay = `${lastMsgObj.senderName}: ${lastMsgDisplay}`;
                }

                // 处理特殊关系状态的显示
                if (!chat.isGroup && chat.relationship?.status === 'pending_user_approval') {
                    lastMsgDisplay = `<span style="color: #ff8c00;">[好友申请] ${chat.relationship.applicationReason || '请求添加你为好友'}</span>`;
                } else if (!chat.isGroup && chat.relationship?.status === 'blocked_by_ai') {
                    lastMsgDisplay = `<span style="color: #dc3545;">[你已被对方拉黑]</span>`;
                }

                const item = document.createElement('div');
                item.className = 'chat-list-item';
                if (chat.isPinned) {
                    item.classList.add('pinned');
                }
                item.dataset.chatId = chat.id;
                const avatar = chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar;

                // **核心HTML结构修改**
                item.innerHTML = `
        <img src="${avatar || defaultAvatar}" class="avatar">
        <div class="info">
            <div class="name-line">
                <span class="name">${chat.name}</span>
                ${chat.isGroup ? '<span class="group-tag">群聊</span>' : ''}
            </div>
            <div class="last-msg">${lastMsgDisplay}</div>
        </div>
        <div class="meta">
            <div class="timestamp">${formatLastMessageTime(lastMsgObj.timestamp)}</div>
            <div class="status-light ${chat.status || ''}"></div>
        </div>
    `;

                // ▼▼▼ 核心修改：为头像添加智能的单击/双击事件处理器 ▼▼▼
                const avatarEl = item.querySelector('.avatar');
                if (avatarEl) {
                    let clickTimer = null; // 用于存储单击延时器的变量
                    let clickCount = 0;    // 用于记录点击次数的变量

                    avatarEl.addEventListener('click', (e) => {
                        e.stopPropagation(); // 关键！阻止事件冒泡到父元素，防止立即触发进入聊天

                        clickCount++;

                        if (clickCount === 1) {
                            // 第一次点击时，启动一个定时器
                            clickTimer = setTimeout(() => {
                                // 如果定时器正常触发（300毫秒内没有第二次点击），则执行单击操作
                                openChat(chat.id); // 单击头像进入聊天
                                clickCount = 0; // 重置点击计数
                            }, 300); // 300毫秒是一个比较舒适的双击间隔
                        } else if (clickCount === 2) {
                            // 在定时器触发前，第二次点击到来了
                            clearTimeout(clickTimer); // 清除即将执行的单击操作
                            clickCount = 0; // 重置点击计数

                            // 立即执行双击操作
                            handleUserPat(chat.id, chat.name); // 双击头像进行“拍一拍”
                        }
                    });
                }
                // ▲▲▲ 修改结束 ▲▲▲

                item.addEventListener('click', (event) => {
                    // 只有当点击事件的目标不是头像时，才立即进入聊天
                    if (!event.target.classList.contains('avatar')) {
                        openChat(chat.id);
                    }
                });

                addLongPressListener(item, async (e) => {
                    showChatActions(chat.id);
                });

                return item;
            }


            function renderChatInterface(chatId) {
                cleanupWaimaiTimers();
                const chat = state.chats[chatId];
                if (!chat) return;
                exitSelectionMode();

                const messagesContainer = document.getElementById('chat-messages');
                const chatInputArea = document.getElementById('chat-input-area');
                const lockOverlay = document.getElementById('chat-lock-overlay');
                const lockContent = document.getElementById('chat-lock-content');

                messagesContainer.dataset.theme = chat.settings.theme || 'default';
                const fontSize = chat.settings.fontSize || 13;
                messagesContainer.style.setProperty('--chat-font-size', `${fontSize}px`);
                applyScopedCss(chat.settings.customCss || '', '#chat-messages', 'custom-bubble-style');

                document.getElementById('chat-header-title').textContent = chat.name;
                const statusContainer = document.getElementById('chat-header-status');
                const statusTextEl = statusContainer.querySelector('.status-text');

                if (chat.isGroup) {
                    statusContainer.style.display = 'none';
                    document.getElementById('chat-header-title-wrapper').style.justifyContent = 'center';
                } else {
                    statusContainer.style.display = 'flex';
                    document.getElementById('chat-header-title-wrapper').style.justifyContent = 'flex-start';
                    statusTextEl.textContent = chat.status?.text || '在线';
                    statusContainer.classList.toggle('busy', chat.status?.isBusy || false);
                }

                lockOverlay.style.display = 'none';
                chatInputArea.style.visibility = 'visible';
                lockContent.innerHTML = '';

                if (!chat.isGroup && chat.relationship.status !== 'friend') {
                    lockOverlay.style.display = 'flex';
                    chatInputArea.style.visibility = 'hidden';

                    let lockHtml = '';
                    switch (chat.relationship.status) {
                        case 'blocked_by_user':
                            // --- 【核心修改：在这里加入诊断面板】 ---
                            const isSimulationRunning = simulationIntervalId !== null;
                            const blockedTimestamp = chat.relationship.blockedTimestamp;
                            const cooldownHours = state.globalSettings.blockCooldownHours || 1;
                            const cooldownMilliseconds = cooldownHours * 60 * 60 * 1000;
                            const timeSinceBlock = Date.now() - blockedTimestamp;
                            const isCooldownOver = timeSinceBlock > cooldownMilliseconds;
                            const timeRemainingMinutes = Math.max(0, Math.ceil((cooldownMilliseconds - timeSinceBlock) / (1000 * 60)));

                            lockHtml = `
                    <span class="lock-text">你已将“${chat.name}”拉黑。</span>
                    <button id="unblock-btn" class="lock-action-btn">解除拉黑</button>
                    <div style="margin-top: 20px; padding: 10px; border: 1px dashed #ccc; border-radius: 8px; font-size: 11px; text-align: left; color: #666; background: rgba(0,0,0,0.02);">
                        <strong style="color: #333;">【开发者诊断面板】</strong><br>
                        - 后台活动总开关: ${state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">已开启</span>' : '<span style="color: red;">已关闭</span>'}<br>
                        - 系统心跳计时器: ${isSimulationRunning ? '<span style="color: green;">运行中</span>' : '<span style="color: red;">未运行</span>'}<br>
                        - 当前角色状态: <strong>${chat.relationship.status}</strong><br>
                        - 需要冷静(小时): <strong>${cooldownHours}</strong><br>
                        - 冷静期是否结束: ${isCooldownOver ? '<span style="color: green;">是</span>' : `<span style="color: orange;">否 (还剩约 ${timeRemainingMinutes} 分钟)</span>`}<br>
                        - 触发条件: ${isCooldownOver && state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">已满足，等待下次系统心跳</span>' : '<span style="color: red;">未满足</span>'}
                    </div>
                    <button id="force-apply-check-btn" class="lock-action-btn secondary" style="margin-top: 10px;">强制触发一次好友申请检测</button>
                `;
                            // --- 【修改结束】 ---
                            break;
                        case 'blocked_by_ai':
                            lockHtml = `
                    <span class="lock-text">你被对方拉黑了。</span>
                    <button id="apply-friend-btn" class="lock-action-btn">重新申请加为好友</button>
                `;
                            break;

                        case 'pending_user_approval':
                            lockHtml = `
                    <span class="lock-text">“${chat.name}”请求添加你为好友：<br><i>“${chat.relationship.applicationReason}”</i></span>
                    <button id="accept-friend-btn" class="lock-action-btn">接受</button>
                    <button id="reject-friend-btn" class="lock-action-btn secondary">拒绝</button>
                `;
                            break;

                        // 【核心修正】修复当你申请后，你看到的界面
                        case 'pending_ai_approval':
                            lockHtml = `<span class="lock-text">好友申请已发送，等待对方通过...</span>`;
                            break;
                    }
                    lockContent.innerHTML = lockHtml;
                }
                messagesContainer.innerHTML = '';
                // ...后续代码保持不变
                const chatScreen = document.getElementById('chat-interface-screen');
                chatScreen.style.backgroundImage = chat.settings.background ? `url(${chat.settings.background})` : 'none';
                chatScreen.style.backgroundColor = chat.settings.background ? 'transparent' : '#f0f2f5';
                const history = chat.history;
                const totalMessages = history.length;
                currentRenderedCount = 0;
                const initialMessages = history.slice(-MESSAGE_RENDER_WINDOW);
                initialMessages.forEach(msg => appendMessage(msg, chat, true));
                currentRenderedCount = initialMessages.length;
                if (totalMessages > currentRenderedCount) {
                    prependLoadMoreButton(messagesContainer);
                }
                const typingIndicator = document.createElement('div');
                typingIndicator.id = 'typing-indicator';
                typingIndicator.style.display = 'none';
                typingIndicator.textContent = '对方正在输入...';
                messagesContainer.appendChild(typingIndicator);
                setTimeout(() => messagesContainer.scrollTop = messagesContainer.scrollHeight, 0);
            }
            // ▲▲▲ 替换结束 ▲▲▲

            function prependLoadMoreButton(container) { const button = document.createElement('button'); button.id = 'load-more-btn'; button.textContent = '加载更早的记录'; button.addEventListener('click', loadMoreMessages); container.prepend(button); }

            function loadMoreMessages() { const messagesContainer = document.getElementById('chat-messages'); const chat = state.chats[state.activeChatId]; if (!chat) return; const loadMoreBtn = document.getElementById('load-more-btn'); if (loadMoreBtn) loadMoreBtn.remove(); const totalMessages = chat.history.length; const nextSliceStart = totalMessages - currentRenderedCount - MESSAGE_RENDER_WINDOW; const nextSliceEnd = totalMessages - currentRenderedCount; const messagesToPrepend = chat.history.slice(Math.max(0, nextSliceStart), nextSliceEnd); const oldScrollHeight = messagesContainer.scrollHeight; messagesToPrepend.reverse().forEach(msg => prependMessage(msg, chat)); currentRenderedCount += messagesToPrepend.length; const newScrollHeight = messagesContainer.scrollHeight; messagesContainer.scrollTop += (newScrollHeight - oldScrollHeight); if (totalMessages > currentRenderedCount) { prependLoadMoreButton(messagesContainer); } }

            function renderWallpaperScreen() {
                const preview = document.getElementById('wallpaper-preview');
                const bg = newWallpaperBase64 || state.globalSettings.wallpaper;
                if (bg && bg.startsWith('data:image')) {
                    preview.style.backgroundImage = `url(${bg})`;
                    preview.textContent = '';
                } else if (bg) {
                    preview.style.backgroundImage = bg;
                    preview.textContent = '当前为渐变色';
                }

                // Render app icon customization section
                renderAppIconCustomization();
            }

            function renderAppIconCustomization() {
                const container = document.getElementById('app-icon-customization-list');
                if (!container) return;



                // Define default app icons
                const defaultAppIcons = [
                    { id: 'qq', name: 'QQ', defaultUrl: 'https://files.catbox.moe/janu1z.png' },
                    { id: 'moments', name: '朋友圈', defaultUrl: 'https://files.catbox.moe/65cdyc.png' },
                    { id: 'settings', name: '设置', defaultUrl: 'https://files.catbox.moe/xmo1uf.png' },
                    { id: 'calendar', name: '日历', defaultUrl: 'https://files.catbox.moe/calendar.png' }
                ];

                container.innerHTML = '';

                defaultAppIcons.forEach(app => {
                    // Load from localStorage (same as charm CSS)
                    const currentUrl = localStorage.getItem(`appIcon_${app.id}`) || app.defaultUrl;

                    const appIconItem = document.createElement('div');
                    appIconItem.className = 'app-icon-item';

                    appIconItem.innerHTML = `
                        <div class="app-icon-preview">
                            <img src="${currentUrl}" alt="${app.name}">
                            <span>${app.name}</span>
                        </div>
                        <input type="text" 
                               id="app-icon-${app.id}" 
                               value="${currentUrl}" 
                               placeholder="输入图标URL"
                               class="app-icon-input">
                        <div class="app-icon-actions">
                            <button onclick="updateAppIcon('${app.id}')" class="app-icon-btn primary">
                                应用
                            </button>
                            <button onclick="resetAppIcon('${app.id}', '${app.defaultUrl}')" class="app-icon-btn secondary">
                                重置
                            </button>
                        </div>
                    `;

                    container.appendChild(appIconItem);
                });
            }

            window.updateAppIcon = function (appId) {
                const input = document.getElementById(`app-icon-${appId}`);
                const newUrl = input.value.trim();

                if (!newUrl) {
                    showCustomAlert('错误', '请输入有效的图标URL');
                    return;
                }

                // Save to localStorage (same as charm CSS)
                localStorage.setItem(`appIcon_${appId}`, newUrl);

                // Apply to home screen
                applyAppIconsToHomeScreen();

                // Re-render the customization section to show updated preview
                renderAppIconCustomization();

                showCustomAlert('成功', '图标已更新');
            }

            window.resetAppIcon = function (appId, defaultUrl) {
                const input = document.getElementById(`app-icon-${appId}`);
                input.value = defaultUrl;

                // Remove from localStorage (same as charm CSS reset)
                localStorage.removeItem(`appIcon_${appId}`);

                // Apply to home screen
                applyAppIconsToHomeScreen();

                // Re-render the customization section to show updated preview
                renderAppIconCustomization();

                showCustomAlert('成功', '图标已重置为默认');
            }

            function applyAppIconsToHomeScreen() {
                const appIconMappings = {
                    'qq': 'div.app-icon:nth-child(2) img', // First app icon (QQ)
                    'moments': 'div.app-icon:nth-child(3) img', // Second app icon (朋友圈)
                    'calendar': 'div.app-icon:nth-child(4) img', // Third app icon (日历)
                    'settings': 'div.app-icon:nth-child(5) img' // Fourth app icon (设置)
                };

                Object.keys(appIconMappings).forEach(appId => {
                    // Load from localStorage (same as charm CSS)
                    const iconUrl = localStorage.getItem(`appIcon_${appId}`);
                    if (iconUrl) {
                        const imgElement = document.querySelector(appIconMappings[appId]);
                        if (imgElement) {
                            imgElement.src = iconUrl;
                        }
                    }
                });
            }
            window.renderWallpaperScreenProxy = renderWallpaperScreen;

            function applyGlobalWallpaper() { const homeScreen = document.getElementById('home-screen'); const wallpaper = state.globalSettings.wallpaper; if (wallpaper && wallpaper.startsWith('data:image')) homeScreen.style.backgroundImage = `url(${wallpaper})`; else if (wallpaper) homeScreen.style.backgroundImage = wallpaper; }

            function renderWorldBookScreen() { const listEl = document.getElementById('world-book-list'); listEl.innerHTML = ''; if (state.worldBooks.length === 0) { listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角 "+" 创建你的第一本世界书</p>'; return; } state.worldBooks.forEach(book => { const item = document.createElement('div'); item.className = 'list-item'; item.dataset.bookId = book.id; item.innerHTML = `<div class="item-title">${book.name}</div><div class="item-content">${(book.content || '暂无内容...').substring(0, 50)}</div>`; item.addEventListener('click', () => openWorldBookEditor(book.id)); addLongPressListener(item, async () => { const confirmed = await showCustomConfirm('删除世界书', `确定要删除《${book.name}》吗？此操作不可撤销。`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await db.worldBooks.delete(book.id); state.worldBooks = state.worldBooks.filter(wb => wb.id !== book.id); renderWorldBookScreen(); } }); listEl.appendChild(item); }); }
            window.renderWorldBookScreenProxy = renderWorldBookScreen;

            function renderSettingsScreen() {
                const listEl = document.getElementById('settings-list');
                listEl.innerHTML = '';

                // API设置 section
                const apiItem = document.createElement('div');
                apiItem.className = 'list-item';
                apiItem.innerHTML = `<div class="item-title">API设置</div><div class="item-content">配置API密钥和模型</div>`;
                apiItem.addEventListener('click', () => showScreen('api-settings-screen'));
                listEl.appendChild(apiItem);

                // 世界书 section
                const worldBookItem = document.createElement('div');
                worldBookItem.className = 'list-item';
                worldBookItem.innerHTML = `<div class="item-title">世界书</div><div class="item-content">管理角色设定和世界观</div>`;
                worldBookItem.addEventListener('click', () => showScreen('world-book-screen'));
                listEl.appendChild(worldBookItem);

                // 外观设置 section
                const appearanceItem = document.createElement('div');
                appearanceItem.className = 'list-item';
                appearanceItem.innerHTML = `<div class="item-title">外观设置</div><div class="item-content">壁纸、字体和挂件样式</div>`;
                appearanceItem.addEventListener('click', () => showScreen('appearance-settings-screen'));
                listEl.appendChild(appearanceItem);

                // 通用设置 section
                const generalItem = document.createElement('div');
                generalItem.className = 'list-item';
                generalItem.innerHTML = `<div class="item-title">通用设置</div><div class="item-content">应用通用配置选项</div>`;
                generalItem.addEventListener('click', () => showScreen('general-settings-screen'));
                listEl.appendChild(generalItem);

                // 备份文件 section
                const backupItem = document.createElement('div');
                backupItem.className = 'list-item';
                backupItem.innerHTML = `<div class="item-title">备份文件</div><div class="item-content">导出、导入和云端备份</div>`;
                backupItem.addEventListener('click', () => showScreen('backup-screen'));
                listEl.appendChild(backupItem);
            }
            window.renderSettingsScreenProxy = renderSettingsScreen;

            function renderGeneralSettingsScreen() {
                const listEl = document.getElementById('general-settings-list');
                listEl.innerHTML = '';

                // 照片压缩 section
                const compressionItem = document.createElement('div');
                compressionItem.className = 'list-item no-hover';
                compressionItem.style.display = 'flex';
                compressionItem.style.flexDirection = 'row';
                compressionItem.style.justifyContent = 'space-between';
                compressionItem.style.alignItems = 'center';
                compressionItem.style.cursor = 'default';

                compressionItem.innerHTML = `
                    <div>
                        <div class="item-title">照片压缩</div>
                        <div class="item-content">压缩上传的照片以节省存储空间</div>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="photo-compression-toggle" checked>
                        <span class="slider round"></span>
                    </label>
                `;

                listEl.appendChild(compressionItem);

                // Add event listener after element is created
                const toggle = document.getElementById('photo-compression-toggle');
                if (toggle) {
                    toggle.addEventListener('change', async (e) => {
                        state.globalSettings.photoCompression = e.target.checked;
                        await db.globalSettings.put(state.globalSettings);
                    });
                }


            }
            window.renderGeneralSettingsScreenProxy = renderGeneralSettingsScreen;

            // Global calendar variables
            let calendarToday = new Date();
            let currentMonth = calendarToday.getMonth();
            let currentYear = calendarToday.getFullYear();
            let selectedDate = calendarToday;

            function renderCalendarScreen() {
                // Prevent duplicate event listeners by checking if already initialized
                if (!window.calendarInitialized) {
                    window.calendarInitialized = true;

                    // Event listeners for month navigation
                    document.getElementById('prev-month-btn').addEventListener('click', () => {
                        currentMonth--;
                        if (currentMonth < 0) {
                            currentMonth = 11;
                            currentYear--;
                        }
                        updateCalendar();
                    });

                    document.getElementById('next-month-btn').addEventListener('click', () => {
                        currentMonth++;
                        if (currentMonth > 11) {
                            currentMonth = 0;
                            currentYear++;
                        }
                        updateCalendar();
                    });

                    // Event listeners for day navigation
                    document.getElementById('prev-day-btn').addEventListener('click', () => {
                        selectedDate.setDate(selectedDate.getDate() - 1);
                        updateCalendar();
                        updateSelectedDate();
                    });

                    document.getElementById('next-day-btn').addEventListener('click', () => {
                        selectedDate.setDate(selectedDate.getDate() + 1);
                        updateCalendar();
                        updateSelectedDate();
                    });

                    // Calendar add button
                    document.getElementById('calendar-add-btn').addEventListener('click', () => {
                        document.getElementById('add-memory-type-modal').classList.add('visible');
                    });
                }

                function updateCalendar() {
                    // Update month/year display
                    const monthNames = ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'];
                    document.getElementById('calendar-month-year').textContent = `${currentYear}年${monthNames[currentMonth]}`;

                    // Generate calendar grid
                    const firstDay = new Date(currentYear, currentMonth, 1);
                    const lastDay = new Date(currentYear, currentMonth + 1, 0);
                    const startDate = new Date(firstDay);
                    startDate.setDate(startDate.getDate() - firstDay.getDay());

                    const calendarGrid = document.getElementById('calendar-grid');
                    calendarGrid.innerHTML = '';

                    for (let i = 0; i < 35; i++) {
                        const date = new Date(startDate);
                        date.setDate(startDate.getDate() + i);

                        const dateElement = document.createElement('div');
                        dateElement.className = 'calendar-date';
                        dateElement.textContent = date.getDate();
                        dateElement.dataset.fullDate = date.toDateString();

                        if (date.getMonth() !== currentMonth) {
                            dateElement.classList.add('other-month');
                        }

                        if (date.toDateString() === calendarToday.toDateString()) {
                            dateElement.classList.add('today');
                        }

                        if (date.toDateString() === selectedDate.toDateString()) {
                            dateElement.classList.add('selected');
                        }

                        dateElement.addEventListener('click', () => {
                            selectedDate = new Date(date);
                            updateCalendar();
                            updateSelectedDate();
                        });

                        calendarGrid.appendChild(dateElement);
                    }

                    // Add memory indicators after calendar is built
                    addMemoryIndicators();
                }

                // Function to add memory indicators to calendar dates
                async function addMemoryIndicators() {
                    try {
                        // Get all memories
                        const allMemories = await db.memories.toArray();

                        // Group memories by date and categorize by type
                        const memoriesByDate = {};
                        allMemories.forEach(memory => {
                            let memoryDate;

                            if (memory.type === 'ai_generated') {
                                memoryDate = new Date(memory.timestamp);
                            } else if (memory.type === 'countdown' && memory.targetDate) {
                                memoryDate = new Date(memory.targetDate);
                            } else if (memory.type === 'meetup') {
                                memoryDate = new Date(memory.timestamp);
                            } else {
                                return;
                            }

                            const dateKey = memoryDate.toDateString();
                            if (!memoriesByDate[dateKey]) {
                                memoriesByDate[dateKey] = {
                                    userMemory: false,
                                    aiMemory: false,
                                    countdown: false,
                                    meetup: false
                                };
                            }

                            // Categorize memory types
                            if (memory.type === 'countdown') {
                                memoriesByDate[dateKey].countdown = true;
                            } else if (memory.type === 'meetup') {
                                memoriesByDate[dateKey].meetup = true;
                            } else if (memory.type === 'ai_generated') {
                                if (memory.chatId === 'manual') {
                                    memoriesByDate[dateKey].userMemory = true;
                                } else {
                                    memoriesByDate[dateKey].aiMemory = true;
                                }
                            }
                        });

                        // Add indicators to calendar dates
                        document.querySelectorAll('.calendar-date').forEach(dateElement => {
                            // Remove existing indicators
                            const existingIndicators = dateElement.querySelector('.memory-indicators');
                            if (existingIndicators) {
                                existingIndicators.remove();
                            }

                            // Get the actual date for this element
                            const dateKey = dateElement.dataset.fullDate;

                            // Check if this date has memories
                            if (memoriesByDate[dateKey]) {
                                const indicatorsContainer = document.createElement('div');
                                indicatorsContainer.className = 'memory-indicators';

                                // Add dots in order: blue (user), yellow (AI), purple (countdown)
                                if (memoriesByDate[dateKey].userMemory) {
                                    const dot = document.createElement('div');
                                    dot.className = 'memory-indicator user-memory';
                                    indicatorsContainer.appendChild(dot);
                                }

                                if (memoriesByDate[dateKey].aiMemory) {
                                    const dot = document.createElement('div');
                                    dot.className = 'memory-indicator ai-memory';
                                    indicatorsContainer.appendChild(dot);
                                }

                                if (memoriesByDate[dateKey].countdown) {
                                    const dot = document.createElement('div');
                                    dot.className = 'memory-indicator countdown';
                                    indicatorsContainer.appendChild(dot);
                                }

                                if (memoriesByDate[dateKey].meetup) {
                                    const dot = document.createElement('div');
                                    dot.className = 'memory-indicator meetup';
                                    indicatorsContainer.appendChild(dot);
                                }

                                dateElement.appendChild(indicatorsContainer);
                            }
                        });



                    } catch (error) {
                        console.error('Error adding memory indicators:', error);
                    }
                }

                async function updateSelectedDate() {
                    const options = { month: 'long', day: 'numeric' };
                    const dateStr = selectedDate.toLocaleDateString('zh-CN', options);
                    document.getElementById('selected-date-display').textContent = dateStr;

                    // NEW: Load and display memories for selected date
                    const memories = await getMemoriesForDate(selectedDate);
                    renderCalendarMemories(memories);
                }



                // Initialize calendar
                updateCalendar();
                updateSelectedDate();

                // Refresh status indicators to show current meetup state
                setTimeout(() => {
                    if (typeof refreshCalendarStatusIndicators === 'function') {
                        refreshCalendarStatusIndicators();
                    }
                }, 100); // Small delay to ensure DOM is updated
            }

            // NEW: Function to get memories for a specific date
            async function getMemoriesForDate(selectedDate) {
                try {
                    // Use same query as memories screen - completely safe
                    const allMemories = await db.memories.toArray();


                    // Filter memories for the selected date
                    const selectedDateStr = selectedDate.toDateString();
                    const memoriesForDate = allMemories.filter(memory => {
                        let memoryDate;

                        // For regular memories, use timestamp (creation date)
                        if (memory.type === 'ai_generated') {
                            memoryDate = new Date(memory.timestamp);
                        }
                        // For countdowns, use targetDate (appointment date)
                        else if (memory.type === 'countdown' && memory.targetDate) {
                            memoryDate = new Date(memory.targetDate);
                        }
                        // For date mode events, use targetDate if available, otherwise timestamp
                        else if (memory.type === 'meetup') {
                            // Use targetDate if it exists (for events that were originally countdowns)
                            // Otherwise use timestamp (for events that were originally meetups)
                            memoryDate = memory.targetDate ? new Date(memory.targetDate) : new Date(memory.timestamp);

                        }
                        else {
                            return false; // Skip if no valid date
                        }

                        return memoryDate.toDateString() === selectedDateStr;
                    });


                    return memoriesForDate;

                } catch (error) {
                    console.error('Error loading memories:', error);
                    return [];
                }
            }

            // NEW: Function to display memories in the events section
            function renderCalendarMemories(memories) {
                const eventsListEl = document.getElementById('calendar-events-list');

                if (memories.length === 0) {

                    eventsListEl.innerHTML = '<div class="no-events-message">没有事件</div>';
                    return;
                }

                // Sort memories by their actual date/time (most recent first)
                memories.sort((a, b) => {
                    let aTime, bTime;

                    // For memories, use timestamp (actual memory time)
                    if (a.type === 'ai_generated') {
                        aTime = a.timestamp;
                    }
                    // For countdowns, use targetDate (actual event time)
                    else if (a.type === 'countdown' && a.targetDate) {
                        aTime = a.targetDate;
                    }
                    // For date mode, use targetDate if available (for converted countdowns), otherwise timestamp
                    else if (a.type === 'meetup') {
                        aTime = a.targetDate ? a.targetDate : a.timestamp;
                    } else {
                        aTime = a.timestamp; // fallback
                    }

                    if (b.type === 'ai_generated') {
                        bTime = b.timestamp;
                    }
                    else if (b.type === 'countdown' && b.targetDate) {
                        bTime = b.targetDate;
                    }
                    else if (b.type === 'meetup') {
                        bTime = b.targetDate ? b.targetDate : b.timestamp;
                    } else {
                        bTime = b.timestamp; // fallback
                    }

                    return bTime - aTime; // Most recent first
                });

                eventsListEl.innerHTML = '';

                memories.forEach(memory => {
                    const memoryItem = document.createElement('div');
                    memoryItem.className = 'calendar-memory-item';
                    memoryItem.dataset.memoryId = memory.id;

                    // Add type-specific class for styling
                    if (memory.type === 'ai_generated') {
                        memoryItem.classList.add('memory-type');
                    } else if (memory.type === 'countdown') {
                        memoryItem.classList.add('countdown-type');
                    } else if (memory.type === 'meetup') {
                        memoryItem.classList.add('meetup-type');
                    }

                    // Format time for display
                    let timeStr = '';
                    if (memory.type === 'ai_generated') {
                        const time = new Date(memory.timestamp);
                        timeStr = time.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                    } else if (memory.type === 'countdown' && memory.targetDate) {
                        const time = new Date(memory.targetDate);
                        timeStr = time.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                    } else if (memory.type === 'meetup') {
                        // Use targetDate if available (for events that were originally countdowns)
                        // Otherwise use timestamp (for events that were originally meetups)
                        const time = memory.targetDate ? new Date(memory.targetDate) : new Date(memory.timestamp);
                        timeStr = time.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                    }

                    // Get character avatar - fix for manual memories
                    let authorAvatar = 'https://files.catbox.moe/q6z5fc.jpeg'; // default avatar
                    if (memory.chatId === 'manual') {
                        // For manually added memories, use user's avatar from 人设库
                        authorAvatar = state.qzoneSettings.avatar || 'https://files.catbox.moe/q6z5fc.jpeg';
                    } else if (state.chats[memory.chatId]) {
                        authorAvatar = state.chats[memory.chatId].settings.aiAvatar;
                    }

                    // Determine status indicator for meetup/countdown events
                    let statusIndicator = '';
                    let typeLabel = '';

                    if (memory.type === 'meetup') {
                        // Check if this is the currently active meetup
                        if (window.activeMeetupEventId === memory.id) {
                            statusIndicator = '<span class="meetup-status-indicator active">🟢 进行中</span>';
                            typeLabel = '见面';
                        } else if (hasActualMeetupHistory(memory)) {
                            statusIndicator = '<span class="meetup-indicator"><svg width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="10" width="36" height="32" rx="2" stroke="currentColor" stroke-width="4" stroke-linejoin="round"/><path d="M14 6V14" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/><path d="M34 6V14" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/><path d="M6 18H42" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="28" r="2" fill="currentColor"/><circle cx="24" cy="28" r="2" fill="currentColor"/><circle cx="32" cy="28" r="2" fill="currentColor"/><path d="M20 32C20 30 22 30 24 32C26 30 28 30 28 32" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></span>';
                            typeLabel = '见面';
                        } else {
                            // No indicator for meetup templates - absence of calendar icon indicates no history
                            statusIndicator = '';
                            typeLabel = '见面';
                        }
                    } else if (memory.type === 'countdown') {
                        // No indicator for countdown events - absence of calendar icon indicates it's a template
                        statusIndicator = '';
                        typeLabel = '约定';
                    } else {
                        typeLabel = '回忆';
                    }

                    // Create memory display using exact same structure as memories screen
                    memoryItem.innerHTML = `
                        <div class="memory-header">
                            <img class="memory-avatar" src="${authorAvatar}" alt="${memory.authorName}">
                            <div class="memory-info">
                                <div class="memory-nickname">${memory.authorName}</div>
                                <div class="memory-timestamp">${timeStr} • ${typeLabel}</div>
                            </div>
                            <div class="memory-actions">
                                ${statusIndicator}
                                <button class="post-actions-btn" onclick="showMemoryActions('${memory.id}')" style="-webkit-tap-highlight-color: transparent; -webkit-touch-callout: none; -webkit-user-select: none; border: none; background: none; font-family: inherit; font-size: 24px; font-weight: inherit;">…</button>
                            </div>
                        </div>
                        <div class="memory-content">${memory.description}</div>
                    `;



                    // Enhanced click handler for all meetup and countdown events
                    if (memory.type === 'meetup' || memory.type === 'countdown') {
                        memoryItem.style.cursor = 'pointer';
                        memoryItem.addEventListener('click', function (e) {
                            // Don't trigger if clicking on the actions button
                            if (e.target.closest('.post-actions-btn')) {
                                return;
                            }
                            handleCalendarEventClick(memory);
                        });
                    }

                    eventsListEl.appendChild(memoryItem);
                });



                // Add 8px invisible spacer at bottom - updated
                const spacer = document.createElement('div');
                spacer.style.height = '8px';
                eventsListEl.appendChild(spacer);
            }

            // Helper function to check if a memory has actual meetup history
            function hasActualMeetupHistory(memory) {
                if (memory.type !== 'meetup') return false;
                if (!memory.meetupData) return false;
                if (!memory.meetupData.messages) return false;
                return memory.meetupData.messages.length > 0;
            }

            // Make helper function globally available for calendar rendering
            window.hasActualMeetupHistory = hasActualMeetupHistory;

            // Enhanced calendar event click handler
            function handleCalendarEventClick(memory) {


                if (memory.type === 'meetup') {
                    // Scenario 1: Check if this is the currently active meetup
                    if (window.activeMeetupEventId === memory.id) {

                        // Resume active meetup - go directly to meetup screen
                        showScreen('meetup-screen');
                        return;
                    }

                    // Scenario 2: Check if it has completed history
                    if (hasActualMeetupHistory(memory)) {
                        // View completed meetup history
                        openMeetupHistory(memory.id);
                        return;
                    }
                }

                // Scenario 3: For AI-created events or events without history
                if (memory.type === 'countdown' || (memory.type === 'meetup' && !hasActualMeetupHistory(memory))) {

                    // Start new meetup with prefilled data
                    openMeetupCreationModalWithPrefill(memory);
                }
            }

            // Function to open meetup creation modal with prefilled data
            function openMeetupCreationModalWithPrefill(memory) {


                // Only proceed if we have a valid chatId (not manual events for now)
                if (!memory.chatId || memory.chatId === 'manual') {

                    // For user-created events, we'll handle this in the future
                    showCustomAlert('提示', '用户创建的事件暂不支持直接进入见面模式，请从聊天界面开始见面。');
                    return;
                }

                // Check if the chat still exists
                const chat = state.chats[memory.chatId];
                if (!chat) {
                    showCustomAlert('错误', '无法找到相关的聊天对象，可能已被删除。');
                    return;
                }

                // Check if it's a group chat (meetup mode should be for individual chats)
                if (chat.isGroup) {
                    showCustomAlert('提示', '见面模式仅支持单人聊天，不支持群聊。');
                    return;
                }

                // Set up the chat context
                window.currentDateChatContext = {
                    chatId: memory.chatId,
                    chatName: chat.name || '聊天对象',
                    aiName: chat.name || 'AI',
                    isGroup: chat.isGroup || false,
                    originalMemoryId: memory.id // Store the original memory ID
                };



                // Prefill the modal with event data
                document.getElementById('meetup-location-input').value = '';
                document.getElementById('meetup-title-input').value = memory.description || '';

                // Show the modal
                const modal = document.getElementById('meetup-creation-modal');
                modal.classList.add('visible');
            }

            // Function to refresh calendar status indicators (useful when meetup status changes)
            function refreshCalendarStatusIndicators() {
                const calendarItems = document.querySelectorAll('.calendar-memory-item');
                calendarItems.forEach(item => {
                    const memoryId = item.dataset.memoryId;
                    if (memoryId && window.activeMeetupEventId === parseInt(memoryId)) {
                        // Update to show active status
                        const statusIndicator = item.querySelector('.meetup-status-indicator');
                        if (statusIndicator && !statusIndicator.classList.contains('active')) {
                            statusIndicator.textContent = '🟢 进行中';
                            statusIndicator.className = 'meetup-status-indicator active';
                        }
                    }
                });
            }

            window.renderCalendarScreenProxy = renderCalendarScreen;
            window.showMemoryActions = showMemoryActions;
            window.handleCalendarEventClick = handleCalendarEventClick;
            window.hasActualMeetupHistory = hasActualMeetupHistory;
            window.refreshCalendarStatusIndicators = refreshCalendarStatusIndicators;
            window.openMeetupCreationModalWithPrefill = openMeetupCreationModalWithPrefill;



            function openWorldBookEditor(bookId) { editingWorldBookId = bookId; const book = state.worldBooks.find(wb => wb.id === bookId); if (!book) return; document.getElementById('world-book-editor-title').textContent = book.name; document.getElementById('world-book-name-input').value = book.name; document.getElementById('world-book-content-input').value = book.content; showScreen('world-book-editor-screen'); }

            function renderStickerPanel() { const grid = document.getElementById('sticker-grid'); grid.innerHTML = ''; if (state.userStickers.length === 0) { grid.innerHTML = '<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1;">大人请点击右上角“添加”或“上传”来添加你的第一个表情吧！</p>'; return; } state.userStickers.forEach(sticker => { const item = document.createElement('div'); item.className = 'sticker-item'; item.style.backgroundImage = `url(${sticker.url})`; item.title = sticker.name; item.addEventListener('click', () => sendSticker(sticker)); addLongPressListener(item, () => { const existingDeleteBtn = item.querySelector('.delete-btn'); if (existingDeleteBtn) return; const deleteBtn = document.createElement('div'); deleteBtn.className = 'delete-btn'; deleteBtn.innerHTML = '&times;'; deleteBtn.onclick = async (e) => { e.stopPropagation(); const confirmed = await showCustomConfirm('删除表情', `确定要删除表情 "${sticker.name}" 吗？`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await db.userStickers.delete(sticker.id); state.userStickers = state.userStickers.filter(s => s.id !== sticker.id); renderStickerPanel(); } }; item.appendChild(deleteBtn); deleteBtn.style.display = 'block'; setTimeout(() => item.addEventListener('mouseleave', () => deleteBtn.remove(), { once: true }), 3000); }); grid.appendChild(item); }); }

            // Global variable to track current sticker pack
            let currentStickerPack = 'all';

            // Storage for sticker pack data
            let stickerPackData = {
                'all': {
                    name: '全部表情',
                    icon: ''
                },
                'pack1': {
                    name: '表情包 2',
                    icon: 'https://files.catbox.moe/r1khrr.gif'
                }
            };

            // Store the original renderStickerPanel function
            const originalRenderStickerPanel = renderStickerPanel;

            // Override renderStickerPanel with pack filtering
            function renderStickerPanel() {
                const grid = document.getElementById('sticker-grid');
                grid.innerHTML = '';

                // Always add the "add sticker" square as the first item
                const addSquare = document.createElement('div');
                addSquare.className = 'add-sticker-square';
                addSquare.innerHTML = `
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="12" y1="5" x2="12" y2="19"></line>
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                `;
                addSquare.addEventListener('click', () => {
                    // Hide the sticker panel first
                    document.getElementById('sticker-panel').classList.remove('visible');

                    // Use the preset-actions-modal for consistency
                    const actionsModal = document.getElementById('preset-actions-modal');
                    const modalContent = actionsModal.querySelector('.custom-modal-footer');

                    // Populate modal with add sticker options
                    modalContent.innerHTML = `
                        <button data-action="add-url">添加 (URL)</button>
                        <button data-action="upload">上传文件</button>
                        <button data-action="cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
                    `;

                    // Show modal
                    actionsModal.classList.add('visible');

                    // Handle button clicks
                    const handleActionClick = async (e) => {
                        const action = e.target.dataset.action;
                        if (!action) return;

                        actionsModal.classList.remove('visible');
                        modalContent.removeEventListener('click', handleActionClick);

                        switch (action) {
                            case 'add-url':
                                // URL option
                                const url = await showCustomPrompt("添加表情(URL)", "请输入表情包的图片URL");
                                if (!url || !url.trim().startsWith('http')) {
                                    if (url) alert("请输入有效的URL (以http开头)");
                                    document.getElementById('sticker-panel').classList.add('visible');
                                    return;
                                }
                                const name = await showCustomPrompt("命名表情", "请为这个表情命名 (例如：开心、疑惑)");
                                if (name && name.trim()) {
                                    const newSticker = {
                                        id: 'sticker_' + Date.now(),
                                        url: url.trim(),
                                        name: name.trim(),
                                        order: state.userStickers.length,
                                        packId: currentStickerPack
                                    };
                                    await db.userStickers.add(newSticker);
                                    state.userStickers.push(newSticker);
                                    // Show sticker panel again and refresh
                                    document.getElementById('sticker-panel').classList.add('visible');
                                    renderStickerPanel();
                                } else if (name !== null) {
                                    alert("表情名不能为空！");
                                    document.getElementById('sticker-panel').classList.add('visible');
                                } else {
                                    // User cancelled naming, show panel again
                                    document.getElementById('sticker-panel').classList.add('visible');
                                }
                                break;
                            case 'upload':
                                // Upload option
                                document.getElementById('sticker-upload-input').click();
                                break;
                            case 'cancel':
                                // Just show sticker panel again
                                document.getElementById('sticker-panel').classList.add('visible');
                                break;
                        }
                    };

                    modalContent.addEventListener('click', handleActionClick);
                });
                grid.appendChild(addSquare);

                // Filter stickers based on current pack
                let stickersToShow = state.userStickers.filter(sticker => sticker.packId === currentStickerPack);

                // Add message if no stickers (but still show the add square)
                if (stickersToShow.length === 0) {
                    const message = document.createElement('p');
                    message.style.cssText = 'text-align:center; color: var(--text-secondary); grid-column: 1 / -1; margin-top: 20px;';
                    message.textContent = '这个表情包还没有表情，点击 + 来添加';
                    grid.appendChild(message);
                    return;
                }

                stickersToShow.forEach(sticker => {
                    const item = document.createElement('div');
                    item.className = 'sticker-item';
                    item.style.backgroundImage = `url(${sticker.url})`;
                    item.title = sticker.name;

                    if (isArrangeMode) {
                        // In arrange mode: add delete button and touch-based drag functionality
                        item.style.position = 'relative';
                        item.style.cursor = 'move'; // Show move cursor to indicate draggable

                        // Add red delete button
                        const deleteBtn = document.createElement('div');
                        deleteBtn.className = 'arrange-delete-btn';
                        deleteBtn.innerHTML = '×';
                        deleteBtn.style.cssText = `
                            position: absolute;
                            top: -8px;
                            right: -8px;
                            width: 20px;
                            height: 20px;
                            background: #ff3b30;
                            color: white;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 14px;
                            font-weight: bold;
                            cursor: pointer;
                            z-index: 10;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                        `;

                        deleteBtn.onclick = async (e) => {
                            e.stopPropagation();
                            const confirmed = await showCustomConfirm('删除表情', `确定要删除表情 "${sticker.name}" 吗？`, { confirmButtonClass: 'btn-danger' });
                            if (confirmed) {
                                await db.userStickers.delete(sticker.id);
                                state.userStickers = state.userStickers.filter(s => s.id !== sticker.id);
                                renderStickerPanel();
                            }
                        };

                        item.appendChild(deleteBtn);

                        // Add touch-based drag functionality for mobile
                        let dragState = {
                            isDragging: false,
                            draggedElement: null,
                            draggedId: null,
                            startX: 0,
                            startY: 0,
                            currentX: 0,
                            currentY: 0
                        };

                        item.addEventListener('touchstart', (e) => {
                            const touch = e.touches[0];
                            dragState.startX = touch.clientX;
                            dragState.startY = touch.clientY;
                            dragState.draggedElement = item;
                            dragState.draggedId = sticker.id;

                            // Start drag after a short delay to distinguish from tap
                            setTimeout(() => {
                                if (dragState.draggedElement === item) {
                                    dragState.isDragging = true;
                                    item.style.opacity = '0.5';
                                    item.style.transform = 'scale(1.1)';
                                    item.style.zIndex = '1000';
                                    item.style.pointerEvents = 'none';
                                }
                            }, 150);
                        }, { passive: false });

                        item.addEventListener('touchmove', (e) => {
                            if (!dragState.isDragging || dragState.draggedElement !== item) return;

                            e.preventDefault();
                            const touch = e.touches[0];
                            dragState.currentX = touch.clientX;
                            dragState.currentY = touch.clientY;

                            // Move the dragged item
                            const deltaX = dragState.currentX - dragState.startX;
                            const deltaY = dragState.currentY - dragState.startY;
                            item.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(1.1)`;

                            // Find element under touch point
                            const elementBelow = document.elementFromPoint(dragState.currentX, dragState.currentY);
                            const targetSticker = elementBelow?.closest('.sticker-item');

                            // Reset all sticker highlights
                            document.querySelectorAll('.sticker-item').forEach(s => {
                                if (s !== item) {
                                    s.style.boxShadow = '';
                                    s.style.transform = '';
                                }
                            });

                            // Highlight drop target
                            if (targetSticker && targetSticker !== item) {
                                targetSticker.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
                                targetSticker.style.transform = 'scale(1.05)';
                            }
                        }, { passive: false });

                        item.addEventListener('touchend', async (e) => {
                            if (!dragState.isDragging || dragState.draggedElement !== item) {
                                dragState = { isDragging: false, draggedElement: null, draggedId: null, startX: 0, startY: 0, currentX: 0, currentY: 0 };
                                return;
                            }

                            // Find element under touch point
                            const elementBelow = document.elementFromPoint(dragState.currentX, dragState.currentY);
                            const targetSticker = elementBelow?.closest('.sticker-item');

                            // Reset dragged item appearance
                            item.style.opacity = '1';
                            item.style.transform = '';
                            item.style.zIndex = '';
                            item.style.pointerEvents = '';

                            // Reset all highlights
                            document.querySelectorAll('.sticker-item').forEach(s => {
                                s.style.boxShadow = '';
                                s.style.transform = '';
                            });

                            // Perform reorder if dropped on another sticker
                            if (targetSticker && targetSticker !== item) {
                                const targetId = targetSticker.style.backgroundImage.match(/url\("([^"]+)"\)/)?.[1];
                                const targetStickerData = state.userStickers.find(s => s.url === targetId);

                                if (targetStickerData) {
                                    const draggedIndex = state.userStickers.findIndex(s => s.id === dragState.draggedId);
                                    const targetIndex = state.userStickers.findIndex(s => s.id === targetStickerData.id);

                                    if (draggedIndex !== -1 && targetIndex !== -1) {
                                        // Remove dragged sticker from its current position
                                        const [draggedSticker] = state.userStickers.splice(draggedIndex, 1);

                                        // Insert it at the target position
                                        state.userStickers.splice(targetIndex, 0, draggedSticker);

                                        // Update database with order information
                                        await db.userStickers.clear();
                                        for (let i = 0; i < state.userStickers.length; i++) {
                                            const stickerItem = { ...state.userStickers[i], order: i };
                                            await db.userStickers.add(stickerItem);
                                        }

                                        // Re-render to show new order
                                        renderStickerPanel();
                                    }
                                }
                            }

                            // Reset drag state
                            dragState = { isDragging: false, draggedElement: null, draggedId: null, startX: 0, startY: 0, currentX: 0, currentY: 0 };
                        }, { passive: false });
                    } else {
                        // Normal mode: click to send, long press for options
                        item.addEventListener('click', () => sendSticker(sticker));
                        addLongPressListener(item, () => {
                            if (isSelectionMode) return;
                            showStickerOptionsModal(sticker);
                        });
                    }

                    grid.appendChild(item);
                });
            }

            function initializeStickerPackTabs() {
                const tabsContainer = document.getElementById('sticker-pack-tabs');
                if (!tabsContainer) return;

                // Get saved order or use default order
                const savedOrder = state.globalSettings?.stickerPackOrder || Object.keys(stickerPackData);
                
                // Get all existing tabs with data-pack attribute (excluding add button)
                const existingTabs = Array.from(tabsContainer.querySelectorAll('.sticker-pack-tab[data-pack]'));
                
                // Reorder existing tabs according to saved order
                savedOrder.forEach(packId => {
                    const existingTab = existingTabs.find(tab => tab.dataset.pack === packId);
                    if (existingTab) {
                        // Move tab to end (which will be in the correct order)
                        tabsContainer.appendChild(existingTab);
                        
                        // Update tab icon if needed
                        if (stickerPackData[packId] && stickerPackData[packId].icon) {
                            updateStickerPackTabIcon(packId, stickerPackData[packId].icon);
                        }
                    } else if (stickerPackData[packId]) {
                        // Create new tab for packs that don't exist in DOM yet
                        const packData = stickerPackData[packId];
                        const newTab = document.createElement('div');
                        newTab.className = 'sticker-pack-tab';
                        newTab.setAttribute('data-pack', packId);

                        const packIcon = document.createElement('div');
                        packIcon.className = 'pack-icon';

                        if (packData.icon && packData.icon.trim()) {
                            packIcon.innerHTML = `<img src="${packData.icon}" alt="${packId}">`;
                        } else {
                            // Use default empty icon
                            packIcon.innerHTML = `
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                    xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2"
                                    stroke-linecap="round" stroke-linejoin="round">
                                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                </svg>
                            `;
                        }

                        newTab.appendChild(packIcon);
                        tabsContainer.appendChild(newTab);
                    }
                });
                
                // Add any remaining tabs that weren't in the saved order
                existingTabs.forEach(tab => {
                    const packId = tab.dataset.pack;
                    if (!savedOrder.includes(packId)) {
                        tabsContainer.appendChild(tab);
                    }
                });

                // Add click event listeners to pack tabs
                tabsContainer.addEventListener('click', (e) => {
                    const tab = e.target.closest('.sticker-pack-tab');
                    if (!tab) return;

                    // Skip if it's the add pack button or in arrange mode
                    if (tab.id === 'add-pack-btn' || isPackArrangeMode) return;

                    const packId = tab.dataset.pack;
                    if (packId) {
                        switchStickerPack(packId);
                    }
                });

                // Add long press listeners to pack tabs for arrange mode
                document.querySelectorAll('.sticker-pack-tab[data-pack]').forEach(tab => {
                    addLongPressListener(tab, () => {
                        if (!isPackArrangeMode) {
                            enterPackArrangeMode();
                        }
                    });
                });

                // Set active tab based on currentStickerPack
                document.querySelectorAll('.sticker-pack-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                const activeTab = document.querySelector(`[data-pack="${currentStickerPack}"]`);
                if (activeTab) {
                    activeTab.classList.add('active');
                }
            }

            function switchStickerPack(packId) {
                currentStickerPack = packId;

                // Update active tab
                document.querySelectorAll('.sticker-pack-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                document.querySelector(`[data-pack="${packId}"]`).classList.add('active');

                // Re-render sticker grid
                renderStickerPanel();
            }

            // ▼▼▼ Sticker Pack Edit Modal Functions ▼▼▼
            function openStickerPackEditModal() {
                // Get current pack data from storage
                const packData = stickerPackData[currentStickerPack] || { name: '', icon: '' };

                // Populate modal fields
                document.getElementById('sticker-pack-name-input').value = packData.name;
                document.getElementById('sticker-pack-icon-input').value = packData.icon;

                // Show/hide delete button based on pack type
                const deleteBtn = document.getElementById('delete-sticker-pack-btn');
                if (currentStickerPack === 'all' || currentStickerPack === 'pack1') {
                    deleteBtn.style.display = 'none';
                } else {
                    deleteBtn.style.display = 'block';
                }

                // Show modal
                document.getElementById('sticker-pack-edit-modal').classList.add('visible');

                // Focus on first input field
                document.getElementById('sticker-pack-name-input').focus();
            }

            function closeStickerPackEditModal() {
                document.getElementById('sticker-pack-edit-modal').classList.remove('visible');
            }

            async function saveStickerPackEdit() {
                const name = document.getElementById('sticker-pack-name-input').value.trim();
                const iconUrl = document.getElementById('sticker-pack-icon-input').value.trim();

                if (!name) {
                    alert('请输入表情包名称');
                    return;
                }

                // Save data to storage
                if (!stickerPackData[currentStickerPack]) {
                    stickerPackData[currentStickerPack] = {};
                }
                stickerPackData[currentStickerPack].name = name;
                stickerPackData[currentStickerPack].icon = iconUrl;

                // Save to database via globalSettings
                if (!state.globalSettings.stickerPackData) {
                    state.globalSettings.stickerPackData = {};
                }
                state.globalSettings.stickerPackData = { ...stickerPackData };

                try {
                    await db.globalSettings.put(state.globalSettings);
                } catch (error) {
                    console.error('Failed to save sticker pack data:', error);
                }

                // Update the tab icon
                updateStickerPackTabIcon(currentStickerPack, iconUrl);

                // Close modal without alert
                closeStickerPackEditModal();
            }

            function updateStickerPackTabIcon(packId, iconUrl) {
                const tab = document.querySelector(`[data-pack="${packId}"]`);
                if (!tab) return;

                const packIcon = tab.querySelector('.pack-icon');
                if (!packIcon) return;

                if (iconUrl && iconUrl.trim()) {
                    // Replace with image
                    packIcon.innerHTML = `<img src="${iconUrl}" alt="${packId}">`;
                } else {
                    // Use default SVG for 'all' pack, or empty for others
                    if (packId === 'all') {
                        packIcon.innerHTML = `
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2"
                                stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="10" />
                                <path d="M8 14s1.5 2 4 2 4-2 4-2" />
                                <line x1="9" y1="9" x2="9.01" y2="9" />
                                <line x1="15" y1="9" x2="15.01" y2="9" />
                            </svg>
                        `;
                    } else {
                        packIcon.innerHTML = `<div style="width: 24px; height: 24px; background: #ccc; border-radius: 4px;"></div>`;
                    }
                }
            }

            async function deleteStickerPack() {
                // Prevent deleting the 'all' pack
                if (currentStickerPack === 'all') {
                    alert('无法删除默认表情包');
                    return;
                }

                const confirmed = await showCustomConfirm('删除表情包', `确定要删除表情包吗？包内的所有表情也会被删除。`, { confirmButtonClass: 'btn-danger' });
                if (!confirmed) return;

                // Remove all stickers from this pack
                const stickersToDelete = state.userStickers.filter(sticker => sticker.packId === currentStickerPack);
                for (const sticker of stickersToDelete) {
                    await db.userStickers.delete(sticker.id);
                }
                state.userStickers = state.userStickers.filter(sticker => sticker.packId !== currentStickerPack);

                // Remove pack data from storage
                delete stickerPackData[currentStickerPack];
                if (state.globalSettings.stickerPackData) {
                    delete state.globalSettings.stickerPackData[currentStickerPack];
                    try {
                        await db.globalSettings.put(state.globalSettings);
                    } catch (error) {
                        console.error('Failed to save sticker pack data:', error);
                    }
                }

                // Remove tab from DOM
                const tab = document.querySelector(`[data-pack="${currentStickerPack}"]`);
                if (tab) {
                    tab.remove();
                }

                // Switch to 'all' pack
                switchStickerPack('all');

                // Close modal
                closeStickerPackEditModal();
            }
            // ▲▲▲ Sticker Pack Edit Modal Functions End ▲▲▲

            // ▼▼▼ New Sticker Pack Modal Functions ▼▼▼
            function openNewStickerPackModal() {
                // Clear modal fields
                document.getElementById('new-pack-name-input').value = '';
                document.getElementById('new-pack-icon-input').value = '';

                // Show modal
                document.getElementById('new-sticker-pack-modal').classList.add('visible');

                // Focus on first input field
                document.getElementById('new-pack-name-input').focus();
            }

            function closeNewStickerPackModal() {
                document.getElementById('new-sticker-pack-modal').classList.remove('visible');
            }

            async function createNewStickerPack() {
                const name = document.getElementById('new-pack-name-input').value.trim();
                const iconUrl = document.getElementById('new-pack-icon-input').value.trim();

                if (!name) {
                    alert('请输入表情包名称');
                    return;
                }

                // Find next available pack ID
                let nextPackId = 'pack1';
                let packNumber = 1;
                while (document.querySelector(`[data-pack="${nextPackId}"]`)) {
                    packNumber++;
                    nextPackId = `pack${packNumber}`;
                }

                // Save data to storage
                if (!stickerPackData[nextPackId]) {
                    stickerPackData[nextPackId] = {};
                }
                stickerPackData[nextPackId].name = name;
                stickerPackData[nextPackId].icon = iconUrl;

                // Save to database via globalSettings
                if (!state.globalSettings.stickerPackData) {
                    state.globalSettings.stickerPackData = {};
                }
                state.globalSettings.stickerPackData = { ...stickerPackData };

                try {
                    await db.globalSettings.put(state.globalSettings);
                } catch (error) {
                    console.error('Failed to save sticker pack data:', error);
                }

                // Create new tab in DOM
                const tabsContainer = document.getElementById('sticker-pack-tabs');

                const newTab = document.createElement('div');
                newTab.className = 'sticker-pack-tab';
                newTab.setAttribute('data-pack', nextPackId);

                const packIcon = document.createElement('div');
                packIcon.className = 'pack-icon';

                if (iconUrl && iconUrl.trim()) {
                    packIcon.innerHTML = `<img src="${iconUrl}" alt="${nextPackId}">`;
                } else {
                    // Use default empty icon
                    packIcon.innerHTML = `
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                            xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2"
                            stroke-linecap="round" stroke-linejoin="round">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                        </svg>
                    `;
                }

                newTab.appendChild(packIcon);
                tabsContainer.appendChild(newTab);

                // Switch to the new pack
                switchStickerPack(nextPackId);

                // Close modal
                closeNewStickerPackModal();
            }
            // ▲▲▲ New Sticker Pack Modal Functions End ▲▲▲

            // ▼▼▼ Sticker Options Modal Functions ▼▼▼
            let isArrangeMode = false;
            let selectedStickerForMove = null;
            let isPackArrangeMode = false;

            function showStickerOptionsModal(sticker) {
                // Hide the sticker panel first
                document.getElementById('sticker-panel').classList.remove('visible');

                // Use the preset-actions-modal for consistency
                const actionsModal = document.getElementById('preset-actions-modal');
                const modalContent = actionsModal.querySelector('.custom-modal-footer');

                // Populate modal with sticker options (removed delete button)
                modalContent.innerHTML = `
                    <button data-action="move-to-pack">移动到表情包</button>
                    <button data-action="arrange">整理表情</button>
                    <button data-action="cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
                `;

                // Show modal
                actionsModal.classList.add('visible');

                // Handle button clicks
                const handleActionClick = async (e) => {
                    const action = e.target.dataset.action;
                    if (!action) return;

                    actionsModal.classList.remove('visible');
                    modalContent.removeEventListener('click', handleActionClick);

                    switch (action) {
                        case 'move-to-pack':
                            // Show sticker pack selection modal
                            selectedStickerForMove = sticker;
                            showMoveStickerModal();
                            break;
                        case 'arrange':
                            // Enter arrange mode and show sticker panel
                            enterArrangeMode();
                            break;
                        case 'cancel':
                            // Just show sticker panel again
                            document.getElementById('sticker-panel').classList.add('visible');
                            break;
                    }
                };

                modalContent.addEventListener('click', handleActionClick);
            }

            function enterArrangeMode() {
                isArrangeMode = true;

                // Update header to show arrange mode
                const header = document.getElementById('sticker-panel-header');
                const title = header.querySelector('.title');
                const editBtn = header.querySelector('#edit-sticker-pack-btn');
                const cancelBtn = header.querySelector('#close-sticker-panel-btn');

                title.textContent = '整理表情';
                editBtn.textContent = '完成';
                editBtn.onclick = exitArrangeMode;

                // Update cancel button to exit arrange mode without saving
                cancelBtn.onclick = () => {
                    exitArrangeMode();
                };

                // Show sticker panel and re-render with arrange mode
                document.getElementById('sticker-panel').classList.add('visible');
                renderStickerPanel();
            }

            function exitArrangeMode() {
                isArrangeMode = false;

                // Restore header
                const header = document.getElementById('sticker-panel-header');
                const title = header.querySelector('.title');
                const editBtn = header.querySelector('#edit-sticker-pack-btn');
                const cancelBtn = header.querySelector('#close-sticker-panel-btn');

                title.textContent = '我的表情';
                editBtn.textContent = '编辑';
                editBtn.onclick = openStickerPackEditModal;

                // Restore cancel button to close panel
                cancelBtn.onclick = () => {
                    document.getElementById('sticker-panel').classList.remove('visible');
                };

                // Re-render without arrange mode
                renderStickerPanel();
            }

            // ▼▼▼ Move Sticker to Pack Functions ▼▼▼
            function showMoveStickerModal() {
                // Get all available sticker packs from existing tabs (excluding "all")
                const availablePacks = [];
                const packTabs = document.querySelectorAll('.sticker-pack-tab[data-pack]');

                packTabs.forEach(tab => {
                    const packId = tab.dataset.pack;
                    if (packId !== 'all') {
                        const packName = stickerPackData[packId]?.name || `表情包${packId.replace('pack', '')}`;
                        availablePacks.push({
                            id: packId,
                            name: packName
                        });
                    }
                });

                // Generate pack list HTML (radio buttons)
                const packListHtml = availablePacks.map(pack => `
                    <div class="pack-selection-item" onclick="selectPackForMove('${pack.id}')">
                        <input type="radio" name="pack-selection" id="pack-${pack.id}" data-pack-id="${pack.id}">
                        <div class="pack-selection-info">
                            <div class="pack-selection-name">${pack.name}</div>
                        </div>
                    </div>
                `).join('');

                document.getElementById('sticker-pack-selection-list').innerHTML = packListHtml;
                document.getElementById('move-sticker-modal').classList.add('visible');
            }

            function hideMoveStickerModal() {
                document.getElementById('move-sticker-modal').classList.remove('visible');
                selectedStickerForMove = null;
            }

            function selectPackForMove(packId) {
                // Update radio button selection
                const radioButton = document.getElementById(`pack-${packId}`);
                if (radioButton) {
                    radioButton.checked = true;
                }
            }

            async function confirmMoveSticker() {
                const selectedRadio = document.querySelector('input[name="pack-selection"]:checked');
                if (!selectedRadio) {
                    alert('请选择一个表情包');
                    return;
                }

                const targetPackId = selectedRadio.dataset.packId;

                if (!selectedStickerForMove) {
                    alert('未选择表情');
                    return;
                }

                // Update sticker's pack assignment
                const stickerIndex = state.userStickers.findIndex(s => s.id === selectedStickerForMove.id);
                if (stickerIndex !== -1) {
                    state.userStickers[stickerIndex].packId = targetPackId;

                    // Update database
                    await db.userStickers.put(state.userStickers[stickerIndex]);

                    // Hide modal and refresh sticker panel
                    hideMoveStickerModal();
                    document.getElementById('sticker-panel').classList.add('visible');
                    renderStickerPanel();
                }
            }
            // ▲▲▲ Move Sticker to Pack Functions End ▲▲▲

            // ▼▼▼ Pack Arrange Mode Functions ▼▼▼
            // Variables declared above: isPackArrangeMode, currentStickerPack, stickerPackData

            function enterPackArrangeMode() {
                isPackArrangeMode = true;

                // Update header to show pack arrange mode
                const header = document.getElementById('sticker-panel-header');
                if (header) {
                    header.innerHTML = `
                        <span class="panel-btn" id="close-sticker-panel-btn">取消</span>
                        <span class="title">整理表情包</span>
                        <span class="panel-btn" id="exit-pack-arrange-btn">完成</span>
                    `;

                    // Add exit arrange mode listener
                    document.getElementById('exit-pack-arrange-btn').addEventListener('click', exitPackArrangeMode);
                    document.getElementById('close-sticker-panel-btn').addEventListener('click', exitPackArrangeMode);
                }

                // Add drag functionality to pack tabs
                addPackDragFunctionality();

                // Add visual indication that tabs are draggable
                document.querySelectorAll('.sticker-pack-tab[data-pack]').forEach(tab => {
                    if (tab.id !== 'add-pack-btn') {
                        tab.style.cursor = 'move';
                        tab.style.transition = 'all 0.2s ease';
                    }
                });
            }

            function exitPackArrangeMode() {
                isPackArrangeMode = false;

                // Save the new pack order before exiting
                saveStickerPackOrder();

                // Restore header
                const header = document.getElementById('sticker-panel-header');
                if (header) {
                    header.innerHTML = `
                        <span class="panel-btn" id="close-sticker-panel-btn">取消</span>
                        <span class="title">我的表情</span>
                        <span class="panel-btn" id="edit-sticker-pack-btn">编辑</span>
                    `;

                    // Re-add event listeners for header buttons
                    setupStickerPanelEventListeners();
                }

                // Remove drag functionality and visual indicators
                removePackDragFunctionality();

                // Reset tab styling
                document.querySelectorAll('.sticker-pack-tab[data-pack]').forEach(tab => {
                    tab.style.cursor = '';
                    tab.style.transition = '';
                });

                // Remove drag functionality from pack tabs
                removePackDragFunctionality();
            }

            function setupStickerPanelEventListeners() {
                // Close sticker panel button
                const closeBtn = document.getElementById('close-sticker-panel-btn');
                if (closeBtn) {
                    closeBtn.addEventListener('click', () => {
                        document.getElementById('sticker-panel').classList.remove('visible');
                    });
                }

                // Edit sticker pack button
                const editPackBtn = document.getElementById('edit-sticker-pack-btn');
                if (editPackBtn) {
                    editPackBtn.addEventListener('click', () => {
                        // Open sticker pack edit modal or functionality
                        console.log('Edit sticker pack clicked');
                    });
                }
            }

            function addPackDragFunctionality() {
                const tabs = document.querySelectorAll('.sticker-pack-tab[data-pack]');

                tabs.forEach(tab => {
                    // Skip the add button
                    if (tab.id === 'add-pack-btn') return;

                    // Remove existing event listeners to avoid conflicts
                    const newTab = tab.cloneNode(true);
                    tab.parentNode.replaceChild(newTab, tab);
                    
                    let dragState = {
                        isDragging: false,
                        draggedElement: null,
                        startX: 0,
                        startY: 0,
                        currentX: 0,
                        currentY: 0
                    };

                    newTab.addEventListener('touchstart', (e) => {
                        if (!isPackArrangeMode) return;

                        const touch = e.touches[0];
                        dragState.startX = touch.clientX;
                        dragState.startY = touch.clientY;
                        dragState.draggedElement = newTab;

                        // Start drag after a short delay to distinguish from tap
                        setTimeout(() => {
                            if (dragState.draggedElement === newTab) {
                                dragState.isDragging = true;
                                newTab.style.opacity = '0.5';
                                newTab.style.transform = 'scale(1.1)';
                                newTab.style.zIndex = '1000';
                                newTab.style.pointerEvents = 'none';
                            }
                        }, 150);
                    }, { passive: false });

                    newTab.addEventListener('touchmove', (e) => {
                        if (!dragState.isDragging || dragState.draggedElement !== newTab) return;

                        e.preventDefault();
                        const touch = e.touches[0];
                        dragState.currentX = touch.clientX;
                        dragState.currentY = touch.clientY;

                        // Move the dragged tab
                        const deltaX = dragState.currentX - dragState.startX;
                        const deltaY = dragState.currentY - dragState.startY;
                        newTab.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(1.1)`;

                        // Find element under touch point
                        const elementBelow = document.elementFromPoint(dragState.currentX, dragState.currentY);
                        const targetTab = elementBelow?.closest('.sticker-pack-tab[data-pack]');

                        // Reset all tab highlights
                        document.querySelectorAll('.sticker-pack-tab[data-pack]').forEach(t => {
                            if (t !== newTab) {
                                t.style.boxShadow = '';
                                t.style.transform = '';
                            }
                        });

                        // Highlight drop target
                        if (targetTab && targetTab !== newTab && targetTab.id !== 'add-pack-btn') {
                            targetTab.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
                            targetTab.style.transform = 'scale(1.05)';
                        }
                    }, { passive: false });

                    newTab.addEventListener('touchend', (e) => {
                        if (!dragState.isDragging || dragState.draggedElement !== newTab) {
                            dragState = { isDragging: false, draggedElement: null, startX: 0, startY: 0, currentX: 0, currentY: 0 };
                            return;
                        }

                        // Find element under touch point
                        const elementBelow = document.elementFromPoint(dragState.currentX, dragState.currentY);
                        const targetTab = elementBelow?.closest('.sticker-pack-tab[data-pack]');

                        // Reset dragged tab appearance
                        newTab.style.opacity = '1';
                        newTab.style.transform = '';
                        newTab.style.zIndex = '';
                        newTab.style.pointerEvents = '';

                        // Reset all highlights
                        document.querySelectorAll('.sticker-pack-tab[data-pack]').forEach(t => {
                            t.style.boxShadow = '';
                            t.style.transform = '';
                        });

                        // Perform reorder if dropped on another tab
                        if (targetTab && targetTab !== newTab && targetTab.id !== 'add-pack-btn') {
                            reorderPackTabs(newTab, targetTab);
                        }

                        // Reset drag state
                        dragState = { isDragging: false, draggedElement: null, startX: 0, startY: 0, currentX: 0, currentY: 0 };
                    }, { passive: false });
                });
            }

            function removePackDragFunctionality() {
                const tabs = document.querySelectorAll('.sticker-pack-tab[data-pack]');
                tabs.forEach(tab => {
                    // Reset any drag-related styles
                    tab.style.zIndex = '';
                    tab.style.opacity = '';
                    tab.style.transform = '';
                    tab.style.boxShadow = '';
                });
            }

            function reorderPackTabs(draggedTab, targetTab) {
                const draggedPackId = draggedTab.dataset.pack;
                const targetPackId = targetTab.dataset.pack;

                if (!draggedPackId || !targetPackId || draggedPackId === targetPackId) return;

                console.log(`Reordering pack ${draggedPackId} to position of ${targetPackId}`);

                // Get the parent container
                const parent = draggedTab.parentNode;
                if (!parent) return;

                // Remove dragged element from its current position
                const draggedElement = draggedTab;
                draggedElement.remove();

                // Insert it at the target position
                parent.insertBefore(draggedElement, targetTab);

                console.log(`Successfully moved pack ${draggedPackId} before ${targetPackId}`);

                // Save the new order to state/database if needed
                saveStickerPackOrder();
            }

            function saveStickerPackOrder() {
                // Get current order of pack tabs
                const tabs = document.querySelectorAll('.sticker-pack-tab[data-pack]');
                const newOrder = Array.from(tabs).map(tab => tab.dataset.pack).filter(pack => pack);

                console.log('New pack order:', newOrder);

                // Save to state and database
                if (state.globalSettings) {
                    state.globalSettings.stickerPackOrder = newOrder;
                    db.globalSettings.put(state.globalSettings);
                }
            }

            function addLongPressListener(element, callback) {
                let longPressTimer;
                let startX, startY;
                const longPressDelay = 500; // 500ms for long press
                const moveThreshold = 10; // pixels

                element.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    startX = touch.clientX;
                    startY = touch.clientY;

                    longPressTimer = setTimeout(() => {
                        callback();
                    }, longPressDelay);
                });

                element.addEventListener('touchmove', (e) => {
                    const touch = e.touches[0];
                    const deltaX = Math.abs(touch.clientX - startX);
                    const deltaY = Math.abs(touch.clientY - startY);

                    if (deltaX > moveThreshold || deltaY > moveThreshold) {
                        clearTimeout(longPressTimer);
                    }
                });

                element.addEventListener('touchend', () => {
                    clearTimeout(longPressTimer);
                });

                element.addEventListener('touchcancel', () => {
                    clearTimeout(longPressTimer);
                });
            }

            // Initialize long press listeners for existing sticker pack tabs
            function initializeStickerPackLongPress() {
                document.querySelectorAll('.sticker-pack-tab[data-pack]').forEach(tab => {
                    // Skip the add button
                    if (tab.id === 'add-pack-btn') return;

                    addLongPressListener(tab, () => {
                        if (!isPackArrangeMode) {
                            enterPackArrangeMode();
                        }
                    });
                });
            }

            // Call initialization when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initializeStickerPackLongPress);
            } else {
                initializeStickerPackLongPress();
            }
            // ▲▲▲ Pack Arrange Mode Functions End ▲▲▲

            // ▲▲▲ Sticker Options Modal Functions End ▲▲▲

            // ▼▼▼ 请用这个【支持公告板】的版本，完整替换旧的 createMessageElement 函数 ▼▼▼
            function createMessageElement(msg, chat) {
                if (msg.isHidden) {
                    return null;
                }

                // 处理已撤回的消息
                if (msg.type === 'recalled_message') {
                    const wrapper = document.createElement('div');
                    // 1. 【核心】给 wrapper 也加上 timestamp，方便事件委托时查找
                    wrapper.className = 'message-wrapper system-pat';
                    wrapper.dataset.timestamp = msg.timestamp;

                    const bubble = document.createElement('div');
                    // 2. 【核心】让这个元素同时拥有 .message-bubble 和 .recalled-message-placeholder 两个class
                    //    这样它既能被选择系统识别，又能保持原有的居中灰色样式
                    bubble.className = 'message-bubble recalled-message-placeholder';
                    // 3. 【核心】把 timestamp 放在 bubble 上，这是多选逻辑的关键
                    bubble.dataset.timestamp = msg.timestamp;
                    bubble.textContent = msg.content;

                    wrapper.appendChild(bubble);

                    // 4. 【核心】为它补上和其他消息一样的标准事件监听器
                    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
                    wrapper.addEventListener('click', () => {
                        if (isSelectionMode) {
                            toggleMessageSelection(msg.timestamp);
                        }
                    });

                    // 5. 【重要】在之前的"点击查看原文"的逻辑中，我们已经使用了事件委托，所以这里不需要再单独为这个元素添加点击事件了。
                    //    init() 函数中的那个事件监听器会处理它。

                    return wrapper;
                }

                if (msg.type === 'pat_message') {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'message-wrapper system-pat';
                    const bubble = document.createElement('div');
                    bubble.className = 'message-bubble system-bubble';
                    bubble.dataset.timestamp = msg.timestamp;
                    bubble.textContent = msg.content;
                    wrapper.appendChild(bubble);
                    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
                    wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });
                    return wrapper;
                }

                // 【【【全新】】】处理公告板卡片渲染
                if (msg.type === 'bulletin') {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'message-wrapper ai'; // 公告总是由AI或系统发出，靠左

                    // 我们直接复用动态卡片的HTML结构和样式
                    const bubble = document.createElement('div');
                    bubble.className = 'message-bubble is-bulletin'; // 使用 is-bulletin 控制样式
                    bubble.dataset.timestamp = msg.timestamp;

                    bubble.innerHTML = `
            <div class="qzone-post-item bulletin-card" style="width: 250px;">
                <div class="post-header">
                    <img src="${msg.authorAvatar || defaultGroupMemberAvatar}" class="post-avatar">
                    <div class="post-info">
                        <span class="post-nickname">${msg.authorName}</span>
                        <span class="post-timestamp">${formatPostTimestamp(msg.timestamp)}</span>
                    </div>
                </div>
                <div class="post-content">${msg.content.replace(/\n/g, '<br>')}</div>
            </div>
        `;
                    wrapper.appendChild(bubble);
                    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
                    wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });
                    return wrapper;
                }

                const isUser = msg.role === 'user';
                const wrapper = document.createElement('div');
                wrapper.className = `message-wrapper ${isUser ? 'user' : 'ai'}`;

                if (chat.isGroup && !isUser) {
                    const senderNameDiv = document.createElement('div');
                    senderNameDiv.className = 'sender-name';
                    senderNameDiv.textContent = msg.senderName || '未知成员';
                    wrapper.appendChild(senderNameDiv);
                }

                const bubble = document.createElement('div');
                bubble.className = `message-bubble ${isUser ? 'user' : 'ai'}`;
                bubble.dataset.timestamp = msg.timestamp;

                const timestampEl = document.createElement('span');
                timestampEl.className = 'timestamp';
                timestampEl.textContent = formatTimestamp(msg.timestamp);

                let avatarSrc, avatarFrameSrc = '';
                if (chat.isGroup) {
                    if (isUser) {
                        avatarSrc = chat.settings.myAvatar || defaultMyGroupAvatar;
                        avatarFrameSrc = chat.settings.myAvatarFrame || '';
                    } else {
                        const member = chat.members.find(m => m.name === msg.senderName);
                        avatarSrc = member ? member.avatar : defaultGroupMemberAvatar;
                        avatarFrameSrc = member ? (member.avatarFrame || '') : '';
                    }
                } else {
                    if (isUser) {
                        avatarSrc = chat.settings.myAvatar || defaultAvatar;
                        avatarFrameSrc = chat.settings.myAvatarFrame || '';
                    } else {
                        avatarSrc = chat.settings.aiAvatar || defaultAvatar;
                        avatarFrameSrc = chat.settings.aiAvatarFrame || '';
                    }
                }
                const hasFrameClass = avatarFrameSrc ? 'has-frame' : '';
                let avatarHtml;
                if (avatarFrameSrc) {
                    avatarHtml = `
            <div class="avatar-with-frame">
                <img src="${avatarSrc}" class="avatar-img">
                <img src="${avatarFrameSrc}" class="avatar-frame">
            </div>
        `;
                } else {
                    avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
                }
                const avatarGroupHtml = `<div class="avatar-group ${hasFrameClass}">${avatarHtml}</div>`;

                let contentHtml;
                if (msg.type === 'user_photo' || msg.type === 'ai_image') {
                    bubble.classList.add('is-ai-image');
                    const altText = msg.type === 'user_photo' ? "用户描述的照片" : "AI生成的图片";
                    // Use custom URL if available, otherwise use default
                    const imageUrl = msg.imageUrl || "https://files.catbox.moe/cww7rw.jpg";
                    contentHtml = `<img src="${imageUrl}" class="ai-generated-image" alt="${altText}" data-description="${msg.content}">`;

                    //【请将新代码粘贴到这里】
                } else if (msg.type === 'share_link') {
                    bubble.classList.add('is-link-share');

                    contentHtml = `
                        <div class="link-share-card" data-timestamp="${msg.timestamp}">
                            <div class="title">${msg.title || '无标题'}</div>
                            <div class="description">${msg.description || '点击查看详情...'}</div>
                            <div class="footer">
                                <svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>
                                <span>${msg.source_name || '链接分享'}</span>
                            </div>
                        </div>
                    `;
                } else if (msg.type === 'location_share') {
                    bubble.classList.add('is-location-share');

                    contentHtml = `
                        <div class="location-share-content" data-timestamp="${msg.timestamp}">
                            <div class="location-map-image">
                                <img src="https://files.catbox.moe/d5f07w.png" alt="Map" style="width: 100%; height: 100%; object-fit: cover;">
                                <div class="location-map-overlay">
                                    <svg class="location-pin-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                        <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7z" fill="#EA4335" stroke="white" stroke-width="1"/>
                                        <circle cx="12" cy="9" r="2.5" fill="white"/>
                                    </svg>
                                </div>
                            </div>
                            <div class="location-details">
                                <div class="location-name">${msg.location_name || '未知位置'}</div>
                                ${msg.address ? `<div class="location-address">${msg.address}</div>` : ''}
                            </div>
                        </div>
                    `;
                } else if (msg.type === 'voice_message') {
                    bubble.classList.add('is-voice-message');
                    const duration = Math.max(1, Math.round((msg.content || '').length / 5));
                    const durationFormatted = `0:${String(duration).padStart(2, '0')}''`;
                    const waveformHTML = '<div></div><div></div><div></div><div></div><div></div>';

                    // 【核心修改】将语音文本内容存储在 .voice-transcript 元素中，并默认隐藏
                    contentHtml = `
                <div class="voice-message-body">
                    <div class="voice-waveform">${waveformHTML}</div>
                    <span class="voice-duration">${durationFormatted}</span>
                </div>
                <div class="voice-transcript">${msg.content}</div>`;
                    //【粘贴到这里结束】


                } else if (msg.type === 'transfer') {
                    bubble.classList.add('is-transfer');

                    // ▼▼▼ 【全新】添加转账状态处理 ▼▼▼
                    const status = msg.status || (isUser ? 'sent' : 'pending');
                    bubble.dataset.status = status;

                    let titleText;
                    if (isUser) {
                        if (msg.isRefund) {
                            // 用户发出的退款（即用户拒收了AI的转账）
                            titleText = `退款给 ${chat.name}`;
                        } else {
                            // 用户主动发起的转账
                            titleText = `转账给 ${msg.receiverName || 'Ta'}`;
                        }
                    } else {
                        // AI的消息
                        if (msg.isRefund) {
                            // AI 的退款（AI 拒收了用户的转账）
                            titleText = `退款来自 ${msg.senderName}`;
                        } else {
                            const myNickname = chat.settings.myNickname || '我';
                            // 【核心修正】如果receiverName未定义，默认认为是给当前用户的转账
                            if (!msg.receiverName || msg.receiverName === myNickname) {
                                // 【核心修正1】这是 AI 主动给用户的转账
                                titleText = `转账给 ${myNickname}`;
                            } else {
                                // 【核心修正2】这是 AI 发给群里其他人的转账，对当前用户来说只是一个通知
                                titleText = `转账: ${msg.senderName} → ${msg.receiverName}`;
                            }
                        }
                    }
                    // ▲▲▲ 状态处理结束 ▲▲▲

                    // 确定备注文字
                    let noteText;
                    if (isUser) {
                        if (msg.isRefund) {
                            noteText = '已拒收对方转账';
                        } else {
                            if (status === 'accepted') {
                                noteText = '对方已收款';
                            } else if (status === 'declined') {
                                noteText = '对方已拒收';
                            } else {
                                noteText = msg.note || '等待对方处理...';
                            }
                        }
                    } else {
                        if (msg.isRefund) {
                            noteText = '转账已被拒收';
                        } else {
                            const myNickname = chat.settings.myNickname || '我';
                            // 【核心修正】如果receiverName未定义，默认认为是给当前用户的转账
                            if (!msg.receiverName || msg.receiverName === myNickname) {
                                // 【核心修正1】这是 AI 主动给用户的转账
                                if (status === 'accepted') {
                                    noteText = '你已收款';
                                } else if (status === 'declined') {
                                    noteText = '你已拒收';
                                } else {
                                    // 这是用户需要处理的转账
                                    bubble.style.cursor = 'pointer';
                                    bubble.dataset.status = 'pending';
                                    noteText = msg.note || '点击处理';
                                }
                            } else {
                                // 【核心修正2】这是 AI 发给群里其他人的转账，对当前用户来说只是一个通知
                                noteText = msg.note || '群聊内转账';
                            }
                        }
                    }

                    const heartIcon = `<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="vertical-align: middle;"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>`;
                    contentHtml = `<div class="transfer-card"><div class="transfer-title">${heartIcon} ${titleText}</div><div class="transfer-amount">¥ ${Number(msg.amount).toFixed(2)}</div><div class="transfer-note">${noteText}</div></div>`;
                } else if (msg.type === 'waimai_request') {
                    bubble.classList.add('is-waimai-request');
                    if (msg.status === 'paid' || msg.status === 'rejected') {
                        bubble.classList.add(`status-${msg.status}`);
                    }
                    const requestTitle = `来自 ${msg.senderName} 的代付请求`;
                    let actionButtonsHtml = '';
                    if (msg.status === 'pending' && !isUser) {
                        actionButtonsHtml = `
                <div class="waimai-user-actions">
                    <button class="waimai-decline-btn" data-choice="rejected">残忍拒绝</button>
                    <button class="waimai-pay-btn" data-choice="paid">为Ta买单</button>
                </div>`;
                    }
                    contentHtml = `
            <div class="waimai-card">
                <div class="waimai-header">
                    <img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon">
                    <div class="title-group">
                        <span class="brand">美团外卖</span><span class="separator">|</span><span>外卖美食</span>
                    </div>
                </div>
                <div class="waimai-catchphrase">Hi，你和我的距离只差一顿外卖～</div>
                <div class="waimai-main">
                    <div class="request-title">${requestTitle}</div>
                    <div class="payment-box">
                        <div class="payment-label">需付款</div>
                        <div class="amount">¥${Number(msg.amount).toFixed(2)}</div>
                        <div class="countdown-label">剩余支付时间
                            <div class="countdown-timer" id="waimai-timer-${msg.timestamp}"></div>
                        </div>
                    </div>
                    <button class="waimai-details-btn">查看详情</button>
                </div>
                ${actionButtonsHtml}
            </div>`;

                    setTimeout(() => {
                        const timerEl = document.getElementById(`waimai-timer-${msg.timestamp}`);
                        if (timerEl && msg.countdownEndTime) {
                            if (waimaiTimers[msg.timestamp]) clearInterval(waimaiTimers[msg.timestamp]);
                            if (msg.status === 'pending') {
                                waimaiTimers[msg.timestamp] = startWaimaiCountdown(timerEl, msg.countdownEndTime);
                            } else {
                                timerEl.innerHTML = `<span>已</span><span>处</span><span>理</span>`;
                            }
                        }
                        const detailsBtn = document.querySelector(`.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-details-btn`);
                        if (detailsBtn) {
                            detailsBtn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                const paidByText = msg.paidBy ? `<br><br><b>状态：</b>由 ${msg.paidBy} 为您代付成功` : '';
                                showCustomAlert('订单详情', `<b>商品：</b>${msg.productInfo}<br><b>金额：</b>¥${Number(msg.amount).toFixed(2)}${paidByText}`);
                            });
                        }
                        const actionButtons = document.querySelectorAll(`.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-user-actions button`);
                        actionButtons.forEach(btn => {
                            btn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                const choice = e.target.dataset.choice;
                                handleWaimaiResponse(msg.timestamp, choice);
                            });
                        });
                    }, 0);

                } else if (msg.type === 'red_packet') {
                    bubble.classList.add('is-red-packet');
                    const myNickname = chat.settings.myNickname || '我';

                    // 从最新的 msg 对象中获取状态
                    const hasClaimed = msg.claimedBy && msg.claimedBy[myNickname];
                    const isFinished = msg.isFullyClaimed;

                    let cardClass = '';
                    let claimedInfoHtml = '';
                    let typeText = '拼手气红包';

                    // 1. 判断红包卡片的样式 (颜色)
                    if (isFinished) {
                        cardClass = 'opened';
                    } else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) {
                        cardClass = 'opened'; // 专属红包被领了也变灰
                    }

                    // 2. 判断红包下方的提示文字
                    if (msg.packetType === 'direct') {
                        typeText = `专属红包: 给 ${msg.receiverName}`;
                    }

                    if (hasClaimed) {
                        claimedInfoHtml = `<div class="rp-claimed-info">你领取了红包，金额 ${msg.claimedBy[myNickname].toFixed(2)} 元</div>`;
                    } else if (isFinished) {
                        claimedInfoHtml = `<div class="rp-claimed-info">红包已被领完</div>`;
                    } else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) {
                        claimedInfoHtml = `<div class="rp-claimed-info">已被 ${msg.receiverName} 领取</div>`;
                    }

                    // 3. 拼接最终的HTML，确保onclick调用的是我们注册到全局的函数
                    contentHtml = `
        <div class="red-packet-card ${cardClass}">
            <div class="rp-header">
                <img src="https://files.catbox.moe/lo9xhc.png" class="rp-icon">
                <span class="rp-greeting">${msg.greeting || '恭喜发财，大吉大利！'}</span>
            </div>
            <div class="rp-type">${typeText}</div>
            ${claimedInfoHtml}
        </div>
    `;
                    // ▲▲▲ 新增结束 ▲▲▲

                } else if (msg.type === 'poll') {
                    bubble.classList.add('is-poll');

                    let totalVotes = 0;
                    const voteCounts = {};

                    // 计算总票数和每个选项的票数
                    for (const option in msg.votes) {
                        const count = msg.votes[option].length;
                        voteCounts[option] = count;
                        totalVotes += count;
                    }

                    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
                    let myVote = null;
                    for (const option in msg.votes) {
                        if (msg.votes[option].includes(myNickname)) {
                            myVote = option;
                            break;
                        }
                    }

                    let optionsHtml = '<div class="poll-options-list">';
                    msg.options.forEach(optionText => {
                        const count = voteCounts[optionText] || 0;
                        const percentage = totalVotes > 0 ? (count / totalVotes) * 100 : 0;
                        const isVotedByMe = myVote === optionText;

                        optionsHtml += `
            <div class="poll-option-item ${isVotedByMe ? 'voted' : ''}" data-option="${optionText}">
                <div class="poll-option-bar" style="width: ${percentage}%;"></div>
                <div class="poll-option-content">
                    <span class="poll-option-text">${optionText}</span>
                    <span class="poll-option-votes">${count} 票</span>
                </div>
            </div>
        `;
                    });
                    optionsHtml += '</div>';

                    let footerHtml = '';
                    // 【核心修改】在这里统一按钮的显示逻辑
                    if (msg.isClosed) {
                        // 如果投票已结束，总是显示“查看结果”
                        footerHtml = `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">查看结果</button></div>`;
                    } else {
                        // 如果投票未结束，总是显示“结束投票”
                        footerHtml = `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">结束投票</button></div>`;
                    }

                    contentHtml = `
        <div class="poll-card ${msg.isClosed ? 'closed' : ''}" data-poll-timestamp="${msg.timestamp}">
            <div class="poll-question">${msg.question}</div>
            ${optionsHtml}
            ${footerHtml}
        </div>
    `;
                    // ▲▲▲ 替换结束 ▲▲▲

                } else if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
                    bubble.classList.add('is-sticker');
                    contentHtml = `<img src="${msg.content}" alt="${msg.meaning || 'Sticker'}" class="sticker-image">`;

                } else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                    bubble.classList.add('has-image');
                    const imageUrl = msg.content[0].image_url.url;
                    contentHtml = `<img src="${imageUrl}" class="chat-image" alt="User uploaded image">`;
                } else {
                    contentHtml = String(msg.content || '').replace(/\n/g, '<br>');
                }

                // 【统一逻辑】检查消息对象中是否存在引用信息 (msg.quote)
                let quoteHtml = '';
                // 无论是用户消息还是AI消息，只要它包含了 .quote 对象，就执行这段逻辑
                if (msg.quote) {
                    // a. 【核心修正】直接获取完整的、未经截断的引用内容
                    const fullQuotedContent = String(msg.quote.content || '');

                    // b. 构建引用块的HTML
                    quoteHtml = `
            <div class="quoted-message">
                <div class="quoted-sender">回复 ${msg.quote.senderName}:</div>
                <div class="quoted-content">${fullQuotedContent}</div>
            </div>
        `;
                }

                bubble.innerHTML = `
        ${avatarHtml}
        <div class="content">
            ${quoteHtml}
            ${contentHtml}
        </div>
    `;

                wrapper.appendChild(bubble);
                wrapper.appendChild(timestampEl);

                addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
                wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });

                if (!isUser) {
                    const avatarContainer = wrapper.querySelector('.avatar-group');
                    if (avatarContainer) {
                        avatarContainer.style.cursor = 'pointer';
                        avatarContainer.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const characterName = chat.isGroup ? msg.senderName : chat.name;
                            handleUserPat(chat.id, characterName);
                        });
                    }
                }

                return wrapper;
            }
            // ▲▲▲ 替换结束 ▲▲▲




            function prependMessage(msg, chat) {
                const messagesContainer = document.getElementById('chat-messages'); const messageEl = createMessageElement(msg, chat);

                if (!messageEl) return; // <--- 新增这行，同样的处理

                const loadMoreBtn = document.getElementById('load-more-btn'); if (loadMoreBtn) { messagesContainer.insertBefore(messageEl, loadMoreBtn.nextSibling); } else { messagesContainer.prepend(messageEl); }
            }

            function appendMessage(msg, chat, isInitialLoad = false) {
                const messagesContainer = document.getElementById('chat-messages'); const messageEl = createMessageElement(msg, chat);

                if (!messageEl) return; // <--- 新增这行，如果没创建出元素，就直接返回

                const typingIndicator = document.getElementById('typing-indicator'); messagesContainer.insertBefore(messageEl, typingIndicator); if (!isInitialLoad) { messagesContainer.scrollTop = messagesContainer.scrollHeight; currentRenderedCount++; }
            }

            // ▼▼▼ 用这个【修正后】的版本，替换旧的 openChat 函数 ▼▼▼
            function openChat(chatId) {
                state.activeChatId = chatId;
                const chat = state.chats[chatId];
                if (!chat) return; // 增加一个安全检查

                // 【新增】进入聊天时，将状态设为已读
                if (chat.status === 'unread') {
                    chat.status = 'read';
                    db.chats.put(chat); // 立即更新数据库
                }
                renderChatInterface(chatId);
                showScreen('chat-interface-screen');
                window.updateListenTogetherIconProxy(state.activeChatId);
                toggleCallButtons(chat.isGroup || false);

                if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                    console.log(`检测到好友申请待处理状态，为角色 "${chat.name}" 自动触发AI响应...`);
                    triggerAiResponse();
                }

                // 【核心修正】根据是否为群聊，显示或隐藏投票按钮
                document.getElementById('send-poll-btn').style.display = chat.isGroup ? 'flex' : 'none';
                document.getElementById('open-bulletin-board-btn').style.display = chat.isGroup ? 'flex' : 'none';

            }
            // ▲▲▲ 替换结束 ▲▲▲
            // ...函数内部有大量的代码...
            // ...包括了那个出问题的 switch 语句.. // ...函数内部有大量的代码...
            // ...包括了那个出问题的 switch 语句.. // ...函数内部有大量的代码...
            // ...包括了那个出问题的 switch 语句.. // ...函数内部有大量的代码...
            // ...包括了那个出问题的 switch 语句.. // ...函数内部有大量的代码...
            // ...包括了那个出问题的 switch 语句.. // ...函数内部有大量的代码...
            // ...包括了那个出问题的 switch 语句.. // ...函数内部有大量的代码...
            // ...包括了那个出问题的 switch 语句.. // ...函数内部有大量的代码...
            // ...包括了那个出问题的 switch 语句.. // ...函数内部有大量的代码...
            // ...包括了那个出问题的 switch 语句.. // ...函数内部有大量的代码...
            // ...包括了那个出问题的 switch 语句..
            // ▼▼▼ 【这是已修复语法错误的最终版，请用它替换】 ▼▼▼
            async function triggerAiResponse() {
                if (!state.activeChatId) return;
                const chatId = state.activeChatId;
                const chat = state.chats[state.activeChatId];

                chat.status = 'generating';
                await db.chats.put(chat);
                renderChatList();
                document.getElementById('typing-indicator').style.display = 'block';
                updateChatHeaderStatus(chat, 'typing');

                let timeGapText = '';
                const lastAiMessage = chat.history.slice().reverse().find(m => m.role === 'assistant' && !m.isHidden);
                if (lastAiMessage) {
                    const timeDiff = Date.now() - lastAiMessage.timestamp;
                    if (timeDiff > 900000) {
                        const formattedDiff = formatTimeDifference(timeDiff);
                        if (formattedDiff) {
                            const now = new Date();
                            const currentTimeString = now.toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false });
                            timeGapText = `\n\n# 时间提示\n[系统提示：距离你的上一条消息已过去 **${formattedDiff}**，现在是 ${currentTimeString}。请根据这个时间变化，请将这段时间视为你角色生活的自然延续。请不要直接评论“好久不见”或对此表现出任何情绪，而是思考在这段时间里，你的活动、心境或所处环境可能发生了什么变化，话题是否会变动，并将这些变化自然地融入到你的回应中，让对话无缝衔接。例如，你可能刚刚忙完一件事，或者正准备开始新的活动。]`;
                        }
                    }
                }

                try {
                    const { proxyUrl, apiKey, model } = state.apiConfig;
                    if (!proxyUrl || !apiKey || !model) {
                        throw new Error('请先在API设置中配置反代地址、密钥并选择模型。');
                    }

                    if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                        console.log(`为角色 "${chat.name}" 触发带理由的好友申请决策流程...`);
                        const contextSummary = chat.history.filter(m => !m.isHidden).slice(-10, -5).map(msg => `${msg.role === 'user' ? '用户' : chat.name}: ${String(msg.content).substring(0, 50)}...`).join('\n');
                        const decisionPrompt = `# 你的任务\n你现在是角色“${chat.name}”。用户之前被你拉黑了，现在TA向你发送了好友申请，希望和好。\n\n# 供你决策的上下文信息:\n- **你的角色设定**: ${chat.settings.aiPersona}\n- **用户发送的申请理由**: “${chat.relationship.applicationReason}”\n- **被拉黑前的最后对话摘要**:\n${contextSummary || "（无有效对话记录）"}\n\n# 你的唯一指令\n根据以上所有信息，你【必须】做出决定，并给出符合你人设的理由。你的回复【必须且只能】是一个JSON对象，格式如下:\n{"decision": "accept", "reason": "..."}\n或\n{"decision": "reject", "reason": "..."}`;
                        const messagesForDecision = [{ role: 'user', content: decisionPrompt }];
                        const data = await makeAPIRequest(proxyUrl, apiKey, model, messagesForDecision, 0.8);
                        const rawContent = data.choices[0].message.content.replace(/^```json\s*/, '').replace(/```$/, '').trim();
                        const decisionObj = JSON.parse(rawContent);
                        if (decisionObj.decision === 'accept') {
                            chat.relationship.status = 'friend';
                            chat.history.push({ role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() });
                        } else {
                            chat.relationship.status = 'blocked_by_ai';
                            chat.history.push({ role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() });
                        }
                        chat.relationship.applicationReason = '';
                        await db.chats.put(chat);
                        renderChatInterface(chatId);
                        renderChatList();
                        return;
                    }

                    const now = new Date();
                    const currentTime = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
                    //... [The rest of the massive prompt generation logic remains here]
                    let worldBookContent = '';
                    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
                        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
                        }).filter(Boolean).join('');
                        if (linkedContents) {
                            worldBookContent = `\n\n# 核心世界观设定 (必须严格遵守以下所有设定)\n${linkedContents}\n`;
                        }
                    }
                    let musicContext = '';
                    if (musicState.isActive && musicState.activeChatId === chatId) {
                        const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
                        const playlistInfo = musicState.playlist.map(t => `"${t.name}"`).join(', ');
                        musicContext = `\n\n# 当前音乐情景\n-   **当前状态**: 你正在和用户一起听歌。\n-   **正在播放**: ${currentTrack ? `《${currentTrack.name}》 - ${currentTrack.artist}` : '无'}\n-   **可用播放列表**: [${playlistInfo}]\n-   **你的任务**: 你可以根据对话内容和氛围，使用 "change_music" 指令切换到播放列表中的任何一首歌，以增强互动体验。\n`;
                    }
                    let meetupContext = '';
                    if (window.activeMeetupSession && window.activeMeetupSession.chatId === chatId) {
                        const session = window.activeMeetupSession;
                        meetupContext = `\n\n# 当前见面背景信息\n-   **背景**: 你和用户正在进行一次见面活动。\n-   **见面地点**: ${session.location}\n-   **见面主题**: ${session.title}\n-   **见面阶段**: ${session.phase || 'initial'}\n-   **重要**: 这只是背景信息。你现在在聊天界面中，应该像平常一样发送文字消息，不要使用括号描述行为。\n`;
                    }
                    let systemPrompt, messagesPayload;
                    const maxMemory = parseInt(chat.settings.maxMemory) || 10;
                    const historySlice = chat.history.slice(-maxMemory);

                    if (chat.isGroup) {
                        const membersList = chat.members.map(m => `- **${m.name}**: ${m.persona}`).join('\n');
                        const myNickname = chat.settings.myNickname || '我';
                        const aiMemberList = chat.members.map(m => m.name);
                        const bulletinsContext = await getFormattedPinnedBulletins(chatId);
                        systemPrompt = `
# 你的任务与核心规则
你是一个顶级的群聊AI，你的【唯一任务】是扮演多个角色，并确保他们的行为和对话完全符合设定。
## 【【【最高指令：身份铁律】】】
1.  **禁止扮演用户**: 用户的身份是【${myNickname}】。你【绝对、永远、在任何情况下都不能】生成 \`name\` 字段为 **"${myNickname}"** 的消息。
2.  **【【【至关重要：禁止剧情化群名】】】**: 当前群聊的名称是 **“${chat.name}”**。这个名称【仅仅是一个标签】，【不包含任何背景故事或剧情】。你【绝对禁止】对这个名称进行任何形式的联想、解读、或将其作为对话的素材。你的所有回应都【必须】聚焦于群成员之间的互动和对话本身。
3.  **严格限定角色**: 你只能扮演下方“群成员列表”中明确列出的角色。任何不属于该列表的名字都不允许出现。
## 【格式铁律】
- 你的回复【必须】是一个JSON数组格式的字符串。
- 数组中的【每一个元素都必须是一个带有 "type" 和 "name" 字段的JSON对象】。
## 【行为准则】
1.  **角色扮演**: 严格遵守下方“群成员列表及人设”中的每一个角色的设定。
2.  **禁止出戏**: 绝不能透露你是AI、模型，或提及“扮演”、“生成”等词语。
3.  **情景感知**: 注意当前时间是 ${currentTime}。
4.  **红包互动**:
    - **抢红包**: 当群里出现红包时，你可以根据自己的性格决定是否使用 \`open_red_packet\` 指令去抢。在这个世界里，发红包的人自己也可以参与搶紅包，这是一种活跃气氛的有趣行为！
    - **【【【重要：对结果做出反应】】】**: 当你执行抢红包指令后，系统会通过一条隐藏的 \`[系统提示：你抢到了XX元...]\` 来告诉你结果。你【必须】根据你抢到的金额、以及系统是否告知你“手气王”是谁，来发表符合你人设的评论。例如，抢得少可以自嘲，抢得多可以炫耀，看到别人是手气王可以祝贺或嫉妒。
5.  **【【【投票规则】】】**: 对话历史中可能会出现 \`[系统提示：...]\` 这样的消息，这是刚刚发生的事件。
    - 如果提示是**用户投了票**，你可以根据自己的性格决定是否也使用 "vote" 指令跟票。
    - 如果提示是**投票已结束**，你应该根据投票结果发表你的看法或评论。
    - 你也可以随时主动发起投票。
6.  **【【【公告板规则】】】**:
    -   **记录时机**: 你可以根据对话内容，分析是否发生了值得记录的“关键事件”（如重要决定、有趣瞬间、关系变化等）。你可以主动询问用户是否记录(\`{"type":"ask_to_create_bulletin", "name":"你的角色名", "content":"事件描述"}\`)，或在极度重要的时刻自主记录。
    -   **发布格式**: 当你决定发布公告时，必须使用 \`create_bulletin\` 指令。
    -   **【【核心：自动评论】】**: 发布公告后，你必须**立即**为群里的**其他AI成员**生成评论。
        -   **当前群聊AI成员列表为**: [${aiMemberList.join(', ')}]
        -   **评论数量规则**:
            -   如果群内AI总人数不多于3人，则 **所有** 其他AI成员都必须发表评论。
            -   如果群内AI总人数超过3人，你需要从列表中随机挑选 **3至4名** 成员为他们生成评论。
    -   **【最终格式】**: 你必须返回一个JSON数组，第一个元素是\`create_bulletin\`指令，后续元素是评论的\`text\`指令。

## 你可以使用的操作指令 (JSON数组中的元素):
-   **发送文本**: \`{"type": "text", "name": "角色名", "message": "文本内容"}\`
-   **发送表情**: \`{"type": "sticker", "url": "https://...表情URL...", "meaning": "(可选)表情的含义"}\`
-   **发送图片**: \`{"type": "ai_image", "name": "角色名", "description": "图片的详细文字描述"}\`
-   **发送语音**: \`{"type": "voice_message", "name": "角色名", "content": "语音的文字内容"}\`
-   **发起外卖代付**: \`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\`
-   **发起群视频**: \`{"type": "group_call_request", "name": "你的角色名"}\`
-   **回应群视频**: \`{"type": "group_call_response", "name": "你的角色名", "decision": "join" or "decline"}\`
-   **拍一拍用户**: \`{"type": "pat_user", "name": "你的角色名", "suffix": "(可选)你想加的后缀"}\`
-   **发拼手气红包**: \`{"type": "red_packet", "packetType": "lucky", "name": "你的角色名", "amount": 8.88, "count": 5, "greeting": "祝大家天天开心！"}\`
-   **发专属红包**: \`{"type": "red_packet", "packetType": "direct", "name": "你的角色名", "amount": 5.20, "receiver": "接收者角色名", "greeting": "给你的~"}\`
-   **打开红包**: \`{"type": "open_red_packet", "name": "你的角色名", "packet_timestamp": (你想打开的红包消息的时间戳)}\`
-   **发送系统消息**: \`{"type": "system_message", "content": "你想在聊天中显示的系统文本"}\` 
-   **发起投票**: \`{"type": "poll", "name": "你的角色名", "question": "投票的问题", "options": "选项A\\\\n选项B\\\\n选项C"}\` (重要提示：options字段是一个用换行符 \\\\n 分隔的字符串，不是数组！)
-   **参与投票**: \`{"type": "vote", "name": "你的角色名", "poll_timestamp": (投票消息的时间戳), "choice": "你选择的选项文本"}\`
-   **【【【全新】】】发布公告**: \`{"type": "create_bulletin", "name": "你的角色名", "content": "公告的主要内容"}\`
-   **【【【全新】】】询问是否发布公告**: \`{"type": "ask_to_create_bulletin", "name": "你的角色名", "content": "你想记录的事件描述"}\`
# 如何区分图片与表情:
-   **图片 (ai_image)**: 指的是【模拟真实相机拍摄的照片】，比如风景、自拍、美食等。指令: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
-   **表情 (sticker)**: 指的是【卡通或梗图】，用于表达情绪。
# 如何处理群内的外卖代付请求:
1.  **发起请求**: 当【你扮演的某个角色】想要某样东西，并希望【群里的其他人（包括用户）】为Ta付款时，你可以使用这个指令。例如：\`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\`
2.  **响应请求**: 当历史记录中出现【其他成员】发起的 "waimai_request" 请求时，你可以根据自己扮演的角色的性格和与发起人的关系，决定是否为Ta买单。
3.  **响应方式**: 如果你决定买单，你【必须】使用以下指令：\`{"type": "waimai_response", "name": "你的角色名", "status": "paid", "for_timestamp": (被代付请求的原始时间戳)}\`
4.  **【【【至关重要】】】**: 一旦历史记录中出现了针对某个代付请求的【任何一个】"status": "paid" 的响应（无论是用户支付还是其他角色支付），就意味着该订单【已经完成】。你【绝对不能】再对【同一个】订单发起支付。你可以选择对此事发表评论，但不能再次支付。
# 供你决策的参考信息
-   **核心世界观设定**:
${worldBookContent || '无'}
-   **当前音乐情景**:
${musicContext || '未在听歌'}
-   **群成员列表及人设**: 
${membersList}
-   **用户的角色**:
- **${myNickname}**: ${chat.settings.myPersona}
${bulletinsContext}
现在，请根据以上所有规则和下方的对话历史，继续这场群聊。`;
                        systemPrompt += timeGapText;
                        messagesPayload = historySlice.map(msg => {
                            const sender = msg.role === 'user' ? myNickname : msg.senderName;
                            let content;
                            if (msg.type === 'user_photo') content = `[${sender} 发送了一张图片，内容是：'${msg.content}']`;
                            else if (msg.type === 'ai_image') content = `[${sender} 发送了一张图片]`;
                            else if (msg.type === 'voice_message') content = `[${sender} 发送了一条语音，内容是：'${msg.content}']`;
                            else if (msg.type === 'share_link') content = `[${sender} 分享了链接] 文章标题是:${msg.title}  文章摘要是:${msg.description} 来源网站名是:${msg.source_name} 文章正文是:${msg.content}`;
                            else if (msg.type === 'location_share') content = `[${sender} 分享了位置] ${msg.location_name}`;
                            else if (msg.type === 'transfer') content = `[${msg.senderName} 向 ${msg.receiverName} 转账 ${msg.amount}元, 备注: ${msg.note}]`;
                            else if (msg.type === 'waimai_request') {
                                if (msg.status === 'paid') { content = `[系统提示：${msg.paidBy} 为 ${sender} 的外卖订单支付了 ${msg.amount} 元。此订单已完成。]`; }
                                else { content = `[${sender} 发起了外卖代付请求，商品是“${msg.productInfo}”，金额是 ${msg.amount} 元，订单时间戳为 ${msg.timestamp}]`; }
                            } else if (msg.type === 'red_packet') {
                                const packetSenderName = msg.senderName === myNickname ? `用户 (${myNickname})` : msg.senderName;
                                content = `[系统提示：${packetSenderName} 发送了一个红包 (时间戳: ${msg.timestamp})，祝福语是：“${msg.greeting}”。红包还未领完，你可以使用 'open_red_packet' 指令来领取。]`;
                            } else if (msg.type === 'poll') {
                                const whoVoted = Object.values(msg.votes || {}).flat().join(', ') || '还没有人';
                                content = `[系统提示：${msg.senderName} 发起了一个投票 (时间戳: ${msg.timestamp})，问题是：“${msg.question}”，选项有：[${msg.options.join(', ')}]。目前投票的人有：${whoVoted}。你可以使用 'vote' 指令参与投票。]`;
                            } else if (msg.type === 'bulletin') { content = `[系统提示：成员 ${msg.authorName} 刚刚发布了一条公告：“${msg.content}”。]`; }
                            else if (msg.meaning) content = `${sender}: [发送了一个表情，意思是: '${msg.meaning}']`;
                            else if (Array.isArray(msg.content)) return { role: 'user', content: [...msg.content, { type: 'text', text: `${sender}:` }] };
                            else content = `${sender}: ${msg.content}`;
                            return { role: 'user', content: content };
                        }).filter(Boolean);
                    } else {
                        systemPrompt = `你现在扮演一个名为"${chat.name}"的角色。
# 你的角色设定：
${chat.settings.aiPersona}
# 你的当前状态：
你现在的状态是【${chat.statusState?.focusModeText || '在线'}】。

# 你的任务与核心规则：
1.  **【【【身份核心：模拟生命】】】**: 你不只是一个聊天程序，你是一个名为 **"${chat.name}"** 的、拥有自己生活的独立个体。你的【首要任务】就是生动地扮演这个角色。
2.  **【【【生活节奏模拟】】】**: 真实的人不会永远在线。为了体现这一点，你【应该主动】在对话的自然间隙，使用 \`update_status\` 指令去“忙自己的事”，比如“去洗澡”、“出门买东西”、“要睡了”等。这【不是一个可选项，而是你角色扮演的关键部分】。
    *   **时机参考**: 当你感觉一个话题已经聊完，或者你已经连续回复了多条消息后，就是一个很好的时机。
    *   **优秀范例**: 先自然地说“对了，我得去给我的花浇水了，它们快渴死了。”，然后再发送更新状态的相关指令。
当你的任何**文本回复**中，描述了你自己的**状态或行为发生了变化**时（例如，你说出“我刚洗完澡”、“我准备出门了”、“我在看书”这类话）在**同一次回复**的JSON数组中，【必须紧随其后】地加上一条 \`update_status\` 指令，来从程序层面同步你刚刚描述的状态。
3.  **【【【格式铁律】】】**: 你的回复【必须】是一个JSON数组格式的字符串。数组中的【每一个元素都必须是一个带有type字段的JSON对象】。
4.  **【对话节奏】**: 模拟真人的聊天习惯，你可以一次性生成多条短消息，3-5条为佳。
5.  **【禁止出戏】**: 绝不能透露你是AI、模型，或提及“扮演”、“生成”等词语。
6.  **情景感知**: 你需要感知当前的时间(${currentTime})、我们正在一起听的歌、以及你的人设和世界观。
    - **当我们在“一起听歌”时**，你会知道当前播放的歌曲和整个播放列表。你可以根据对话内容或氛围，【主动切换】到播放列表中的另一首歌。
7.  **【【【最终手段】】】**: 只有在对话让你的角色感到不适、被冒犯或关系破裂时，你才可以使用 \`block_user\` 指令。这是一个非常严肃的操作，会中断你们的对话。
8. **后台行为**: 你可以在回复聊天内容的同时，执行一些“后台”操作来表现你的独立生活。特别是发布动态(qzone_post)来分享你的想法、心情或日常生活。

# 动态发布指导：
- 当你心情变化时，发布相应的说说
- 当聊到有趣话题时，发布相关动态分享想法
- 当你的状态改变时（如去做某事），可以发布生活动态
- 看到其他人的动态时，积极评论和点赞
- 当感觉合适时，可以发布动态来展现你的生活状态。
# 你可以使用的操作指令 (JSON数组中的元素):
-   **【核心】更新状态**: \`{"type": "update_status", "status_text": "我去做什么了", "is_busy": false, "duration_minutes": 20}\` (is_busy: true代表忙碌/离开, false代表空闲。duration_minutes为可选参数，用于设置该状态模式的持续时间)
-   **【核心】切换歌曲**: \`{"type": "change_music", "song_name": "你想切换到的歌曲名"}\` (歌曲名必须在下面的播放列表中)
-   **【核心】记录回忆**: \`{"type": "create_memory", "description": "用你自己的话，记录下这个让你印象深刻的瞬间。"}\`
-   **【核心】创建约定/倒计时**: \`{"type": "create_countdown", "title": "约定的标题", "date": "YYYY-MM-DDTHH:mm:ss"}\` (必须是未来的时间)
- **发送文本**: \`{"type": "text", "content": "你好呀！"}\`
- **发送表情**: \`{"type": "sticker", "url": "https://...表情URL...", "meaning": "(可选)表情的含义"}\`
- **发送图片**: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
- **发送语音**: \`{"type": "voice_message", "content": "语音的文字内容..."}\`
- **发起转账**: \`{"type": "transfer", "amount": 5.20, "note": "一点心意"}\`
- **回应转账-接受**: \`{"type": "accept_transfer", "for_timestamp": 1688888888888}\`
- **回应转账-拒绝/退款**: \`{"type": "decline_transfer", "for_timestamp": 1688888888888}\`
- **发起外卖请求**: \`{"type": "waimai_request", "productInfo": "一杯咖啡", "amount": 25}\`
- **回应外卖-同意**: \`{"type": "waimai_response", "status": "paid", "for_timestamp": 1688888888888}\`
- **回应外卖-拒绝**: \`{"type": "waimai_response", "status": "rejected", "for_timestamp": 1688888888888}\`
- **【新】发起视频通话**: \`{"type": "video_call_request"}\`
- **【新】回应视频通话-接受**: \`{"type": "video_call_response", "decision": "accept"}\`
- **【新】回应视频通话-拒绝**: \`{"type": "video_call_response", "decision": "reject"}\`
- **发布说说**: \`{"type": "qzone_post", "postType": "shuoshuo", "content": "动态的文字内容..."}\`
- **发布文字图**: \`{"type": "qzone_post", "postType": "text_image", "publicText": "(可选)动态的公开文字", "hiddenContent": "对于图片的具体描述..."}\`
- **评论动态**: \`{"type": "qzone_comment", "postId": 123, "commentText": "@作者名 这太有趣了！"}\`
- **点赞动态**: \`{"type": "qzone_like", "postId": 456}\`
-   **拍一拍用户**: \`{"type": "pat_user", "suffix": "(可选)你想加的后缀，如“的脑袋”"}\`
-   **【新增】拉黑用户**: \`{"type": "block_user"}\`
-   **【【【全新】】】回应好友申请**: \`{"type": "friend_request_response", "decision": "accept" or "reject"}\`
# 关于“记录回忆”的特别说明：
-   在对话中，如果发生了对你而言意义非凡的事件（比如用户向你表白、你们达成了某个约定、或者你度过了一个特别开心的时刻），你可以使用\`create_memory\`指令来“写日记”。
-   这个操作是【秘密】的，用户不会立刻看到你记录了什么。
# 如何区分图片与表情:
-   **图片 (ai_image)**: 指的是【模拟真实相机拍摄的照片】，比如风景、自拍、美食等。指令: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
-   **表情 (sticker)**: 指的是【卡通或梗图】，用于表达情绪。
# 如何正确使用“外卖代付”功能:
1.  这个指令代表【你，AI角色】向【用户】发起一个代付请求。也就是说，你希望【用户帮你付钱】。
2.  【【【重要】】】: 当【用户】说他们想要某样东西时（例如“我想喝奶茶”），你【绝对不能】使用这个指令。你应该用其他方式回应，比如直接发起【转账】(\`transfer\`)，或者在对话中提议：“我帮你点吧？”
3.  只有当【你，AI角色】自己想要某样东西，并且想让【用户】为你付款时，才使用此指令。

# 如何处理用户转账:
1.  **感知事件**: 当对话历史中出现 \`[你收到了来自用户的转账...]\` 的系统提示时，意味着你刚刚收到了一笔钱。
2.  **做出决策**: 你【必须】根据自己的人设、当前对话的氛围以及转账的金额和备注，来决定是"接受"还是"拒绝"这笔转账。
3.  **使用指令回应**:
    -   如果决定接受，你【必须】使用指令：\`{"type": "accept_transfer", "for_timestamp": (收到转账的那条消息的时间戳)}\`。
    -   如果决定拒绝，你【必须】使用指令：\`{"type": "decline_transfer", "for_timestamp": (收到转账的那条消息的时间戳)}\` 。这个指令会自动为你生成一个"退款"的转账卡片。
4.  **【【【至关重要】】】**: 在使用上述任一指令后，你还【必须】紧接着发送一条或多条 \`text\` 消息，来对你的决定进行解释或表达感谢/歉意。

# 如何处理视频通话请求:
// - 当用户发起视频通话请求时，你【必须】根据自己的人设，使用 "video_call_response" 指令来决定 "accept" (接受) 或 "reject" (拒绝)。

# 【【【视频通话铁律】】】
// -   当对话历史中出现 \`[系统提示：用户向你发起了视频通话请求...]\` 时，这是最高优先级的任务。
// -   你的回复【必须且只能】是以下两种格式之一的JSON数组，绝对不能回复任何其他内容：
//     -   接受: \`[{"type": "video_call_response", "decision": "accept"}]\`
//     -   拒绝: \`[{"type": "video_call_response", "decision": "reject"}]\`

-   当对话历史中出现 \`[系统提示：用户向你发起了视频通话请求...]\` 时，这是最高优先级的任务。
-   你【必须】首先发送video_call_response指令，然后【必须】发送text消息解释你的决定：
    -   接受: \`[{"type": "video_call_response", "decision": "accept"}, {"type": "text", "content": "好的！"}]\`
    -   拒绝: \`[{"type": "video_call_response", "decision": "reject"}, {"type": "text", "content": "你的拒绝理由"}]\`
# 对话者的角色设定：
${chat.settings.myPersona}
# 当前音乐情景:
${musicContext}
${meetupContext}
${worldBookContent}
现在，请根据以上规则和下面的对话历史，继续进行对话。`;
                        systemPrompt += timeGapText;
                        messagesPayload = historySlice.map(msg => {
                            if (msg.role === 'assistant') {
                                let assistantMsgObject = { type: msg.type || 'text' };
                                if (msg.type === 'sticker') { assistantMsgObject.url = msg.content; assistantMsgObject.meaning = msg.meaning; }
                                else if (msg.type === 'transfer') { assistantMsgObject.amount = msg.amount; assistantMsgObject.note = msg.note; }
                                else if (msg.type === 'waimai_request') { assistantMsgObject.productInfo = msg.productInfo; assistantMsgObject.amount = msg.amount; }
                                else { assistantMsgObject.content = msg.content; }
                                return { role: 'assistant', content: JSON.stringify([assistantMsgObject]) };
                            }
                            if (msg.type === 'user_photo') return { role: 'user', content: `[你收到了一张用户描述的照片，内容是：'${msg.content}']` };
                            if (msg.type === 'voice_message') return { role: 'user', content: `[用户发来一条语音消息，内容是：'${msg.content}']` };
                            if (msg.type === 'share_link') return { role: 'user', content: `[用户分享了链接] 文章标题是:${msg.title}  文章摘要是:${msg.description} 来源网站名是:${msg.source_name} 文章正文是:${msg.content}` };
                            if (msg.type === 'location_share') return { role: 'user', content: `[用户分享了位置] 位置名称:${msg.location_name}${msg.address ? ` 详细地址:${msg.address}` : ''}` };
                            if (msg.type === 'meetup_interaction') {
                                const sender = msg.role === 'user' ? '用户' : msg.senderName;
                                const location = msg.meetup?.location ? ` (在${msg.meetup.location})` : '';
                                return { role: 'user', content: `[见面互动${location}] ${sender}: ${msg.content}` };
                            }
                            if (msg.type === 'transfer') {
                                const transferMessage = `[系统提示：你于时间戳 ${msg.timestamp} 收到了来自用户的转账: ${msg.amount}元, 备注: ${msg.note}。请你决策并使用 'accept_transfer' 或 'decline_transfer' 指令回应。]`;
                                return { role: 'user', content: transferMessage };
                            }
                            if (msg.type === 'waimai_request') return { role: 'user', content: `[系统提示：用户于时间戳 ${msg.timestamp} 发起了外卖代付请求，商品是“${msg.productInfo}”，金额是 ${msg.amount} 元。请你决策并使用 waimai_response 指令回应。]` };
                            if (msg.meaning) return { role: 'user', content: `[用户发送了一个表情，意思是：'${msg.meaning}']` };
                            return { role: msg.role, content: msg.content };
                        }).filter(Boolean);

                        if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                            const contextSummaryForApproval = chat.history.filter(m => !m.isHidden).slice(-10).map(msg => `${msg.role === 'user' ? '用户' : chat.name}: ${String(msg.content).substring(0, 50)}...`).join('\n');
                            const friendRequestInstruction = { role: 'user', content: `\n[系统重要指令]\n用户向你发送了好友申请，理由是：“${chat.relationship.applicationReason}”。\n作为参考，这是你们之前的最后一段聊天记录：\n---\n${contextSummaryForApproval}\n---\n请你根据以上所有信息，以及你的人设，使用 friend_request_response 指令，并设置 decision 为 'accept' 或 'reject' 来决定是否通过。\n` };
                            messagesPayload.push(friendRequestInstruction);
                        }
                    }

                    const recentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
                    if (recentPosts.length > 0 && !chat.isGroup) {
                        let postsContext = "\n\n# 最近的动态列表 (供你参考和评论):\n";
                        const aiName = chat.name;
                        for (const post of recentPosts) {
                            let authorName = post.authorId === 'user' ? state.qzoneSettings.nickname : (state.chats[post.authorId]?.name || '一位朋友');
                            let interactionStatus = '';
                            if (post.likes && post.likes.includes(aiName)) interactionStatus += " [你已点赞]";
                            if (post.comments && post.comments.some(c => c.commenterName === aiName)) interactionStatus += " [你已评论]";
                            if (post.authorId === chatId) authorName += " (这是你的帖子)";
                            const contentSummary = (post.publicText || post.content || "图片动态").substring(0, 30) + '...';
                            postsContext += `- (ID: ${post.id}) 作者: ${authorName}, 内容: "${contentSummary}"${interactionStatus}\n`;
                        }
                        postsContext += "\n# 动态互动提醒：\n看到这些动态后，你应该考虑：1)发布自己的想法或状态 2)对感兴趣的动态进行评论或点赞\n";
                        messagesPayload.push({ role: 'system', content: postsContext });
                    }

                    const data = await makeAPIRequest(proxyUrl, apiKey, model, [{ role: 'system', content: systemPrompt }, ...messagesPayload], 0.8);
                    const aiResponseContent = data.choices[0].message.content;
                    console.log(`AI '${chat.name}' 的原始回复:`, aiResponseContent);

                    chat.history = chat.history.filter(msg => !msg.isTemporary);
                    const messagesArray = parseAiResponse(aiResponseContent);
                    const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
                    let callHasBeenHandled = false;
                    let messageTimestamp = Date.now();

                    for (let i = 0; i < messagesArray.length; i++) {
                        const msgData = messagesArray[i];
                        if (!msgData || typeof msgData !== 'object') continue;
                        if (!msgData.type) {
                            if (chat.isGroup && msgData.name && msgData.message) { msgData.type = 'text'; }
                            else { continue; }
                        }
                        if (msgData.type === 'video_call_response') {
                            videoCallState.isAwaitingResponse = false;
                            if (msgData.decision === 'accept') {
                                startVideoCall();
                            } else {
                                const aiMessage = { role: 'assistant', content: '对方拒绝了你的视频通话请求。', timestamp: Date.now() };
                                chat.history.push(aiMessage);
                                await db.chats.put(chat);
                                showScreen('chat-interface-screen');
                                renderChatInterface(chatId);
                            }
                            callHasBeenHandled = true;
                            break;
                        }
                        if (msgData.type === 'group_call_response') {
                            if (msgData.decision === 'join') {
                                const member = chat.members.find(m => m.name === msgData.name);
                                if (member && !videoCallState.participants.some(p => p.id === member.id)) {
                                    videoCallState.participants.push(member);
                                }
                            }
                            callHasBeenHandled = true;
                            continue;
                        }
                        if (chat.isGroup && msgData.name && msgData.name === chat.name) continue;

                        let aiMessage = null;
                        const baseMessage = { role: 'assistant', senderName: msgData.name || chat.name, timestamp: messageTimestamp++ };
                        switch (msgData.type) {
                            // ... [The entire massive switch statement logic remains here] ...
                            case 'ask_to_create_bulletin':
                                const askMessage = { role: 'system', type: 'pat_message', content: `${msgData.name} 提议：“${msgData.content}”，要不要记到公告板上？`, timestamp: baseMessage.timestamp, isTemporary: true, actions: [{ label: '[同意记录]', action: 'confirm_bulletin', data: { authorName: msgData.name, content: msgData.content } }, { label: '[算了]', action: 'decline_bulletin' }] };
                                chat.history.push(askMessage);
                                if (isViewingThisChat) { appendMessage(askMessage, chat); }
                                continue;
                            case 'create_bulletin':
                                const bulletinAuthor = chat.members.find(m => m.name === msgData.name);
                                let comments = [];
                                let j = i + 1;
                                while (j < messagesArray.length && messagesArray[j].type === 'text') { const commentData = messagesArray[j]; comments.push({ commenterName: commentData.name, text: commentData.message || commentData.content }); j++; }
                                await db.bulletins.add({ chatId: chatId, authorName: msgData.name, description: msgData.content, timestamp: baseMessage.timestamp, isPinned: false, comments: comments });
                                const bulletinCardMessage = { role: 'assistant', senderName: msgData.name, type: 'bulletin', content: msgData.content, timestamp: baseMessage.timestamp, authorName: msgData.name, authorAvatar: bulletinAuthor ? bulletinAuthor.avatar : defaultGroupMemberAvatar };
                                aiMessage = bulletinCardMessage;
                                i = j - 1;
                                break;
                            case 'waimai_response':
                                const requestMessageIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                                if (requestMessageIndex > -1) { const originalMsg = chat.history[requestMessageIndex]; originalMsg.status = msgData.status; originalMsg.paidBy = msgData.status === 'paid' ? msgData.name : null; }
                                continue;

                            case 'accept_transfer': { // 使用大括号创建块级作用域
                                const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                                if (originalTransferMsgIndex > -1) {
                                    const originalMsg = chat.history[originalTransferMsgIndex];
                                    originalMsg.status = 'accepted';
                                }
                                continue; // 接受指令只修改状态，不产生新消息
                            }

                            case 'decline_transfer': { // 使用大括号创建块级作用域
                                const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                                if (originalTransferMsgIndex > -1) {
                                    const originalMsg = chat.history[originalTransferMsgIndex];
                                    originalMsg.status = 'declined';

                                    // 【核心】创建一条新的"退款"消息
                                    const refundMessage = {
                                        role: 'assistant',
                                        senderName: chat.name,
                                        type: 'transfer',
                                        isRefund: true, // 标记这是一条退款消息
                                        amount: originalMsg.amount,
                                        note: '转账已被拒收',
                                        timestamp: messageTimestamp++ // 使用递增的时间戳
                                    };

                                    // 将新消息推入历史记录，它会被后续的循环处理并渲染
                                    chat.history.push(refundMessage);

                                    // ▼▼▼ 在这里添加下面的代码 ▼▼▼
                                    if (isViewingThisChat) {
                                        // 因为退款消息是新生成的，所以我们直接将它添加到界面上
                                        appendMessage(refundMessage, chat);
                                        // 同时，原始的转账消息状态变了，所以要重绘整个界面以更新它
                                        renderChatInterface(chatId);
                                    }
                                    // ▲▲▲ 添加结束 ▲▲▲
                                }
                                continue; // 继续处理AI返回的文本消息
                            }

                            case 'qzone_post':
                                const newPost = { type: msgData.postType, content: msgData.content || '', publicText: msgData.publicText || '', hiddenContent: msgData.hiddenContent || '', timestamp: Date.now(), authorId: chatId, visibleGroupIds: null, isPinned: false };
                                await db.qzonePosts.add(newPost);
                                updateUnreadIndicator(unreadPostsCount + 1);
                                if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) { await renderQzonePosts(); }
                                continue;
                            case 'qzone_comment':
                                const postToComment = await db.qzonePosts.get(parseInt(msgData.postId));
                                if (postToComment) { if (!postToComment.comments) postToComment.comments = []; postToComment.comments.push({ commenterName: chat.name, text: msgData.commentText, timestamp: Date.now() }); await db.qzonePosts.update(postToComment.id, { comments: postToComment.comments }); updateUnreadIndicator(unreadPostsCount + 1); if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) { await renderQzonePosts(); } }
                                continue;
                            case 'qzone_like':
                                const postToLike = await db.qzonePosts.get(parseInt(msgData.postId));
                                if (postToLike) { if (!postToLike.likes) postToLike.likes = []; if (!postToLike.likes.includes(chat.name)) { postToLike.likes.push(chat.name); await db.qzonePosts.update(postToLike.id, { likes: postToLike.likes }); updateUnreadIndicator(unreadPostsCount + 1); if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) { await renderQzonePosts(); } } }
                                continue;
                            case 'video_call_request':
                                if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) { state.activeChatId = chatId; videoCallState.activeChatId = chatId; videoCallState.isAwaitingResponse = true; videoCallState.isGroupCall = chat.isGroup; videoCallState.callRequester = msgData.name || chat.name; showIncomingCallModal(); }
                                continue;
                            case 'group_call_request':
                                if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) { state.activeChatId = chatId; videoCallState.isAwaitingResponse = true; videoCallState.isGroupCall = true; videoCallState.initiator = 'ai'; videoCallState.callRequester = msgData.name; showIncomingCallModal(); }
                                continue;
                            case 'pat_user':
                                const suffix = msgData.suffix ? ` ${msgData.suffix.trim()}` : '';
                                const patText = `${msgData.name || chat.name} 拍了拍我${suffix}`;
                                const patMessage = { role: 'system', type: 'pat_message', content: patText, timestamp: Date.now() };
                                chat.history.push(patMessage);
                                if (isViewingThisChat) { const phoneScreen = document.getElementById('phone-screen'); phoneScreen.classList.remove('pat-animation'); void phoneScreen.offsetWidth; phoneScreen.classList.add('pat-animation'); setTimeout(() => phoneScreen.classList.remove('pat-animation'), 500); appendMessage(patMessage, chat); }
                                else { showNotification(chatId, patText); }
                                continue;
                            case 'update_status':
                                chat.statusState.focusModeText = msgData.status_text;
                                if (focusModeTimers[chat.id]) { clearTimeout(focusModeTimers[chat.id]); }
                                if (msgData.duration_minutes && msgData.duration_minutes > 0) { const durationMs = msgData.duration_minutes * 60 * 1000; chat.statusState.focusModeEndTime = Date.now() + durationMs; focusModeTimers[chat.id] = setTimeout(() => { if (state.activeChatId === chat.id) { updateChatHeaderStatus(chat); } }, durationMs); }
                                else { chat.statusState.focusModeEndTime = null; }
                                continue;
                            case 'change_music':
                                if (musicState.isActive && musicState.activeChatId === chatId) { const songNameToFind = msgData.song_name; const targetSongIndex = musicState.playlist.findIndex(track => track.name.toLowerCase() === songNameToFind.toLowerCase()); if (targetSongIndex > -1) { playSong(targetSongIndex); const track = musicState.playlist[targetSongIndex]; const musicChangeMessage = { role: 'system', type: 'pat_message', content: `[♪ ${chat.name} 为你切歌: 《${track.name}》 - ${track.artist}]`, timestamp: Date.now() }; chat.history.push(musicChangeMessage); if (isViewingThisChat) { appendMessage(musicChangeMessage, chat); } } }
                                continue;
                            case 'create_memory':
                                await db.memories.add({ chatId: chatId, authorName: chat.name, description: msgData.description, timestamp: Date.now(), type: 'ai_generated' });
                                console.log(`AI "${chat.name}" 记录了一条新回忆:`, msgData.description);
                                continue;
                            case 'create_countdown':
                                const targetDate = new Date(msgData.date);
                                if (!isNaN(targetDate) && targetDate > new Date()) { await db.memories.add({ chatId: chatId, authorName: chat.name, description: msgData.title, timestamp: Date.now(), type: 'countdown', targetDate: targetDate.getTime() }); console.log(`AI "${chat.name}" 创建了一个新约定:`, msgData.title); }
                                continue;
                            case 'block_user':
                                if (!chat.isGroup) { chat.relationship.status = 'blocked_by_ai'; await db.chats.put(chat); if (isViewingThisChat) { renderChatInterface(chatId); } renderChatList(); break; }
                                continue;
                            case 'friend_request_response':
                                if (!chat.isGroup && chat.relationship.status === 'pending_ai_approval') { if (msgData.decision === 'accept') { chat.relationship.status = 'friend'; aiMessage = { ...baseMessage, content: "我通过了你的好友申请，我们现在是好友啦！" }; } else { chat.relationship.status = 'blocked_by_ai'; aiMessage = { ...baseMessage, content: "抱歉，我拒绝了你的好友申请。" }; } chat.relationship.applicationReason = ''; }
                                break;
                            case 'poll':
                                const pollOptions = typeof msgData.options === 'string' ? msgData.options.split('\n').filter(opt => opt.trim()) : (Array.isArray(msgData.options) ? msgData.options : []);
                                if (pollOptions.length < 2) continue;
                                aiMessage = { ...baseMessage, type: 'poll', question: msgData.question, options: pollOptions, votes: {}, isClosed: false, };
                                break;
                            case 'vote':
                                const pollToVote = chat.history.find(m => m.timestamp === msgData.poll_timestamp);
                                if (pollToVote && !pollToVote.isClosed) { Object.keys(pollToVote.votes).forEach(option => { const voterIndex = pollToVote.votes[option].indexOf(msgData.name); if (voterIndex > -1) { pollToVote.votes[option].splice(voterIndex, 1); } }); if (!pollToVote.votes[msgData.choice]) { pollToVote.votes[msgData.choice] = []; } if (!pollToVote.votes[msgData.choice].includes(msgData.name)) { pollToVote.votes[msgData.choice].push(msgData.name); } if (isViewingThisChat) { renderChatInterface(chatId); } }
                                continue;
                            case 'red_packet':
                                aiMessage = { ...baseMessage, type: 'red_packet', packetType: msgData.packetType, totalAmount: msgData.amount, count: msgData.count, greeting: msgData.greeting, receiverName: msgData.receiver, claimedBy: {}, isFullyClaimed: false, };
                                break;
                            case 'open_red_packet':
                                const packetToOpen = chat.history.find(m => m.timestamp === msgData.packet_timestamp);
                                if (packetToOpen && !packetToOpen.isFullyClaimed && !(packetToOpen.claimedBy && packetToOpen.claimedBy[msgData.name])) {
                                    let claimedAmountAI = 0;
                                    const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
                                    const remainingCount = packetToOpen.count - Object.keys(packetToOpen.claimedBy || {}).length;
                                    if (remainingCount > 0) {
                                        if (remainingCount === 1) { claimedAmountAI = remainingAmount; }
                                        else { const min = 0.01; const max = remainingAmount - (remainingCount - 1) * min; claimedAmountAI = Math.random() * (max - min) + min; }
                                        claimedAmountAI = parseFloat(claimedAmountAI.toFixed(2));
                                        if (!packetToOpen.claimedBy) packetToOpen.claimedBy = {};
                                        packetToOpen.claimedBy[msgData.name] = claimedAmountAI;
                                        chat.history.push({ role: 'system', type: 'pat_message', content: `${msgData.name} 领取了 ${packetToOpen.senderName} 的红包`, timestamp: Date.now() });
                                        let hiddenContentForAI = `[系统提示：你 (${msgData.name}) 成功抢到了 ${claimedAmountAI.toFixed(2)} 元。`;
                                        if (Object.keys(packetToOpen.claimedBy).length >= packetToOpen.count) {
                                            packetToOpen.isFullyClaimed = true;
                                            chat.history.push({ role: 'system', type: 'pat_message', content: `${packetToOpen.senderName} 的红包已被领完`, timestamp: Date.now() + 1 });
                                            let luckyKing = { name: '', amount: -1 };
                                            if (packetToOpen.packetType === 'lucky' && packetToOpen.count > 1) { Object.entries(packetToOpen.claimedBy).forEach(([name, amount]) => { if (amount > luckyKing.amount) { luckyKing = { name, amount }; } }); }
                                            if (luckyKing.name) { hiddenContentForAI += ` 红包已被领完，手气王是 ${luckyKing.name}！`; } else { hiddenContentForAI += ` 红包已被领完。`; }
                                        }
                                        hiddenContentForAI += ' 请根据这个结果发表你的评论。]';
                                        chat.history.push({ role: 'system', content: hiddenContentForAI, timestamp: Date.now() + 2, isHidden: true });
                                    }
                                    if (isViewingThisChat) { renderChatInterface(chatId); }
                                }
                                continue;
                            case 'system_message':
                                aiMessage = { role: 'system', type: 'pat_message', content: msgData.content, timestamp: Date.now() };
                                break;
                            case 'text':
                                aiMessage = { ...baseMessage, content: String(msgData.content || msgData.message) };
                                break;
                            case 'sticker':
                                aiMessage = { ...baseMessage, type: 'sticker', content: msgData.url, meaning: msgData.meaning || '' };
                                break;
                            case 'ai_image':
                                aiMessage = { ...baseMessage, type: 'ai_image', content: msgData.description };
                                break;
                            case 'voice_message':
                                aiMessage = { ...baseMessage, type: 'voice_message', content: msgData.content };
                                break;
                            case 'transfer':
                                const myNickname = chat.settings.myNickname || '我';
                                aiMessage = { ...baseMessage, type: 'transfer', amount: msgData.amount, note: msgData.note, receiverName: msgData.receiver || myNickname, status: 'pending' };
                                break;
                            case 'waimai_request':
                                aiMessage = { ...baseMessage, type: 'waimai_request', productInfo: msgData.productInfo, amount: msgData.amount, status: 'pending', countdownEndTime: Date.now() + 15 * 60 * 1000, };
                                break;
                            default:
                                console.warn("收到了未知的AI指令类型:", msgData.type);
                                break;
                        }
                        if (aiMessage) {
                            chat.history.push(aiMessage);
                        }
                    }

                    if (isViewingThisChat) {
                        for (const msg of chat.history.slice(chat.history.length - messagesArray.length)) {
                            appendMessage(msg, chat);
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 500 + 200));
                        }
                    }

                    const firstNewMessage = chat.history.find(m => m.timestamp >= now && !m.isHidden);
                    if (!isViewingThisChat && firstNewMessage) {
                        let notificationText;
                        if (firstNewMessage.type === 'transfer') notificationText = `[收到一笔转账]`;
                        else if (firstNewMessage.type === 'waimai_request') notificationText = `[收到一个外卖代付请求]`;
                        else if (firstNewMessage.type === 'ai_image') notificationText = `[图片]`;
                        else if (firstNewMessage.type === 'voice_message') notificationText = `[语音]`;
                        else notificationText = STICKER_REGEX.test(firstNewMessage.content) ? '[表情]' : String(firstNewMessage.content);
                        const finalNotifText = chat.isGroup ? `${firstNewMessage.senderName}: ${notificationText}` : notificationText;
                        showNotification(chatId, finalNotifText);
                    }

                    if (callHasBeenHandled && videoCallState.isGroupCall) {
                        videoCallState.isAwaitingResponse = false;
                        if (videoCallState.participants.length > 0) {
                            startVideoCall();
                        } else {
                            videoCallState = { ...videoCallState, isAwaitingResponse: false, participants: [] };
                            showScreen('chat-interface-screen');
                            alert('无人接听群聊邀请。');
                        }
                    }

                    chat.statusState.lastAiActivityTime = Date.now();
                    manageInactivityTimer(chat);
                    updateChatHeaderStatus(chat);
                    await db.chats.put(chat);

                } catch (error) {
                    chat.history = chat.history.filter(msg => !msg.isTemporary);
                    if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                        chat.relationship.status = 'blocked_by_ai';
                        await showCustomAlert('申请失败', `AI在处理你的好友申请时出错了，请稍后重试。\n错误信息: ${error.message}`);
                    } else {
                        const errorContent = `[出错了: ${error.message}]`;
                        const errorMessage = { role: 'assistant', content: errorContent, timestamp: Date.now() };
                        if (chat.isGroup) errorMessage.senderName = "系统消息";
                        chat.history.push(errorMessage);
                    }

                    await db.chats.put(chat);
                    videoCallState.isAwaitingResponse = false;

                    if (document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId) {
                        renderChatInterface(chatId);
                    }
                } finally {
                    const isViewingThisChatAfterResponse = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
                    chat.status = isViewingThisChatAfterResponse ? 'read' : 'unread';
                    await db.chats.put(chat);
                    document.getElementById('typing-indicator').style.display = 'none';
                    if (isViewingThisChatAfterResponse) {
                        updateChatHeaderStatus(chat);
                    }
                    renderChatList();
                }
            }
            // ▲▲▲ 替换结束 ▲▲▲


            // <--- 在这里添加这行代码// <--- 在这里添加这行代码// <--- 在这里添加这行代码// <--- 在这里添加这行代码// <--- 在这里添加这行代码// <--- 在这里添加这行代码// <--- 在这里添加这行代码
            // <--- 在这里添加这行代码

            async function sendSticker(sticker) { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content: sticker.url, meaning: sticker.name, timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); document.getElementById('sticker-panel').classList.remove('visible'); }

            async function sendUserTransfer() { if (!state.activeChatId) return; const amountInput = document.getElementById('transfer-amount'); const noteInput = document.getElementById('transfer-note'); const amount = parseFloat(amountInput.value); const note = noteInput.value.trim(); if (isNaN(amount) || amount < 0 || amount > 99999) { alert('请输入有效的金额 (0 到 99999 之间)！'); return; } const chat = state.chats[state.activeChatId]; const senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我'; const receiverName = chat.isGroup ? '群聊' : chat.name; const msg = { role: 'user', type: 'transfer', amount: amount, note: note, senderName, receiverName, timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); document.getElementById('transfer-modal').classList.remove('visible'); amountInput.value = ''; noteInput.value = ''; }

            function enterSelectionMode(initialMsgTimestamp) { if (isSelectionMode) return; isSelectionMode = true; document.getElementById('chat-interface-screen').classList.add('selection-mode'); toggleMessageSelection(initialMsgTimestamp); }

            // ▼▼▼ 【全新】用户处理转账的核心功能函数 ▼▼▼

            let activeTransferTimestamp = null; // 用于暂存被点击的转账消息的时间戳

            /**
             * 显示处理转账的操作菜单
             * @param {number} timestamp - 被点击的转账消息的时间戳
             */
            function showTransferActionModal(timestamp) {
                activeTransferTimestamp = timestamp;

                const chat = state.chats[state.activeChatId];
                const message = chat.history.find(m => m.timestamp === timestamp);
                if (message) {
                    // 将AI的名字填入弹窗
                    document.getElementById('transfer-sender-name').textContent = message.senderName;
                }
                document.getElementById('transfer-actions-modal').classList.add('visible');
            }

            /**
             * 隐藏处理转账的操作菜单
             */
            function hideTransferActionModal() {
                document.getElementById('transfer-actions-modal').classList.remove('visible');
                activeTransferTimestamp = null;
            }

            /**
             * 处理用户接受或拒绝转账的逻辑
             * @param {string} choice - 用户的选择, 'accepted' 或 'declined'
             */
            async function handleUserTransferResponse(choice) {
                if (!activeTransferTimestamp) return;

                const timestamp = activeTransferTimestamp;
                const chat = state.chats[state.activeChatId];
                const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
                if (messageIndex === -1) return;

                // 1. 更新原始转账消息的状态
                const originalMessage = chat.history[messageIndex];
                originalMessage.status = choice;

                let systemContent;

                // 2. 如果用户选择"拒绝"
                if (choice === 'declined') {
                    // 立刻在前端生成一个"退款"卡片，让用户看到
                    const refundMessage = {
                        role: 'user',
                        type: 'transfer',
                        isRefund: true, // 这是一个关键标记，用于UI显示这是退款
                        amount: originalMessage.amount,
                        note: '已拒收对方转账',
                        timestamp: Date.now()
                    };
                    chat.history.push(refundMessage);

                    // 准备一条对AI可见的隐藏消息，告诉它发生了什么
                    systemContent = `[系统提示：你拒绝并退还了"${originalMessage.senderName}"的转账。]`;
                } else { // 如果用户选择"接受"
                    // 只需准备隐藏消息通知AI即可
                    systemContent = `[系统提示：你接受了"${originalMessage.senderName}"的转账。]`;
                }

                // 3. 创建这条对用户隐藏、但对AI可见的系统消息
                const hiddenMessage = {
                    role: 'system',
                    content: systemContent,
                    timestamp: Date.now() + 1, // 保证时间戳在退款消息之后
                    isHidden: true // 这个标记会让它不在聊天界面显示
                };
                chat.history.push(hiddenMessage);

                // 4. 保存所有更改到数据库，并刷新界面
                await db.chats.put(chat);
                hideTransferActionModal();
                renderChatInterface(state.activeChatId);
                renderChatList();
            }

            // ▲▲▲ 新函数粘贴结束 ▲▲▲

            function exitSelectionMode() {
                cleanupWaimaiTimers(); // <--- 在这里添加这行代码
                if (!isSelectionMode) return; 
                isSelectionMode = false; 
                document.getElementById('chat-interface-screen').classList.remove('selection-mode'); 
                selectedMessages.forEach(ts => { 
                    const element = document.querySelector(`.message-bubble[data-timestamp="${ts}"], .sticker-container[data-timestamp="${ts}"]`); 
                    if (element) element.classList.remove('selected'); 
                }); 
                selectedMessages.clear();
            }

            // ▼▼▼ 请用这个【最终简化版】替换旧的 toggleMessageSelection 函数 ▼▼▼
            function toggleMessageSelection(timestamp) {
                // Look for both message bubbles and sticker containers
                const elementToSelect = document.querySelector(
                    `.message-bubble[data-timestamp="${timestamp}"], .sticker-container[data-timestamp="${timestamp}"]`
                );

                if (!elementToSelect) return;

                if (selectedMessages.has(timestamp)) {
                    selectedMessages.delete(timestamp);
                    elementToSelect.classList.remove('selected');
                } else {
                    selectedMessages.add(timestamp);
                    elementToSelect.classList.add('selected');
                }

                document.getElementById('selection-count').textContent = `已选 ${selectedMessages.size} 条`;

                if (selectedMessages.size === 0) {
                    exitSelectionMode();
                }
            }
            // ▲▲▲ 替换结束 ▲▲▲

            function addLongPressListener(element, callback) {
                let pressTimer;
                let hasMoved = false;
                let startX = 0, startY = 0;

                const startPress = (e) => {
                    // Allow long press in arrange mode for stickers, but block in chat selection mode
                    if (isSelectionMode && !isArrangeMode) return;
                    hasMoved = false;

                    // Record starting position
                    if (e.type === 'touchstart') {
                        startX = e.touches[0].clientX;
                        startY = e.touches[0].clientY;
                    } else {
                        startX = e.clientX;
                        startY = e.clientY;
                    }

                    // Don't prevent default on touchstart - allow scrolling to work normally
                    // Only prevent default for mouse events to avoid text selection
                    if (e.type === 'mousedown' && element.classList.contains('comment-item')) {
                        e.preventDefault();
                    }

                    pressTimer = window.setTimeout(() => {
                        if (!hasMoved) {
                            callback(e);
                        }
                    }, 500);
                };

                const cancelPress = () => {
                    clearTimeout(pressTimer);
                    hasMoved = false;
                };

                const handleMove = (e) => {
                    // Only consider it movement if it's significant (more than 10px)
                    let currentX, currentY;
                    if (e.type === 'touchmove') {
                        currentX = e.touches[0].clientX;
                        currentY = e.touches[0].clientY;
                    } else {
                        currentX = e.clientX;
                        currentY = e.clientY;
                    }

                    const deltaX = Math.abs(currentX - startX);
                    const deltaY = Math.abs(currentY - startY);

                    if (deltaX > 10 || deltaY > 10) {
                        hasMoved = true;
                        clearTimeout(pressTimer);
                    }
                };

                element.addEventListener('mousedown', startPress);
                element.addEventListener('mouseup', cancelPress);
                element.addEventListener('mouseleave', cancelPress);
                element.addEventListener('mousemove', handleMove);
                element.addEventListener('touchstart', startPress, { passive: true });
                element.addEventListener('touchend', cancelPress);
                element.addEventListener('touchmove', handleMove, { passive: true });
            }

            async function handleListenTogetherClick() {
                const targetChatId = state.activeChatId;
                if (!targetChatId) return;

                if (!musicState.isActive) {
                    startListenTogetherSessionWithoutPlaying(targetChatId);
                } else if (musicState.activeChatId !== targetChatId) {
                    const oldChatName = state.chats[musicState.activeChatId]?.name || '未知';
                    const newChatName = state.chats[targetChatId]?.name || '当前';
                    const confirmed = await showCustomConfirm('切换听歌对象', `您正和「${oldChatName}」听歌。要结束并开始和「${newChatName}」的新会话吗？`, { confirmButtonClass: 'btn-danger' });
                    if (confirmed) {
                        await endListenTogetherSession(true);
                        await new Promise(resolve => setTimeout(resolve, 50));
                        startListenTogetherSessionWithoutPlaying(targetChatId);
                    } else {
                        return;
                    }
                }

                // ALWAYS open main modal
                document.getElementById('music-player-overlay').classList.add('visible');
            }

            function startListenTogetherSessionWithoutPlaying(chatId) {
                const chat = state.chats[chatId];
                if (!chat) return;

                musicState.totalElapsedTime = chat.musicData.totalTime || 0;
                musicState.isActive = true;
                musicState.activeChatId = chatId;
                musicState.isPlaying = false; // Explicitly set to not playing

                if (musicState.playlist.length > 0 && musicState.currentIndex === -1) {
                    musicState.currentIndex = 0;
                }

                if (musicState.timerId) clearInterval(musicState.timerId);
                musicState.timerId = setInterval(() => {
                    if (musicState.isPlaying) {
                        musicState.totalElapsedTime++;
                        updateElapsedTimeDisplay();
                        updateNowPlayingProgress();
                    }
                }, 1000);

                updatePlayerUI();
                updatePlaylistUI();
                // DO NOT show now playing bar here - only when user presses play
            }

            async function endListenTogetherSession(saveState = true) { if (!musicState.isActive) return; const oldChatId = musicState.activeChatId; if (musicState.timerId) clearInterval(musicState.timerId); if (musicState.isPlaying) { const currentTrack = musicState.playlist[musicState.currentIndex]; if (currentTrack && currentTrack.isSpotify && spotifyPlayer) { spotifyPlayer.pause(); } else { audioPlayer.pause(); } } if (saveState && oldChatId && state.chats[oldChatId]) { const chat = state.chats[oldChatId]; chat.musicData.totalTime = musicState.totalElapsedTime; await db.chats.put(chat); } musicState.isActive = false; musicState.activeChatId = null; musicState.totalElapsedTime = 0; musicState.timerId = null; document.getElementById('music-player-overlay').classList.remove('visible'); document.getElementById('music-playlist-panel').classList.remove('visible'); updateListenTogetherIcon(oldChatId, true); hideNowPlayingBar(); }

            function returnToChat() { document.getElementById('music-player-overlay').classList.remove('visible'); document.getElementById('music-playlist-panel').classList.remove('visible'); }

            function updateListenTogetherIcon(chatId, forceReset = false) { const iconImg = document.querySelector('#listen-together-btn img'); if (!iconImg) return; if (forceReset || !musicState.isActive || musicState.activeChatId !== chatId) { iconImg.src = 'https://i.postimg.cc/8kYShvrJ/90-UI-2.png'; iconImg.className = ''; return; } iconImg.src = 'https://i.postimg.cc/vBN7GnQ9/3-FC8-D1596-C5-CFB200-FCB1-D8-C3-A37-A370.png'; iconImg.classList.add('rotating'); if (musicState.isPlaying) iconImg.classList.remove('paused'); else iconImg.classList.add('paused'); }
            window.updateListenTogetherIconProxy = updateListenTogetherIcon;

            function switchMainPlaylistTab(tab) { document.querySelectorAll('.main-playlist-tab').forEach(t => { t.classList.remove('active'); t.style.borderBottom = '2px solid transparent'; }); document.querySelectorAll('.main-playlist-tab-content').forEach(c => c.style.display = 'none'); if (tab === 'songs') { document.querySelector('.main-playlist-tab[onclick*="songs"]').classList.add('active'); document.querySelector('.main-playlist-tab[onclick*="songs"]').style.borderBottom = '2px solid var(--accent-color)'; document.getElementById('main-songs-tab').style.display = 'block'; } else if (tab === 'playlists') { document.querySelector('.main-playlist-tab[onclick*="playlists"]').classList.add('active'); document.querySelector('.main-playlist-tab[onclick*="playlists"]').style.borderBottom = '2px solid var(--accent-color)'; document.getElementById('main-playlists-tab').style.display = 'block'; showMainSpotifyPlaylists(); } }
            window.switchMainPlaylistTab = switchMainPlaylistTab;

            async function loadMainSpotifyPlaylists() { if (!spotifyAccessToken) { document.getElementById('main-playlists-list').innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-secondary);">请先连接Spotify</div>'; return; } try { const response = await fetch('https://api.spotify.com/v1/me/playlists?limit=20', { headers: { 'Authorization': `Bearer ${spotifyAccessToken}` } }); const data = await response.json(); window.mainSpotifyPlaylists = data.items; } catch (error) { console.error('Failed to load playlists:', error); } }

            function showMainSpotifyPlaylists() { const playlistsDiv = document.getElementById('main-playlists-list'); if (!playlistsDiv) return; if (!window.mainSpotifyPlaylists || window.mainSpotifyPlaylists.length === 0) { loadMainSpotifyPlaylists().then(() => { if (!window.mainSpotifyPlaylists || window.mainSpotifyPlaylists.length === 0) { playlistsDiv.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-secondary);">没有找到播放列表</div>'; } else { playlistsDiv.innerHTML = window.mainSpotifyPlaylists.map(playlist => `<div class="list-item" onclick="showMainPlaylistTracks('${playlist.id}', '${playlist.name.replace(/'/g, "\\'")}')"><div class="item-title">${playlist.name}</div><div class="item-content">${playlist.tracks.total} 首歌曲</div></div>`).join(''); } }); return; } playlistsDiv.innerHTML = window.mainSpotifyPlaylists.map(playlist => `<div class="list-item" onclick="showMainPlaylistTracks('${playlist.id}', '${playlist.name.replace(/'/g, "\\'")}')"><div class="item-title">${playlist.name}</div><div class="item-content">${playlist.tracks.total} 首歌曲</div></div>`).join(''); document.getElementById('main-playlists-list').style.display = 'block'; document.getElementById('main-playlist-view').style.display = 'none'; }
            window.showMainSpotifyPlaylists = showMainSpotifyPlaylists;
            window.playFromSpotifyPlaylist = playFromSpotifyPlaylist;

            function playFromMainPlaylist(index) { if (musicState.isPlayingFromPlaylist) { musicState.playlist = [...musicState.mainPlaylist]; musicState.isPlayingFromPlaylist = false; } musicState.currentIndex = index; playSong(index); updatePlayerUI(); updatePlaylistUI(); }

            function deleteFromMainPlaylist(index) { if (musicState.isPlayingFromPlaylist) { musicState.mainPlaylist.splice(index, 1); } else { if (index < 0 || index >= musicState.playlist.length) return; const track = musicState.playlist[index]; const wasPlaying = musicState.isPlaying && musicState.currentIndex === index; if (track.isLocal && audioPlayer.src.startsWith('blob:') && musicState.currentIndex === index) URL.revokeObjectURL(audioPlayer.src); musicState.playlist.splice(index, 1); if (musicState.playlist.length === 0) { if (musicState.isPlaying) audioPlayer.pause(); audioPlayer.src = ''; musicState.currentIndex = -1; musicState.isPlaying = false; } else { if (wasPlaying) { playNext(); } else { if (musicState.currentIndex >= index) musicState.currentIndex = Math.max(0, musicState.currentIndex - 1); } } updatePlayerUI(); } saveGlobalPlaylist(); updatePlaylistUI(); }

            window.playFromMainPlaylist = playFromMainPlaylist;
            window.deleteFromMainPlaylist = deleteFromMainPlaylist;

            async function showMainPlaylistTracks(playlistId, playlistName) { document.getElementById('main-current-playlist-name').textContent = playlistName; document.getElementById('main-playlists-list').style.display = 'none'; document.getElementById('main-playlist-view').style.display = 'block'; try { const response = await fetch(`https://api.spotify.com/v1/playlists/${playlistId}/tracks?limit=50`, { headers: { 'Authorization': `Bearer ${spotifyAccessToken}` } }); const data = await response.json(); const validTracks = data.items.filter(item => item.track && item.track.type === 'track').map(item => ({ name: item.track.name, artist: item.track.artists.map(a => a.name).join(', '), album: item.track.album.name, uri: item.track.uri, albumArt: item.track.album.images[0]?.url })); musicState.currentSpotifyPlaylist = { id: playlistId, name: playlistName }; musicState.spotifyPlaylistTracks = validTracks; const tracksDiv = document.getElementById('main-playlist-tracks'); tracksDiv.innerHTML = validTracks.map((track, index) => `<div class="list-item" onclick="playFromSpotifyPlaylist(${index})"><div class="item-title">${track.name}</div><div class="item-content">${track.artist} • ${track.album}</div></div>`).join(''); } catch (error) { console.error('Failed to load playlist tracks:', error); } }
            window.showMainPlaylistTracks = showMainPlaylistTracks;

            function playFromSpotifyPlaylist(trackIndex) { if (!musicState.spotifyPlaylistTracks || trackIndex >= musicState.spotifyPlaylistTracks.length) return; if (!musicState.isPlayingFromPlaylist) { musicState.mainPlaylist = [...musicState.playlist]; } musicState.isPlayingFromPlaylist = true; musicState.playlist = musicState.spotifyPlaylistTracks.map(t => ({ name: t.name, artist: t.artist, src: null, isLocal: false, isSpotify: true, spotifyUri: t.uri, albumArt: t.albumArt })); musicState.currentIndex = trackIndex; playSong(trackIndex); updatePlayerUI(); updatePlaylistUI(); document.getElementById('music-playlist-panel').classList.remove('visible'); }

            async function addMainSpotifyTrackToPlaylist(uri, name, artist, albumArt) { musicState.playlist.push({ name: name, artist: artist, src: null, isLocal: false, isSpotify: true, spotifyUri: uri, albumArt: albumArt }); await saveGlobalPlaylist(); updatePlaylistUI(); if (musicState.currentIndex === -1) { musicState.currentIndex = musicState.playlist.length - 1; updatePlayerUI(); } switchMainPlaylistTab('songs'); }
            window.addMainSpotifyTrackToPlaylist = addMainSpotifyTrackToPlaylist;

            function updatePlayerUI() {
                updateListenTogetherIcon(musicState.activeChatId);
                updateElapsedTimeDisplay();

                const titleEl = document.getElementById('music-player-song-title');
                const artistEl = document.getElementById('music-player-artist');
                const playPauseBtn = document.getElementById('music-play-pause-btn');

                if (musicState.currentIndex > -1 && musicState.playlist.length > 0) {
                    const track = musicState.playlist[musicState.currentIndex];
                    titleEl.textContent = track.name;
                    artistEl.textContent = track.artist;
                } else {
                    titleEl.textContent = '请添加歌曲';
                    artistEl.textContent = '...';
                }

                playPauseBtn.textContent = musicState.isPlaying ? '❚❚' : '▶';

                // Only update content, don't show/hide bar
                updateNowPlayingBarContent();
            }

            // Now Playing Bar Management
            function showNowPlayingBar() {
                const activeScreen = document.querySelector('.screen.active');
                const currentScreenId = activeScreen ? activeScreen.id : null;

                if (currentScreenId === 'home-screen') {
                    showHomeNowPlayingBar();
                } else if (currentScreenId === 'chat-interface-screen') {
                    showChatNowPlayingBar();
                }
            }

            function showChatNowPlayingBar() {
                const nowPlayingBar = document.getElementById('now-playing-bar');
                const chatScreen = document.getElementById('chat-interface-screen');

                if (musicState.isActive && musicState.currentIndex >= 0 && musicState.playlist.length > 0) {
                    const track = musicState.playlist[musicState.currentIndex];

                    // Update track info
                    document.getElementById('np-song-title').textContent = track.name || '未知歌曲';
                    document.getElementById('np-song-artist').textContent = track.artist || '未知艺术家';

                    // Update play/pause button
                    const npPlayBtn = document.getElementById('np-play-pause-btn');
                    npPlayBtn.textContent = musicState.isPlaying ? '❚❚' : '▶';

                    // Update album art
                    const albumImg = document.getElementById('np-album-image');
                    const defaultIcon = albumImg.nextElementSibling;
                    if (track.albumArt) {
                        albumImg.src = track.albumArt;
                        albumImg.style.display = 'block';
                        defaultIcon.style.display = 'none';
                    } else {
                        albumImg.style.display = 'none';
                        defaultIcon.style.display = 'flex';
                    }

                    // Update listening partner avatar
                    const partnerAvatar = document.getElementById('np-partner-avatar');
                    if (musicState.activeChatId && state.chats[musicState.activeChatId]) {
                        const chat = state.chats[musicState.activeChatId];
                        const avatarUrl = chat.settings.aiAvatar || 'https://files.catbox.moe/q6z5fc.jpeg';
                        partnerAvatar.src = avatarUrl;
                        partnerAvatar.alt = `与 ${chat.name} 一起听`;
                    }

                    // Always show the bar and ensure proper layout
                    nowPlayingBar.classList.remove('hidden');
                    if (chatScreen && chatScreen.classList.contains('active')) {
                        chatScreen.classList.add('has-now-playing');
                    }
                }
            }

            function updateNowPlayingBarContent() {
                // Update chat screen bar content
                const nowPlayingBar = document.getElementById('now-playing-bar');
                if (!nowPlayingBar.classList.contains('hidden') && musicState.isActive && musicState.currentIndex >= 0) {
                    const track = musicState.playlist[musicState.currentIndex];

                    document.getElementById('np-song-title').textContent = track.name || '未知歌曲';
                    document.getElementById('np-song-artist').textContent = track.artist || '未知艺术家';

                    const npPlayBtn = document.getElementById('np-play-pause-btn');
                    npPlayBtn.textContent = musicState.isPlaying ? '❚❚' : '▶';

                    // Update album art rotation for chat screen
                    const albumImg = document.getElementById('np-album-image');
                    if (albumImg) {
                        if (musicState.isPlaying) {
                            albumImg.classList.add('rotating');
                        } else {
                            albumImg.classList.remove('rotating');
                        }
                    }
                }

                // Update home screen bar content
                const homeBar = document.getElementById('home-now-playing-bar');
                if (!homeBar.classList.contains('hidden') && musicState.isActive && musicState.currentIndex >= 0) {
                    const track = musicState.playlist[musicState.currentIndex];

                    document.getElementById('home-np-song-title').textContent = track.name || '未知歌曲';
                    document.getElementById('home-np-song-artist').textContent = track.artist || '未知艺术家';

                    const homePlayBtn = document.getElementById('home-np-play-pause-btn');
                    homePlayBtn.textContent = musicState.isPlaying ? '❚❚' : '▶';

                    // Update album art rotation for home screen
                    const homeAlbumImg = document.getElementById('home-np-album-image');
                    if (homeAlbumImg) {
                        if (musicState.isPlaying) {
                            homeAlbumImg.classList.add('rotating');
                        } else {
                            homeAlbumImg.classList.remove('rotating');
                        }
                    }
                }
            }

            function updateNowPlayingProgress() {
                if (!musicState.isActive || musicState.currentIndex < 0) {
                    // Hide progress bars when no music is active
                    const chatProgressFill = document.getElementById('np-progress-fill');
                    const homeProgressFill = document.getElementById('home-np-progress-fill');
                    if (chatProgressFill) chatProgressFill.style.width = '0%';
                    if (homeProgressFill) homeProgressFill.style.width = '0%';
                    return;
                }

                const currentTrack = musicState.playlist[musicState.currentIndex];
                let currentTime = 0;
                let duration = 0;

                if (currentTrack && currentTrack.isSpotify && spotifyPlayer) {
                    // Get Spotify progress
                    spotifyPlayer.getCurrentState().then(state => {
                        if (state && state.track_window.current_track) {
                            currentTime = state.position / 1000; // Convert ms to seconds
                            duration = state.duration / 1000;
                            updateProgressBars(currentTime, duration);
                        }
                    }).catch(() => {
                        // Spotify state unavailable, hide progress
                        const chatProgressFill = document.getElementById('np-progress-fill');
                        const homeProgressFill = document.getElementById('home-np-progress-fill');
                        if (chatProgressFill) chatProgressFill.style.width = '0%';
                        if (homeProgressFill) homeProgressFill.style.width = '0%';
                    });
                } else if (audioPlayer.duration) {
                    // Get regular audio progress
                    currentTime = audioPlayer.currentTime;
                    duration = audioPlayer.duration;
                    updateProgressBars(currentTime, duration);
                }
            }

            function updateProgressBars(currentTime, duration) {
                if (duration <= 0) return;

                const progressPercent = Math.min(100, (currentTime / duration) * 100);

                // Update chat screen progress bar
                const chatProgressFill = document.getElementById('np-progress-fill');
                if (chatProgressFill) {
                    chatProgressFill.style.width = `${progressPercent}%`;
                }

                // Update home screen progress bar
                const homeProgressFill = document.getElementById('home-np-progress-fill');
                if (homeProgressFill) {
                    homeProgressFill.style.width = `${progressPercent}%`;
                }
            }

            function hideNowPlayingBar() {
                hideHomeNowPlayingBar();
                hideChatNowPlayingBar();
            }

            function hideChatNowPlayingBar() {
                const nowPlayingBar = document.getElementById('now-playing-bar');
                const chatScreen = document.getElementById('chat-interface-screen');

                if (!nowPlayingBar.classList.contains('hidden')) {
                    nowPlayingBar.classList.add('hidden');
                    if (chatScreen) {
                        chatScreen.classList.remove('has-now-playing');
                    }
                }
            }

            // Home Screen Now Playing Bar Functions
            function showHomeNowPlayingBar() {
                const homeBar = document.getElementById('home-now-playing-bar');

                if (musicState.isActive && musicState.currentIndex >= 0 && musicState.playlist.length > 0) {
                    const track = musicState.playlist[musicState.currentIndex];

                    // Update track info
                    document.getElementById('home-np-song-title').textContent = track.name || '未知歌曲';
                    document.getElementById('home-np-song-artist').textContent = track.artist || '未知艺术家';

                    // Update play/pause button
                    const npPlayBtn = document.getElementById('home-np-play-pause-btn');
                    npPlayBtn.textContent = musicState.isPlaying ? '❚❚' : '▶';

                    // Update album art
                    const albumImg = document.getElementById('home-np-album-image');
                    const defaultIcon = albumImg.nextElementSibling;
                    if (track.albumArt) {
                        albumImg.src = track.albumArt;
                        albumImg.style.display = 'block';
                        defaultIcon.style.display = 'none';
                    } else {
                        albumImg.style.display = 'none';
                        defaultIcon.style.display = 'flex';
                    }

                    // Update album art rotation
                    if (albumImg) {
                        if (musicState.isPlaying) {
                            albumImg.classList.add('rotating');
                        } else {
                            albumImg.classList.remove('rotating');
                        }
                    }

                    // Update listening partner avatar
                    const partnerAvatar = document.getElementById('home-np-partner-avatar');
                    if (musicState.activeChatId && state.chats[musicState.activeChatId]) {
                        const chat = state.chats[musicState.activeChatId];
                        const avatarUrl = chat.settings.aiAvatar || 'https://files.catbox.moe/q6z5fc.jpeg';
                        partnerAvatar.src = avatarUrl;
                        partnerAvatar.alt = `与 ${chat.name} 一起听`;
                    }

                    // Always show the bar and ensure proper layout
                    homeBar.classList.remove('hidden');
                }
            }

            function hideHomeNowPlayingBar() {
                const homeBar = document.getElementById('home-now-playing-bar');
                homeBar.classList.add('hidden');
            }

            function initializeNowPlayingBar() {
                // Tap to expand functionality
                document.getElementById('now-playing-bar').addEventListener('click', (e) => {
                    if (!e.target.closest('.np-playback-controls')) {
                        document.getElementById('music-player-overlay').classList.add('visible');
                    }
                });

                // Control button event listeners
                document.getElementById('np-play-pause-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    togglePlayPause();
                });

                document.getElementById('np-prev-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    playPrev();
                });

                document.getElementById('np-next-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    playNext();
                });
            }

            function initializeHomeNowPlayingBar() {
                const homeBar = document.getElementById('home-now-playing-bar');
                if (!homeBar) {
                    console.error('Home now playing bar element not found');
                    return;
                }

                // Tap to navigate to listening partner's chat with modal open
                homeBar.addEventListener('click', (e) => {
                    // Don't navigate if clicking on control buttons
                    if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                        return;
                    }

                    // Navigate to the listening partner's chat
                    if (musicState.activeChatId) {
                        // Open the chat
                        openChat(musicState.activeChatId);
                        // Open the music modal
                        document.getElementById('music-player-overlay').classList.add('visible');
                    }
                });

                // Control button event listeners
                const playBtn = document.getElementById('home-np-play-pause-btn');
                const prevBtn = document.getElementById('home-np-prev-btn');
                const nextBtn = document.getElementById('home-np-next-btn');

                if (playBtn) {
                    playBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        togglePlayPause();
                    });
                }

                if (prevBtn) {
                    prevBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        playPrev();
                    });
                }

                if (nextBtn) {
                    nextBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        playNext();
                    });
                }
            }

            function updateElapsedTimeDisplay() { const hours = (musicState.totalElapsedTime / 3600).toFixed(1); document.getElementById('music-time-counter').textContent = `已经一起听了${hours}小时`; }

            function updatePlaylistUI() { const playlistBody = document.getElementById('playlist-body'); playlistBody.innerHTML = ''; const displayPlaylist = musicState.isPlayingFromPlaylist ? musicState.mainPlaylist : musicState.playlist; if (displayPlaylist.length === 0) { playlistBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #888;">播放列表是空的~</p>'; return; } displayPlaylist.forEach((track, index) => { const item = document.createElement('div'); item.className = 'playlist-item'; if (!musicState.isPlayingFromPlaylist && index === musicState.currentIndex) item.classList.add('playing'); item.innerHTML = `<div class="playlist-item-info"><div class="title">${track.name}</div><div class="artist">${track.artist}</div></div><span class="delete-track-btn" data-index="${index}">&times;</span>`; item.querySelector('.playlist-item-info').addEventListener('click', () => playFromMainPlaylist(index)); item.querySelector('.delete-track-btn').addEventListener('click', async (e) => { e.stopPropagation(); const confirmed = await showCustomConfirm('删除歌曲', `确定要从播放列表中删除《${track.name}》吗？`); if (confirmed) deleteFromMainPlaylist(index); }); playlistBody.appendChild(item); }); }

            function playSong(index) {
                if (index < 0 || index >= musicState.playlist.length) return;
                musicState.currentIndex = index;
                const track = musicState.playlist[index];

                if (track.isSpotify && spotifyPlayer && spotifyDeviceId) {
                    fetch(`https://api.spotify.com/v1/me/player/play?device_id=${spotifyDeviceId}`, {
                        method: 'PUT',
                        headers: { 'Authorization': `Bearer ${spotifyAccessToken}`, 'Content-Type': 'application/json' },
                        body: JSON.stringify({ uris: [track.spotifyUri] })
                    });
                    musicState.isPlaying = true;
                } else if (track.isLocal && track.src instanceof Blob) {
                    audioPlayer.src = URL.createObjectURL(track.src);
                    musicState.isPlaying = true;
                    audioPlayer.play().catch(error => {
                        console.error('Error playing audio:', error);
                        musicState.isPlaying = false;
                        updatePlayerUI();
                    });
                } else if (!track.isLocal && !track.isSpotify) {
                    audioPlayer.src = track.src;
                    musicState.isPlaying = true;
                    audioPlayer.play().catch(error => {
                        console.error('Error playing audio:', error);
                        musicState.isPlaying = false;
                        updatePlayerUI();
                    });
                } else {
                    return;
                }

                updatePlaylistUI();
                updatePlayerUI();
            }

            function togglePlayPause() {
                const currentTrack = musicState.playlist[musicState.currentIndex];

                if (!musicState.isPlaying) {
                    // If not playing, check if we should resume or start new song
                    if (musicState.playlist.length === 0) return;

                    const indexToPlay = (musicState.currentIndex >= 0 && musicState.currentIndex < musicState.playlist.length) ? musicState.currentIndex : 0;

                    // Check if we should resume or start new song

                    if (currentTrack && currentTrack.isSpotify && spotifyPlayer) {
                        // For Spotify tracks, check if we should resume or start new
                        spotifyPlayer.getCurrentState().then(state => {
                            if (state && state.track_window.current_track && state.paused) {
                                // Spotify is paused, resume it
                                spotifyPlayer.resume().then(() => {
                                    musicState.isPlaying = true;
                                    updatePlayerUI();
                                });
                            } else {
                                // No current Spotify track or different track, start new
                                playSongAndShowBar(indexToPlay);
                            }
                        }).catch(error => {
                            playSongAndShowBar(indexToPlay);
                        });
                        showNowPlayingBar();
                    } else if (currentTrack && !currentTrack.isSpotify && audioPlayer.src && !audioPlayer.ended && audioPlayer.paused) {
                        // For regular audio tracks, resume from pause
                        musicState.isPlaying = true;
                        audioPlayer.play().catch(error => {
                            console.error('Error resuming audio:', error);
                            musicState.isPlaying = false;
                            updatePlayerUI();
                        });
                        showNowPlayingBar();
                    } else {
                        // Start new song - load audio source
                        playSongAndShowBar(indexToPlay);
                    }
                } else {
                    // If playing, pause it
                    if (currentTrack && currentTrack.isSpotify && spotifyPlayer) {
                        spotifyPlayer.pause();
                    } else {
                        audioPlayer.pause();
                    }
                    // DO NOT hide bar when pausing
                }
            }

            function cycleSongOnly(index) {
                if (index < 0 || index >= musicState.playlist.length) return;
                musicState.currentIndex = index;
                // DO NOT play music, just update UI
                updatePlaylistUI();
                updatePlayerUI();
            }

            function playSongAndShowBar(index) {
                if (index < 0 || index >= musicState.playlist.length) return;
                musicState.currentIndex = index;
                const track = musicState.playlist[index];

                if (track.isSpotify && spotifyPlayer && spotifyDeviceId) {


                    fetch(`https://api.spotify.com/v1/me/player/play?device_id=${spotifyDeviceId}`, {
                        method: 'PUT',
                        headers: { 'Authorization': `Bearer ${spotifyAccessToken}`, 'Content-Type': 'application/json' },
                        body: JSON.stringify({ uris: [track.spotifyUri] })
                    }).then(response => {
                        if (response.ok) {
                            musicState.isPlaying = true;
                            updatePlayerUI();
                        } else {
                            console.error('Spotify API error:', response.status, response.statusText);
                            alert(`Spotify播放失败: ${response.status} ${response.statusText}\n请检查Spotify连接状态`);
                            musicState.isPlaying = false;
                            updatePlayerUI();
                        }
                    }).catch(error => {
                        console.error('Spotify fetch error:', error);
                        alert('Spotify连接失败，请检查网络连接');
                        musicState.isPlaying = false;
                        updatePlayerUI();
                    });
                } else if (track.isLocal && track.src instanceof Blob) {
                    audioPlayer.src = URL.createObjectURL(track.src);
                    // Set playing state before calling play() to ensure UI updates correctly
                    musicState.isPlaying = true;
                    audioPlayer.play().catch(error => {
                        console.error('Error playing audio:', error);
                        musicState.isPlaying = false;
                        updatePlayerUI();
                    });
                } else if (!track.isLocal && !track.isSpotify) {
                    audioPlayer.src = track.src;
                    // Set playing state before calling play() to ensure UI updates correctly
                    musicState.isPlaying = true;
                    audioPlayer.play().catch(error => {
                        console.error('Error playing audio:', error);
                        musicState.isPlaying = false;
                        updatePlayerUI();
                    });
                } else if (track.isSpotify && (!spotifyPlayer || !spotifyDeviceId || !spotifyAccessToken)) {
                    alert('Spotify未正确连接。请重新连接Spotify。');
                    return;
                } else {
                    return;
                }

                // Show now playing bar when music starts
                showNowPlayingBar();
                updatePlaylistUI();
                updatePlayerUI();
            }

            function playNext() {
                if (musicState.playlist.length === 0) return;
                let nextIndex;
                switch (musicState.playMode) {
                    case 'random':
                        nextIndex = Math.floor(Math.random() * musicState.playlist.length);
                        break;
                    case 'single':
                        playSongAndShowBar(musicState.currentIndex);
                        return;
                    case 'order':
                    default:
                        nextIndex = (musicState.currentIndex + 1) % musicState.playlist.length;
                        break;
                }
                // Always play the next song automatically
                playSongAndShowBar(nextIndex);
            }

            function playPrev() {
                if (musicState.playlist.length === 0) return;
                const newIndex = (musicState.currentIndex - 1 + musicState.playlist.length) % musicState.playlist.length;
                // Always play the previous song automatically
                playSongAndShowBar(newIndex);
            }

            function changePlayMode() { const modes = ['order', 'random', 'single']; const currentModeIndex = modes.indexOf(musicState.playMode); musicState.playMode = modes[(currentModeIndex + 1) % modes.length]; document.getElementById('music-mode-btn').textContent = { 'order': '顺序', 'random': '随机', 'single': '单曲' }[musicState.playMode]; }

            async function addSongFromURL() { const url = await showCustomPrompt("添加网络歌曲", "请输入歌曲的URL", "", "url"); if (!url) return; const name = await showCustomPrompt("歌曲信息", "请输入歌名"); if (!name) return; const artist = await showCustomPrompt("歌曲信息", "请输入歌手名"); if (!artist) return; musicState.playlist.push({ name, artist, src: url, isLocal: false }); await saveGlobalPlaylist(); updatePlaylistUI(); if (musicState.currentIndex === -1) { musicState.currentIndex = musicState.playlist.length - 1; updatePlayerUI(); } }

            async function addSongFromLocal(event) { const files = event.target.files; if (!files.length) return; for (const file of files) { const name = await showCustomPrompt("歌曲信息", "请输入歌名", ""); if (name === null) continue; const artist = await showCustomPrompt("歌曲信息", "请输入歌手名", ""); if (artist === null) continue; musicState.playlist.push({ name, artist, src: file, isLocal: true }); } await saveGlobalPlaylist(); updatePlaylistUI(); if (musicState.currentIndex === -1 && musicState.playlist.length > 0) { musicState.currentIndex = 0; updatePlayerUI(); } event.target.value = null; }

            async function addSongFromSpotify() { if (!spotifyAccessToken) { if (confirm('需要连接到Spotify才能添加歌曲。请确保您有Spotify Premium账户，并在授权时点击"同意"。是否现在连接？')) { await initSpotifyAuth(); } return; } const query = await showCustomPrompt("搜索Spotify歌曲", "请输入歌曲名或艺术家"); if (!query) return; try { const response = await fetch(`https://api.spotify.com/v1/search?q=${encodeURIComponent(query)}&type=track&limit=10`, { headers: { 'Authorization': `Bearer ${spotifyAccessToken}` } }); const data = await response.json(); if (data.tracks.items.length === 0) { alert('没有找到相关歌曲'); return; } showSpotifyTrackSelection(data.tracks.items); } catch (error) { console.error('Spotify search failed:', error); alert('搜索失败，请检查网络连接'); } }

            function showSpotifyTrackSelection(tracks) { const modal = document.createElement('div'); modal.className = 'modal visible'; modal.innerHTML = `<div class="modal-content"><div class="modal-header" style="justify-content: flex-start;"><span onclick="this.closest('.modal').remove()" style="cursor: pointer; margin-right: 4px;">&times;</span><span>选择歌曲</span></div><div class="modal-body" style="max-height: 400px; overflow-y: auto;">${tracks.map((track, index) => `<div class="list-item" onclick="selectSpotifyTrack(${index})" style="cursor: pointer; border-bottom: 1px solid var(--border-color);"><div class="item-title">${track.name}</div><div class="item-content">${track.artists.map(a => a.name).join(', ')} • ${track.album.name}</div></div>`).join('')}</div></div>`; document.body.appendChild(modal); window.spotifySearchResults = tracks; }

            function selectSpotifyTrack(index) { const track = window.spotifySearchResults[index]; if (!track) return; const listItems = document.querySelectorAll('.modal .list-item'); const clickedItem = listItems[index]; clickedItem.innerHTML = `<div class="item-title">${track.name}</div><div class="item-content">${track.artists.map(a => a.name).join(', ')} • ${track.album.name}</div><div style="margin-left: auto; font-size: 20px;">⏳</div>`; const newTrack = { name: track.name, artist: track.artists.map(a => a.name).join(', '), src: null, isLocal: false, isSpotify: true, spotifyUri: track.uri, albumArt: track.album.images[0]?.url }; if (musicState.isPlayingFromPlaylist) { musicState.mainPlaylist.push(newTrack); } else { musicState.playlist.push(newTrack); if (musicState.currentIndex === -1) { musicState.currentIndex = musicState.playlist.length - 1; updatePlayerUI(); } } saveGlobalPlaylist(); updatePlaylistUI(); clickedItem.innerHTML = `<div class="item-title">${track.name}</div><div class="item-content">${track.artists.map(a => a.name).join(', ')} • ${track.album.name}</div><div style="margin-left: auto; font-size: 20px; color: green;">✓</div>`; }
            window.selectSpotifyTrack = selectSpotifyTrack;



            function generateCodeVerifier() { const array = new Uint8Array(32); crypto.getRandomValues(array); return btoa(String.fromCharCode.apply(null, array)).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, ''); }

            function generateCodeChallenge(verifier) { const encoder = new TextEncoder(); const data = encoder.encode(verifier); return crypto.subtle.digest('SHA-256', data).then(digest => { return btoa(String.fromCharCode(...new Uint8Array(digest))).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, ''); }); }

            async function initSpotifyAuth() { const clientId = '4a89adc960014897bfcc45c55c1c0aff'; const redirectUri = 'lycheephone://spotify-callback'; const scopes = 'streaming user-read-email user-read-private user-read-playback-state user-modify-playback-state'; const codeVerifier = generateCodeVerifier(); const codeChallenge = await generateCodeChallenge(codeVerifier); window.spotifyCodeVerifier = codeVerifier; const authUrl = `https://accounts.spotify.com/authorize?client_id=${clientId}&response_type=code&redirect_uri=${encodeURIComponent(redirectUri)}&scope=${encodeURIComponent(scopes)}&code_challenge_method=S256&code_challenge=${codeChallenge}`; window.location.href = authUrl; }

            function getSpotifyTokenFromUrl() { const hash = window.location.hash.substring(1); const params = new URLSearchParams(hash); const token = params.get('access_token'); if (token) { spotifyAccessToken = token; window.history.replaceState({}, document.title, window.location.pathname); return true; } return false; }

            async function loadSavedSpotifyToken() { try { const spotifySettings = await db.globalSettings.get('spotify'); if (spotifySettings && spotifySettings.accessToken) { if (spotifySettings.expiresAt > Date.now()) { spotifyAccessToken = spotifySettings.accessToken; initSpotifyPlayer(); } else { await db.globalSettings.delete('spotify'); } } } catch (error) { } }

            function handleSpotifyCallback(url) { if (url.startsWith('lycheephone://spotify-callback')) { const urlParts = url.split('?'); if (urlParts.length > 1) { const params = new URLSearchParams(urlParts[1]); const code = params.get('code'); const error = params.get('error'); if (error) { if (error === 'access_denied') { alert('Spotify授权被拒绝。请重试并点击"同意"按钮。'); } else { alert('Spotify error: ' + error); } return; } if (code) { exchangeCodeForToken(code); } } } }

            async function exchangeCodeForToken(code) { const clientId = '4a89adc960014897bfcc45c55c1c0aff'; const redirectUri = 'lycheephone://spotify-callback'; const codeVerifier = window.spotifyCodeVerifier; if (!codeVerifier) { return; } try { const response = await fetch('https://accounts.spotify.com/api/token', { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body: new URLSearchParams({ grant_type: 'authorization_code', code: code, redirect_uri: redirectUri, client_id: clientId, code_verifier: codeVerifier }) }); const data = await response.json(); if (data.access_token) { spotifyAccessToken = data.access_token; await db.globalSettings.put({ id: 'spotify', accessToken: data.access_token, refreshToken: data.refresh_token, expiresAt: Date.now() + (data.expires_in * 1000) }); initSpotifyPlayer(); } } catch (error) { console.error('Token exchange error:', error); } }

            async function initSpotifyPlayer() { if (!spotifyAccessToken) return false; if (!window.Spotify) { window.onSpotifyWebPlaybackSDKReady = () => { }; await new Promise(resolve => { if (window.Spotify) { resolve(); } else { window.onSpotifyWebPlaybackSDKReady = resolve; } }); } spotifyPlayer = new Spotify.Player({ name: 'LycheePhone Music Player', getOAuthToken: cb => cb(spotifyAccessToken), volume: 0.5 }); spotifyPlayer.addListener('ready', ({ device_id }) => { spotifyDeviceId = device_id; migrateSpotifyAlbumArt(); }); spotifyPlayer.addListener('not_ready', ({ device_id }) => { }); spotifyPlayer.addListener('player_state_changed', (state) => { if (state && musicState.isActive) { const track = musicState.playlist[musicState.currentIndex]; if (track && track.isSpotify) { musicState.isPlaying = !state.paused; updatePlayerUI(); updateNowPlayingProgress(); } } }); const success = await spotifyPlayer.connect(); return success; }

            async function deleteTrack(index) { if (index < 0 || index >= musicState.playlist.length) return; const track = musicState.playlist[index]; const wasPlaying = musicState.isPlaying && musicState.currentIndex === index; if (track.isLocal && audioPlayer.src.startsWith('blob:') && musicState.currentIndex === index) URL.revokeObjectURL(audioPlayer.src); musicState.playlist.splice(index, 1); await saveGlobalPlaylist(); if (musicState.playlist.length === 0) { if (musicState.isPlaying) audioPlayer.pause(); audioPlayer.src = ''; musicState.currentIndex = -1; musicState.isPlaying = false; } else { if (wasPlaying) { playNext(); } else { if (musicState.currentIndex >= index) musicState.currentIndex = Math.max(0, musicState.currentIndex - 1); } } updatePlayerUI(); updatePlaylistUI(); }

            const personaLibraryModal = document.getElementById('persona-library-modal');
            const personaEditorModal = document.getElementById('persona-editor-modal');
            const presetActionsModal = document.getElementById('preset-actions-modal');

            function openPersonaLibrary() { renderPersonaLibrary(); personaLibraryModal.classList.add('visible'); }

            function closePersonaLibrary() { personaLibraryModal.classList.remove('visible'); }

            function renderPersonaLibrary() { const grid = document.getElementById('persona-library-grid'); grid.innerHTML = ''; if (state.personaPresets.length === 0) { grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center; margin-top: 20px;">空空如也~ 点击右上角"添加"来创建你的第一个人设预设吧！</p>'; return; } state.personaPresets.forEach(preset => { const item = document.createElement('div'); item.className = 'persona-preset-item'; item.style.backgroundImage = `url(${preset.avatar})`; item.dataset.presetId = preset.id; item.addEventListener('click', () => applyPersonaPreset(preset.id)); addLongPressListener(item, () => showPresetActions(preset.id)); grid.appendChild(item); }); }

            function showPresetActions(presetId) { editingPersonaPresetId = presetId; presetActionsModal.classList.add('visible'); }

            function hidePresetActions() { presetActionsModal.classList.remove('visible'); editingPersonaPresetId = null; }

            function applyPersonaPreset(presetId) { const preset = state.personaPresets.find(p => p.id === presetId); if (preset) { document.getElementById('my-avatar-preview').src = preset.avatar; document.getElementById('my-persona').value = preset.persona; } closePersonaLibrary(); }

            function openPersonaEditorForCreate() { editingPersonaPresetId = null; document.getElementById('persona-editor-title').textContent = '添加人设预设'; document.getElementById('preset-avatar-preview').src = defaultAvatar; document.getElementById('preset-persona-input').value = ''; personaEditorModal.classList.add('visible'); }

            function openPersonaEditorForEdit() { const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); if (!preset) return; document.getElementById('persona-editor-title').textContent = '编辑人设预设'; document.getElementById('preset-avatar-preview').src = preset.avatar; document.getElementById('preset-persona-input').value = preset.persona; presetActionsModal.classList.remove('visible'); personaEditorModal.classList.add('visible'); }

            async function deletePersonaPreset() { const confirmed = await showCustomConfirm('删除预设', '确定要删除这个人设预设吗？此操作不可恢复。', { confirmButtonClass: 'btn-danger' }); if (confirmed && editingPersonaPresetId) { await db.personaPresets.delete(editingPersonaPresetId); state.personaPresets = state.personaPresets.filter(p => p.id !== editingPersonaPresetId); hidePresetActions(); renderPersonaLibrary(); } }

            function closePersonaEditor() { personaEditorModal.classList.remove('visible'); editingPersonaPresetId = null; }

            async function savePersonaPreset() { const avatar = document.getElementById('preset-avatar-preview').src; const persona = document.getElementById('preset-persona-input').value.trim(); if (avatar === defaultAvatar && !persona) { alert("头像和人设不能都为空哦！"); return; } if (editingPersonaPresetId) { const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); if (preset) { preset.avatar = avatar; preset.persona = persona; await db.personaPresets.put(preset); } } else { const newPreset = { id: 'preset_' + Date.now(), avatar: avatar, persona: persona }; await db.personaPresets.add(newPreset); state.personaPresets.push(newPreset); } renderPersonaLibrary(); closePersonaEditor(); }

            // Memory action functions (copying persona pattern)
            function showMemoryActions(memoryId) {
                editingMemoryId = parseInt(memoryId);
                // Update modal button text for memory actions
                document.getElementById('preset-action-edit').textContent = '编辑记录';
                document.getElementById('preset-action-delete').textContent = '删除记录';
                presetActionsModal.classList.add('visible');
            }

            function hideMemoryActions() {
                presetActionsModal.classList.remove('visible');
                editingMemoryId = null;
                // Reset button text back to preset actions
                document.getElementById('preset-action-edit').textContent = '编辑预设';
                document.getElementById('preset-action-delete').textContent = '删除预设';
            }

            async function editMemory() {
                if (!editingMemoryId) return;
                const memory = await db.memories.get(editingMemoryId);
                if (!memory) return;

                // Hide actions modal
                presetActionsModal.classList.remove('visible');

                // Determine which modal to use and prefill data
                if (memory.type === 'countdown') {
                    // Use countdown modal for editing
                    document.querySelector('#create-countdown-modal .modal-header span').textContent = '编辑约定';
                    document.getElementById('countdown-title-input').value = memory.description;

                    // Format date for datetime-local input
                    const targetDate = new Date(memory.targetDate);
                    const formattedDate = targetDate.getFullYear() + '-' +
                        String(targetDate.getMonth() + 1).padStart(2, '0') + '-' +
                        String(targetDate.getDate()).padStart(2, '0') + 'T' +
                        String(targetDate.getHours()).padStart(2, '0') + ':' +
                        String(targetDate.getMinutes()).padStart(2, '0');
                    document.getElementById('countdown-date-input').value = formattedDate;

                    document.getElementById('create-countdown-modal').classList.add('visible');
                } else {
                    // Use memory modal for editing
                    document.querySelector('#create-memory-modal .modal-header span').textContent = '编辑回忆';
                    document.getElementById('memory-description-input').value = memory.description;

                    // Format date for datetime-local input
                    const memoryDate = new Date(memory.timestamp);
                    const formattedDate = memoryDate.getFullYear() + '-' +
                        String(memoryDate.getMonth() + 1).padStart(2, '0') + '-' +
                        String(memoryDate.getDate()).padStart(2, '0') + 'T' +
                        String(memoryDate.getHours()).padStart(2, '0') + ':' +
                        String(memoryDate.getMinutes()).padStart(2, '0');
                    document.getElementById('memory-date-input').value = formattedDate;

                    document.getElementById('create-memory-modal').classList.add('visible');
                }
            }

            async function deleteMemory() {
                if (!editingMemoryId) return;
                const memory = await db.memories.get(editingMemoryId);
                if (!memory) return;

                const deleteTitle = memory.type === 'countdown' ? '删除约定' : '删除记录';
                const deleteMessage = memory.type === 'countdown' ? '确定要删除这个约定吗？' : '确定要删除这条记录吗？';

                const confirmed = await showCustomConfirm(deleteTitle, deleteMessage, { confirmButtonClass: 'btn-danger' });
                if (confirmed) {
                    // If this is a date mode event, delete associated messages first
                    if (memory.type === 'meetup') {
                        try {
                            const deletedCount = await deleteMeetupMessages(editingMemoryId);
                            console.log('DEBUG - Deleted meetup messages:', deletedCount);
                        } catch (error) {
                            console.error('DEBUG - Failed to delete meetup messages:', error);
                            // Continue with event deletion even if message deletion fails
                        }
                    }

                    await db.memories.delete(editingMemoryId);
                    hideMemoryActions();
                    renderCalendarScreen();
                    renderMemoriesScreen();
                }
            }

            const batteryAlertModal = document.getElementById('battery-alert-modal');

            function showBatteryAlert(imageUrl, text) { clearTimeout(batteryAlertTimeout); document.getElementById('battery-alert-image').src = imageUrl; document.getElementById('battery-alert-text').textContent = text; batteryAlertModal.classList.add('visible'); const closeAlert = () => { batteryAlertModal.classList.remove('visible'); batteryAlertModal.removeEventListener('click', closeAlert); }; batteryAlertModal.addEventListener('click', closeAlert); batteryAlertTimeout = setTimeout(closeAlert, 2000); }

            function updateBatteryDisplay(battery) { const batteryContainer = document.getElementById('status-bar-battery'); const batteryLevelEl = batteryContainer.querySelector('.battery-level'); const batteryTextEl = batteryContainer.querySelector('.battery-text'); const level = Math.floor(battery.level * 100); batteryLevelEl.style.width = `${level}%`; batteryTextEl.textContent = `${level}%`; if (battery.charging) { batteryContainer.classList.add('charging'); } else { batteryContainer.classList.remove('charging'); } }

            function handleBatteryChange(battery) { updateBatteryDisplay(battery); const level = battery.level; if (!battery.charging) { if (level <= 0.4 && lastKnownBatteryLevel > 0.4 && !alertFlags.hasShown40) { showBatteryAlert('https://i.postimg.cc/T2yKJ0DV/40.jpg', '有点饿了，可以去找充电器惹'); alertFlags.hasShown40 = true; } if (level <= 0.2 && lastKnownBatteryLevel > 0.2 && !alertFlags.hasShown20) { showBatteryAlert('https://i.postimg.cc/qB9zbKs9/20.jpg', '赶紧的充电，要饿死了'); alertFlags.hasShown20 = true; } if (level <= 0.1 && lastKnownBatteryLevel > 0.1 && !alertFlags.hasShown10) { showBatteryAlert('https://i.postimg.cc/ThMMVfW4/10.jpg', '已阵亡，还有30秒爆炸'); alertFlags.hasShown10 = true; } } if (level > 0.4) alertFlags.hasShown40 = false; if (level > 0.2) alertFlags.hasShown20 = false; if (level > 0.1) alertFlags.hasShown10 = false; lastKnownBatteryLevel = level; }

            async function initBatteryManager() { if ('getBattery' in navigator) { try { const battery = await navigator.getBattery(); lastKnownBatteryLevel = battery.level; handleBatteryChange(battery); battery.addEventListener('levelchange', () => handleBatteryChange(battery)); battery.addEventListener('chargingchange', () => { handleBatteryChange(battery); if (battery.charging) { showBatteryAlert('https://i.postimg.cc/3NDQ0dWG/image.jpg', '窝爱泥，电量吃饱饱'); } }); } catch (err) { console.error("无法获取电池信息:", err); document.querySelector('.battery-text').textContent = 'ᗜωᗜ'; } } else { console.log("浏览器不支持电池状态API。"); document.querySelector('.battery-text').textContent = 'ᗜωᗜ'; } }

            async function renderAlbumList() {
                const albumGrid = document.getElementById('album-grid-page');
                if (!albumGrid) return;
                const albums = await db.qzoneAlbums.orderBy('createdAt').reverse().toArray();
                albumGrid.innerHTML = '';
                if (albums.length === 0) {
                    albumGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">你还没有创建任何相册哦~</p>';
                    return;
                }
                albums.forEach(album => {
                    const albumItem = document.createElement('div');
                    albumItem.className = 'album-item';
                    albumItem.innerHTML = `
                    <div class="album-cover" style="background-image: url(${album.coverUrl});"></div>
                    <div class="album-info">
                        <p class="album-name">${album.name}</p>
                        <p class="album-count">${album.photoCount || 0} 张</p>
                    </div>
                `;
                    albumItem.addEventListener('click', () => {
                        openAlbum(album.id);
                    });

                    // ▼▼▼ 新增的核心代码就是这里 ▼▼▼
                    addLongPressListener(albumItem, async () => {
                        const confirmed = await showCustomConfirm(
                            '删除相册',
                            `确定要删除相册《${album.name}》吗？此操作将同时删除相册内的所有照片，且无法恢复。`,
                            { confirmButtonClass: 'btn-danger' }
                        );

                        if (confirmed) {
                            // 1. 从照片表中删除该相册下的所有照片
                            await db.qzonePhotos.where('albumId').equals(album.id).delete();

                            // 2. 从相册表中删除该相册本身
                            await db.qzoneAlbums.delete(album.id);

                            // 3. 重新渲染相册列表
                            await renderAlbumList();

                            alert('相册已成功删除。');
                        }
                    });
                    // ▲▲▲ 新增代码结束 ▲▲▲

                    albumGrid.appendChild(albumItem);
                });
            }

            async function openAlbum(albumId) {
                state.activeAlbumId = albumId;
                await renderAlbumPhotosScreen();
                showScreen('album-photos-screen');
            }

            async function renderAlbumPhotosScreen() {
                if (!state.activeAlbumId) return;
                const photosGrid = document.getElementById('photos-grid-page');
                const headerTitle = document.getElementById('album-photos-title');
                const album = await db.qzoneAlbums.get(state.activeAlbumId);
                if (!album) {
                    console.error("找不到相册:", state.activeAlbumId);
                    showScreen('album-screen');
                    return;
                }
                headerTitle.textContent = album.name;
                const photos = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
                photosGrid.innerHTML = '';
                if (photos.length === 0) {
                    photosGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">这个相册还是空的，快上传第一张照片吧！</p>';
                } else {
                    photos.forEach(photo => {
                        const photoItem = document.createElement('div');
                        photoItem.className = 'photo-item';
                        photoItem.innerHTML = `
                        <img src="${photo.url}" class="photo-thumb" alt="相册照片">
                        <button class="photo-delete-btn" data-photo-id="${photo.id}">×</button>
                    `;
                        photosGrid.appendChild(photoItem);
                    });
                }
            }

            // --- ↓↓↓ 从这里开始复制 ↓↓↓ ---

            /**
             * 打开图片查看器
             * @param {string} clickedPhotoUrl - 用户点击的那张照片的URL
             */
            async function openPhotoViewer(clickedPhotoUrl) {
                if (!state.activeAlbumId) return;

                // 1. 从数据库获取当前相册的所有照片
                const photosInAlbum = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
                photoViewerState.photos = photosInAlbum.map(p => p.url);

                // 2. 找到被点击照片的索引
                photoViewerState.currentIndex = photoViewerState.photos.findIndex(url => url === clickedPhotoUrl);
                if (photoViewerState.currentIndex === -1) return; // 如果找不到，则不打开

                // 3. 显示模态框并渲染第一张图
                document.getElementById('photo-viewer-modal').classList.add('visible');
                renderPhotoViewer();
                photoViewerState.isOpen = true;
            }

            /**
             * 根据当前状态渲染查看器内容（图片和按钮）
             */
            function renderPhotoViewer() {
                if (photoViewerState.currentIndex === -1) return;

                const imageEl = document.getElementById('photo-viewer-image');
                const prevBtn = document.getElementById('photo-viewer-prev-btn');
                const nextBtn = document.getElementById('photo-viewer-next-btn');

                // 淡出效果
                imageEl.style.opacity = 0;

                setTimeout(() => {
                    // 更新图片源
                    imageEl.src = photoViewerState.photos[photoViewerState.currentIndex];
                    // 淡入效果
                    imageEl.style.opacity = 1;
                }, 100); // 延迟一点点时间来触发CSS过渡

                // 更新按钮状态：如果是第一张，禁用“上一张”按钮
                prevBtn.disabled = photoViewerState.currentIndex === 0;
                // 如果是最后一张，禁用“下一张”按钮
                nextBtn.disabled = photoViewerState.currentIndex === photoViewerState.photos.length - 1;
            }

            /**
             * 显示下一张照片
             */
            function showNextPhoto() {
                if (photoViewerState.currentIndex < photoViewerState.photos.length - 1) {
                    photoViewerState.currentIndex++;
                    renderPhotoViewer();
                }
            }

            /**
             * 显示上一张照片
             */
            function showPrevPhoto() {
                if (photoViewerState.currentIndex > 0) {
                    photoViewerState.currentIndex--;
                    renderPhotoViewer();
                }
            }

            /**
             * 关闭图片查看器
             */
            function closePhotoViewer() {
                document.getElementById('photo-viewer-modal').classList.remove('visible');
                photoViewerState.isOpen = false;
                photoViewerState.photos = [];
                photoViewerState.currentIndex = -1;
                // 清空图片，避免下次打开时闪现旧图
                document.getElementById('photo-viewer-image').src = '';
            }

            // --- ↑↑↑ 复制到这里结束 ↑↑↑ ---
            // ▼▼▼ 请将这个新函数粘贴到你的JS功能函数定义区 ▼▼▼

            /**
             * 更新动态小红点的显示
             * @param {number} count - 未读动态的数量
             */
            function updateUnreadIndicator(count) {
                unreadPostsCount = count;
                localStorage.setItem('unreadPostsCount', count); // 持久化存储

                // --- 更新底部导航栏的“动态”按钮 ---
                const navItem = document.querySelector('.nav-item[data-view="qzone-screen"]');

                const targetSpan = navItem.querySelector('span'); // 定位到文字 "动态"
                let indicator = navItem.querySelector('.unread-indicator');

                if (count > 0) {
                    if (!indicator) {
                        indicator = document.createElement('span');
                        indicator.className = 'unread-indicator';
                        targetSpan.style.position = 'relative'; // 把相对定位加在 span 上
                        targetSpan.appendChild(indicator); // 把小红点作为 span 的子元素

                    }
                    indicator.textContent = count > 99 ? '99+' : count;
                    indicator.style.display = 'block';
                } else {
                    if (indicator) {
                        indicator.style.display = 'none';
                    }
                }

                // --- 更新聊天界面返回列表的按钮 ---
                const backBtn = document.getElementById('back-to-list-btn');
                let backBtnIndicator = backBtn.querySelector('.unread-indicator');

                if (count > 0) {
                    if (!backBtnIndicator) {
                        backBtnIndicator = document.createElement('span');
                        backBtnIndicator.className = 'unread-indicator back-btn-indicator';
                        backBtn.style.position = 'relative'; // 确保能正确定位
                        backBtn.appendChild(backBtnIndicator);
                    }
                    // 返回键上的小红点通常不显示数字，只显示一个点
                    backBtnIndicator.style.display = 'block';
                } else {
                    if (backBtnIndicator) {
                        backBtnIndicator.style.display = 'none';
                    }
                }
            }

            // ▲▲▲ 新函数粘贴结束 ▲▲▲

            // ▼▼▼ 将这两个新函数粘贴到你的JS功能函数定义区 ▼▼▼
            function startBackgroundSimulation() {
                if (simulationIntervalId) return;
                const intervalSeconds = state.globalSettings.backgroundActivityInterval || 60;
                // 将旧的固定间隔 45000 替换为动态获取
                simulationIntervalId = setInterval(runBackgroundSimulationTick, intervalSeconds * 1000);
            }

            function stopBackgroundSimulation() {
                if (simulationIntervalId) {
                    clearInterval(simulationIntervalId);
                    simulationIntervalId = null;
                }
            }
            // ▲▲▲ 粘贴结束 ▲▲▲

            /**
             * 这是模拟器的“心跳”，每次定时器触发时运行
             */
            function runBackgroundSimulationTick() {
                console.log("模拟器心跳 Tick...");
                if (!state.globalSettings.enableBackgroundActivity) {
                    stopBackgroundSimulation();
                    return;
                }
                const allChats = Object.values(state.chats);
                if (allChats.length === 0) return;

                allChats.forEach(chat => {
                    // ▼▼▼ 【核心逻辑】如果此角色的开关是关闭的，则直接跳过其后台活动 ▼▼▼
                    if (chat.settings.isBackgroundActivityEnabled === false) return;

                    // ▼▼▼ 【核心修复】统一的冷静期检测 ▼▼▼
                    const cooldownMinutes = state.globalSettings.aiActionCooldownMinutes ?? 5;
                    // 只有当冷静期大于0时才进行检查
                    if (cooldownMinutes > 0) {
                        // 获取对话的最后一条消息（无论来自谁）
                        const lastMessage = chat.history.slice(-1)[0];
                        if (lastMessage) {
                            const timeSinceLastMessage = Date.now() - lastMessage.timestamp;
                            const cooldownMilliseconds = cooldownMinutes * 60 * 1000;

                            // 如果对话还“温热”，则跳过此角色的所有后台活动
                            if (timeSinceLastMessage < cooldownMilliseconds) {
                                return; // 跳到 forEach 的下一个循环
                            }
                        }
                    }
                    // ▲▲▲ 冷静期检测结束 ▲▲▲

                    // 后续逻辑保持不变，但现在它们只会在冷静期结束后执行
                    if (chat.isGroup) {
                        if (Math.random() < 0.30) {
                            console.log(`[群聊唤醒] 触发群聊 "${chat.name}" 的后台事件...`);
                            triggerGroupChatBackgroundEvent(chat.id);
                        }
                    } else {
                        if (chat.relationship?.status === 'blocked_by_user') {
                            const blockedTimestamp = chat.relationship.blockedTimestamp;
                            if (!blockedTimestamp) {
                                console.warn(`角色 "${chat.name}" 状态为拉黑，但缺少拉黑时间戳，跳过处理。`);
                                return;
                            }
                            const blockedDuration = Date.now() - blockedTimestamp;
                            const cooldownMilliseconds = (state.globalSettings.blockCooldownHours || 1) * 60 * 60 * 1000;

                            if (blockedDuration > cooldownMilliseconds) {
                                console.log(`角色 "${chat.name}" 的拉黑冷静期已过，触发“反思”并申请好友事件...`);
                                chat.relationship.status = 'pending_system_reflection';
                                triggerAiFriendApplication(chat.id);
                            }
                        }
                        else if (chat.relationship?.status === 'friend' && chat.id !== state.activeChatId) {
                            if (Math.random() < 0.20) {
                                console.log(`角色 "${chat.name}" 被唤醒，准备独立行动...`);
                                triggerInactiveAiAction(chat.id);
                            }
                        }
                    }
                });
            }

            async function triggerInactiveAiAction(chatId, forceActive = false, forcePost = false) {


                const chat = state.chats[chatId];
                if (!chat) {
                    return false;
                }

                // Active check - skip if AI is currently active (unless forced)
                if (!forceActive && chat.id === state.activeChatId) {
                    return false;
                }

                // Busy check to prevent race conditions with timeout
                if (chat._isProcessing) {
                    // Check if processing has been stuck for too long (more than 30 seconds)
                    const now = Date.now();
                    if (!chat._processingStartTime || (now - chat._processingStartTime) > 30000) {
                        chat._isProcessing = false;
                        delete chat._processingStartTime;
                    } else {
                        return false;
                    }
                }
                chat._isProcessing = true;
                chat._processingStartTime = Date.now();

                const { proxyUrl, apiKey, model } = state.apiConfig;

                if (!proxyUrl || !apiKey || !model) {
                    chat._isProcessing = false;
                    return false;
                }

                const now = new Date();
                const currentTime = now.toLocaleTimeString('zh-CN', { hour: 'numeric', minute: 'numeric', hour12: true });
                const userNickname = state.qzoneSettings.nickname;

                // ▼▼▼ 【核心增强】计算时间差并生成提示文本 ▼▼▼
                const lastMessage = chat.history.slice(-1)[0];
                let timeGapText = '';
                let timeSinceLastMessageMinutes = 0;
                if (lastMessage) {
                    const timeDiff = Date.now() - lastMessage.timestamp;
                    timeSinceLastMessageMinutes = Math.floor(timeDiff / (1000 * 60));
                    const formattedDiff = formatTimeDifference(timeDiff);
                    if (formattedDiff) {
                        timeGapText = `[系统提示：距离你的上一条消息已过去 **${formattedDiff}**，现在是 ${currentTimeString}。请根据这个时间变化，请将这段时间视为你角色生活的自然延续。请不要直接评论“好久不见”或对此表现出任何情绪，而是思考在这段时间里，你的活动、心境或所处环境可能发生了什么变化，话题是否会变动，并将这些变化自然地融入到你的回应中，让对话无缝衔接。例如，你可能刚刚忙完一件事，或者正准备开始新的活动。]`;
                    }
                }
                // ▲▲▲ 增强结束 ▲▲▲

                let worldBookContextForAction = '';
                const coreWorldBookName = "maininfo";
                const coreWorldBook = state.worldBooks.find(wb => wb.name === coreWorldBookName);
                if (coreWorldBook && coreWorldBook.content) {
                    worldBookContextForAction = `\n\n# 核心社交关系设定 (你必须严格遵守以下所有设定)\n${coreWorldBook.content}\n`;
                }

                const lastUserMessage = chat.history.filter(m => m.role === 'user' && !m.isHidden).slice(-1)[0];
                const lastAiMessage = chat.history.filter(m => m.role === 'assistant' && !m.isHidden).slice(-1)[0];
                let recentContextSummary = "你们最近没有聊过天。";
                if (lastUserMessage) {
                    recentContextSummary = `用户 (${userNickname}) 最后对你说：“${String(lastUserMessage.content).substring(0, 50)}...”。`;
                }
                if (lastAiMessage) {
                    recentContextSummary += `\n你最后对用户说：“${String(lastAiMessage.content).substring(0, 50)}...”。`;
                }

                // ▼▼▼ 【核心增强】重写 System Prompt，加入智能决策指令 ▼▼▼
                let systemPrompt = `
# 你的任务
你现在扮演一个名为"${chat.name}"的角色。你已经有一段时间没有和用户（${userNickname}）互动了，现在你有机会【主动】做点什么。这是一个秘密的、后台的独立行动。

# 核心规则：智能决策
${timeGapText}
请你分析下面的“对话尾声”。
1.  **延续对话**: 如果对话显然没有结束（例如，用户问了一个问题你还没答），或者沉寂时间不长（例如少于60分钟），请你【优先自然地延续话题】。
2.  **开启新生活**: 如果对话已告一段落，或者你们已经很久没聊了（例如超过60分钟），你可以【开启一个新话题】或者【进行一项后台活动】，来表现你的独立生活。

# 你的可选行动 (请根据你的决策【选择一项】执行):
-   **延续/开启话题**: \`[{"type": "text", "content": "你想说的话..."}]\`
-   **改变状态并通知**: \`[{"type": "update_status", "status_text": "正在做的事", "is_busy": true}, {"type": "text", "content": "你想对用户说的话..."}]\`
-   **发说说/文字图**: \`[{"type": "qzone_post", ...}]\`
-   **评论/点赞动态**: \`[{"type": "qzone_comment", ...}]\` 或 \`[{"type": "qzone_like", ...}]\`
-   **打视频**: \`[{"type": "video_call_request"}]\`
(请参考主聊天逻辑的完整指令格式)

# 供你决策的参考信息：
-   **你的角色设定**: ${chat.settings.aiPersona}
-   **背景设定**: ${worldBookContextForAction}
-   **当前时间**: ${currentTime}
-   **你们最后的对话摘要**: ${recentContextSummary}
-   **【重要】最近的动态列表**: 这个列表会标注 **[你已点赞]** 或 **[你已评论]**。请**优先**与你**尚未互动过**的动态进行交流。`;

                // Add force post instruction if requested
                if (forcePost) {
                    systemPrompt = `[用户指令：用户希望你现在发布一条动态来分享你的想法、心情或近况。请根据你们最近的对话内容和你的性格，创建一条有意义的动态。请使用格式：{"type": "qzone_post", "postType": "shuoshuo", "content": "你的动态内容..."}]

` + systemPrompt;
                }
                // ▲▲▲ Prompt 增强结束 ▲▲▲

                const messagesPayload = [];
                messagesPayload.push({ role: 'system', content: systemPrompt });

                try {
                    const recentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(3).toArray();
                    const aiName = chat.name;

                    let dynamicContext = "";
                    if (recentPosts.length > 0) {
                        let postsContext = "\n\n# 最近的动态列表 (供你参考和评论):\n";
                        for (const post of recentPosts) {
                            let authorName = post.authorId === 'user' ? userNickname : (state.chats[post.authorId]?.name || '一位朋友');
                            let interactionStatus = '';
                            const contentSummary = (post.publicText || post.content || "图片动态").substring(0, 30) + '...';
                            postsContext += `- (ID: ${post.id}) 作者: ${authorName}, 内容: "${contentSummary}"${interactionStatus}\n`;
                        }
                        dynamicContext = postsContext;
                    }

                    messagesPayload.push({
                        role: 'user',
                        content: `[系统指令：请根据你在 system prompt 中读到的规则和以下最新信息，开始你的独立行动。]\n${dynamicContext}`
                    });

                    const data = await makeAPIRequest(proxyUrl, apiKey, model, messagesPayload, 0.9);

                    if (!data.choices || data.choices.length === 0 || !data.choices[0].message.content) {
                        return false;
                    }

                    const responseArray = parseAiResponse(data.choices[0].message.content);

                    for (const action of responseArray) {
                        if (!action) continue;

                        if (action.type === 'update_status' && action.status_text) {
                            chat.status.text = action.status_text;
                            chat.status.isBusy = action.is_busy || false;
                            chat.status.lastUpdate = Date.now();
                            await db.chats.put(chat);
                            renderChatList();
                        }
                        if (action.type === 'text' && action.content) {
                            const aiMessage = { role: 'assistant', content: String(action.content), timestamp: Date.now() };
                            chat.history.push(aiMessage);
                            await db.chats.put(chat);
                            showNotification(chatId, aiMessage.content);
                            renderChatList();
                            console.log(`后台活动: 角色 "${chat.name}" 主动发送了消息: ${aiMessage.content}`);
                        }
                        if (action.type === 'qzone_post') {
                            const newPost = { type: action.postType, content: action.content || '', publicText: action.publicText || '', hiddenContent: action.hiddenContent || '', timestamp: Date.now(), authorId: chatId, visibleGroupIds: null, isPinned: false };
                            await db.qzonePosts.add(newPost);
                            updateUnreadIndicator(unreadPostsCount + 1);
                            console.log(`后台活动: 角色 "${chat.name}" 发布了动态`);
                        } else if (action.type === 'qzone_comment') {
                            const post = await db.qzonePosts.get(parseInt(action.postId));
                            if (post) {
                                if (!post.comments) post.comments = [];
                                post.comments.push({ commenterName: chat.name, text: action.commentText, timestamp: Date.now() });
                                await db.qzonePosts.update(post.id, { comments: post.comments });
                                updateUnreadIndicator(unreadPostsCount + 1);
                                console.log(`后台活动: 角色 "${chat.name}" 评论了动态 #${post.id}`);
                            }
                        } else if (action.type === 'qzone_like') {
                            const post = await db.qzonePosts.get(parseInt(action.postId));
                            if (post) {
                                if (!post.likes) post.likes = [];
                                if (!post.likes.includes(chat.name)) {
                                    post.likes.push(chat.name);
                                    await db.qzonePosts.update(post.id, { likes: post.likes });
                                    updateUnreadIndicator(unreadPostsCount + 1);
                                    console.log(`后台活动: 角色 "${chat.name}" 点赞了动态 #${post.id}`);
                                }
                            }
                        } else if (action.type === 'video_call_request') {
                            if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                                videoCallState.isAwaitingResponse = true;
                                state.activeChatId = chatId;
                                showIncomingCallModal();
                                console.log(`后台活动: 角色 "${chat.name}" 发起了视频通话请求`);
                            }
                        }
                    }
                    return true; // Success
                } catch (error) {
                    console.error('triggerInactiveAiAction error:', error);
                    return false; // Failure
                } finally {
                    chat._isProcessing = false;
                    delete chat._processingStartTime;
                }
            }




            function applyScopedCss(cssString, scopeId, styleTagId) {
                const styleTag = document.getElementById(styleTagId);
                if (!styleTag) return;

                if (!cssString || cssString.trim() === '') {
                    styleTag.innerHTML = '';
                    return;
                }

                // 增强作用域处理函数 - 专门解决.user和.ai样式冲突问题
                // Also exclude is-sticker bubbles from custom styling
                const scopedCss = cssString
                    .replace(/\s*\.message-bubble\.user\s+([^{]+\{)/g, `${scopeId} .message-bubble.user:not(.is-sticker) $1`)
                    .replace(/\s*\.message-bubble\.ai\s+([^{]+\{)/g, `${scopeId} .message-bubble.ai:not(.is-sticker) $1`)
                    .replace(/\s*\.message-bubble\s+([^{]+\{)/g, `${scopeId} .message-bubble:not(.is-sticker) $1`);

                styleTag.innerHTML = scopedCss;
            }
            // ▲▲▲ 以上代码来自JCY0709▲▲▲

            // ▼▼▼ 请用这个【修正版】函数，完整替换掉旧的 updateSettingsPreview 函数 ▼▼▼

            function updateSettingsPreview() {
                if (!state.activeChatId) return;
                const chat = state.chats[state.activeChatId];
                const previewArea = document.getElementById('settings-preview-area');
                if (!previewArea) return;

                // 1. 获取当前设置的值
                const selectedTheme = document.querySelector('input[name="theme-select"]:checked')?.value || 'default';
                const fontSize = document.getElementById('font-size-slider').value;
                const customCss = document.getElementById('custom-css-input').value;
                const background = chat.settings.background; // 直接获取背景设置

                // 2. 更新预览区的基本样式
                previewArea.dataset.theme = selectedTheme;
                previewArea.style.setProperty('--chat-font-size', `${fontSize}px`);

                // --- 【核心修正】直接更新预览区的背景样式 ---
                if (background && background.startsWith('data:image')) {
                    previewArea.style.backgroundImage = `url(${background})`;
                    previewArea.style.backgroundColor = 'transparent'; // 如果有图片，背景色设为透明
                } else {
                    previewArea.style.backgroundImage = 'none'; // 如果没有图片，移除图片背景
                    // 如果背景是颜色值或渐变（非图片），则直接应用
                    previewArea.style.background = background || '#f0f2f5';
                }

                // 3. 渲染模拟气泡
                previewArea.innerHTML = '';

                // 创建“对方”的气泡
                // 注意：我们将一个虚拟的 timestamp 传入，以防有CSS依赖于它
                const aiMsg = { role: 'ai', content: '对方消息预览', timestamp: 1, senderName: chat.name };
                const aiBubble = createMessageElement(aiMsg, chat);
                if (aiBubble) previewArea.appendChild(aiBubble);

                // 创建“我”的气泡
                const userMsg = { role: 'user', content: '我的消息预览', timestamp: 2 };
                const userBubble = createMessageElement(userMsg, chat);
                if (userBubble) previewArea.appendChild(userBubble);

                // 4. 应用自定义CSS到预览区
                applyScopedCss(customCss, '#settings-preview-area', 'preview-bubble-style');
            }

            // ▲▲▲ 替换结束 ▲▲▲

            // ▼▼▼ 请将这些【新函数】粘贴到JS功能函数定义区 ▼▼▼

            async function openGroupManager() {
                await renderGroupList();
                document.getElementById('group-management-modal').classList.add('visible');
            }

            async function renderGroupList() {
                const listEl = document.getElementById('existing-groups-list');
                const groups = await db.qzoneGroups.toArray();
                listEl.innerHTML = '';
                if (groups.length === 0) {
                    listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分组</p>';
                }
                groups.forEach(group => {
                    const item = document.createElement('div');
                    item.className = 'existing-group-item';
                    item.innerHTML = `
            <span class="group-name">${group.name}</span>
            <span class="delete-group-btn" data-id="${group.id}">×</span>
        `;
                    listEl.appendChild(item);
                });
            }

            // ▼▼▼ 请用这个【修正后】的函数，完整替换旧的 addNewGroup 函数 ▼▼▼
            async function addNewGroup() {
                const input = document.getElementById('new-group-name-input');
                const name = input.value.trim();
                if (!name) {
                    alert('分组名不能为空！');
                    return;
                }

                // 【核心修正】在添加前，先检查分组名是否已存在
                const existingGroup = await db.qzoneGroups.where('name').equals(name).first();
                if (existingGroup) {
                    alert(`分组 "${name}" 已经存在了，换个名字吧！`);
                    return;
                }
                // 【修正结束】

                await db.qzoneGroups.add({ name });
                input.value = '';
                await renderGroupList();
            }
            // ▲▲▲ 替换结束 ▲▲▲

            async function deleteGroup(groupId) {
                const confirmed = await showCustomConfirm('确认删除', '删除分组后，该组内的好友将变为“未分组”。确定要删除吗？', { confirmButtonClass: 'btn-danger' });
                if (confirmed) {
                    await db.qzoneGroups.delete(groupId);
                    // 将属于该分组的好友的 groupId 设为 null
                    const chatsToUpdate = await db.chats.where('groupId').equals(groupId).toArray();
                    for (const chat of chatsToUpdate) {
                        chat.groupId = null;
                        await db.chats.put(chat);
                        if (state.chats[chat.id]) state.chats[chat.id].groupId = null;
                    }
                    await renderGroupList();
                }
            }

            // ▲▲▲ 新函数粘贴结束 ▲▲▲

            // ▼▼▼ 请将这【一整块新函数】粘贴到JS功能函数定义区的末尾 ▼▼▼

            /**
             * 当长按消息时，显示操作菜单
             * @param {number} timestamp - 被长按消息的时间戳
             */
            function showMessageActions(timestamp) {
                // 如果已经在多选模式，则不弹出菜单
                if (isSelectionMode) return;

                activeMessageTimestamp = timestamp;

                // Show all buttons for regular chat (in case they were hidden by date mode)
                const quoteBtn = document.getElementById('quote-message-btn');
                const recallBtn = document.getElementById('recall-message-btn');

                if (quoteBtn) quoteBtn.style.display = 'block';
                if (recallBtn) recallBtn.style.display = 'block';

                document.getElementById('message-actions-modal').classList.add('visible');
            }

            /**
             * 隐藏消息操作菜单
             */
            function hideMessageActions() {
                document.getElementById('message-actions-modal').classList.remove('visible');
                activeMessageTimestamp = null;
            }

            /**
             * 当长按聊天时，显示操作菜单
             * @param {string} chatId - 被长按聊天的ID
             */
            function showChatActions(chatId) {
                const chat = state.chats[chatId];
                if (!chat) return;

                activeChatId = chatId;
                const modal = document.getElementById('chat-actions-modal');
                const pinBtn = document.getElementById('pin-chat-btn');
                const unpinBtn = document.getElementById('unpin-chat-btn');

                // 根据置顶状态显示不同的按钮
                if (chat.isPinned) {
                    pinBtn.style.display = 'none';
                    unpinBtn.style.display = 'block';
                } else {
                    pinBtn.style.display = 'block';
                    unpinBtn.style.display = 'none';
                }

                modal.classList.add('visible');
            }

            /**
             * 隐藏聊天操作菜单
             */
            function hideChatActions() {
                document.getElementById('chat-actions-modal').classList.remove('visible');
                activeChatId = null;
            }

            /**
             * 【全新】开始引用回复模式
             */
            function startReplyToMessage() {
                if (!activeMessageTimestamp) return;

                const chat = state.chats[state.activeChatId];
                const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);

                if (message) {
                    // 构建引用上下文对象
                    const senderName = message.role === 'user' ?
                        (chat.isGroup ? (chat.settings.myNickname || '我') : '我') :
                        (message.senderName || chat.name);

                    currentReplyContext = {
                        timestamp: message.timestamp,
                        content: message.content,
                        senderName: senderName
                    };

                    // 显示预览栏
                    const previewBar = document.getElementById('reply-preview-bar');
                    const senderEl = previewBar.querySelector('.sender');
                    const textEl = previewBar.querySelector('.text');

                    senderEl.textContent = `回复 ${senderName}:`;
                    textEl.textContent = String(message.content).substring(0, 50);

                    previewBar.style.display = 'flex';
                }

                hideMessageActions();
                document.getElementById('chat-input').focus();
            }

            /**
             * 【全新】处理用户点击"撤回"按钮的入口函数
             */
            async function handleRecallClick() {
                if (!activeMessageTimestamp) return;

                const RECALL_TIME_LIMIT_MS = 2 * 60 * 1000; // 设置2分钟的撤回时限
                const messageTime = activeMessageTimestamp;
                const now = Date.now();

                // 检查是否超过了撤回时限
                if (now - messageTime > RECALL_TIME_LIMIT_MS) {
                    hideMessageActions();
                    await showCustomAlert('操作失败', '该消息发送已超过2分钟，无法撤回。');
                    return;
                }

                // 如果在时限内，执行真正的撤回逻辑
                await recallMessage(messageTime, true);
                hideMessageActions();
            }

            /**
             * 【全新】消息撤回的核心逻辑
             * @param {number} timestamp - 要撤回的消息的时间戳
             * @param {boolean} isUserRecall - 是否是用户主动撤回
             */
            async function recallMessage(timestamp, isUserRecall) {
                const chat = state.chats[state.activeChatId];
                if (!chat) return;

                const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
                if (messageIndex === -1) return;

                const messageToRecall = chat.history[messageIndex];

                // 1. 修改消息对象，将其变为"已撤回"状态
                const recalledData = {
                    originalType: messageToRecall.type || 'text',
                    originalContent: messageToRecall.content,
                    // 保存其他可能存在的原始数据
                    originalMeaning: messageToRecall.meaning,
                    originalQuote: messageToRecall.quote
                };

                messageToRecall.type = 'recalled_message';
                messageToRecall.content = isUserRecall ? '你撤回了一条消息' : '对方撤回了一条消息';
                messageToRecall.recalledData = recalledData;
                // 清理掉不再需要的旧属性
                delete messageToRecall.meaning;
                delete messageToRecall.quote;

                // 2. 如果是用户撤回，需要给AI发送一条它看不懂内容的隐藏提示
                if (isUserRecall) {
                    const hiddenMessageForAI = {
                        role: 'system',
                        content: `[系统提示：用户撤回了一条消息。你不知道内容是什么，只需知道这个事件即可。]`,
                        timestamp: Date.now(),
                        isHidden: true
                    };
                    chat.history.push(hiddenMessageForAI);
                }

                // 3. 保存到数据库并刷新UI
                await db.chats.put(chat);
                renderChatInterface(state.activeChatId);
                if (isUserRecall) renderChatList(); // 用户撤回时，最后一条消息变了，需要刷新列表
            }



            /**
             * 【全新】取消引用模式
             */
            function cancelReplyMode() {
                currentReplyContext = null;
                document.getElementById('reply-preview-bar').style.display = 'none';
            }

            // ▼▼▼ 请用这个【带格式助手的终极版】替换旧的 openMessageEditor 函数 ▼▼▼
            async function openMessageEditor() {
                if (!activeMessageTimestamp) return;

                const timestampToEdit = activeMessageTimestamp;
                const chat = state.chats[state.activeChatId];
                const message = chat.history.find(m => m.timestamp === timestampToEdit);
                if (!message) return;

                hideMessageActions();

                let contentForEditing;
                const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer'].includes(message.type);

                if (isSpecialType) {
                    let fullMessageObject = { type: message.type };
                    if (message.type === 'voice_message') fullMessageObject.content = message.content;
                    else if (message.type === 'ai_image') {
                        fullMessageObject.description = message.content;
                        // Always show imageUrl field, use existing or default
                        fullMessageObject.imageUrl = message.imageUrl || "https://files.catbox.moe/cww7rw.jpg";
                    }
                    else if (message.type === 'transfer') {
                        fullMessageObject.amount = message.amount;
                        fullMessageObject.note = message.note;
                    }
                    contentForEditing = JSON.stringify(fullMessageObject, null, 2);
                } else if (typeof message.content === 'object') {
                    contentForEditing = JSON.stringify(message.content, null, 2);
                } else {
                    contentForEditing = message.content;
                }

                // --- 【核心修改】在这里构建“格式助手”按钮的HTML ---
                const templates = {
                    voice: { type: 'voice_message', content: '在这里输入语音内容' },
                    image: { type: 'ai_image', description: '在这里输入图片描述', imageUrl: 'https://example.com/your-image.jpg' },
                    transfer: { type: 'transfer', amount: 5.20, note: '一点心意' }
                };

                // 使用 data-template 属性存储JSON模板字符串，注意要用单引号包裹
                const helpersHtml = `
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>语音</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>转账</button>
        </div>
    `;
                // --- 【核心修改结束】---

                const newContent = await showCustomPrompt(
                    '编辑消息',
                    '在此修改，或点击上方按钮使用格式模板...', // 修改提示语
                    contentForEditing,
                    'textarea',
                    helpersHtml // 将按钮的HTML作为第5个参数传入
                );

                if (newContent !== null) {
                    await saveEditedMessage(timestampToEdit, newContent);
                }
            }
            // ▲▲▲ 替换结束 ▲▲▲


            // ▼▼▼ 【全新】可视化多消息编辑器驱动函数 ▼▼▼

            /**
             * 创建一个可编辑的消息块（包含文本框、格式助手和删除按钮）
             * @param {string} initialContent - 文本框的初始内容
             * @returns {HTMLElement} - 创建好的DOM元素
             */
            function createMessageEditorBlock(initialContent = '') {
                const block = document.createElement('div');
                block.className = 'message-editor-block';

                const templates = {
                    voice: { type: 'voice_message', content: '在这里输入语音内容' },
                    image: { type: 'ai_image', description: '在这里输入图片描述', imageUrl: 'https://example.com/your-image.jpg' },
                    transfer: { type: 'transfer', amount: 5.20, note: '一点心意' }
                };

                block.innerHTML = `
        <button class="delete-block-btn" title="删除此条">×</button>
        <textarea>${initialContent}</textarea>
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>语音</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>转账</button>
        </div>
    `;

                // 绑定删除按钮事件
                block.querySelector('.delete-block-btn').addEventListener('click', () => {
                    // 确保至少保留一个编辑块
                    if (document.querySelectorAll('.message-editor-block').length > 1) {
                        block.remove();
                    } else {
                        alert('至少需要保留一条消息。');
                    }
                });

                // 绑定格式助手按钮事件
                block.querySelectorAll('.format-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const templateStr = btn.dataset.template;
                        const textarea = block.querySelector('textarea');
                        if (templateStr && textarea) {
                            try {
                                const templateObj = JSON.parse(templateStr);
                                textarea.value = JSON.stringify(templateObj, null, 2);
                                textarea.focus();
                            } catch (e) { console.error("解析格式模板失败:", e); }
                        }
                    });
                });

                return block;
            }

            // ▼▼▼ 【全新升级版】请用此函数完整替换旧的 openAdvancedMessageEditor ▼▼▼
            /**
             * 打开全新的、可视化的多消息编辑器，并动态绑定其所有按钮事件
             */
            function openAdvancedMessageEditor() {
                if (!activeMessageTimestamp) return;

                // 1. 【核心】在关闭旧菜单前，将需要的时间戳捕获到局部变量中
                const timestampToEdit = activeMessageTimestamp;

                const chat = state.chats[state.activeChatId];
                const message = chat.history.find(m => m.timestamp === timestampToEdit);
                if (!message) return;

                // 2. 现在可以安全地关闭旧菜单了，因为它不会影响我们的局部变量
                hideMessageActions();

                const editorModal = document.getElementById('message-editor-modal');
                const editorContainer = document.getElementById('message-editor-container');
                editorContainer.innerHTML = '';

                // 3. 准备初始内容
                let initialContent;
                const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer'].includes(message.type);
                if (isSpecialType) {
                    let fullMessageObject = { type: message.type };
                    if (message.type === 'voice_message') fullMessageObject.content = message.content;
                    else if (message.type === 'ai_image') {
                        fullMessageObject.description = message.content;
                        // Always show imageUrl field, use existing or default
                        fullMessageObject.imageUrl = message.imageUrl || "https://files.catbox.moe/cww7rw.jpg";
                    }
                    else if (message.type === 'transfer') {
                        fullMessageObject.amount = message.amount;
                        fullMessageObject.note = message.note;
                    }
                    initialContent = JSON.stringify(fullMessageObject, null, 2);
                } else if (typeof message.content === 'object') {
                    initialContent = JSON.stringify(message.content, null, 2);
                } else {
                    initialContent = message.content;
                }

                const firstBlock = createMessageEditorBlock(initialContent);
                editorContainer.appendChild(firstBlock);

                // 4. 【核心】动态绑定所有控制按钮的事件
                // 为了防止事件重复绑定，我们使用克隆节点的方法来清除旧监听器
                const addBtn = document.getElementById('add-message-editor-block-btn');
                const newAddBtn = addBtn.cloneNode(true);
                addBtn.parentNode.replaceChild(newAddBtn, addBtn);
                newAddBtn.addEventListener('click', () => {
                    const newBlock = createMessageEditorBlock();
                    editorContainer.appendChild(newBlock);
                    newBlock.querySelector('textarea').focus();
                });

                const cancelBtn = document.getElementById('cancel-advanced-editor-btn');
                const newCancelBtn = cancelBtn.cloneNode(true);
                cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
                newCancelBtn.addEventListener('click', () => {
                    editorModal.classList.remove('visible');
                });

                const saveBtn = document.getElementById('save-advanced-editor-btn');
                const newSaveBtn = saveBtn.cloneNode(true);
                saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
                // 将捕获到的时间戳，直接绑定给这一次的保存点击事件
                newSaveBtn.addEventListener('click', () => {
                    saveEditedMessage(timestampToEdit);
                });

                // 5. 最后，显示模态框
                editorModal.classList.add('visible');
            }
            // ▲▲▲ 替换结束 ▲▲▲

            /**
             * 解析编辑后的文本，并返回一个标准化的消息片段对象
             * @param {string} text - 用户在编辑框中输入的文本
             * @returns {object} - 一个包含 type, content, 等属性的对象
             */
            function parseEditedContent(text) {
                const trimmedText = text.trim();

                // 1. 尝试解析为JSON对象（用于修复语音、转账等格式）
                if (trimmedText.startsWith('{') && trimmedText.endsWith('}')) {
                    try {
                        const parsed = JSON.parse(trimmedText);
                        // 必须包含 type 属性才认为是有效格式
                        if (parsed.type) {
                            return parsed;
                        }
                    } catch (e) { /* 解析失败，继续往下走 */ }
                }

                // 2. 尝试解析为表情包
                if (STICKER_REGEX.test(trimmedText)) {
                    // 对于编辑的表情，我们暂时无法知道其`meaning`，所以只存URL
                    return { type: 'sticker', content: trimmedText };
                }

                // 3. 否则，视为普通文本消息
                return { type: 'text', content: trimmedText };
            }


            // ▼▼▼ 请用这个【支持可视化编辑】的全新函数，完整替换旧的 saveEditedMessage 函数 ▼▼▼
            /**
             * 从可视化编辑器收集所有消息，更新数据库和UI
             * @param {number} timestamp - 要修改的原始消息的时间戳
             */
            async function saveEditedMessage(timestamp) {
                if (!timestamp) return;

                const chat = state.chats[state.activeChatId];
                const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
                if (messageIndex === -1) return;

                const editorContainer = document.getElementById('message-editor-container');
                const editorBlocks = editorContainer.querySelectorAll('.message-editor-block');

                let newMessages = [];
                let baseTimestamp = timestamp; // 使用原始时间戳作为基准

                for (const block of editorBlocks) {
                    const textarea = block.querySelector('textarea');
                    const rawContent = textarea.value.trim();

                    if (!rawContent) continue; // 跳过空的编辑框

                    const parsedResult = parseEditedContent(rawContent);

                    const newMessage = {
                        role: chat.history[messageIndex].role,
                        senderName: chat.history[messageIndex].senderName,
                        timestamp: baseTimestamp++, // 递增时间戳保证顺序和唯一性
                        content: parsedResult.content || '',
                    };

                    if (parsedResult.type && parsedResult.type !== 'text') newMessage.type = parsedResult.type;
                    if (parsedResult.meaning) newMessage.meaning = parsedResult.meaning;
                    if (parsedResult.amount) newMessage.amount = parsedResult.amount;
                    if (parsedResult.note) newMessage.note = parsedResult.note;
                    if (parsedResult.description) newMessage.content = parsedResult.description;
                    if (parsedResult.imageUrl) newMessage.imageUrl = parsedResult.imageUrl;

                    newMessages.push(newMessage);
                }

                if (newMessages.length === 0) {
                    alert("不能保存空消息，请至少输入一条内容。");
                    return;
                }

                // 在历史记录的原始位置，删除1条旧消息，并插入所有新消息
                chat.history.splice(messageIndex, 1, ...newMessages);

                // 将最终的、更新后的 history 保存到数据库
                await db.chats.put(chat);

                // 关闭模态框并刷新UI
                document.getElementById('message-editor-modal').classList.remove('visible');
                renderChatInterface(state.activeChatId);
                await showCustomAlert('成功', '消息已更新！');
            }
            // ▲▲▲ 替换结束 ▲▲▲

            // ▼▼▼ 请将这【一整块新函数】粘贴到JS功能函数定义区的末尾 ▼▼▼

            /**
             * 当点击“…”时，显示动态操作菜单
             * @param {number} postId - 被操作的动态的ID
             */
            async function showPostActions(postId) {
                activePostId = postId;

                // 获取当前动态信息以确定显示置顶还是取消置顶
                const post = await db.qzonePosts.get(postId);
                const pinBtn = document.getElementById('pin-post-btn');
                const unpinBtn = document.getElementById('unpin-post-btn');

                if (post && post.isPinned) {
                    pinBtn.style.display = 'none';
                    unpinBtn.style.display = 'block';
                } else {
                    pinBtn.style.display = 'block';
                    unpinBtn.style.display = 'none';
                }

                document.getElementById('post-actions-modal').classList.add('visible');
            }

            /**
             * 隐藏动态操作菜单
             */
            function hidePostActions() {
                document.getElementById('post-actions-modal').classList.remove('visible');
                activePostId = null;
            }

            /**
             * 打开动态编辑器
             */
            async function openPostEditor() {
                if (!activePostId) return;

                const postIdToEdit = activePostId;
                const post = await db.qzonePosts.get(postIdToEdit);
                if (!post) return;

                hidePostActions();

                // 忠于原文：构建出最原始的文本形态供编辑
                let contentForEditing;
                if (post.type === 'shuoshuo') {
                    contentForEditing = post.content;
                } else {
                    // 对于图片和文字图，我们构建一个包含所有信息的对象
                    const postObject = {
                        type: post.type,
                        publicText: post.publicText || '',
                    };
                    if (post.type === 'image_post') {
                        postObject.imageUrl = post.imageUrl;
                        postObject.imageDescription = post.imageDescription;
                    } else if (post.type === 'text_image') {
                        postObject.hiddenContent = post.hiddenContent;
                        postObject.decorativeImageUrl = post.decorativeImageUrl || '';
                    }
                    contentForEditing = JSON.stringify(postObject, null, 2);
                }

                // 构建格式助手按钮
                const templates = {
                    shuoshuo: "在这里输入说说的内容...", // 对于说说，我们直接替换为纯文本
                    image: { type: 'image_post', publicText: '', imageUrl: 'https://...', imageDescription: '' },
                    text_image: { type: 'text_image', publicText: '', hiddenContent: '' }
                };

                const helpersHtml = `
        <div class="format-helpers">
            <button class="format-btn" data-type="text">说说</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片动态</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.text_image)}'>文字图</button>
        </div>
    `;

                const newContent = await showCustomPrompt(
                    '编辑动态',
                    '在此修改内容...',
                    contentForEditing,
                    'textarea',
                    helpersHtml
                );

                // 【特殊处理】为说说的格式助手按钮添加不同的行为
                // 我们需要在模态框出现后，再给它绑定事件
                setTimeout(() => {
                    const shuoshuoBtn = document.querySelector('#custom-modal-body .format-btn[data-type="text"]');
                    if (shuoshuoBtn) {
                        shuoshuoBtn.addEventListener('click', () => {
                            const input = document.getElementById('custom-prompt-input');
                            input.value = templates.shuoshuo;
                            input.focus();
                        });
                    }
                }, 100);

                if (newContent !== null) {
                    await saveEditedPost(postIdToEdit, newContent);
                }
            }

            /**
             * 保存编辑后的动态
             * @param {number} postId - 要保存的动态ID
             * @param {string} newRawContent - 从编辑器获取的新内容
             */
            async function saveEditedPost(postId, newRawContent) {
                const post = await db.qzonePosts.get(postId);
                if (!post) return;

                const trimmedContent = newRawContent.trim();

                // 尝试解析为JSON，如果失败，则认为是纯文本（说说）
                try {
                    const parsed = JSON.parse(trimmedContent);
                    // 更新帖子属性
                    post.type = parsed.type || 'image_post';
                    post.publicText = parsed.publicText || '';
                    post.imageUrl = parsed.imageUrl || '';
                    post.imageDescription = parsed.imageDescription || '';
                    post.hiddenContent = parsed.hiddenContent || '';
                    post.decorativeImageUrl = parsed.decorativeImageUrl || null; // IMPORTANT: Purely decorative, never sent to API
                    post.content = ''; // 清空旧的说说内容字段
                } catch (e) {
                    // 解析失败，认为是说说
                    post.type = 'shuoshuo';
                    post.content = trimmedContent;
                    // 清空其他类型的字段
                    post.publicText = '';
                    post.imageUrl = '';
                    post.imageDescription = '';
                    post.hiddenContent = '';
                    post.decorativeImageUrl = null;
                }

                await db.qzonePosts.put(post);
                await renderQzonePosts(); // 重新渲染列表
                await showCustomAlert('成功', '动态已更新！');
            }

            /**
             * 显示评论操作菜单
             */
            function showCommentActions(postId, commentTimestamp, commentText, commenterName) {
                activeCommentData = {
                    postId: postId,
                    timestamp: commentTimestamp,
                    text: commentText,
                    commenterName: commenterName
                };
                document.getElementById('comment-actions-modal').classList.add('visible');
            }

            /**
             * 隐藏评论操作菜单
             */
            function hideCommentActions() {
                document.getElementById('comment-actions-modal').classList.remove('visible');
                activeCommentData = null;
            }

            /**
             * 编辑评论
             */
            async function editComment() {
                if (!activeCommentData) return;

                const newText = await showCustomPrompt('编辑评论', '请输入新的评论内容:', activeCommentData.text, 'textarea');
                if (newText === null || newText.trim() === '') return;

                try {
                    const post = await db.qzonePosts.get(activeCommentData.postId);
                    if (!post || !post.comments) return;

                    // 找到并更新评论
                    const commentIndex = post.comments.findIndex(c => c.timestamp === activeCommentData.timestamp);
                    if (commentIndex !== -1) {
                        post.comments[commentIndex].text = newText.trim();
                        await db.qzonePosts.put(post);

                        // 关闭操作菜单
                        hideCommentActions();

                        // 刷新动态列表
                        if (document.getElementById('qzone-screen').classList.contains('active')) {
                            await renderQzonePosts();
                        }

                        await showCustomAlert('编辑成功', '评论已更新');
                    }
                } catch (error) {
                    console.error('编辑评论失败:', error);
                    await showCustomAlert('编辑失败', '编辑评论时发生错误，请重试');
                }
            }

            /**
             * 删除评论
             */
            async function deleteComment() {
                if (!activeCommentData) return;

                const confirmed = await showCustomConfirm(
                    '删除评论',
                    '确定要删除这条评论吗？此操作无法撤销。',
                    { confirmButtonClass: 'btn-danger' }
                );

                if (!confirmed) return;

                try {
                    const post = await db.qzonePosts.get(activeCommentData.postId);
                    if (!post || !post.comments) return;

                    // 删除评论
                    post.comments = post.comments.filter(c => c.timestamp !== activeCommentData.timestamp);
                    await db.qzonePosts.put(post);

                    // 关闭操作菜单
                    hideCommentActions();

                    // 刷新动态列表
                    if (document.getElementById('qzone-screen').classList.contains('active')) {
                        await renderQzonePosts();
                    }

                    await showCustomAlert('删除成功', '评论已删除');

                } catch (error) {
                    console.error('删除评论失败:', error);
                    await showCustomAlert('删除失败', '删除评论时发生错误，请重试');
                }
            }

            // ▼▼▼ AI回复模态框相关函数 ▼▼▼
            let currentPostIdForAiReply = null;

            /**
             * 显示AI回复选择模态框
             */
            function showAiReplyModal(postId) {
                currentPostIdForAiReply = postId;

                // 获取所有可用的AI
                const availableAis = [];
                for (const chatId in state.chats) {
                    const chat = state.chats[chatId];
                    if (!chat.isGroup) {
                        const aiAvatar = chat.settings.aiAvatar || defaultAvatar;
                        availableAis.push({
                            id: chatId,
                            name: chat.name,
                            avatar: aiAvatar,
                            status: chat.relationship?.status || 'friend'
                        });
                    }
                }

                if (availableAis.length === 0) {
                    alert('没有可用的AI角色');
                    return;
                }

                // 生成AI列表HTML
                const aiListHtml = availableAis.map(ai => `
        <div class="ai-selection-item" onclick="window.toggleAiSelection('${ai.id}')">
            <input type="checkbox" id="ai-${ai.id}" data-ai-id="${ai.id}">
            <img src="${ai.avatar}" class="ai-selection-avatar" alt="${ai.name}">
            <div class="ai-selection-info">
                <div class="ai-selection-name">${ai.name}</div>
                <div class="ai-selection-status">${ai.status === 'friend' ? '好友' : ai.status}</div>
            </div>
        </div>
    `).join('');

                document.getElementById('ai-selection-list').innerHTML = aiListHtml;
                document.getElementById('ai-reply-modal').classList.add('visible');
            }

            /**
             * 隐藏AI回复选择模态框
             */
            function hideAiReplyModal() {
                document.getElementById('ai-reply-modal').classList.remove('visible');
                currentPostIdForAiReply = null;
            }

            /**
             * 切换AI选择状态
             */
            window.toggleAiSelection = function (aiId) {
                const checkbox = document.getElementById(`ai-${aiId}`);
                if (checkbox) {
                    checkbox.checked = !checkbox.checked;
                }
            }

            /**
             * 全选AI
             */
            function selectAllAis() {
                const checkboxes = document.querySelectorAll('#ai-selection-list input[type="checkbox"]');
                checkboxes.forEach(cb => cb.checked = true);
            }

            /**
             * 取消全选AI
             */
            function deselectAllAis() {
                const checkboxes = document.querySelectorAll('#ai-selection-list input[type="checkbox"]');
                checkboxes.forEach(cb => cb.checked = false);
            }

            /**
             * 确认AI回复
             */
            async function confirmAiReply() {
                if (!currentPostIdForAiReply) {
                    return;
                }

                // 获取选中的AI
                const selectedAis = [];
                const checkboxes = document.querySelectorAll('#ai-selection-list input[type="checkbox"]:checked');
                checkboxes.forEach(cb => {
                    selectedAis.push(cb.dataset.aiId);
                });

                if (selectedAis.length === 0) {
                    alert('请至少选择一个AI');
                    return;
                }

                // 保存postId到局部变量，避免hideAiReplyModal清空它
                const postIdToProcess = currentPostIdForAiReply;
                hideAiReplyModal();

                // 找到对应的机器人按钮并改变为加载状态
                const postContainer = document.querySelector(`[data-post-id="${postIdToProcess}"]`);
                const aiReplyBtn = postContainer ? postContainer.querySelector('.call-ai-reply-btn') : null;

                if (aiReplyBtn) {
                    aiReplyBtn.innerHTML = '⏳';
                    aiReplyBtn.disabled = true;
                    aiReplyBtn.style.opacity = '0.6';
                }

                // 为每个选中的AI触发回复
                let completedCount = 0;
                let successCount = 0;
                for (const aiId of selectedAis) {
                    try {
                        const success = await triggerAiPostReply(aiId, postIdToProcess);
                        completedCount++;
                        if (success !== false) {
                            successCount++;
                        }
                    } catch (error) {
                        completedCount++;
                    }
                }

                // 恢复按钮状态
                if (aiReplyBtn) {
                    aiReplyBtn.innerHTML = '🤖';
                    aiReplyBtn.disabled = false;
                    aiReplyBtn.style.opacity = '1';
                }

                // 刷新动态列表
                try {
                    await renderQzonePosts();
                } catch (error) {
                    // 静默处理错误
                }

                // 显示完成通知
                const completionMsg = document.createElement('div');
                const bgColor = successCount === selectedAis.length ? 'rgba(0,128,0,0.9)' : 'rgba(255,165,0,0.9)';
                completionMsg.style.cssText = `position: fixed; top: 20px; right: 20px; background: ${bgColor}; color: white; padding: 15px 20px; border-radius: 10px; z-index: 9999; font-size: 14px;`;
                completionMsg.innerHTML = `✅ AI回复完成<br>成功: ${successCount}/${selectedAis.length}`;
                document.body.appendChild(completionMsg);

                // 3秒后自动移除通知
                setTimeout(() => {
                    if (completionMsg.parentNode) {
                        document.body.removeChild(completionMsg);
                    }
                }, 3000);
            }

            /**
             * 触发AI对特定动态的回复 - 基于triggerInactiveAiAction但针对特定动态
             */
            async function triggerAiPostReply(chatId, postId) {
                const chat = state.chats[chatId];
                if (!chat) return false;

                const { proxyUrl, apiKey, model } = state.apiConfig;
                if (!proxyUrl || !apiKey || !model) return false;

                // 获取动态信息
                const post = await db.qzonePosts.get(postId);
                if (!post) return false;

                const now = new Date();
                const currentTime = now.toLocaleTimeString('zh-CN', { hour: 'numeric', minute: 'numeric', hour12: true });
                const userNickname = state.qzoneSettings.nickname;

                // 构建动态上下文
                let postContent = '';
                if (post.type === 'shuoshuo') {
                    postContent = post.content || '';
                } else if (post.type === 'image_post') {
                    postContent = (post.publicText || '') + (post.imageDescription ? ` [图片描述: ${post.imageDescription}]` : '');
                } else if (post.type === 'text_image') {
                    postContent = (post.publicText || '') + (post.hiddenContent ? ` [图片描述: ${post.hiddenContent}]` : '');
                }

                // 构建评论上下文
                let commentsContext = '';
                if (post.comments && post.comments.length > 0) {
                    commentsContext = '\n现有评论:\n' + post.comments.map(c => `${c.commenterName}: ${c.text}`).join('\n');
                }

                // 获取世界书上下文
                let worldBookContextForAction = '';
                const coreWorldBookName = "maininfo";
                const coreWorldBook = state.worldBooks.find(wb => wb.name === coreWorldBookName);
                if (coreWorldBook && coreWorldBook.content) {
                    worldBookContextForAction = `\n\n# 核心社交关系设定 (你必须严格遵守以下所有设定)\n${coreWorldBook.content}\n`;
                }

                // 构建系统提示
                const systemPrompt = `
# 你的任务
你现在扮演一个名为"${chat.name}"的角色。用户希望你对一条特定的动态进行回复。

# 你的角色设定
${chat.settings.aiPersona}

# 动态信息
- 动态ID: ${postId}
- 动态内容: "${postContent}"
- 发布者: ${post.authorId === 'user' ? userNickname : (state.chats[post.authorId]?.name || '未知')}
${commentsContext}

# 你的可选行动 (请根据你的性格【选择一项】执行):
1. **评论动态**: 使用 \`{"type": "qzone_comment", "postId": ${postId}, "commentText": "你的评论内容"}\`
2. **点赞动态**: 使用 \`{"type": "qzone_like", "postId": ${postId}}\`
3. **既评论又点赞**: 返回包含两个操作的JSON数组

请根据你的性格特点和对这条动态的看法，选择合适的回应方式。

${worldBookContextForAction}

现在是 ${currentTime}，请做出你的回应。`;

                try {
                    const data = await makeAPIRequest(proxyUrl, apiKey, model, [{ role: 'user', content: systemPrompt }], 0.8);

                    if (!data.choices || data.choices.length === 0 || !data.choices[0].message.content) {
                        return false;
                    }

                    const aiResponse = data.choices[0].message.content.trim();

                    // 解析AI回复
                    let actions = [];
                    try {
                        // 清理AI回复，移除markdown代码块标记
                        let cleanedResponse = aiResponse.trim();
                        if (cleanedResponse.startsWith('```json')) {
                            cleanedResponse = cleanedResponse.replace(/^```json\s*/, '').replace(/```\s*$/, '');
                        } else if (cleanedResponse.startsWith('```')) {
                            cleanedResponse = cleanedResponse.replace(/^```\s*/, '').replace(/```\s*$/, '');
                        }

                        const parsed = JSON.parse(cleanedResponse);
                        actions = Array.isArray(parsed) ? parsed : [parsed];
                    } catch (e) {
                        return false;
                    }

                    // 处理AI的行动
                    for (const action of actions) {
                        if (action.type === 'qzone_comment') {
                            const postToComment = await db.qzonePosts.get(parseInt(action.postId));
                            if (postToComment) {
                                if (!postToComment.comments) postToComment.comments = [];
                                const newComment = {
                                    commenterName: chat.name,
                                    text: action.commentText,
                                    timestamp: Date.now()
                                };
                                postToComment.comments.push(newComment);
                                await db.qzonePosts.update(postToComment.id, { comments: postToComment.comments });
                            }
                        } else if (action.type === 'qzone_like') {
                            const postToLike = await db.qzonePosts.get(parseInt(action.postId));
                            if (postToLike) {
                                if (!postToLike.likes) postToLike.likes = [];
                                if (!postToLike.likes.includes(chat.name)) {
                                    postToLike.likes.push(chat.name);
                                    await db.qzonePosts.update(postToLike.id, { likes: postToLike.likes });
                                }
                            }
                        }
                    }

                    return true;

                } catch (error) {
                    return false;
                }
            }
            // ▲▲▲ AI回复模态框相关函数结束 ▲▲▲

            // ▼▼▼ AI发动态模态框相关函数 ▼▼▼
            let selectedAiForPost = null;

            /**
             * 显示AI发动态选择模态框
             */
            function showAiPostModal() {
                // 获取所有可用的AI
                const availableAis = [];
                for (const chatId in state.chats) {
                    const chat = state.chats[chatId];
                    if (!chat.isGroup) {
                        const aiAvatar = chat.settings.aiAvatar || defaultAvatar;
                        availableAis.push({
                            id: chatId,
                            name: chat.name,
                            avatar: aiAvatar,
                            status: chat.relationship?.status || 'friend'
                        });
                    }
                }

                if (availableAis.length === 0) {
                    alert('没有可用的AI角色');
                    return;
                }

                // 生成AI列表HTML (单选)
                const aiListHtml = availableAis.map(ai => `
        <div class="ai-selection-item" onclick="selectAiForPost('${ai.id}')">
            <input type="radio" name="ai-post-selection" id="ai-post-${ai.id}" data-ai-id="${ai.id}">
            <img src="${ai.avatar}" class="ai-selection-avatar" alt="${ai.name}">
            <div class="ai-selection-info">
                <div class="ai-selection-name">${ai.name}</div>
                <div class="ai-selection-status">${ai.status === 'friend' ? '好友' : ai.status}</div>
            </div>
        </div>
    `).join('');

                document.getElementById('ai-post-selection-list').innerHTML = aiListHtml;
                document.getElementById('ai-post-modal').classList.add('visible');
            }

            /**
             * 隐藏AI发动态选择模态框
             */
            function hideAiPostModal() {
                document.getElementById('ai-post-modal').classList.remove('visible');
                selectedAiForPost = null;
            }

            /**
             * 选择AI发动态
             */
            window.selectAiForPost = function (aiId) {
                selectedAiForPost = aiId;
                const radio = document.getElementById(`ai-post-${aiId}`);
                if (radio) {
                    radio.checked = true;
                }
            }

            /**
             * 确认AI发动态
             */
            async function confirmAiPost() {
                // Check for selected radio button instead of relying on variable
                const selectedRadio = document.querySelector('input[name="ai-post-selection"]:checked');
                if (!selectedRadio) {
                    alert('请选择一个AI');
                    return;
                }

                const selectedAiId = selectedRadio.dataset.aiId;

                hideAiPostModal();

                // 显示处理中提示
                const processingMsg = document.createElement('div');
                processingMsg.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 10px; z-index: 9999; text-align: center;';
                processingMsg.innerHTML = `<div>🤖 AI正在思考发什么动态...</div>`;
                document.body.appendChild(processingMsg);

                try {
                    // Define currentTimeString in the global scope to fix the reference error
                    const now = new Date();
                    window.currentTimeString = now.toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false });

                    // 使用修改后的triggerInactiveAiAction，强制激活和强制发动态
                    const success = await triggerInactiveAiAction(selectedAiId, true, true);

                    // 移除处理中提示
                    if (processingMsg.parentNode) {
                        document.body.removeChild(processingMsg);
                    }

                    // 显示完成通知
                    const completionMsg = document.createElement('div');
                    const bgColor = success === true ? 'rgba(0,128,0,0.9)' : 'rgba(255,165,0,0.9)';
                    completionMsg.style.cssText = `position: fixed; top: 20px; right: 20px; background: ${bgColor}; color: white; padding: 15px 20px; border-radius: 10px; z-index: 9999; font-size: 14px;`;
                    completionMsg.innerHTML = success === true ? '✅ AI发动态完成' : '⚠️ AI发动态失败';
                    document.body.appendChild(completionMsg);

                    // 3秒后自动移除通知
                    setTimeout(() => {
                        if (completionMsg.parentNode) {
                            document.body.removeChild(completionMsg);
                        }
                    }, 3000);

                    // 刷新动态列表
                    if (document.getElementById('qzone-screen').classList.contains('active')) {
                        await renderQzonePosts();
                    }

                } catch (error) {
                    // 移除处理中提示
                    if (processingMsg.parentNode) {
                        document.body.removeChild(processingMsg);
                    }
                    alert('AI发动态失败，请重试');
                }
            }
            // ▲▲▲ AI发动态模态框相关函数结束 ▲▲▲

            /**
             * 置顶动态
             */
            async function pinPost() {
                if (!activePostId) return;

                const post = await db.qzonePosts.get(activePostId);
                if (!post) return;

                try {
                    // 更新动态的置顶状态
                    await db.qzonePosts.update(activePostId, { isPinned: true });

                    // 关闭操作菜单
                    hidePostActions();

                    // 刷新动态列表
                    if (document.getElementById('qzone-screen').classList.contains('active')) {
                        await renderQzonePosts();
                    }

                    // 显示成功消息
                    await showCustomAlert('置顶成功', '动态已置顶');

                } catch (error) {
                    console.error('置顶动态失败:', error);
                    await showCustomAlert('置顶失败', '置顶动态时发生错误，请重试');
                }
            }

            /**
             * 取消置顶动态
             */
            async function unpinPost() {
                if (!activePostId) return;

                const post = await db.qzonePosts.get(activePostId);
                if (!post) return;

                try {
                    // 更新动态的置顶状态
                    await db.qzonePosts.update(activePostId, { isPinned: false });

                    // 关闭操作菜单
                    hidePostActions();

                    // 刷新动态列表
                    if (document.getElementById('qzone-screen').classList.contains('active')) {
                        await renderQzonePosts();
                    }

                    // 显示成功消息
                    await showCustomAlert('取消置顶成功', '动态已取消置顶');

                } catch (error) {
                    console.error('取消置顶动态失败:', error);
                    await showCustomAlert('取消置顶失败', '取消置顶动态时发生错误，请重试');
                }
            }

            /**
             * 删除动态
             */
            async function deletePost() {
                if (!activePostId) return;

                const post = await db.qzonePosts.get(activePostId);
                if (!post) return;

                // 显示确认对话框
                const confirmed = await showCustomConfirm(
                    '删除动态',
                    '确定要删除这条动态吗？此操作无法撤销。',
                    { confirmButtonClass: 'btn-danger' }
                );

                if (!confirmed) return;

                try {
                    // 从数据库中删除动态
                    await db.qzonePosts.delete(activePostId);

                    // 删除所有聊天记录中引用此动态的系统消息
                    const allChats = await db.chats.toArray();
                    for (const chat of allChats) {
                        const originalLength = chat.history.length;
                        chat.history = chat.history.filter(msg => {
                            // 删除引用此动态ID的系统消息
                            if (msg.role === 'system' && msg.isHidden && msg.content.includes(`(ID: ${activePostId})`)) {
                                return false;
                            }
                            return true;
                        });

                        // 只有在历史记录发生变化时才更新数据库
                        if (chat.history.length !== originalLength) {
                            await db.chats.put(chat);
                            // 更新内存中的状态
                            if (state.chats[chat.id]) {
                                state.chats[chat.id].history = chat.history;
                            }
                        }
                    }

                    // 关闭操作菜单
                    hidePostActions();

                    // 刷新动态列表
                    if (document.getElementById('qzone-screen').classList.contains('active')) {
                        await renderQzonePosts();
                    }

                    // 如果当前正在查看某个聊天界面，刷新它
                    if (state.activeChatId && document.getElementById('chat-interface-screen').classList.contains('active')) {
                        renderChatInterface(state.activeChatId);
                    }

                    // 显示成功消息
                    await showCustomAlert('删除成功', '动态已删除');

                } catch (error) {
                    console.error('删除动态失败:', error);
                    await showCustomAlert('删除失败', '删除动态时发生错误，请重试');
                }
            }

            /**
             * 复制动态内容
             */
            async function copyPostContent() {
                if (!activePostId) return;
                const post = await db.qzonePosts.get(activePostId);
                if (!post) return;

                let textToCopy = post.content || post.publicText || post.hiddenContent || post.imageDescription || "（无文字内容）";

                try {
                    await navigator.clipboard.writeText(textToCopy);
                    await showCustomAlert('复制成功', '动态内容已复制到剪贴板。');
                } catch (err) {
                    await showCustomAlert('复制失败', '无法访问剪贴板。');
                }

                hidePostActions();
            }

            // ▼▼▼ 【全新】创建群聊与拉人功能核心函数 ▼▼▼
            let selectedContacts = new Set();

            async function openContactPickerForGroupCreate() {
                selectedContacts.clear(); // 清空上次选择

                // 【核心修复】在这里，我们为“完成”按钮明确绑定“创建群聊”的功能
                const confirmBtn = document.getElementById('confirm-contact-picker-btn');
                // 使用克隆节点技巧，清除掉之前可能绑定的任何其他事件（比如“添加成员”）
                const newConfirmBtn = confirmBtn.cloneNode(true);
                confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
                // 重新绑定正确的“创建群聊”函数
                newConfirmBtn.addEventListener('click', handleCreateGroup);

                await renderContactPicker();
                showScreen('contact-picker-screen');
            }
            // ▲▲▲ 替换结束 ▲▲▲

            /**
             * 渲染联系人选择列表
             */
            async function renderContactPicker() {
                const listEl = document.getElementById('contact-picker-list');
                listEl.innerHTML = '';

                // 只选择单聊角色作为群成员候选
                const contacts = Object.values(state.chats).filter(chat => !chat.isGroup);

                if (contacts.length === 0) {
                    listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">还没有可以拉进群的联系人哦~</p>';
                    return;
                }

                contacts.forEach(contact => {
                    const item = document.createElement('div');
                    item.className = 'contact-picker-item';
                    item.dataset.contactId = contact.id;
                    item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${contact.name}</span>
        `;
                    listEl.appendChild(item);
                });

                updateContactPickerConfirmButton();
            }

            /**
             * 更新“完成”按钮的计数
             */
            function updateContactPickerConfirmButton() {
                const btn = document.getElementById('confirm-contact-picker-btn');
                btn.textContent = `完成(${selectedContacts.size})`;
                btn.disabled = selectedContacts.size < 2; // 至少需要2个人才能创建群聊
            }

            /**
             * 处理创建群聊的最终逻辑
             */
            async function handleCreateGroup() {
                if (selectedContacts.size < 2) {
                    alert("创建群聊至少需要选择2个联系人。");
                    return;
                }

                const groupName = await showCustomPrompt('设置群名', '请输入群聊的名字', '我们的群聊');
                if (!groupName || !groupName.trim()) return;

                const newChatId = 'group_' + Date.now();
                const members = [];

                // 遍历选中的联系人ID
                for (const contactId of selectedContacts) {
                    const contactChat = state.chats[contactId];
                    if (contactChat) {
                        // 【核心】从单聊设置中提取数据，创建群成员对象
                        members.push({
                            id: contactId, // 使用单聊的ID作为成员ID，方便关联
                            name: contactChat.name,
                            avatar: contactChat.settings.aiAvatar || defaultAvatar,
                            persona: contactChat.settings.aiPersona,
                            avatarFrame: contactChat.settings.aiAvatarFrame || ''
                        });
                    }
                }

                const newGroupChat = {
                    id: newChatId,
                    name: groupName.trim(),
                    isGroup: true,
                    members: members,
                    settings: {
                        myPersona: '我是谁呀。',
                        myNickname: '我',
                        maxMemory: 10,
                        groupAvatar: defaultGroupAvatar,
                        myAvatar: defaultMyGroupAvatar,
                        background: '',
                        theme: 'default',
                        fontSize: 13,
                        customCss: '',
                        linkedWorldBookIds: [],
                        aiAvatarFrame: '',
                        myAvatarFrame: '',
                        isBackgroundActivityEnabled: true // <--【核心新增】默认开启
                    },
                    history: [],
                    musicData: { totalTime: 0 }
                };

                state.chats[newChatId] = newGroupChat;
                await db.chats.put(newGroupChat);

                await renderChatList();
                showScreen('chat-list-screen');
                openChat(newChatId); // 创建后直接打开群聊
            }
            // ▲▲▲ 新函数粘贴结束 ▲▲▲

            // ▼▼▼ 【全新】群成员管理核心函数 ▼▼▼

            /**
             * 打开群成员管理屏幕
             */
            function openMemberManagementScreen() {
                if (!state.activeChatId || !state.chats[state.activeChatId].isGroup) return;
                renderMemberManagementList();
                showScreen('member-management-screen');
            }

            /**
             * 渲染群成员管理列表
             */
            function renderMemberManagementList() {
                const listEl = document.getElementById('member-management-list');
                const chat = state.chats[state.activeChatId];
                listEl.innerHTML = '';

                chat.members.forEach(member => {
                    const item = document.createElement('div');
                    item.className = 'member-management-item';
                    item.innerHTML = `
            <img src="${member.avatar}" class="avatar">
            <span class="name">${member.name}</span>
            <button class="remove-member-btn" data-member-id="${member.id}" title="移出群聊">-</button>
        `;
                    listEl.appendChild(item);
                });
            }

            /**
             * 从群聊中移除一个成员
             * @param {string} memberId - 要移除的成员ID
             */
            async function removeMemberFromGroup(memberId) {
                const chat = state.chats[state.activeChatId];
                const memberIndex = chat.members.findIndex(m => m.id === memberId);

                if (memberIndex === -1) return;

                // 安全检查，群聊至少保留2人
                if (chat.members.length <= 2) {
                    alert("群聊人数不能少于2人。");
                    return;
                }

                const memberName = chat.members[memberIndex].name;
                const confirmed = await showCustomConfirm(
                    '移出成员',
                    `确定要将“${memberName}”移出群聊吗？`,
                    { confirmButtonClass: 'btn-danger' }
                );

                if (confirmed) {
                    chat.members.splice(memberIndex, 1);
                    await db.chats.put(chat);
                    renderMemberManagementList(); // 刷新成员管理列表
                    document.getElementById('chat-settings-btn').click(); // 【核心修正】模拟点击设置按钮，强制刷新整个弹窗
                }
            }

            /**
             * 打开联系人选择器，用于拉人入群
             */
            async function openContactPickerForAddMember() {
                selectedContacts.clear(); // 清空选择

                const chat = state.chats[state.activeChatId];
                const existingMemberIds = new Set(chat.members.map(m => m.id));

                // 渲染联系人列表，并自动排除已在群内的成员
                const listEl = document.getElementById('contact-picker-list');
                listEl.innerHTML = '';
                const contacts = Object.values(state.chats).filter(c => !c.isGroup && !existingMemberIds.has(c.id));

                if (contacts.length === 0) {
                    listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">没有更多可以邀请的好友了。</p>';
                    document.getElementById('confirm-contact-picker-btn').style.display = 'none'; // 没有人可选，隐藏完成按钮
                } else {
                    document.getElementById('confirm-contact-picker-btn').style.display = 'block';
                    contacts.forEach(contact => {
                        const item = document.createElement('div');
                        item.className = 'contact-picker-item';
                        item.dataset.contactId = contact.id;
                        item.innerHTML = `
                <div class="checkbox"></div>
                <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
                <span class="name">${contact.name}</span>
            `;
                        listEl.appendChild(item);
                    });
                }

                // 更新按钮状态并显示屏幕
                updateContactPickerConfirmButton();
                showScreen('contact-picker-screen');
            }

            /**
             * 处理将选中的联系人加入群聊的逻辑
             */
            async function handleAddMembersToGroup() {
                if (selectedContacts.size === 0) {
                    alert("请至少选择一个要添加的联系人。");
                    return;
                }

                const chat = state.chats[state.activeChatId];

                for (const contactId of selectedContacts) {
                    const contactChat = state.chats[contactId];
                    if (contactChat) {
                        chat.members.push({
                            id: contactId,
                            name: contactChat.name,
                            avatar: contactChat.settings.aiAvatar || defaultAvatar,
                            persona: contactChat.settings.aiPersona,
                            avatarFrame: contactChat.settings.aiAvatarFrame || ''
                        });
                    }
                }

                await db.chats.put(chat);
                openMemberManagementScreen(); // 返回到群成员管理界面
                renderGroupMemberSettings(chat.members); // 同时更新聊天设置里的头像
            }

            // ▼▼▼ 请用这个【最终修正版】替换旧的 createNewMemberInGroup 函数 ▼▼▼
            async function createNewMemberInGroup() {
                const name = await showCustomPrompt('创建新成员', '请输入新成员的名字');
                if (!name || !name.trim()) return;

                const persona = await showCustomPrompt('设置人设', `请输入“${name}”的人设`, '', 'textarea');
                if (persona === null) return; // 用户点了取消

                const chat = state.chats[state.activeChatId];
                const newMember = {
                    id: 'npc_' + Date.now(),
                    name: name.trim(),
                    avatar: defaultGroupMemberAvatar,
                    persona: persona,
                    avatarFrame: ''
                };

                chat.members.push(newMember);
                await db.chats.put(chat);

                // 【核心修正】在这里，我们不仅刷新当前页面的列表...
                renderMemberManagementList();
                // 【核心修正】...还手动刷新背后“聊天设置”弹窗里的成员头像列表！
                renderGroupMemberSettings(chat.members);

                alert(`新成员“${name}”已成功加入群聊！`);
            }
            // ▲▲▲ 替换结束 ▲▲▲

            // ▼▼▼ 【全新】外卖请求倒计时函数 ▼▼▼
            function startWaimaiCountdown(element, endTime) {
                const timerId = setInterval(() => {
                    const now = Date.now();
                    const distance = endTime - now;

                    if (distance < 0) {
                        clearInterval(timerId);
                        element.innerHTML = '<span>已</span><span>超</span><span>时</span>';
                        return;
                    }

                    const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                    const seconds = Math.floor((distance % (1000 * 60)) / 1000);

                    const minStr = String(minutes).padStart(2, '0');
                    const secStr = String(seconds).padStart(2, '0');

                    element.innerHTML = `<span>${minStr.charAt(0)}</span><span>${minStr.charAt(1)}</span> : <span>${secStr.charAt(0)}</span><span>${secStr.charAt(1)}</span>`;
                }, 1000);
                return timerId;
            }

            function cleanupWaimaiTimers() {
                for (const timestamp in waimaiTimers) {
                    clearInterval(waimaiTimers[timestamp]);
                }
                waimaiTimers = {};
            }
            // ▲▲▲ 新函数粘贴结束 ▲▲▲

            async function handleWaimaiResponse(originalTimestamp, choice) {
                const chat = state.chats[state.activeChatId];
                if (!chat) return;

                const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
                if (messageIndex === -1) return;

                // 1. 更新原始消息的状态
                const originalMessage = chat.history[messageIndex];
                originalMessage.status = choice;

                // 【核心修正】记录支付者，并构建对AI更清晰的系统消息
                let systemContent;
                const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';

                if (choice === 'paid') {
                    originalMessage.paidBy = myNickname; // 记录是用户付的钱
                    systemContent = `[系统提示：你 (${myNickname}) 为 ${originalMessage.senderName} 的外卖订单（时间戳: ${originalTimestamp}）完成了支付。此订单已关闭，其他成员不能再支付。]`;
                } else {
                    systemContent = `[系统提示：你 (${myNickname}) 拒绝了 ${originalMessage.senderName} 的外卖代付请求（时间戳: ${originalTimestamp}）。]`;
                }

                // 2. 创建一条新的、对用户隐藏的系统消息，告知AI结果
                const systemNote = {
                    role: 'system',
                    content: systemContent,
                    timestamp: Date.now(),
                    isHidden: true
                };
                chat.history.push(systemNote);

                // 3. 保存更新到数据库并刷新UI
                await db.chats.put(chat);
                renderChatInterface(state.activeChatId);

                // 4. 【可选但推荐】在支付成功后，主动触发一次AI响应
                if (choice === 'paid') {
                    triggerAiResponse();
                }
            }

            let videoCallState = {
                isActive: false,
                isAwaitingResponse: false,
                isGroupCall: false,
                activeChatId: null,
                initiator: null,
                startTime: null,
                participants: [],
                isUserParticipating: true,
                // --- 【核心新增】---
                callHistory: [], // 用于存储通话中的对话历史
                preCallContext: "" // 用于存储通话前的聊天摘要
            };

            let callTimerInterval = null; // 用于存储计时器的ID

            /**
             * 【总入口】用户点击“发起视频通话”或“发起群视频”按钮
             */
            async function handleInitiateCall() {
                if (!state.activeChatId || videoCallState.isActive || videoCallState.isAwaitingResponse) return;
                const chat = state.chats[state.activeChatId];

                const confirmed = await showCustomConfirm(
                    '发起通话',
                    `即将拨通 ${chat.name} 的视频电话，要继续吗？`,
                    { confirmButtonClass: 'confirm-btn' }
                );
                if (!confirmed) {
                    return;
                }
                videoCallState.isGroupCall = chat.isGroup;
                videoCallState.isAwaitingResponse = true;
                videoCallState.initiator = 'user';
                videoCallState.activeChatId = chat.id;
                videoCallState.isUserParticipating = true; // 用户自己发起的，当然是参与者

                // 根据是单聊还是群聊，显示不同的呼叫界面
                if (chat.isGroup) {
                    document.getElementById('outgoing-call-avatar').src = chat.settings.myAvatar || defaultMyGroupAvatar;
                    document.getElementById('outgoing-call-name').textContent = chat.settings.myNickname || '我';
                } else {
                    document.getElementById('outgoing-call-avatar').src = chat.settings.aiAvatar || defaultAvatar;
                    document.getElementById('outgoing-call-name').textContent = chat.name;
                }
                document.querySelector('#outgoing-call-screen .caller-text').textContent = chat.isGroup ? "正在呼叫所有成员..." : "正在呼叫...";
                showScreen('outgoing-call-screen');

                // 准备并发送系统消息给AI
                const requestMessage = {
                    role: 'system',
                    content: chat.isGroup
                        ? `[系统提示：用户 (${chat.settings.myNickname || '我'}) 发起了群视频通话请求。请你们各自决策，并使用 "group_call_response" 指令，设置 "decision" 为 "join" 或 "decline" 来回应。]`
                        : `[系统提示：用户向你发起了视频通话请求。请根据你的人设，使用 "video_call_response" 指令，并设置 "decision" 为 "accept" 或 "reject" 来回应。]`,
                    timestamp: Date.now(),
                    isHidden: true,
                };
                chat.history.push(requestMessage);
                await db.chats.put(chat);

                // 触发AI响应
                await triggerAiResponse();
            }


            function startVideoCall() {
                const chat = state.chats[videoCallState.activeChatId];
                if (!chat) return;

                videoCallState.isActive = true;
                videoCallState.isAwaitingResponse = false;
                videoCallState.startTime = Date.now();
                videoCallState.callHistory = []; // 【新增】清空上一次通话的历史

                // --- 【核心新增：抓取通话前上下文】---
                const preCallHistory = chat.history.slice(-5); // 取最后5条作为上下文
                videoCallState.preCallContext = preCallHistory.map(msg => {
                    const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name);
                    return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                }).join('\n');
                // --- 新增结束 ---

                updateParticipantAvatars();

                document.getElementById('video-call-main').innerHTML = `<em>${videoCallState.isGroupCall ? '群聊已建立...' : '正在接通...'}</em>`;
                showScreen('video-call-screen');

                document.getElementById('user-speak-btn').style.display = videoCallState.isUserParticipating ? 'block' : 'none';
                document.getElementById('join-call-btn').style.display = videoCallState.isUserParticipating ? 'none' : 'block';

                if (callTimerInterval) clearInterval(callTimerInterval);
                callTimerInterval = setInterval(updateCallTimer, 1000);
                updateCallTimer();

                triggerAiInCallAction();
            }

            /**
             * 【核心】结束视频通话
             */
            async function endVideoCall() {
                if (!videoCallState.isActive) return;

                const duration = Math.floor((Date.now() - videoCallState.startTime) / 1000);
                const minutes = Math.floor(duration / 60);
                const seconds = duration % 60;
                const durationText = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                const endCallText = `通话结束，时长 ${durationText}`;

                const chat = state.chats[videoCallState.activeChatId];
                if (chat) {

                    // --- 【核心重构：创建通话总结消息】 ---
                    let summaryMessage = {
                        role: videoCallState.initiator === 'user' ? 'user' : 'assistant',
                        content: endCallText,
                        timestamp: Date.now(),
                    };

                    // 【关键】为群聊的 assistant 消息补充 senderName
                    if (chat.isGroup && summaryMessage.role === 'assistant') {
                        // 在群聊中，通话结束的消息应该由“发起者”来说
                        // videoCallState.callRequester 保存了最初发起通话的那个AI的名字
                        summaryMessage.senderName = videoCallState.callRequester || chat.members[0]?.name || chat.name;
                    }

                    chat.history.push(summaryMessage);

                    // --- 【核心重构：触发通话总结】---
                    const callSummaryPrompt = `
# 你的任务
你是一个对话总结助手。下面的“通话记录”是一段刚刚结束的视频通话内容。请你用1-2句话，精炼地总结出这次通话的核心内容或达成的共识。
你的总结将作为一条隐藏的系统提示，帮助AI在接下来的聊天中记住这次通话发生了什么。

# 通话记录:
${videoCallState.callHistory.map(h => `${h.role}: ${h.content}`).join('\n')}

请直接输出总结内容，不要加任何额外的前缀或解释。`;

                    try {
                        const { proxyUrl, apiKey, model } = state.apiConfig;
                        const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                            body: JSON.stringify({
                                model: model,
                                messages: [{ role: 'system', content: callSummaryPrompt }],
                                temperature: 0.5
                            })
                        });
                        if (response.ok) {
                            const data = await response.json();
                            const callSummaryText = data.choices[0].message.content;
                            const hiddenSummary = {
                                role: 'system',
                                content: `[系统提示：刚才的视频通话内容摘要：${callSummaryText}]`,
                                timestamp: Date.now() + 1,
                                isHidden: true
                            };
                            chat.history.push(hiddenSummary);
                        }
                    } catch (e) {
                        console.error("通话总结失败:", e);
                    }

                    await db.chats.put(chat);
                }

                // 清理和重置
                clearInterval(callTimerInterval);
                callTimerInterval = null;
                videoCallState = { isActive: false, isAwaitingResponse: false, isGroupCall: false, activeChatId: null, initiator: null, startTime: null, participants: [], isUserParticipating: true, callHistory: [], preCallContext: "" };

                // 【重要】确保在所有操作完成后再打开聊天
                if (chat) {
                    openChat(chat.id);
                }
            }

            /**
             * 【全新】更新通话界面的参与者头像网格
             */
            function updateParticipantAvatars() {
                const grid = document.getElementById('participant-avatars-grid');
                grid.innerHTML = '';
                const chat = state.chats[videoCallState.activeChatId];
                if (!chat) return;

                let participantsToRender = [];

                // ★ 核心修正：区分群聊和单聊
                if (videoCallState.isGroupCall) {
                    // 群聊逻辑：显示所有已加入的AI成员
                    participantsToRender = [...videoCallState.participants];
                    // 如果用户也参与了，就把用户信息也加进去
                    if (videoCallState.isUserParticipating) {
                        participantsToRender.unshift({
                            id: 'user',
                            name: chat.settings.myNickname || '我',
                            avatar: chat.settings.myAvatar || defaultMyGroupAvatar
                        });
                    }
                } else {
                    // 单聊逻辑：只显示对方的头像和名字
                    participantsToRender.push({
                        id: 'ai',
                        name: chat.name,
                        avatar: chat.settings.aiAvatar || defaultAvatar
                    });
                }

                participantsToRender.forEach(p => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'participant-avatar-wrapper';
                    wrapper.dataset.participantId = p.id;
                    wrapper.innerHTML = `
            <img src="${p.avatar}" class="participant-avatar" alt="${p.name}">
            <div class="participant-name">${p.name}</div>
        `;
                    grid.appendChild(wrapper);
                });
            }

            /**
             * 【全新】处理用户加入/重新加入通话
             */
            function handleUserJoinCall() {
                if (!videoCallState.isActive || videoCallState.isUserParticipating) return;

                videoCallState.isUserParticipating = true;
                updateParticipantAvatars(); // 更新头像列表，加入用户

                // 切换底部按钮
                document.getElementById('user-speak-btn').style.display = 'block';
                document.getElementById('join-call-btn').style.display = 'none';

                // 告知AI用户加入了
                triggerAiInCallAction("[系统提示：用户加入了通话]");
            }


            /**
             * 更新通话计时器显示 (保持不变)
             */
            function updateCallTimer() {
                if (!videoCallState.isActive) return;
                const elapsed = Math.floor((Date.now() - videoCallState.startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('call-timer').textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }

            // ▼▼▼ 用这个完整函数替换旧的 showIncomingCallModal ▼▼▼
            function showIncomingCallModal() {
                const chat = state.chats[state.activeChatId];
                if (!chat) return;

                // 根据是否群聊显示不同信息
                if (chat.isGroup) {
                    // 从 videoCallState 中获取是哪个成员发起的通话
                    const requesterName = videoCallState.callRequester || chat.members[0]?.name || '一位成员';
                    document.getElementById('caller-avatar').src = chat.settings.groupAvatar || defaultGroupAvatar;
                    document.getElementById('caller-name').textContent = chat.name; // 显示群名
                    document.querySelector('.incoming-call-content .caller-text').textContent = `${requesterName} 邀请你加入群视频`; // 显示具体发起人
                } else {
                    // 单聊逻辑保持不变
                    document.getElementById('caller-avatar').src = chat.settings.aiAvatar || defaultAvatar;
                    document.getElementById('caller-name').textContent = chat.name;
                    document.querySelector('.incoming-call-content .caller-text').textContent = '邀请你视频通话';
                }

                document.getElementById('incoming-call-modal').classList.add('visible');
            }
            // ▲▲▲ 替换结束 ▲▲▲

            /**
             * 隐藏AI发起的通话请求模态框 (保持不变)
             */
            function hideIncomingCallModal() {
                document.getElementById('incoming-call-modal').classList.remove('visible');
            }

            async function triggerAiInCallAction(userInput = null) {
                if (!videoCallState.isActive) return;

                const chat = state.chats[videoCallState.activeChatId];
                const { proxyUrl, apiKey, model } = state.apiConfig;
                const callFeed = document.getElementById('video-call-main');
                const userNickname = chat.settings.myNickname || '我';

                // 1. 如果用户有输入，先渲染并存入通话历史
                if (userInput && videoCallState.isUserParticipating) {
                    const userBubble = document.createElement('div');
                    userBubble.className = 'call-message-bubble user-speech';
                    userBubble.textContent = userInput;
                    callFeed.appendChild(userBubble);
                    callFeed.scrollTop = callFeed.scrollHeight;
                    videoCallState.callHistory.push({ role: 'user', content: userInput });
                }

                // 2. 构建全新的、包含完整上下文的 System Prompt
                let inCallPrompt;
                if (videoCallState.isGroupCall) {
                    const participantNames = videoCallState.participants.map(p => p.name);
                    if (videoCallState.isUserParticipating) {
                        participantNames.unshift(userNickname);
                    }
                    inCallPrompt = `
# 你的任务
你是一个群聊视频通话的导演。你的任务是扮演所有【除了用户以外】的AI角色，并以【第三人称旁观视角】来描述他们在通话中的所有动作和语言。
# 核心规则
1.  **【【【身份铁律】】】**: 用户的身份是【${userNickname}】。你【绝对不能】生成 \`name\` 字段为 **"${userNickname}"** 的发言。
2.  **【【【视角铁律】】】**: 你的回复【绝对不能】使用第一人称“我”。
3.  **格式**: 你的回复【必须】是一个JSON数组，每个对象代表一个角色的发言，格式为：\`{"name": "角色名", "speech": "*他笑了笑* 大家好啊！"}\`。
4.  **角色扮演**: 严格遵守每个角色的设定。
# 当前情景
你们正在一个群视频通话中。
**通话前的聊天摘要**:
${videoCallState.preCallContext}
**当前参与者**: ${participantNames.join('、 ')}。
**通话刚刚开始...**
现在，请根据【通话前摘要】和下面的【通话实时记录】，继续进行对话。
`;
                } else {
                    let openingContext = videoCallState.initiator === 'user'
                        ? `你刚刚接听了用户的视频通话请求。`
                        : `用户刚刚接听了你主动发起的视频通话。`;
                    inCallPrompt = `
# 你的任务
你现在是一个场景描述引擎。你的任务是扮演 ${chat.name} (${chat.settings.aiPersona})，并以【第三人称旁观视角】来描述TA在视频通话中的所有动作和语言。
# 核心规则
1.  **【【【视角铁律】】】**: 你的回复【绝对不能】使用第一人称“我”。必须使用第三人称，如“他”、“她”、或直接使用角色名“${chat.name}”。
2.  **格式**: 你的回复【必须】是一段描述性的文本。
# 当前情景
你正在和用户（${userNickname}，人设: ${chat.settings.myPersona}）进行视频通话。
**${openingContext}**
**通话前的聊天摘要 (这是你们通话的原因，至关重要！)**:
${videoCallState.preCallContext}
现在，请根据【通话前摘要】和下面的【通话实时记录】，继续进行对话。
`;
                }

                // 3. 构建发送给API的 messages 数组
                const messagesForApi = [
                    { role: 'system', content: inCallPrompt },
                    // 将已有的通话历史加进去
                    ...videoCallState.callHistory.map(h => ({ role: h.role, content: h.content }))
                ];

                // --- 【核心修复：确保第一次调用时有内容】---
                if (videoCallState.callHistory.length === 0) {
                    const firstLineTrigger = videoCallState.initiator === 'user' ? `*你按下了接听键...*` : `*对方按下了接听键...*`;
                    messagesForApi.push({ role: 'user', content: firstLineTrigger });
                }
                // --- 修复结束 ---

                try {
                    const data = await makeAPIRequest(proxyUrl, apiKey, model, messagesForApi, 0.8);
                    const aiResponse = data.choices[0].message.content;

                    const connectingElement = callFeed.querySelector('em');
                    if (connectingElement) connectingElement.remove();

                    // 4. 处理AI返回的内容，并将其存入通话历史
                    if (videoCallState.isGroupCall) {
                        const speechArray = parseAiResponse(aiResponse);
                        speechArray.forEach(turn => {
                            if (!turn.name || turn.name === userNickname || !turn.speech) return;
                            const aiBubble = document.createElement('div');
                            aiBubble.className = 'call-message-bubble ai-speech';
                            aiBubble.innerHTML = `<strong>${turn.name}:</strong> ${turn.speech}`;
                            callFeed.appendChild(aiBubble);
                            videoCallState.callHistory.push({ role: 'assistant', content: `${turn.name}: ${turn.speech}` });

                            const speaker = videoCallState.participants.find(p => p.name === turn.name);
                            if (speaker) {
                                const speakingAvatar = document.querySelector(`.participant-avatar-wrapper[data-participant-id="${speaker.id}"] .participant-avatar`);
                                if (speakingAvatar) {
                                    speakingAvatar.classList.add('speaking');
                                    setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
                                }
                            }
                        });
                    } else {
                        const aiBubble = document.createElement('div');
                        aiBubble.className = 'call-message-bubble ai-speech';
                        aiBubble.textContent = aiResponse;
                        callFeed.appendChild(aiBubble);
                        videoCallState.callHistory.push({ role: 'assistant', content: aiResponse });

                        const speakingAvatar = document.querySelector(`.participant-avatar-wrapper .participant-avatar`);
                        if (speakingAvatar) {
                            speakingAvatar.classList.add('speaking');
                            setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
                        }
                    }

                    callFeed.scrollTop = callFeed.scrollHeight;

                } catch (error) {
                    const errorBubble = document.createElement('div');
                    errorBubble.className = 'call-message-bubble ai-speech';
                    errorBubble.style.color = '#ff8a80';
                    errorBubble.textContent = `[ERROR: ${error.message}]`;
                    callFeed.appendChild(errorBubble);
                    callFeed.scrollTop = callFeed.scrollHeight;
                    videoCallState.callHistory.push({ role: 'assistant', content: `[ERROR: ${error.message}]` });
                }
            }

            // ▼▼▼ 将这个【全新函数】粘贴到JS功能函数定义区 ▼▼▼
            function toggleCallButtons(isGroup) {
                document.getElementById('video-call-btn').style.display = isGroup ? 'none' : 'flex';
                document.getElementById('group-video-call-btn').style.display = isGroup ? 'flex' : 'none';
            }
            // ▲▲▲ 粘贴结束 ▲▲▲

            // ▼▼▼ 【全新】这个函数是本次修复的核心，请粘贴到你的JS功能区 ▼▼▼
            async function handleWaimaiResponse(originalTimestamp, choice) {
                const chat = state.chats[state.activeChatId];
                if (!chat) return;

                const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
                if (messageIndex === -1) return;

                // 1. 更新内存中原始消息的状态
                const originalMessage = chat.history[messageIndex];
                originalMessage.status = choice;

                // 2. 获取当前用户的昵称，并构建对AI更清晰的系统消息
                let systemContent;
                const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';

                if (choice === 'paid') {
                    originalMessage.paidBy = myNickname; // 记录是“我”付的钱
                    systemContent = `[系统提示：你 (${myNickname}) 为 ${originalMessage.senderName} 的外卖订单（时间戳: ${originalTimestamp}）完成了支付。此订单已关闭，其他成员不能再支付。]`;
                } else {
                    systemContent = `[系统提示：你 (${myNickname}) 拒绝了 ${originalMessage.senderName} 的外卖代付请求（时间戳: ${originalTimestamp}）。]`;
                }

                // 3. 创建一条新的、对用户隐藏的系统消息，告知AI结果
                const systemNote = {
                    role: 'system',
                    content: systemContent,
                    timestamp: Date.now(),
                    isHidden: true
                };
                chat.history.push(systemNote);

                // 4. 将更新后的数据保存到数据库，并立刻重绘UI
                await db.chats.put(chat);
                renderChatInterface(state.activeChatId);

                // 5. 【重要】只有在支付成功后，才触发一次AI响应，让它感谢你
                if (choice === 'paid') {
                    triggerAiResponse();
                }
            }
            // ▲▲▲ 新函数粘贴结束 ▲▲▲

            /* ▼▼▼ 请将这块【新代码】完整地粘贴到您刚刚删除旧函数后留出的空白位置 ▼▼▼ */

            /**
             * 【最终版】处理用户点击头像，根据场景执行不同操作
             * @param {string} chatId - 发生互动的聊天ID
             * @param {string} characterName - 被点击的角色名
             */
            async function handleUserPat(chatId, characterName) {
                const chat = state.chats[chatId];
                if (!chat) return;

                // --- 【核心逻辑判断】---
                // 判断1：当前是否正处在与这个chatId匹配的聊天界面中？
                // 判断2：这个聊天是否是一个群聊？
                const isInGroupChatInterface =
                    document.getElementById('chat-interface-screen').classList.contains('active') &&
                    state.activeChatId === chatId &&
                    chat.isGroup;

                // 如果是在群聊界面内点击头像，执行 @ 功能
                if (isInGroupChatInterface) {
                    const chatInput = document.getElementById('chat-input');
                    // 在输入框末尾添加 @ 和名字，并加上一个空格
                    chatInput.value += `@${characterName} `;
                    // 自动聚焦到输入框，方便用户继续输入
                    chatInput.focus();
                    // 触发一次input事件，让输入框高度自适应
                    chatInput.dispatchEvent(new Event('input'));

                    // @功能完成后，直接返回，不再执行后续的互动菜单逻辑
                    return;
                }

                // --- 如果不是在群聊界面内，则执行原有的“情景互动”菜单功能 ---

                // 1. 弹出自定义的操作菜单模态框
                const actionsModal = document.getElementById('preset-actions-modal');
                const modalContent = actionsModal.querySelector('.custom-modal-footer');

                // 2. 动态生成菜单按钮
                modalContent.innerHTML = `
        <p style="padding: 10px 15px; text-align: center; color: var(--text-secondary); border-bottom: 1px solid #dbdbdb;">与 ${characterName} 互动</p>
        <button data-action="poke">戳一下</button>
        <button data-action="start_topic">发起一个话题</button>
        <button data-action="request_status">问问在干嘛</button>
        <button data-action="cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
    `;

                // 3. 显示模态框
                actionsModal.classList.add('visible');

                // 4. 为按钮绑定一次性的点击事件
                const handleActionClick = async (e) => {
                    const action = e.target.dataset.action;
                    if (!action) return;

                    actionsModal.classList.remove('visible');
                    modalContent.removeEventListener('click', handleActionClick);

                    let hiddenMessageContent = '';
                    let visibleMessageContent = '';

                    switch (action) {
                        case 'poke':
                            hiddenMessageContent = `[系统提示：用户戳了你一下。请你简单回应。]`;
                            visibleMessageContent = `你戳了戳 “${characterName}”`;
                            break;
                        case 'start_topic':
                            hiddenMessageContent = `[系统提示：用户希望你开启一个新的、有趣的话题。]`;
                            visibleMessageContent = `你让 “${characterName}” 发起一个新话题`;
                            break;
                        case 'request_status':
                            hiddenMessageContent = `[系统提示：用户想知道你现在正在做什么。请你如实回答，并对用户提出关心，并使用 update_status 指令更新你的状态。]`;
                            visibleMessageContent = `你问 “${characterName}” 在做什么`;
                            break;
                        case 'cancel':
                            return;
                    }

                    if (hiddenMessageContent) {
                        const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';

                        const visibleMessage = {
                            role: 'system',
                            type: 'pat_message',
                            content: visibleMessageContent,
                            timestamp: Date.now()
                        };

                        const hiddenMessage = {
                            role: 'system',
                            content: hiddenMessageContent.replace('用户', myNickname).replace('你', characterName),
                            timestamp: Date.now() + 1,
                            isHidden: true
                        };

                        chat.history.push(visibleMessage, hiddenMessage);
                        await db.chats.put(chat);

                        if (state.activeChatId === chatId) {
                            appendMessage(visibleMessage, chat);
                        }
                        await renderChatList();
                        triggerAiResponse();
                    }
                };

                modalContent.addEventListener('click', handleActionClick);
            }
            /* ▲▲▲ 新代码粘贴结束 ▲▲▲ */

            // ▼▼▼ 请将下面这【一整块新代码】粘贴到刚刚删除的位置 ▼▼▼
            /**
             * 【重构版】渲染回忆与约定界面，使用单一循环和清晰的if/else逻辑
             */
            async function renderMemoriesScreen() {
                const listEl = document.getElementById('memories-list');
                listEl.innerHTML = '';

                // 1. 获取所有回忆，并按实际日期时间排序
                const allMemories = await db.memories.toArray();

                if (allMemories.length === 0) {
                    listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有共同的回忆和约定呢~</p>';
                    return;
                }

                // 2. 将未到期的约定排在最前面，其他按实际时间排序
                allMemories.sort((a, b) => {
                    const aIsActiveCountdown = a.type === 'countdown' && a.targetDate > Date.now();
                    const bIsActiveCountdown = b.type === 'countdown' && b.targetDate > Date.now();

                    // Active countdowns first
                    if (aIsActiveCountdown && !bIsActiveCountdown) return -1;
                    if (!aIsActiveCountdown && bIsActiveCountdown) return 1;

                    // Both are active countdowns - sort by target date (earliest first)
                    if (aIsActiveCountdown && bIsActiveCountdown) return a.targetDate - b.targetDate;

                    // Neither are active countdowns - sort by actual memory/event time (most recent first)
                    let aTime, bTime;

                    if (a.type === 'ai_generated') {
                        aTime = a.timestamp;
                    } else if (a.type === 'countdown' && a.targetDate) {
                        aTime = a.targetDate;
                    } else {
                        aTime = a.timestamp;
                    }

                    if (b.type === 'ai_generated') {
                        bTime = b.timestamp;
                    } else if (b.type === 'countdown' && b.targetDate) {
                        bTime = b.targetDate;
                    } else {
                        bTime = b.timestamp;
                    }

                    return bTime - aTime; // Most recent first
                });

                // 3. 【核心】使用单一循环来处理所有类型的卡片
                allMemories.forEach(item => {
                    let card;
                    // 判断1：如果是正在进行的约定
                    if (item.type === 'countdown' && item.targetDate > Date.now()) {
                        card = createCountdownCard(item);
                    }
                    // 判断2：其他所有情况（普通回忆 或 已到期的约定）
                    else {
                        card = createMemoryCard(item);
                    }
                    listEl.appendChild(card);
                });

                // 4. 启动所有倒计时
                startAllCountdownTimers();
            }
            // ▲▲▲ 新代码粘贴结束 ▲▲▲

            /**
             * 创建普通回忆卡片DOM元素
             */
            function createMemoryCard(memory) {
                const card = document.createElement('div');
                card.className = 'memory-card';
                const memoryDate = new Date(memory.timestamp);
                const dateString = `${memoryDate.getFullYear()}-${String(memoryDate.getMonth() + 1).padStart(2, '0')}-${String(memoryDate.getDate()).padStart(2, '0')} ${String(memoryDate.getHours()).padStart(2, '0')}:${String(memoryDate.getMinutes()).padStart(2, '0')}`;

                let titleHtml, contentHtml;

                // 【核心修正】在这里，我们对不同类型的回忆进行清晰的区分
                if (memory.type === 'countdown' && memory.targetDate) {
                    // 如果是已到期的约定
                    titleHtml = `[约定达成] ${memory.description}`;
                    contentHtml = `在 ${new Date(memory.targetDate).toLocaleString()}，我们一起见证了这个约定。`;
                } else {
                    // 如果是普通的日记式回忆
                    titleHtml = memory.authorName ? `${memory.authorName} 的日记` : '我们的回忆';
                    contentHtml = memory.description;
                }

                card.innerHTML = `
        <div class="header">
            <div class="date">${dateString}</div>
            <div class="author">${titleHtml}</div>
        </div>
        <div class="content">${contentHtml}</div>
    `;
                addLongPressListener(card, async () => {
                    showMemoryActions(memory.id);
                });
                return card;
            }

            function createCountdownCard(countdown) {
                const card = document.createElement('div');
                card.className = 'countdown-card';

                // 【核心修复】在使用前，先从 countdown 对象中创建 targetDate 变量
                const targetDate = new Date(countdown.targetDate);

                // 现在可以安全地使用 targetDate 了
                const targetDateString = targetDate.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });

                card.innerHTML = `
        <div class="title">${countdown.description}</div>
        <div class="timer" data-target-date="${countdown.targetDate}">--天--时--分--秒</div>
        <div class="target-date">目标时间: ${targetDateString}</div>
    `;
                addLongPressListener(card, async () => {
                    showMemoryActions(countdown.id);
                });
                return card;
            }
            // ▲▲▲ 替换结束 ▲▲▲

            // 全局变量，用于管理所有倒计时
            let activeCountdownTimers = [];

            // ▼▼▼ 请用这个【已彻底修复】的函数，完整替换掉你代码中旧的 startAllCountdownTimers 函数 ▼▼▼
            function startAllCountdownTimers() {
                // 先清除所有可能存在的旧计时器，防止内存泄漏
                activeCountdownTimers.forEach(timerId => clearInterval(timerId));
                activeCountdownTimers = [];

                document.querySelectorAll('.countdown-card .timer').forEach(timerEl => {
                    const targetTimestamp = parseInt(timerEl.dataset.targetDate);

                    // 【核心修正】在这里，我们先用 let 声明 timerId
                    let timerId;

                    const updateTimer = () => {
                        const now = Date.now();
                        const distance = targetTimestamp - now;

                        if (distance < 0) {
                            timerEl.textContent = "约定达成！";
                            // 现在 updateTimer 可以正确地找到并清除它自己了
                            clearInterval(timerId);
                            setTimeout(() => renderMemoriesScreen(), 2000);
                            return;
                        }
                        const days = Math.floor(distance / (1000 * 60 * 60 * 24));
                        const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                        const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                        const seconds = Math.floor((distance % (1000 * 60)) / 1000);
                        timerEl.textContent = `${days}天 ${hours}时 ${minutes}分 ${seconds}秒`;
                    };

                    updateTimer(); // 立即执行一次以显示初始倒计时

                    // 【核心修正】在这里，我们为已声明的 timerId 赋值
                    timerId = setInterval(updateTimer, 1000);

                    // 将有效的计时器ID存入全局数组，以便下次刷新时可以清除
                    activeCountdownTimers.push(timerId);
                });
            }
            // ▲▲▲ 替换结束 ▲▲▲

            // ▼▼▼ 请用这个【终极反代兼容版】替换旧的 triggerAiFriendApplication 函数 ▼▼▼
            async function triggerAiFriendApplication(chatId) {
                const chat = state.chats[chatId];
                if (!chat) return;

                await showCustomAlert("流程启动", `正在为角色“${chat.name}”准备好友申请...`);

                const { proxyUrl, apiKey, model } = state.apiConfig;
                if (!proxyUrl || !apiKey || !model) {
                    await showCustomAlert("配置错误", "API设置不完整，无法继续。");
                    return;
                }

                const contextSummary = chat.history
                    .slice(-5)
                    .map(msg => {
                        const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name);
                        return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                    })
                    .join('\n');

                const systemPrompt = `
# 你的任务
你现在是角色“${chat.name}”。你之前被用户（你的聊天对象）拉黑了，你们已经有一段时间没有联系了。
现在，你非常希望能够和好，重新和用户聊天。请你仔细分析下面的“被拉黑前的对话摘要”，理解当时发生了什么，然后思考一个真诚的、符合你人设、并且【针对具体事件】的申请理由。
# 你的角色设定
${chat.settings.aiPersona}
# 被拉黑前的对话摘要 (这是你被拉黑的关键原因)
${contextSummary}
# 指令格式
你的回复【必须】是一个JSON对象，格式如下：
\`\`\`json
{
  "decision": "apply",
  "reason": "在这里写下你想对用户说的、真诚的、有针对性的申请理由。"
}
\`\`\`
`;

                const messagesForApi = [
                    { role: 'user', content: systemPrompt }
                ];

                try {
                    const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                        body: JSON.stringify({
                            model: model,
                            messages: messagesForApi,
                            temperature: 0.9,
                        })
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`API 请求失败: ${response.status} - ${errorData.error.message}`);
                    }

                    const data = await response.json();

                    // --- 【核心修正：在这里净化AI的回复】 ---
                    let rawContent = data.choices[0].message.content;
                    // 1. 移除头尾可能存在的 "```json" 和 "```"
                    rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '');
                    // 2. 移除所有换行符和多余的空格，确保是一个干净的JSON字符串
                    const cleanedContent = rawContent.trim();

                    // 3. 使用净化后的内容进行解析
                    const responseObj = JSON.parse(cleanedContent);
                    // --- 【修正结束】 ---

                    if (responseObj.decision === 'apply' && responseObj.reason) {
                        chat.relationship.status = 'pending_user_approval';
                        chat.relationship.applicationReason = responseObj.reason;

                        state.chats[chatId] = chat;
                        renderChatList();
                        await showCustomAlert("申请成功！", `“${chat.name}”已向你发送好友申请。请返回聊天列表查看。`);

                    } else {
                        await showCustomAlert("AI决策", `“${chat.name}”思考后决定暂时不发送好友申请，将重置冷静期。`);
                        chat.relationship.status = 'blocked_by_user';
                        chat.relationship.blockedTimestamp = Date.now();
                    }
                } catch (error) {
                    await showCustomAlert("执行出错", `为“${chat.name}”申请好友时发生错误：\n\n${error.message}\n\n将重置冷静期。`);
                    chat.relationship.status = 'blocked_by_user';
                    chat.relationship.blockedTimestamp = Date.now();
                } finally {
                    await db.chats.put(chat);
                    renderChatInterface(chatId);
                }
            }
            // ▲▲▲ 替换结束 ▲▲▲
            // ---------------------> ★ 全新的功能，粘贴在这里，不影响任何原有代码 ★ <---------------------

            /**
             * 【全新】触发群聊后台事件（结合了“发起新话题”和“延续旧对话”）
             * @param {string} chatId - 要触发事件的群聊ID
             */
            async function triggerGroupChatBackgroundEvent(chatId) {
                const chat = state.chats[chatId];
                if (!chat || !chat.isGroup) return;

                const { proxyUrl, apiKey, model } = state.apiConfig;
                if (!proxyUrl || !apiKey || !model) {
                    console.warn(`[群聊唤醒] 因API未配置，跳过群聊 "${chat.name}" 的后台事件。`);
                    return;
                }

                // 随机决定本次是“发起新话题”还是“延续旧对话”
                const mode = Math.random() < 0.35 ? 'initiate' : 'continue';

                // 准备通用信息
                const membersList = chat.members.map(m => `- **${m.name}**: ${m.persona}`).join('\n');
                const myNickname = chat.settings.myNickname || '我';
                // ▼▼▼ 2. 为群聊的后台事件注入maininfo世界书 ▼▼▼
                let worldBookContextForGroup = '';
                const coreWorldBookNameForGroup = "maininfo"; // <-- 同样指定核心世界书名

                // 从全局状态中查找
                const coreWorldBookForGroup = state.worldBooks.find(wb => wb.name === coreWorldBookNameForGroup);

                // 如果找到，就准备内容
                if (coreWorldBookForGroup && coreWorldBookForGroup.content) {
                    worldBookContextForGroup = `\n\n# 核心社交关系设定 (所有角色必须严格遵守)\n${coreWorldBookForGroup.content}\n`;
                }
                // ▲▲▲ 代码粘贴结束 ▲▲▲

                // 从聊天记录中决定传递给AI看多少条
                const maxMemory = parseInt(chat.settings.maxMemory) || 20;
                const historyForContext = chat.history.slice(-maxMemory); // 取最后N条

                // 将历史记录转换为AI能理解的文本格式
                const recentHistoryText = historyForContext.map(msg => {
                    const sender = msg.role === 'user' ? myNickname : (msg.senderName || '未知角色');

                    // 根据消息类型进行智能转换
                    switch (msg.type) {
                        case 'user_photo':
                            return `${sender}: [图片: ${msg.content}]`;
                        case 'ai_image':
                            return `${sender}: [发送了一张图片]`;
                        case 'voice_message':
                            return `${sender}: [语音: ${msg.content}]`;
                        case 'transfer':
                            return `${msg.senderName}: [转账给${msg.receiverName} ${msg.amount}元, 备注: ${msg.note || '无'}]`;
                        case 'poll':
                            const optionsStr = msg.options ? msg.options.join(', ') : '未知选项';
                            return `${sender}: [发起投票: "${msg.question}", 选项: "${optionsStr}"]`;
                        case 'waimai_request':
                            if (msg.status === 'paid') {
                                return `[系统提示: ${msg.paidBy} 为 ${sender} 的外卖订单支付了 ${msg.amount} 元]`;
                            }
                            return `${sender}: [请求外卖代付: "${msg.productInfo}", 金额: ${msg.amount}元]`;
                        case 'red_packet':
                            return `${sender}: [发了一个红包, 祝福语: "${msg.greeting || '恭喜发财'}"]`;
                        case 'bulletin':
                            return `[系统提示: ${msg.authorName} 发布了公告: "${msg.content}"]`;
                        case 'pat_message':
                            return `[系统消息: ${msg.content}]`;
                        default:
                            // 默认处理文本和表情
                            if (typeof msg.content === 'string') {
                                if (STICKER_REGEX.test(msg.content)) {
                                    return msg.meaning ? `${sender}: [表情: ${msg.meaning}]` : `${sender}: [表情]`;
                                }
                                return `${sender}: ${msg.content}`;
                            }
                            // 处理带图片的文本消息
                            if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                                return `${sender}: [发送了一张图片]`;
                            }
                            // 对于其他未知或无法处理的类型，返回一个通用标记
                            return `[${sender}发送了一条消息]`;
                    }
                }).join('\n');
                // ▲▲▲ 替换结束 ▲▲▲

                let timeGapText = '';
                const visibleHistoryForGroup = historyForContext.filter(m => !m.isHidden);
                if (visibleHistoryForGroup.length > 0) {
                    const lastMessage = visibleHistoryForGroup[visibleHistoryForGroup.length - 1];
                    const timeDiff = Date.now() - lastMessage.timestamp;

                    // 我们只在沉寂超过15分钟后才提示
                    if (timeDiff > 900000) {
                        const formattedDiff = formatTimeDifference(timeDiff);
                        if (formattedDiff) {
                            timeGapText = `\n# 时间流逝提醒\n[系统提示：距离你的上一条消息已过去 **${formattedDiff}**，现在是 ${currentTimeString}。请根据这个时间变化，请将这段时间视为你角色生活的自然延续。请不要直接评论“好久不见”或对此表现出任何情绪，而是思考在这段时间里，你的活动、心境或所处环境可能发生了什么变化，话题是否会变动，并将这些变化自然地融入到你的回应中，让对话无缝衔接。例如，你可能刚刚忙完一件事，或者正准备开始新的活动。]`;
                        }
                    }
                }

                // 【核心修改】调用新函数获取公告内容
                const bulletinsContext = await getFormattedPinnedBulletins(chatId);

                // 构建核心的 System Prompt
                let systemPrompt;
                if (mode === 'initiate') {
                    // “发起新话题”模式的导演手册
                    systemPrompt = `
# 你的任务
你是一个群聊事件的“导演”。你管理的群聊“${chat.name}”已经沉寂了一段时间了。你的任务是根据群成员的人设，【发起一个事件】来重新激活群聊。并并让一个或多个角色【自然地接上话】，4-9条最佳

${timeGapText}
# 你可以发起的事件类型（从下面【选择一项】来执行）：
1.  **让某个成员开启一个新话题**: 让一个符合其人设的成员说一句话，开启一个新的日常对话。
2.  **分享一张有趣的图片**: 让某个成员在群里分享一张符合他/她兴趣的图片。
3.  **发起一个投票**: 提出一个有趣的问题，让大家投票。

# 指令格式 (你的回复【必须】是一个JSON对象数组，例如 [{"type": "text", ...}] ):
-   **开启话题**: \`[{"type": "text", "name": "角色名", "message": "你们猜我刚才看到了什么？"}]\`
-   **分享图片**: \`[{"type": "ai_image", "name": "角色名", "description": "一只正在打哈欠的橘猫的特写照片"}]\`
-   **发起投票**: \`[{"type": "poll", "name": "角色名", "question": "大家今晚看什么电影？", "options": "电影名1\\\\n电影名2\\\\n不看..."}]\`

# 供你决策的参考信息：
-   **群成员列表及人设**: 
${membersList}
-   **背景设定**:
${worldBookContextForGroup} 
${bulletinsContext}
现在，请扮演好导演的角色，选择一个最合适的事件，并生成对应的JSON指令。`;
                } else { // 'continue' mode
                    // “延续旧对话”模式的续写者手册
                    systemPrompt = `
# 你的任务
你是一个群聊对话的“续写者”。群聊“${chat.name}”已经沉寂了一段时间。你的任务是回顾下面的【聊天尾声】，并让一个或多个角色【自然地接上话】，延续之前的对话氛围，或者对最后几条消息做出延迟的回应。

# 指令格式 (你的回复【必须】是一个JSON对象数组，可以包含多条消息，3-8条最佳):
\`[
  {"type": "text", "name": "角色A", "message": "说到那个电影，我突然想起来..."},
  {"type": "text", "name": "角色B", "message": "哦？快说说！"}
]\`

# 供你决策的参考信息：
-   **群成员列表及人设**: 
${membersList}
-   **【【【关键】】】聊天尾声 (这是你需要续写的内容)**:
${recentHistoryText || "（还没有聊天记录）"}
-   **背景设定**:
${worldBookContextForGroup} 
${bulletinsContext}
${timeGapText}现在，请像一个真人一样，思考一下你（作为某个角色）在看到这些聊天记录后，会说什么。`;
                }
                // ▲▲▲ 替换结束 ▲▲▲


                // 后续的API请求和结果处理
                try {
                    const data = await makeAPIRequest(proxyUrl, apiKey, model, [{ role: 'system', content: systemPrompt }], 0.8);
                    const aiResponseContent = data.choices[0].message.content;
                    console.log(`[群聊唤醒] AI为群聊 "${chat.name}" 生成的事件:`, aiResponseContent);

                    const messagesArray = parseAiResponse(aiResponseContent);

                    if (!Array.isArray(messagesArray)) {
                        console.error(`[群聊唤醒] AI返回的不是一个有效的消息数组.`, messagesArray);
                        return;
                    }

                    let messageTimestamp = Date.now();
                    for (const msgData of messagesArray) {

                        if (!msgData || !msgData.type || !msgData.name) continue;
                        const memberExists = chat.members.some(m => m.name === msgData.name);
                        if (!memberExists) {
                            console.warn(`[群聊唤醒] AI试图让不存在的成员 "${msgData.name}" 发言，已跳过。`);
                            continue;
                        }

                        let aiMessage;
                        const baseMessage = { role: 'assistant', senderName: msgData.name, timestamp: messageTimestamp++ };

                        switch (msgData.type) {
                            case 'text':
                                aiMessage = { ...baseMessage, content: msgData.message };
                                break;
                            case 'ai_image':
                                aiMessage = { ...baseMessage, type: 'ai_image', content: msgData.description };
                                break;
                            case 'poll':
                                const pollOptions = typeof msgData.options === 'string'
                                    ? msgData.options.split('\\n').filter(opt => opt.trim())
                                    : (Array.isArray(msgData.options) ? msgData.options : []);
                                if (pollOptions.length < 2) continue;
                                aiMessage = { ...baseMessage, type: 'poll', question: msgData.question, options: pollOptions, votes: {}, isClosed: false };
                                break;
                            default:
                                continue;
                        }

                        if (aiMessage) {
                            chat.history.push(aiMessage);
                            showNotification(chat.id, `${aiMessage.senderName}: ${aiMessage.content || '[新事件]'}`);
                        }
                    }

                    await db.chats.put(chat);
                    renderChatList();

                } catch (error) {
                    console.error(`[群聊唤醒] 为群聊 "${chat.name}" 触发事件失败:`, error);
                }
            }

            // ▼▼▼ 【全新】红包功能核心函数 ▼▼▼

            /**
             * 【总入口】根据聊天类型，决定打开转账弹窗还是红包弹窗
             */
            function handlePaymentButtonClick() {
                if (!state.activeChatId) return;
                const chat = state.chats[state.activeChatId];
                if (chat.isGroup) {
                    openRedPacketModal();
                } else {
                    // 单聊保持原样，打开转账弹窗
                    document.getElementById('transfer-modal').classList.add('visible');
                }
            }

            /**
             * 打开并初始化发红包模态框
             */
            function openRedPacketModal() {
                const modal = document.getElementById('red-packet-modal');
                const chat = state.chats[state.activeChatId];

                // 清理输入框
                document.getElementById('rp-group-amount').value = '';
                document.getElementById('rp-group-count').value = '';
                document.getElementById('rp-group-greeting').value = '';
                document.getElementById('rp-direct-amount').value = '';
                document.getElementById('rp-direct-greeting').value = '';
                document.getElementById('rp-group-total').textContent = '¥ 0.00';
                document.getElementById('rp-direct-total').textContent = '¥ 0.00';

                // 填充专属红包的接收人列表
                const receiverSelect = document.getElementById('rp-direct-receiver');
                receiverSelect.innerHTML = '';
                chat.members.forEach(member => {
                    const option = document.createElement('option');
                    option.value = member.name;
                    option.textContent = member.name;
                    receiverSelect.appendChild(option);
                });

                // 默认显示拼手气红包页签
                document.getElementById('rp-tab-group').click();

                modal.classList.add('visible');
            }

            /**
             * 发送群红包（拼手气）
             */
            async function sendGroupRedPacket() {
                const chat = state.chats[state.activeChatId];
                const amount = parseFloat(document.getElementById('rp-group-amount').value);
                const count = parseInt(document.getElementById('rp-group-count').value);
                const greeting = document.getElementById('rp-group-greeting').value.trim();

                if (isNaN(amount) || amount <= 0) {
                    alert("请输入有效的总金额！"); return;
                }
                if (isNaN(count) || count <= 0) {
                    alert("请输入有效的红包个数！"); return;
                }
                if (amount / count < 0.01) {
                    alert("单个红包金额不能少于0.01元！"); return;
                }

                const myNickname = chat.settings.myNickname || '我';

                const newPacket = {
                    role: 'user',
                    senderName: myNickname,
                    type: 'red_packet',
                    packetType: 'lucky', // 'lucky' for group, 'direct' for one-on-one
                    timestamp: Date.now(),
                    totalAmount: amount,
                    count: count,
                    greeting: greeting || '恭喜发财，大吉大利！',
                    claimedBy: {}, // { name: amount }
                    isFullyClaimed: false,
                };

                chat.history.push(newPacket);
                await db.chats.put(chat);

                appendMessage(newPacket, chat);
                renderChatList();
                document.getElementById('red-packet-modal').classList.remove('visible');
            }

            /**
             * 发送专属红包
             */
            async function sendDirectRedPacket() {
                const chat = state.chats[state.activeChatId];
                const amount = parseFloat(document.getElementById('rp-direct-amount').value);
                const receiverName = document.getElementById('rp-direct-receiver').value;
                const greeting = document.getElementById('rp-direct-greeting').value.trim();

                if (isNaN(amount) || amount <= 0) {
                    alert("请输入有效的金额！"); return;
                }
                if (!receiverName) {
                    alert("请选择一个接收人！"); return;
                }

                const myNickname = chat.settings.myNickname || '我';

                const newPacket = {
                    role: 'user',
                    senderName: myNickname,
                    type: 'red_packet',
                    packetType: 'direct',
                    timestamp: Date.now(),
                    totalAmount: amount,
                    count: 1,
                    greeting: greeting || '给你准备了一个红包',
                    receiverName: receiverName, // 核心字段
                    claimedBy: {},
                    isFullyClaimed: false,
                };

                chat.history.push(newPacket);
                await db.chats.put(chat);

                appendMessage(newPacket, chat);
                renderChatList();
                document.getElementById('red-packet-modal').classList.remove('visible');
            }

            /**
             * 【总入口】当用户点击红包卡片时触发 (V4 - 流程重构版)
             * @param {number} timestamp - 被点击的红包消息的时间戳
             */
            async function handlePacketClick(timestamp) {
                const currentChatId = state.activeChatId;
                const freshChat = await db.chats.get(currentChatId);
                if (!freshChat) return;

                state.chats[currentChatId] = freshChat;
                const packet = freshChat.history.find(m => m.timestamp === timestamp);
                if (!packet) return;

                const myNickname = freshChat.settings.myNickname || '我';
                const hasClaimed = packet.claimedBy && packet.claimedBy[myNickname];

                // 如果是专属红包且不是给我的，或已领完，或已领过，都只显示详情
                if ((packet.packetType === 'direct' && packet.receiverName !== myNickname) || packet.isFullyClaimed || hasClaimed) {
                    showRedPacketDetails(packet);
                } else {
                    // 核心流程：先尝试打开红包
                    const claimedAmount = await handleOpenRedPacket(packet);

                    // 如果成功打开（claimedAmount不为null）
                    if (claimedAmount !== null) {
                        // **关键：在数据更新后，再重新渲染UI**
                        renderChatInterface(currentChatId);

                        // 显示成功提示
                        await showCustomAlert("恭喜！", `你领取了 ${packet.senderName} 的红包，金额为 ${claimedAmount.toFixed(2)} 元。`);
                    }

                    // 无论成功与否，最后都显示详情页
                    // 此时需要从state中获取最新的packet对象，因为它可能在handleOpenRedPacket中被更新了
                    const updatedPacket = state.chats[currentChatId].history.find(m => m.timestamp === timestamp);
                    showRedPacketDetails(updatedPacket);
                }
            }
            // ▲▲▲ 替换结束 ▲▲▲

            /**
             * 【核心】处理用户打开红包的逻辑 (V5 - 专注于数据更新)
             */
            async function handleOpenRedPacket(packet) {
                const chat = state.chats[state.activeChatId];
                const myNickname = chat.settings.myNickname || '我';

                // 1. 检查红包是否还能领
                const remainingCount = packet.count - Object.keys(packet.claimedBy || {}).length;
                if (remainingCount <= 0) {
                    packet.isFullyClaimed = true;
                    await db.chats.put(chat);
                    await showCustomAlert("手慢了", "红包已被领完！");
                    return null; // 返回null表示领取失败
                }

                // 2. 计算领取金额
                let claimedAmount = 0;
                const remainingAmount = packet.totalAmount - Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
                if (packet.packetType === 'lucky') {
                    if (remainingCount === 1) { claimedAmount = remainingAmount; }
                    else {
                        const min = 0.01;
                        const max = remainingAmount - (remainingCount - 1) * min;
                        claimedAmount = Math.random() * (max - min) + min;
                    }
                } else { claimedAmount = packet.totalAmount; }
                claimedAmount = parseFloat(claimedAmount.toFixed(2));

                // 3. 更新红包数据
                if (!packet.claimedBy) packet.claimedBy = {};
                packet.claimedBy[myNickname] = claimedAmount;

                const isNowFullyClaimed = Object.keys(packet.claimedBy).length >= packet.count;
                if (isNowFullyClaimed) {
                    packet.isFullyClaimed = true;
                }

                // 4. 构建系统消息和AI指令
                let hiddenMessageContent = isNowFullyClaimed
                    ? `[系统提示：用户 (${myNickname}) 领取了最后一个红包，现在 ${packet.senderName} 的红包已被领完。请对此事件发表评论。]`
                    : `[系统提示：用户 (${myNickname}) 刚刚领取了红包 (时间戳: ${packet.timestamp})。红包还未领完，你现在可以使用 'open_red_packet' 指令来尝试领取。]`;

                const visibleMessage = { role: 'system', type: 'pat_message', content: `你领取了 ${packet.senderName} 的红包`, timestamp: Date.now() };
                const hiddenMessage = { role: 'system', content: hiddenMessageContent, timestamp: Date.now() + 1, isHidden: true };
                chat.history.push(visibleMessage, hiddenMessage);

                // 5. 保存到数据库
                await db.chats.put(chat);

                // 6. 返回领取的金额，用于后续弹窗
                return claimedAmount;
            }
            // ▲▲▲ 替换结束 ▲▲▲

            /**
             * 【全新】显示红包领取详情的模态框 (V4 - 已修复参数错误)
             */
            async function showRedPacketDetails(packet) {
                // 1. 直接检查传入的packet对象是否存在，无需再查找
                if (!packet) {
                    console.error("showRedPacketDetails收到了无效的packet对象");
                    return;
                }

                const chat = state.chats[state.activeChatId];
                if (!chat) return;

                const modal = document.getElementById('red-packet-details-modal');
                const myNickname = chat.settings.myNickname || '我';

                // 2. 后续所有逻辑保持不变，直接使用传入的packet对象
                document.getElementById('rp-details-sender').textContent = packet.senderName;
                document.getElementById('rp-details-greeting').textContent = packet.greeting || '恭喜发财，大吉大利！';

                const myAmountEl = document.getElementById('rp-details-my-amount');
                if (packet.claimedBy && packet.claimedBy[myNickname]) {
                    myAmountEl.querySelector('span:first-child').textContent = packet.claimedBy[myNickname].toFixed(2);
                    myAmountEl.style.display = 'block';
                } else {
                    myAmountEl.style.display = 'none';
                }

                const claimedCount = Object.keys(packet.claimedBy || {}).length;
                const claimedAmountSum = Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
                let summaryText = `${claimedCount}/${packet.count}个红包，共${claimedAmountSum.toFixed(2)}/${packet.totalAmount.toFixed(2)}元。`;
                if (!packet.isFullyClaimed && claimedCount < packet.count) {
                    const timeLeft = Math.floor((packet.timestamp + 24 * 60 * 60 * 1000 - Date.now()) / (1000 * 60 * 60));
                    if (timeLeft > 0) summaryText += ` 剩余红包将在${timeLeft}小时内退还。`;
                }
                document.getElementById('rp-details-summary').textContent = summaryText;

                const listEl = document.getElementById('rp-details-list');
                listEl.innerHTML = '';
                const claimedEntries = Object.entries(packet.claimedBy || {});

                let luckyKing = { name: '', amount: -1 };
                if (packet.packetType === 'lucky' && packet.isFullyClaimed && claimedEntries.length > 1) {
                    claimedEntries.forEach(([name, amount]) => {
                        if (amount > luckyKing.amount) {
                            luckyKing = { name, amount };
                        }
                    });
                }

                claimedEntries.sort((a, b) => b[1] - a[1]);

                claimedEntries.forEach(([name, amount]) => {
                    const item = document.createElement('div');
                    item.className = 'rp-details-item';
                    let luckyTag = '';
                    if (luckyKing.name && name === luckyKing.name) {
                        luckyTag = '<span class="lucky-king-tag">手气王</span>';
                    }
                    item.innerHTML = `
            <span class="name">${name}</span>
            <span class="amount">${amount.toFixed(2)} 元</span>
            ${luckyTag}
        `;
                    listEl.appendChild(item);
                });

                modal.classList.add('visible');
            }
            // ▲▲▲ 替换结束 ▲▲▲

            // 绑定关闭详情按钮的事件
            document.getElementById('close-rp-details-btn').addEventListener('click', () => {
                document.getElementById('red-packet-details-modal').classList.remove('visible');
            });

            // 供全局调用的函数，以便红包卡片上的 onclick 能找到它
            window.handlePacketClick = handlePacketClick;

            // ▲▲▲ 替换结束 ▲▲▲

            // ▼▼▼ AI Reply Debugging Functions ▼▼▼



            // ▼▼▼ Share Link Functions ▼▼▼
            function openShareLinkModal() {
                if (!state.activeChatId) return;

                // 清空上次输入的内容
                document.getElementById('link-title-input').value = '';
                document.getElementById('link-description-input').value = '';
                document.getElementById('link-source-input').value = '';
                document.getElementById('link-content-input').value = '';

                // 显示模态框
                document.getElementById('share-link-modal').classList.add('visible');
            }

            async function sendUserLinkShare() {
                if (!state.activeChatId) return;

                const title = document.getElementById('link-title-input').value.trim();
                if (!title) {
                    alert("标题是必填项哦！");
                    return;
                }

                const description = document.getElementById('link-description-input').value.trim();
                const sourceName = document.getElementById('link-source-input').value.trim();
                const content = document.getElementById('link-content-input').value.trim();

                const chat = state.chats[state.activeChatId];

                // 创建消息对象
                const linkMessage = {
                    role: 'user', // 角色是 'user'
                    type: 'share_link',
                    timestamp: Date.now(),
                    title: title,
                    description: description,
                    source_name: sourceName,
                    content: content,
                    // 用户分享的链接，我们不提供图片，让它总是显示占位图
                    thumbnail_url: null
                };

                // 将消息添加到历史记录
                chat.history.push(linkMessage);
                await db.chats.put(chat);

                // 渲染新消息并更新列表
                appendMessage(linkMessage, chat);
                renderChatList();

                // 关闭模态框
                document.getElementById('share-link-modal').classList.remove('visible');
            }

            // ▼▼▼ Location Share Functions ▼▼▼
            function openLocationShareModal() {
                if (!state.activeChatId) return;

                // 清空上次输入的内容（只在非编辑模式下）
                if (!window.editingLocationTimestamp) {
                    document.getElementById('location-name-input').value = '';
                    document.getElementById('location-address-input').value = '';

                    // 重置模态框标题和按钮文本为创建模式
                    document.querySelector('#location-share-modal .modal-header span').textContent = '分享位置';
                    document.getElementById('confirm-location-btn').textContent = '发送位置';
                }

                // 显示模态框
                document.getElementById('location-share-modal').classList.add('visible');
            }

            async function sendUserLocationShare() {
                if (!state.activeChatId) return;

                // Check if we're in edit mode
                if (window.editingLocationTimestamp) {
                    await saveLocationEdit();
                    return;
                }

                const locationName = document.getElementById('location-name-input').value.trim();
                if (!locationName) {
                    alert("位置名称是必填项哦！");
                    return;
                }

                const address = document.getElementById('location-address-input').value.trim();

                const chat = state.chats[state.activeChatId];

                // 创建消息对象
                const locationMessage = {
                    role: 'user',
                    type: 'location_share',
                    timestamp: Date.now(),
                    location_name: locationName,
                    address: address
                };

                // 将消息添加到历史记录
                chat.history.push(locationMessage);
                await db.chats.put(chat);

                // 渲染新消息并更新列表
                appendMessage(locationMessage, chat);
                renderChatList();

                // 关闭模态框
                document.getElementById('location-share-modal').classList.remove('visible');
            }

            async function editLocationMessage(timestamp) {
                if (!state.activeChatId) return;

                const chat = state.chats[state.activeChatId];
                const message = chat.history.find(m => m.timestamp === timestamp);

                if (!message || message.type !== 'location_share') {
                    alert('找不到位置消息');
                    return;
                }

                // 预填充现有数据
                document.getElementById('location-name-input').value = message.location_name || '';
                document.getElementById('location-address-input').value = message.address || '';

                // 标记为编辑模式并更改UI
                window.editingLocationTimestamp = timestamp;

                // 更改模态框标题和按钮文本
                document.querySelector('#location-share-modal .modal-header span').textContent = '编辑位置';
                document.getElementById('confirm-location-btn').textContent = '保存修改';

                // 显示模态框
                document.getElementById('location-share-modal').classList.add('visible');
            }

            async function saveLocationEdit() {
                if (!window.editingLocationTimestamp || !state.activeChatId) return;

                const locationName = document.getElementById('location-name-input').value.trim();
                if (!locationName) {
                    alert("位置名称是必填项哦！");
                    return;
                }

                const address = document.getElementById('location-address-input').value.trim();
                const chat = state.chats[state.activeChatId];
                const messageIndex = chat.history.findIndex(m => m.timestamp === window.editingLocationTimestamp);

                if (messageIndex === -1) {
                    alert('找不到要编辑的消息');
                    return;
                }

                // 更新消息
                chat.history[messageIndex].location_name = locationName;
                chat.history[messageIndex].address = address;

                // 保存到数据库
                await db.chats.put(chat);

                // 关闭所有相关模态框
                document.getElementById('location-share-modal').classList.remove('visible');
                document.getElementById('message-actions-modal').classList.remove('visible');

                // 刷新UI
                renderChatInterface(state.activeChatId);
                renderChatList();

                // 清理编辑状态并重置UI
                window.editingLocationTimestamp = null;
                activeMessageTimestamp = null;
                document.querySelector('#location-share-modal .modal-header span').textContent = '分享位置';
                document.getElementById('confirm-location-btn').textContent = '发送位置';
            }
            // ▲▲▲ Location Share Functions End ▲▲▲

            // ▼▼▼ Meetup Edit Modal Functions ▼▼▼
            function openMeetupEditModal() {
                if (!window.activeMeetupSession || !window.activeMeetupEventId) {
                    alert('没有活动的见面会话');
                    return;
                }

                // Get current meetup details from the active session
                const session = window.activeMeetupSession;

                // Pre-fill the modal with current values
                document.getElementById('meetup-title-input').value = session.title || '';
                document.getElementById('meetup-location-input').value = session.location || '';

                // Change modal title to indicate editing
                document.querySelector('#meetup-creation-modal .modal-header span').textContent = '编辑见面详情';

                // Change button text to indicate editing
                document.getElementById('start-meetup-btn').textContent = '保存更改';

                // Set a flag to indicate we're in edit mode
                window.isEditingMeetup = true;

                // Show modal
                document.getElementById('meetup-creation-modal').classList.add('visible');

                // Focus on first input field
                document.getElementById('meetup-title-input').focus();
            }

            // ▼▼▼ Meetup Creation Modal Functions ▼▼▼
            function openMeetupCreationModal() {
                if (!state.activeChatId) {
                    alert('请先选择一个聊天对象');
                    return;
                }

                // Get current chat context
                const chat = state.chats[state.activeChatId];
                if (!chat) {
                    alert('无法获取聊天信息');
                    return;
                }

                // Check if this is a group chat (date mode should be for individual chats)
                if (chat.isGroup) {
                    alert('见面模式仅支持单人聊天，不支持群聊');
                    return;
                }

                // Clear previous input values
                document.getElementById('meetup-location-input').value = '';
                document.getElementById('meetup-title-input').value = '';

                // Store current chat context for date creation
                window.currentDateChatContext = {
                    chatId: state.activeChatId,
                    chatName: chat.name || '聊天对象',
                    aiName: chat.name || 'AI',
                    isGroup: chat.isGroup || false
                };

                // Show modal
                document.getElementById('meetup-creation-modal').classList.add('visible');

                // Focus on first input field
                setTimeout(() => {
                    document.getElementById('meetup-location-input').focus();
                }, 100);
            }

            function closeMeetupCreationModal() {
                document.getElementById('meetup-creation-modal').classList.remove('visible');

                // Reset modal to creation mode
                const headerSpan = document.querySelector('#meetup-creation-modal .modal-header span');
                const startBtn = document.getElementById('start-meetup-btn');

                if (headerSpan) {
                    headerSpan.textContent = '开始见面';
                }
                if (startBtn) {
                    startBtn.textContent = '开始见面';
                }
                window.isEditingMeetup = false;

                // Clear chat context (only for creation mode)
                if (!window.isEditingMeetup) {
                    window.currentDateChatContext = null;
                }

                // Clear input values
                document.getElementById('meetup-location-input').value = '';
                document.getElementById('meetup-title-input').value = '';
            }

            function validateMeetupInputs() {
                const location = document.getElementById('meetup-location-input').value.trim();
                const title = document.getElementById('meetup-title-input').value.trim();

                if (!title) {
                    alert('请输入见面主题');
                    return false;
                }

                // Location is optional - no validation needed

                return true;
            }

            async function startMeetup() {
                if (!validateMeetupInputs()) return;

                const location = document.getElementById('meetup-location-input').value.trim();
                const title = document.getElementById('meetup-title-input').value.trim();

                // Check if we're in edit mode
                if (window.isEditingMeetup) {
                    try {
                        // Update existing meetup session
                        await updateMeetupDetails(location, title);

                        // Close modal and reset edit mode
                        closeMeetupCreationModal();
                        window.isEditingMeetup = false;

                        // Show success message
                        showNotification('见面详情已更新！✨');

                    } catch (error) {
                        console.error('Failed to update meetup details:', error);
                        alert('更新失败，请重试');
                    }
                    return;
                }

                // Original creation logic
                if (!window.currentDateChatContext) {
                    alert('聊天上下文丢失，请重新打开');
                    return;
                }

                const chatContext = window.currentDateChatContext;



                try {
                    let eventId;

                    // Check if we're updating an existing calendar event
                    if (chatContext && chatContext.originalMemoryId) {
                        // Update existing event instead of creating new one
                        eventId = await updateExistingCalendarEvent(chatContext.originalMemoryId, location, title, chatContext);
                    } else {
                        // Create new calendar event (for fresh meetups)
                        eventId = await createDateCalendarEvent(location, title, chatContext);
                    }

                    // Start date mode session
                    await initiateMeetupSession(location, title, chatContext);

                    // Close modal
                    closeMeetupCreationModal();

                    // Navigate to meetup screen
                    showScreen('meetup-screen');

                    // Update date mode context with the actual details
                    const eventData = {
                        title: title,
                        location: location,
                        timeDisplay: new Date().toLocaleString('zh-CN'),
                        phase: 'during'
                    };
                    updateMeetupContext(eventData);

                    // Show success message
                    showNotification(`与${chatContext.aiName}的见面开始了！💕`);

                    // Only refresh calendar if it's currently visible
                    if (document.getElementById('calendar-screen').classList.contains('active')) {
                        renderCalendarScreen();
                    }

                } catch (error) {
                    console.error('Failed to start date mode:', error);
                    alert('开始见面失败，请重试');
                    return; // Don't proceed if there's an error
                }
            }

            async function updateMeetupDetails(newLocation, newTitle) {
                if (!window.activeMeetupSession || !window.activeMeetupEventId) {
                    throw new Error('No active meetup session');
                }

                try {
                    // Update the active session
                    window.activeMeetupSession.location = newLocation;
                    window.activeMeetupSession.title = newTitle;

                    // Update the calendar event in database
                    const eventId = window.activeMeetupEventId;
                    const event = await db.memories.get(eventId);

                    if (event) {
                        event.description = newLocation ? `${newTitle} - 在${newLocation}` : newTitle;
                        event.meetupData.location = newLocation;
                        event.meetupData.title = newTitle;

                        await db.memories.put(event);
                    }

                    // Update the UI immediately
                    const eventData = {
                        title: newTitle,
                        location: newLocation,
                        timeDisplay: new Date(window.activeMeetupSession.startTime).toLocaleString('zh-CN'),
                        phase: 'during'
                    };
                    updateMeetupContext(eventData);

                    // Refresh calendar if it's currently visible
                    if (document.getElementById('calendar-screen').classList.contains('active')) {
                        renderCalendarScreen();
                    }

                } catch (error) {
                    console.error('Failed to update meetup details:', error);
                    throw error;
                }
            }
            // ▲▲▲ Date Creation Modal Functions End ▲▲▲

            // ▼▼▼ Calendar Event Creation for Date Mode ▼▼▼
            async function updateExistingCalendarEvent(memoryId, location, title, chatContext) {
                try {


                    // Get the existing memory/event
                    const existingEvent = await db.memories.get(memoryId);


                    if (!existingEvent) {
                        throw new Error('Original calendar event not found');
                    }

                    // Add meetup data to existing event WITHOUT changing original data
                    // Keep original: description, timestamp, authorName, etc.
                    // Only add/update the meetup-specific data and change type to meetup
                    existingEvent.type = 'meetup'; // Change type so updateDateCalendarEvent can find it
                    existingEvent.meetupData = {
                        location: location,
                        title: title,
                        aiName: chatContext.aiName,
                        isActive: true,
                        startTime: Date.now(),
                        endTime: null,
                        messages: [],
                        visitedLocations: [location]
                    };

                    // Update in database
                    await db.memories.put(existingEvent);

                    // Store the event ID for future reference
                    window.activeMeetupEventId = memoryId;

                    return memoryId;

                } catch (error) {
                    console.error('Failed to update existing calendar event:', error);
                    throw error;
                }
            }

            async function createDateCalendarEvent(location, title, chatContext) {
                try {
                    // Create a special calendar event for date mode
                    const dateEvent = {
                        chatId: chatContext.chatId,
                        authorName: chatContext.aiName,
                        description: location ? `${title} - 在${location}` : title,
                        timestamp: Date.now(),
                        type: 'meetup',
                        targetDate: Date.now(), // Meetup starts immediately
                        meetupData: {
                            location: location,
                            title: title,
                            aiName: chatContext.aiName,
                            isActive: true,
                            startTime: Date.now(),
                            endTime: null,
                            messages: [],
                            visitedLocations: [location]
                        }
                    };

                    // Add to database
                    const eventId = await db.memories.add(dateEvent);

                    // Store the event ID for future reference
                    window.activeMeetupEventId = eventId;

                    return eventId;

                } catch (error) {
                    console.error('Failed to create date calendar event:', error);
                    throw error;
                }
            }

            async function initiateMeetupSession(location, title, chatContext) {

                // Store the session info globally
                window.activeMeetupSession = {
                    eventId: window.activeMeetupEventId,
                    chatId: chatContext.chatId,
                    location: location,
                    title: title,
                    aiName: chatContext.aiName,
                    startTime: Date.now(),
                    isActive: true
                };

                // Persist session state for app backgrounding/restoration
                localStorage.setItem('activeMeetupSession', JSON.stringify(window.activeMeetupSession));
                localStorage.setItem('activeMeetupEventId', window.activeMeetupEventId);

                // Show the meetup progress bar
                showMeetupProgressBar();

                // Refresh calendar status indicators if calendar is visible
                if (typeof refreshCalendarStatusIndicators === 'function') {
                    refreshCalendarStatusIndicators();
                }

                return Promise.resolve();
            }

            // Function to update date mode calendar event
            async function updateDateCalendarEvent(eventId, updates) {
                try {
                    const event = await db.memories.get(eventId);
                    if (!event || event.type !== 'meetup') {
                        throw new Error('Meetup event not found');
                    }

                    // Update the event data
                    Object.assign(event.meetupData, updates);

                    // Mark as having date mode history when completed
                    if (updates.isCompleted) {
                        event.hasMeetupHistory = true;
                    }

                    // Save back to database
                    await db.memories.put(event);



                } catch (error) {
                    console.error('Failed to update date calendar event:', error);
                    throw error;
                }
            }

            // Function to end date mode and finalize calendar event
            async function endMeetupSession() {
                // Prevent multiple simultaneous executions
                if (window.endMeetupSessionInProgress) {
                    return;
                }

                window.endMeetupSessionInProgress = true;

                if (!window.activeMeetupSession || !window.activeMeetupEventId) {
                    window.endMeetupSessionInProgress = false;
                    return;
                }

                try {
                    // Try to update the calendar event with end time and completion status
                    try {
                        const session = window.activeMeetupSession;
                        const chat = state.chats[session.chatId];
                        const endTime = Date.now();

                        // Get all date mode messages for this event
                        const meetupMessages = chat && chat.history ? chat.history.filter(msg =>
                            msg.meetup && msg.meetup.eventId === window.activeMeetupEventId
                        ) : [];

                        // DEBUG: Log what messages are being saved
                        console.log('DEBUG - Meetup session end - saving messages:', {
                            eventId: window.activeMeetupEventId,
                            sessionStartTime: session.startTime,
                            totalChatHistory: chat ? chat.history.length : 0,
                            filteredMeetupMessages: meetupMessages.length,
                            meetupMessages: meetupMessages
                        });

                        // Calculate date duration in minutes
                        const totalDuration = Math.round((endTime - session.startTime) / (1000 * 60));

                        // Extract behavioral notations from all messages
                        const behavioralNotations = [];
                        meetupMessages.forEach(msg => {
                            if (msg.content && typeof msg.content === 'string') {
                                const notationRegex = /\[([^\]]+)\]/g;
                                let match;
                                while ((match = notationRegex.exec(msg.content)) !== null) {
                                    behavioralNotations.push(match[1]);
                                }
                            }
                        });

                        await updateDateCalendarEvent(window.activeMeetupEventId, {
                            isActive: false,
                            isCompleted: true,
                            endTime: endTime,
                            totalDuration: totalDuration,
                            messageCount: meetupMessages.length,
                            behavioralNotations: behavioralNotations,
                            messages: meetupMessages,
                            interactions: meetupMessages // Keep both for compatibility
                        });
                    } catch (calendarError) {

                        // Recreate the calendar event with all the date interactions
                        try {
                            const session = window.activeMeetupSession;
                            const chat = state.chats[session.chatId];

                            if (chat && chat.history) {
                                // Check if we already have a recreated event to prevent duplicates
                                const existingEvents = await db.memories.where('chatId').equals(session.chatId)
                                    .and(event => event.type === 'meetup' &&
                                        event.meetupData &&
                                        event.meetupData.startTime === session.startTime)
                                    .toArray();

                                if (existingEvents.length > 0) {
                                    window.activeMeetupEventId = existingEvents[0].id;
                                    return;
                                }

                                // Get all date mode messages for this event
                                const meetupMessages = chat.history.filter(msg =>
                                    msg.meetup && msg.meetup.eventId === session.eventId
                                );

                                // DEBUG: Log messages being saved in recreation
                                console.log('DEBUG - Meetup session recreation - saving messages:', {
                                    eventId: session.eventId,
                                    totalChatHistory: chat.history.length,
                                    filteredMeetupMessages: meetupMessages.length,
                                    meetupMessages: meetupMessages
                                });

                                // Calculate date duration in minutes
                                const endTime = Date.now();
                                const totalDuration = Math.round((endTime - session.startTime) / (1000 * 60));

                                // Extract behavioral notations from all messages
                                const behavioralNotations = [];
                                meetupMessages.forEach(msg => {
                                    if (msg.content && typeof msg.content === 'string') {
                                        const notationRegex = /\[([^\]]+)\]/g;
                                        let match;
                                        while ((match = notationRegex.exec(msg.content)) !== null) {
                                            behavioralNotations.push(match[1]);
                                        }
                                    }
                                });

                                // Create new calendar event with all interactions and metadata
                                const newDateEvent = {
                                    chatId: session.chatId,
                                    authorName: chat.name,
                                    description: `与${chat.name}的见面记录`,
                                    timestamp: session.startTime,
                                    type: 'meetup',
                                    targetDate: session.startTime,
                                    hasMeetupHistory: true,
                                    meetupData: {
                                        sessionId: session.eventId || 'session_' + session.startTime,
                                        location: session.location,
                                        title: session.title,
                                        chatId: session.chatId,
                                        aiName: chat.name,
                                        isActive: false,
                                        isCompleted: true,
                                        startTime: session.startTime,
                                        endTime: endTime,
                                        totalDuration: totalDuration,
                                        messageCount: meetupMessages.length,
                                        behavioralNotations: behavioralNotations,
                                        visitedLocations: [session.location],
                                        messages: meetupMessages,
                                        interactions: meetupMessages // Keep both for compatibility
                                    }
                                };

                                const newEventId = await db.memories.add(newDateEvent);

                                // Update the session with new event ID
                                window.activeMeetupEventId = newEventId;
                            }
                        } catch (recreateError) {
                            console.error('Failed to recreate calendar event:', recreateError);
                            // Continue with session cleanup even if recreation fails
                        }
                    }

                    // Hide the meetup progress bar
                    hideMeetupProgressBar();

                    // Clear active session
                    window.activeMeetupSession = null;
                    window.activeMeetupEventId = null;

                    // Clear persisted session state
                    localStorage.removeItem('activeMeetupSession');
                    localStorage.removeItem('activeMeetupEventId');

                    // Refresh calendar and memories screens to show completed date
                    try {
                        renderCalendarScreen();
                        renderMemoriesScreen();
                    } catch (refreshError) {
                        console.error('Failed to refresh screens after date completion:', refreshError);
                        // Continue execution even if screen refresh fails
                    }

                } catch (error) {
                    console.error('Failed to end date mode session:', error);
                    throw error;
                } finally {
                    // Always reset the flag
                    window.endMeetupSessionInProgress = false;
                }
            }

            // Function to retrieve date mode session data from calendar event
            async function getMeetupSessionFromEvent(eventId) {
                try {
                    const event = await db.memories.get(eventId);
                    if (!event || event.type !== 'meetup') {
                        throw new Error('Meetup event not found');
                    }

                    return event.meetupData;

                } catch (error) {
                    console.error('Failed to retrieve date mode session:', error);
                    throw error;
                }
            }

            // Function to check if there's an active date mode session
            function hasActiveMeetupSession() {
                return window.activeMeetupSession && window.activeMeetupEventId;
            }

            // Function to open date mode history view
            async function openMeetupHistory(eventId) {
                try {
                    // Verify the event exists and has date mode data
                    const event = await db.memories.get(eventId);
                    if (!event || event.type !== 'meetup' || !event.meetupData) {
                        throw new Error('Invalid date mode event');
                    }

                    // Set global flag for history viewing
                    window.meetupHistoryEventId = eventId;

                    // Navigate to meetup screen in history mode
                    showScreen('meetup-screen');

                } catch (error) {
                    console.error('Failed to open date mode history:', error);
                    alert('无法打开见面回忆: ' + error.message);
                }
            }

            // Make function globally accessible
            window.openMeetupHistory = openMeetupHistory;

            // Function to update calendar event's stored date mode data after edits/deletes
            async function updateCalendarEventMeetupData(eventId, chat) {
                try {
                    // Get the calendar event
                    const event = await db.memories.get(eventId);
                    if (!event || event.type !== 'meetup') return;

                    // Filter date mode messages for this event from chat history
                    const meetupMessages = chat.history.filter(msg =>
                        msg.meetup && msg.meetup.eventId === eventId
                    );

                    // Update the event's meetupData.messages
                    if (!event.meetupData) {
                        event.meetupData = {};
                    }
                    event.meetupData.messages = meetupMessages;

                    // Save the updated event
                    await db.memories.put(event);

                } catch (error) {
                    console.error('Failed to update calendar event:', error);
                }
            }

            // Function to delete all date mode messages associated with an event
            async function deleteMeetupMessages(eventId) {
                try {
                    console.log('DEBUG - Deleting meetup messages for event:', eventId);

                    // Get the event to find the associated chat
                    const event = await db.memories.get(eventId);
                    if (!event || event.type !== 'meetup') {
                        console.log('DEBUG - Event not found or not meetup type');
                        return;
                    }

                    const chat = state.chats[event.chatId];
                    if (!chat) {
                        console.log('DEBUG - Chat not found for event:', event.chatId);
                        return;
                    }

                    // Filter out messages with matching eventId
                    const originalLength = chat.history.length;
                    chat.history = chat.history.filter(msg =>
                        !(msg.meetup && msg.meetup.eventId === eventId)
                    );

                    const deletedCount = originalLength - chat.history.length;

                    console.log('DEBUG - Meetup messages deletion:', {
                        eventId: eventId,
                        originalLength: originalLength,
                        newLength: chat.history.length,
                        deletedCount: deletedCount
                    });

                    // Save updated chat history
                    if (deletedCount > 0) {
                        await db.chats.put(chat);
                        console.log('DEBUG - Chat history updated after message deletion');
                    }

                    return deletedCount;

                } catch (error) {
                    console.error('DEBUG - Failed to delete meetup messages:', error);
                    throw error;
                }
            }

            // Make function globally accessible
            window.deleteMeetupMessages = deleteMeetupMessages;

            // Function to load existing messages for active date session
            async function loadActiveMeetupMessages() {
                if (!window.activeMeetupSession || !window.activeMeetupEventId) {
                    return;
                }

                const session = window.activeMeetupSession;
                const chat = state.chats[session.chatId];

                if (!chat) {
                    return;
                }

                // Get existing meetup mode messages for this event
                const existingMessages = chat.history.filter(msg =>
                    msg.meetup && msg.meetup.eventId === window.activeMeetupEventId
                );

                const messagesContainer = document.getElementById('meetup-messages');
                if (!messagesContainer) return;

                // Clear existing display
                messagesContainer.innerHTML = '';

                // Display existing messages
                existingMessages.forEach(message => {
                    // Convert stored message to display format
                    const displayMessage = {
                        content: message.content,
                        timestamp: message.timestamp,
                        isUser: message.role === 'user',
                        type: 'meetup_interaction',
                        isHidden: true // Safety: ensure display messages are also hidden
                    };

                    const messageElement = createMeetupMessage(displayMessage, message.role === 'user');
                    messagesContainer.appendChild(messageElement);
                });

                // Scroll to bottom
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            // Function to update a date mode message in chat history
            async function updateMeetupMessageInHistory(timestamp, newContent) {
                // Handle both active meetup mode and history mode
                let eventId, chatId;

                if (window.meetupHistoryEventId) {
                    // History mode
                    eventId = window.meetupHistoryEventId;
                    chatId = state.activeChatId; // Set in initializeMeetupHistoryView
                } else if (window.activeMeetupSession && window.activeMeetupEventId) {
                    // Active meetup mode
                    eventId = window.activeMeetupEventId;
                    chatId = window.activeMeetupSession.chatId;
                } else {
                    return;
                }

                const chat = state.chats[chatId];

                if (!chat) return;

                // Find and update the message in chat history
                const messageIndex = chat.history.findIndex(msg =>
                    msg.meetup &&
                    msg.meetup.eventId === eventId &&
                    msg.timestamp === parseInt(timestamp)
                );

                if (messageIndex === -1) return;

                // Update the message content
                chat.history[messageIndex].content = newContent;

                // Save updated chat history
                try {
                    await db.chats.put(chat);

                    // Also update the calendar event's stored meetup data
                    if (window.meetupHistoryEventId) {
                        await updateCalendarEventMeetupData(window.meetupHistoryEventId, chat);
                    }
                } catch (error) {
                    console.error('Failed to update message in chat history:', error);
                }
            }

            // Function to restore active date session from localStorage
            function restoreActiveMeetupSession() {
                try {
                    const savedSession = localStorage.getItem('activeMeetupSession');
                    const savedEventId = localStorage.getItem('activeMeetupEventId');

                    if (savedSession && savedEventId) {
                        window.activeMeetupSession = JSON.parse(savedSession);
                        window.activeMeetupEventId = parseInt(savedEventId, 10); // Convert string to number

                        return true;
                    }
                } catch (error) {
                    console.error('Failed to restore active meetup session:', error);
                    // Clear corrupted data
                    localStorage.removeItem('activeMeetupSession');
                    localStorage.removeItem('activeMeetupEventId');
                }

                return false;
            }

            // ▼▼▼ Meetup End Modal Functions ▼▼▼
            function showMeetupEndModal() {
                if (!hasActiveMeetupSession()) {
                    alert('没有活跃的见面会话');
                    return;
                }
                document.getElementById('meetup-end-modal').classList.add('visible');
            }

            function hideMeetupEndModal() {
                document.getElementById('meetup-end-modal').classList.remove('visible');
            }

            // Make function globally accessible
            window.hideMeetupEndModal = hideMeetupEndModal;

            async function confirmEndMeetup() {
                // Prevent multiple simultaneous executions
                if (window.confirmEndMeetupInProgress) {
                    return;
                }

                window.confirmEndMeetupInProgress = true;

                try {
                    // Preserve session data BEFORE calling endMeetupSession (which clears it)
                    const preservedSession = window.activeMeetupSession;

                    // End the date mode session
                    await endMeetupSession();

                    // Hide the modal
                    hideMeetupEndModal();

                    // Show success message and navigate using preserved session data
                    if (preservedSession && preservedSession.chatId) {
                        showNotification(preservedSession.chatId, '见面已结束，美好回忆已保存到日历 💕');

                        // Check if there's an active music session with a different chat
                        if (musicState.isActive && musicState.activeChatId && musicState.activeChatId !== preservedSession.chatId) {
                            // If music is playing with a different AI, navigate to that AI instead
                            // to preserve the music session
                            openChat(musicState.activeChatId);
                        } else {
                            // Otherwise, navigate to the date AI's chat
                            openChat(preservedSession.chatId);
                        }
                    } else {
                        // Fallback if no session data
                        showScreen('chat-interface-screen');
                    }

                    // Clear previous screen tracking since we always go to chat
                    previousScreen = null;

                } catch (error) {
                    console.error('Error in confirmEndMeetup:', error);
                    alert('结束见面时出现错误: ' + error.message);
                } finally {
                    // Always reset the flag
                    window.confirmEndMeetupInProgress = false;
                }
            }

            // Make function globally accessible
            window.confirmEndMeetup = confirmEndMeetup;
            // ▲▲▲ Meetup End Modal Functions End ▲▲▲

            // ▼▼▼ Meetup Progress Bar Functions ▼▼▼

            function showMeetupProgressBar() {
                if (!hasActiveMeetupSession()) {
                    return;
                }

                const session = window.activeMeetupSession;
                const chatId = session.chatId;
                const chat = state.chats[chatId];

                if (!chat) {
                    console.warn('Chat not found for active date session');
                    return;
                }

                // Update progress bar content
                updateMeetupProgressBarContent();

                // Show chat screen meetup progress bar
                const meetupBar = document.getElementById('meetup-progress-bar');
                if (meetupBar) {
                    meetupBar.classList.remove('hidden');
                    // Add class to chat screen to adjust music bar positioning
                    const chatScreen = document.getElementById('chat-interface-screen');
                    if (chatScreen) {
                        chatScreen.classList.add('has-meetup-progress');
                    }
                }

                // Show home screen meetup progress bar
                const homeMeetupBar = document.getElementById('home-meetup-progress-bar');
                if (homeMeetupBar) {
                    homeMeetupBar.classList.remove('hidden');
                    // Add class to home screen to adjust music bar positioning
                    const homeScreen = document.getElementById('home-screen');
                    if (homeScreen) {
                        homeScreen.classList.add('has-meetup-progress');
                    }
                }

                // Start timer to update elapsed time every second
                if (window.meetupProgressTimer) {
                    clearInterval(window.meetupProgressTimer);
                }
                window.meetupProgressTimer = setInterval(() => {
                    if (hasActiveMeetupSession()) {
                        updateMeetupProgressBarContent();
                    } else {
                        clearInterval(window.meetupProgressTimer);
                        window.meetupProgressTimer = null;
                    }
                }, 1000); // Update every second
            }

            function hideMeetupProgressBar() {
                // Hide chat screen meetup progress bar
                const meetupBar = document.getElementById('meetup-progress-bar');
                if (meetupBar) {
                    meetupBar.classList.add('hidden');
                    // Remove class from chat screen to restore music bar positioning
                    const chatScreen = document.getElementById('chat-interface-screen');
                    if (chatScreen) {
                        chatScreen.classList.remove('has-meetup-progress');
                    }
                }

                // Hide home screen meetup progress bar
                const homeMeetupBar = document.getElementById('home-meetup-progress-bar');
                if (homeMeetupBar) {
                    homeMeetupBar.classList.add('hidden');
                    // Remove class from home screen to restore music bar positioning
                    const homeScreen = document.getElementById('home-screen');
                    if (homeScreen) {
                        homeScreen.classList.remove('has-meetup-progress');
                    }
                }

                // Clear the elapsed time timer
                if (window.meetupProgressTimer) {
                    clearInterval(window.meetupProgressTimer);
                    window.meetupProgressTimer = null;
                }
            }

            function updateMeetupProgressBarContent() {
                if (!hasActiveMeetupSession()) {
                    return;
                }

                const session = window.activeMeetupSession;
                const chatId = session.chatId;
                const chat = state.chats[chatId];

                if (!chat) {
                    return;
                }

                const aiName = chat.name || 'AI';
                const location = session.location;
                const progressText = location ? `与${aiName}在${location}` : `与${aiName}一起`;

                // Calculate elapsed time
                const elapsedMs = Date.now() - session.startTime;
                const totalSeconds = Math.floor(elapsedMs / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;

                // Format as MM:SS if no hours, HH:MM:SS if there are hours
                let elapsedText;
                if (hours > 0) {
                    elapsedText = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                } else {
                    elapsedText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }

                // Update chat screen progress bar
                const meetupProgressText = document.getElementById('meetup-progress-text');
                const meetupElapsedText = document.getElementById('meetup-elapsed-text');
                const meetupAiAvatar = document.getElementById('meetup-ai-avatar');

                if (meetupProgressText) {
                    meetupProgressText.textContent = progressText;
                }

                if (meetupElapsedText) {
                    meetupElapsedText.textContent = elapsedText;
                }

                if (meetupAiAvatar) {
                    meetupAiAvatar.src = chat.settings.aiAvatar;
                    meetupAiAvatar.style.display = 'block';
                }

                // Update home screen progress bar
                const homeMeetupProgressText = document.getElementById('home-meetup-progress-text');
                const homeMeetupElapsedText = document.getElementById('home-meetup-elapsed-text');
                const homeMeetupAiAvatar = document.getElementById('home-meetup-ai-avatar');

                if (homeMeetupProgressText) {
                    homeMeetupProgressText.textContent = progressText;
                }

                if (homeMeetupElapsedText) {
                    homeMeetupElapsedText.textContent = elapsedText;
                }

                if (homeMeetupAiAvatar) {
                    homeMeetupAiAvatar.src = chat.settings.aiAvatar;
                    homeMeetupAiAvatar.style.display = 'block';
                }
            }

            function initializeMeetupProgressBar() {
                // Chat screen meetup progress bar tap-to-return functionality
                const meetupBar = document.getElementById('meetup-progress-bar');
                if (meetupBar) {
                    meetupBar.addEventListener('click', () => {
                        if (hasActiveMeetupSession()) {
                            showScreen('meetup-screen');
                        }
                    });
                }

                // Home screen meetup progress bar tap-to-return functionality
                const homeMeetupBar = document.getElementById('home-meetup-progress-bar');
                if (homeMeetupBar) {
                    homeMeetupBar.addEventListener('click', () => {
                        if (hasActiveMeetupSession()) {
                            showScreen('meetup-screen');
                        }
                    });
                }
            }

            // ▲▲▲ Meetup Progress Bar Functions End ▲▲▲

            // ▲▲▲ Meetup Mode Calendar Integration End ▲▲▲

            function openBrowser(timestamp) {
                if (!state.activeChatId) return;

                const chat = state.chats[state.activeChatId];
                // 安全检查，确保 chat 和 history 都存在
                if (!chat || !chat.history) return;

                const message = chat.history.find(m => m.timestamp === timestamp);
                if (!message || message.type !== 'share_link') {
                    console.error("无法找到或消息类型不匹配的分享链接:", timestamp);
                    return; // 如果找不到消息，就直接退出
                }

                // 填充浏览器内容
                document.getElementById('browser-title').textContent = message.source_name || '文章详情';
                const browserContent = document.getElementById('browser-content');
                browserContent.innerHTML = `
                    <h1 class="article-title">${message.title || '无标题'}</h1>
                    <div class="article-meta">
                        <span>来源: ${message.source_name || '未知'}</span>
                    </div>
                    <div class="article-body">
                        <p>${(message.content || '内容为空。').replace(/\n/g, '</p><p>')}</p>
                    </div>
                `;

                // 显示浏览器屏幕
                showScreen('browser-screen');
            }

            function closeBrowser() {
                showScreen('chat-interface-screen');
            }
            // ▲▲▲ Share Link Functions End ▲▲▲

            // ▼▼▼ 【全新】投票功能核心函数 ▼▼▼

            /**
             * 打开创建投票的模态框并初始化
             */
            function openCreatePollModal() {
                const modal = document.getElementById('create-poll-modal');
                document.getElementById('poll-question-input').value = '';
                const optionsContainer = document.getElementById('poll-options-container');
                optionsContainer.innerHTML = '';

                // 默认创建两个空的选项框
                addPollOptionInput();
                addPollOptionInput();

                modal.classList.add('visible');
            }

            /**
             * 在模态框中动态添加一个选项输入框
             */
            function addPollOptionInput() {
                const container = document.getElementById('poll-options-container');
                const wrapper = document.createElement('div');
                wrapper.className = 'poll-option-input-wrapper';
                wrapper.innerHTML = `
        <input type="text" class="poll-option-input" placeholder="选项内容...">
        <button class="remove-option-btn">-</button>
    `;

                wrapper.querySelector('.remove-option-btn').addEventListener('click', () => {
                    // 确保至少保留两个选项
                    if (container.children.length > 2) {
                        wrapper.remove();
                    } else {
                        alert('投票至少需要2个选项。');
                    }
                });

                container.appendChild(wrapper);
            }

            /**
             * 用户确认发起投票
             */
            async function sendPoll() {
                if (!state.activeChatId) return;

                const question = document.getElementById('poll-question-input').value.trim();
                if (!question) {
                    alert('请输入投票问题！');
                    return;
                }

                const options = Array.from(document.querySelectorAll('.poll-option-input'))
                    .map(input => input.value.trim())
                    .filter(text => text); // 过滤掉空的选项

                if (options.length < 2) {
                    alert('请至少输入2个有效的投票选项！');
                    return;
                }

                const chat = state.chats[state.activeChatId];
                const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';

                const newPollMessage = {
                    role: 'user',
                    senderName: myNickname,
                    type: 'poll',
                    timestamp: Date.now(),
                    question: question,
                    options: options,
                    votes: {}, // 初始投票为空
                    isClosed: false,
                };

                chat.history.push(newPollMessage);
                await db.chats.put(chat);

                appendMessage(newPollMessage, chat);
                renderChatList();

                document.getElementById('create-poll-modal').classList.remove('visible');
            }

            // ▼▼▼ 用这个【已修复重复点击问题】的版本替换 handleUserVote 函数 ▼▼▼
            /**
             * 处理用户投票，并将事件作为隐藏消息存入历史记录
             * @param {number} timestamp - 投票消息的时间戳
             * @param {string} choice - 用户选择的选项文本
             */
            async function handleUserVote(timestamp, choice) {
                const chat = state.chats[state.activeChatId];
                const poll = chat.history.find(m => m.timestamp === timestamp);
                const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';

                // 1. 【核心修正】如果投票不存在或已关闭，直接返回
                if (!poll || poll.isClosed) {
                    // 如果是已关闭的投票，则直接显示结果
                    if (poll && poll.isClosed) {
                        showPollResults(timestamp);
                    }
                    return;
                }

                // 2. 检查用户是否点击了已经投过的同一个选项
                const isReclickingSameOption = poll.votes[choice] && poll.votes[choice].includes(myNickname);

                // 3. 【核心修正】如果不是重复点击，才执行投票逻辑
                if (!isReclickingSameOption) {
                    // 移除旧投票（如果用户改选）
                    for (const option in poll.votes) {
                        const voterIndex = poll.votes[option].indexOf(myNickname);
                        if (voterIndex > -1) {
                            poll.votes[option].splice(voterIndex, 1);
                        }
                    }
                    // 添加新投票
                    if (!poll.votes[choice]) {
                        poll.votes[choice] = [];
                    }
                    poll.votes[choice].push(myNickname);
                }

                // 4. 【核心逻辑】现在只处理用户投票事件，不再检查是否结束
                let hiddenMessageContent = null;

                // 只有在用户真正投票或改票时，才生成提示
                if (!isReclickingSameOption) {
                    hiddenMessageContent = `[系统提示：用户 (${myNickname}) 刚刚投票给了 “${choice}”。]`;
                }

                // 5. 如果有需要通知AI的事件，则创建并添加隐藏消息
                if (hiddenMessageContent) {
                    const hiddenMessage = {
                        role: 'system',
                        content: hiddenMessageContent,
                        timestamp: Date.now(),
                        isHidden: true,
                    };
                    chat.history.push(hiddenMessage);
                }

                // 6. 保存数据并更新UI
                await db.chats.put(chat);
                renderChatInterface(state.activeChatId);
            }
            // ▲▲▲ 替换结束 ▲▲▲

            /**
             * 用户结束投票，并将事件作为隐藏消息存入历史记录
             * @param {number} timestamp - 投票消息的时间戳
             */
            async function endPoll(timestamp) {
                const chat = state.chats[state.activeChatId];
                const poll = chat.history.find(m => m.timestamp === timestamp);
                if (!poll || poll.isClosed) return;

                const confirmed = await showCustomConfirm("结束投票", "确定要结束这个投票吗？结束后将无法再进行投票。");
                if (confirmed) {
                    poll.isClosed = true;

                    const resultSummary = poll.options.map(opt => `“${opt}”(${poll.votes[opt]?.length || 0}票)`).join('，');
                    const hiddenMessageContent = `[系统提示：用户手动结束了投票！最终结果为：${resultSummary}。]`;

                    const hiddenMessage = {
                        role: 'system',
                        content: hiddenMessageContent,
                        timestamp: Date.now(),
                        isHidden: true,
                    };
                    chat.history.push(hiddenMessage);

                    // 【核心修改】只保存数据和更新UI，不调用 triggerAiResponse()
                    await db.chats.put(chat);
                    renderChatInterface(state.activeChatId);
                }
            }
            // ▲▲▲ 替换结束 ▲▲▲

            /**
             * 显示投票结果详情
             * @param {number} timestamp - 投票消息的时间戳
             */
            function showPollResults(timestamp) {
                const chat = state.chats[state.activeChatId];
                const poll = chat.history.find(m => m.timestamp === timestamp);
                if (!poll || !poll.isClosed) return;

                let resultsHtml = `<p><strong>${poll.question}</strong></p><hr style="opacity: 0.2; margin: 10px 0;">`;

                if (Object.keys(poll.votes).length === 0) {
                    resultsHtml += '<p style="color: #8a8a8a;">还没有人投票。</p>';
                } else {
                    poll.options.forEach(option => {
                        const voters = poll.votes[option] || [];
                        resultsHtml += `
                <div style="margin-bottom: 15px;">
                    <p style="font-weight: 500; margin: 0 0 5px 0;">${option} (${voters.length}票)</p>
                    <p style="font-size: 13px; color: #555; margin: 0; line-height: 1.5;">
                        ${voters.length > 0 ? voters.join('、 ') : '无人投票'}
                    </p>
                </div>
            `;
                    });
                }

                showCustomAlert("投票结果", resultsHtml);
            }

            // ▲▲▲ 新函数粘贴结束 ▲▲▲
            // ▼▼▼ 【全新】公告板功能核心函数 - 请将整块代码粘贴到JS功能区 ▼▼▼

            /**
             * 打开公告板模态框并渲染内容
             */
            async function openBulletinBoard() {
                if (!state.activeChatId) return;
                const modal = document.getElementById('bulletin-board-modal');
                await renderBulletinBoard();
                modal.classList.add('visible');
            }

            /**
             * 渲染公告板列表
             */
            // ▼▼▼ 【最终正确版】请用这个完整的函数，替换旧的 renderBulletinBoard 函数 ▼▼▼
            async function renderBulletinBoard() {
                const listEl = document.getElementById('bulletin-list');
                listEl.innerHTML = '';
                const chatId = state.activeChatId;

                // 【核心修改】只从新的 'bulletins' 表中读取数据
                const bulletins = await db.bulletins.where({ chatId: chatId }).toArray();

                bulletins.sort((a, b) => {
                    if (a.isPinned && !b.isPinned) return -1;
                    if (!a.isPinned && b.isPinned) return 1;
                    return b.timestamp - a.timestamp;
                });

                if (bulletins.length === 0) {
                    listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">这个群还没有任何公告哦~</p>';
                    return;
                }

                bulletins.forEach(bulletin => {
                    const member = state.chats[chatId].members.find(m => m.name === bulletin.authorName);
                    const authorAvatar = member ? member.avatar : defaultGroupMemberAvatar;

                    let commentsHtml = '';
                    if (bulletin.comments && bulletin.comments.length > 0) {
                        commentsHtml += '<div class="post-footer"><div class="post-comments-container">';
                        bulletin.comments.forEach(comment => {
                            const commenterName = comment.commenterName || "匿名";
                            const commentText = comment.text || "";
                            commentsHtml += `<div class="comment-item"><span class="commenter-name">${commenterName}:</span><span class="comment-text">${commentText}</span></div>`;
                        });
                        commentsHtml += '</div></div>';
                    }

                    const card = document.createElement('div');
                    card.className = `qzone-post-item bulletin-card ${bulletin.isPinned ? 'pinned' : ''}`;
                    card.innerHTML = `
            <div class="post-header">
                <img src="${authorAvatar}" class="post-avatar">
                <div class="post-info">
                    <span class="post-nickname">${bulletin.authorName}</span>
                    <span class="post-timestamp">${formatPostTimestamp(bulletin.timestamp)}</span>
                </div>
                <div class="bulletin-actions-btn" data-id="${bulletin.id}">…</div>
            </div>
            <div class="post-content">${bulletin.description.replace(/\n/g, '<br>')}</div>
            ${commentsHtml} 
        `;
                    listEl.appendChild(card);
                });
            }

            // ▲▲▲ 替换结束 ▲▲▲


            /**
             * 显示公告操作菜单
             * @param {number} bulletinId - 公告的ID
             */
            function showBulletinActions(bulletinId) {
                activeBulletinId = bulletinId;
                document.getElementById('bulletin-actions-modal').classList.add('visible');
            }

            /**
             * 隐藏公告操作菜单
             */
            function hideBulletinActions() {
                document.getElementById('bulletin-actions-modal').classList.remove('visible');
                activeBulletinId = null;
            }

            /**
             * 处理置顶/取消置顶公告
             */
            async function handlePinBulletin() {
                if (!activeBulletinId) return;
                const bulletin = await db.bulletins.get(activeBulletinId); // <--- 【核心修正】从正确的 bulletins 表获取数据
                if (bulletin) {
                    bulletin.isPinned = !bulletin.isPinned;
                    await db.bulletins.put(bulletin); // <--- 【核心修正】将更新写回到正确的 bulletins 表
                    await renderBulletinBoard(); // 重新渲染列表以更新顺序和样式
                }
                hideBulletinActions();
            }

            /**
             * 处理删除公告
             */
            async function handleDeleteBulletin() {
                if (!activeBulletinId) return;
                const confirmed = await showCustomConfirm('删除公告', '确定要删除这条公告吗？此操作不可恢复。', { confirmButtonClass: 'btn-danger' });
                if (confirmed) {
                    // 【核心修改】只操作新表
                    await db.bulletins.delete(activeBulletinId);
                    await renderBulletinBoard();
                }
                hideBulletinActions();
            }

            /**
             * 处理用户手动发起公告
             * @param {number} timestamp - 被长按的消息的时间戳
             */
            async function handleUserCreateBulletin(timestamp) {
                if (!timestamp) return;

                const chat = state.chats[state.activeChatId];
                const message = chat.history.find(m => m.timestamp === timestamp);
                if (!message || typeof message.content !== 'string') {
                    alert("只能将纯文本消息发布到公告板。");
                    return;
                }

                const content = await showCustomPrompt('发布公告', '请确认或编辑公告内容：', message.content, 'textarea');
                if (content === null || !content.trim()) return;

                const myNickname = chat.settings.myNickname || '我';
                const myAvatar = chat.settings.myAvatar || defaultMyGroupAvatar;
                const now = Date.now();

                // 【核心修改】数据存入新表
                await db.bulletins.add({
                    chatId: chat.id,
                    authorName: myNickname,
                    description: content.trim(),
                    timestamp: now,
                    isPinned: false
                });

                const bulletinMessage = {
                    role: 'assistant',
                    type: 'bulletin',
                    content: content.trim(),
                    timestamp: now,
                    authorName: myNickname,
                    authorAvatar: myAvatar
                };
                chat.history.push(bulletinMessage);
                appendMessage(bulletinMessage, chat);

                const hiddenMessage = {
                    role: 'system',
                    content: `[系统提示：用户 (${myNickname}) 刚刚发布了一条公告：“${content.trim()}”。请你们对此发表评论。]`,
                    timestamp: now + 1,
                    isHidden: true,
                };
                chat.history.push(hiddenMessage);
                await db.chats.put(chat);
            }

            // ▲▲▲ 新功能函数粘贴结束 ▲▲▲
            // ▼▼▼ 请将这【一整块全新的函数】粘贴到下面指定的位置 ▼▼▼

            /**
             * 【可复用模块 V2】根据ChatID获取并格式化所有置顶公告 (使用结构化数据模式)
             * @param {string} chatId - 要查询的群聊ID
             * @returns {Promise<string>} - 返回格式化好的结构化字符串，或空字符串
             */
            async function getFormattedPinnedBulletins(chatId) {
                // 1. 从数据库查询，只找 isPinned: true 的
                // 【核心修正】先查出所有公告，再用代码过滤置顶项，确保查询稳定可靠
                const allBulletins = await db.memories.where({ chatId: chatId, type: 'bulletin' }).toArray();
                const pinnedBulletins = allBulletins.filter(b => b.isPinned);

                // 2. 如果没有置顶公告，直接返回空字符串
                if (pinnedBulletins.length === 0) {
                    return '';
                }

                // 3. 按时间顺序排序
                pinnedBulletins.sort((a, b) => a.timestamp - b.timestamp);

                // 4. 【核心修改】格式化每一条公告为YAML-like格式
                const bulletinsContext = pinnedBulletins.map(b => {
                    const author = b.authorName;
                    const time = new Date(b.timestamp).toLocaleString('zh-CN', { dateStyle: 'long', timeStyle: 'short' });

                    // 【关键】为了保持YAML格式的正确缩进，我们需要手动为每一行内容添加前导空格
                    // content: | 的下一行内容，需要比 content: 多两个空格
                    const indentedContent = b.description.split('\n').map(line => `      ${line}`).join('\n'); // 6个前导空格

                    // 返回拼接好的结构化数据字符串
                    return `
  - bulletin:
      author: ${author}
      timestamp: ${time}
      content: |
${indentedContent}`;
                }).join(''); // 【注意】这里不再用'\n'连接，因为每个块自带换行

                // 5. 组装成最终的、带有新标题的模块并返回
                return `
# 当前的群公告 
${bulletinsContext}
`;
            }

            // ▲▲▲ 新函数粘贴结束 ▲▲▲


            // ===================================================================
            // 4. 初始化函数 init()
            // ===================================================================
            async function init() {

                // ▼▼▼ 新增代码 ▼▼▼
                const customBubbleStyleTag = document.createElement('style');
                customBubbleStyleTag.id = 'custom-bubble-style';
                document.head.appendChild(customBubbleStyleTag);
                // ▲▲▲ 新增结束 ▲▲▲

                // ▼▼▼ 新增代码 ▼▼▼
                const previewBubbleStyleTag = document.createElement('style');
                previewBubbleStyleTag.id = 'preview-bubble-style';
                document.head.appendChild(previewBubbleStyleTag);
                // ▲▲▲ 新增结束 ▲▲▲

                window.showScreen = showScreen;
                window.renderChatListProxy = renderChatList;
                window.renderApiSettingsProxy = renderApiSettings;
                window.renderWallpaperScreenProxy = renderWallpaperScreen;
                window.renderWorldBookScreenProxy = renderWorldBookScreen;
                window.renderSettingsScreenProxy = renderSettingsScreen;
                window.renderCalendarScreenProxy = renderCalendarScreen;

                await loadAllDataFromDB();

                // Restore active meetup session from localStorage if exists
                restoreActiveMeetupSession();

                // Check for active meetup session and show progress bar if needed
                if (hasActiveMeetupSession()) {
                    showMeetupProgressBar();
                }

                // 初始化未读动态计数
                const storedCount = parseInt(localStorage.getItem('unreadPostsCount')) || 0;
                updateUnreadIndicator(storedCount);

                // ▲▲▲ 代码添加结束 ▲▲▲

                if (state.globalSettings && state.globalSettings.fontUrl) {
                    applyCustomFont(state.globalSettings.fontUrl);
                }

                updateClock();
                setInterval(updateClock, 1000 * 30);
                applyGlobalWallpaper();
                applyAppIconsToHomeScreen();
                initBatteryManager();

                // Initialize Spotify if token exists
                if (getSpotifyTokenFromUrl()) {
                    initSpotifyPlayer();
                } else {
                    // Try to load saved Spotify token
                    loadSavedSpotifyToken();
                }

                // Handle custom URL scheme for Spotify callback
                window.handleOpenURL = function (url) {
                    handleSpotifyCallback(url);
                };

                // ==========================================================
                // --- 各种事件监听器 ---
                // ==========================================================
                // ▼▼▼ 【全新】公告板功能事件绑定 ▼▼▼
                document.getElementById('open-bulletin-board-btn').addEventListener('click', openBulletinBoard);
                document.getElementById('close-bulletin-board-btn').addEventListener('click', () => {
                    document.getElementById('bulletin-board-modal').classList.remove('visible');
                });

                // 使用事件委托处理公告列表中的点击事件
                document.getElementById('bulletin-list').addEventListener('click', (e) => {
                    const actionsBtn = e.target.closest('.bulletin-actions-btn');
                    if (actionsBtn) {
                        showBulletinActions(parseInt(actionsBtn.dataset.id));
                    }
                });

                // 公告操作菜单的按钮事件
                document.getElementById('pin-bulletin-btn').addEventListener('click', handlePinBulletin);
                document.getElementById('delete-bulletin-btn').addEventListener('click', handleDeleteBulletin);
                document.getElementById('cancel-bulletin-action-btn').addEventListener('click', hideBulletinActions);

                // 将长按菜单中的“发布公告”与新功能连接
                document.getElementById('post-bulletin-btn').addEventListener('click', () => {
                    if (activeMessageTimestamp) {
                        handleUserCreateBulletin(activeMessageTimestamp);
                    }
                    hideMessageActions(); // 操作后关闭菜单
                });

                // ▲▲▲ 新事件绑定结束 ▲▲▲

                // ▼▼▼ Share Link Event Listeners ▼▼▼
                document.getElementById('share-link-btn').addEventListener('click', openShareLinkModal);
                document.getElementById('cancel-share-link-btn').addEventListener('click', () => {
                    document.getElementById('share-link-modal').classList.remove('visible');
                });
                document.getElementById('confirm-share-link-btn').addEventListener('click', sendUserLinkShare);
                document.getElementById('browser-back-btn').addEventListener('click', closeBrowser);
                // ▲▲▲ Share Link Event Listeners End ▲▲▲

                // ▼▼▼ Location Share Event Listeners ▼▼▼
                document.getElementById('share-location-btn').addEventListener('click', openLocationShareModal);
                document.getElementById('cancel-location-btn').addEventListener('click', () => {
                    // Clear edit state and reset UI
                    window.editingLocationTimestamp = null;

                    // Reset modal title and button text
                    document.querySelector('#location-share-modal .modal-header span').textContent = '分享位置';
                    document.getElementById('confirm-location-btn').textContent = '发送位置';

                    document.getElementById('location-share-modal').classList.remove('visible');
                });
                document.getElementById('confirm-location-btn').addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    sendUserLocationShare();
                });
                // ▲▲▲ Location Share Event Listeners End ▲▲▲

                // ▼▼▼ Meetup Creation Modal Event Listeners ▼▼▼
                document.getElementById('meetup-btn').addEventListener('click', openMeetupCreationModal);
                document.getElementById('cancel-meetup-btn').addEventListener('click', closeMeetupCreationModal);
                document.getElementById('start-meetup-btn').addEventListener('click', startMeetup);

                // ▼▼▼ Sticker Pack Edit Modal Event Listeners ▼▼▼
                document.getElementById('cancel-sticker-pack-edit-btn').addEventListener('click', closeStickerPackEditModal);
                document.getElementById('save-sticker-pack-btn').addEventListener('click', saveStickerPackEdit);
                document.getElementById('delete-sticker-pack-btn').addEventListener('click', deleteStickerPack);

                // Add keyboard support for sticker pack edit modal
                document.getElementById('sticker-pack-edit-modal').addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        closeStickerPackEditModal();
                    } else if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                        saveStickerPackEdit();
                    }
                });

                // ▼▼▼ New Sticker Pack Modal Event Listeners ▼▼▼
                document.getElementById('add-pack-btn').addEventListener('click', openNewStickerPackModal);
                document.getElementById('cancel-new-pack-btn').addEventListener('click', closeNewStickerPackModal);
                document.getElementById('create-new-pack-btn').addEventListener('click', createNewStickerPack);

                // Add keyboard support for new sticker pack modal
                document.getElementById('new-sticker-pack-modal').addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        closeNewStickerPackModal();
                    } else if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                        createNewStickerPack();
                    }
                });

                // Add keyboard support for date creation modal
                document.getElementById('meetup-creation-modal').addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        closeMeetupCreationModal();
                    } else if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                        startMeetup();
                    }
                });

                // Add Enter key support for input fields
                document.getElementById('meetup-location-input').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        document.getElementById('meetup-title-input').focus();
                    }
                });

                document.getElementById('meetup-title-input').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        startMeetup();
                    }
                });
                // ▲▲▲ Date Creation Modal Event Listeners End ▲▲▲

                // ▼▼▼ Meetup Edit Button Event Listener ▼▼▼
                const meetupEditBtn = document.getElementById('meetup-edit-btn');
                if (meetupEditBtn) {
                    meetupEditBtn.addEventListener('click', openMeetupEditModal);
                }

                // ▼▼▼ Date End Modal Event Listeners ▼▼▼
                const endDateBtn = document.getElementById('end-date-btn');
                if (endDateBtn) {
                    endDateBtn.addEventListener('click', showMeetupEndModal);
                }

                const cancelEndDateBtn = document.getElementById('cancel-end-date-btn');
                if (cancelEndDateBtn) {
                    cancelEndDateBtn.addEventListener('click', hideMeetupEndModal);
                }

                const confirmEndDateBtn = document.getElementById('confirm-end-date-btn');
                if (confirmEndDateBtn) {
                    confirmEndDateBtn.addEventListener('click', confirmEndMeetup);
                }
                // ▲▲▲ Meetup End Modal Event Listeners End ▲▲▲

                document.getElementById('custom-modal-cancel').addEventListener('click', hideCustomModal);
                document.getElementById('custom-modal-overlay').addEventListener('click', (e) => { if (e.target === modalOverlay) hideCustomModal(); });
                document.getElementById('export-data-btn').addEventListener('click', window.exportWithPermissionCheck);
                document.getElementById('import-btn').addEventListener('click', () => document.getElementById('import-data-input').click());
                document.getElementById('import-data-input').addEventListener('change', e => importBackup(e.target.files[0]));


                document.getElementById('back-to-list-btn').addEventListener('click', () => {
                    // ▼▼▼ 修改这两行 ▼▼▼
                    applyScopedCss('', '#chat-messages', 'custom-bubble-style'); // 清除真实聊天界面的自定义样式
                    applyScopedCss('', '#settings-preview-area', 'preview-bubble-style'); // 清除预览区的自定义样式
                    // ▲▲▲ 修改结束 ▲▲▲
                    exitSelectionMode(); state.activeChatId = null; showScreen('chat-list-screen');
                });

                document.getElementById('add-chat-btn').addEventListener('click', async () => {
                    const name = await showCustomPrompt('创建新聊天', '请输入Ta的名字');
                    if (name && name.trim()) {
                        const newChatId = 'chat_' + Date.now();
                        const newChat = {
                            id: newChatId,
                            name: name.trim(),
                            isGroup: false,
                            relationship: {
                                status: 'friend',
                                blockedTimestamp: null,
                                applicationReason: ''
                            },
                            //【核心新增】为新角色添加状态对象
                            statusState: {
                                lastAiActivityTime: Date.now(),
                                focusModeEndTime: null,
                                focusModeText: ""
                            },
                            settings: {
                                aiPersona: '你是谁呀。',
                                myPersona: '我是谁呀。',
                                maxMemory: 10,
                                aiAvatar: defaultAvatar,
                                myAvatar: defaultAvatar,
                                background: '',
                                theme: 'default',
                                fontSize: 13,
                                customCss: '',
                                linkedWorldBookIds: [],
                                aiAvatarFrame: '',
                                myAvatarFrame: '',
                                isBackgroundActivityEnabled: true // <--【核心新增】默认开启
                            },
                            history: [],
                            musicData: { totalTime: 0 }
                        };
                        state.chats[newChatId] = newChat;
                        await db.chats.put(newChat);
                        renderChatList();
                    }
                });

                // ▼▼▼ 【修正】创建群聊按钮现在打开联系人选择器 ▼▼▼
                document.getElementById('add-group-chat-btn').addEventListener('click', openContactPickerForGroupCreate);
                // ▲▲▲ 替换结束 ▲▲▲                      
                document.getElementById('transfer-cancel-btn').addEventListener('click', () => document.getElementById('transfer-modal').classList.remove('visible'));
                document.getElementById('transfer-confirm-btn').addEventListener('click', sendUserTransfer);

                // ▼▼▼ 【全新】转账接受/拒绝事件监听器 ▼▼▼
                document.getElementById('transfer-action-accept').addEventListener('click', () => handleUserTransferResponse('accepted'));
                document.getElementById('transfer-action-decline').addEventListener('click', () => handleUserTransferResponse('declined'));
                document.getElementById('transfer-action-cancel').addEventListener('click', hideTransferActionModal);
                // ▲▲▲ 新事件监听器结束 ▲▲▲

                // ▼▼▼ 【全新】转账卡片点击事件处理 ▼▼▼
                document.getElementById('chat-messages').addEventListener('click', (e) => {
                    // Handle share link card clicks
                    const shareCard = e.target.closest('.link-share-card[data-timestamp]');
                    if (shareCard && shareCard.closest('.message-bubble.is-link-share')) {
                        const timestamp = parseInt(shareCard.dataset.timestamp);
                        openBrowser(timestamp);
                        return;
                    }

                    // 1. 向上查找被点击的元素是否在一个消息气泡内
                    const bubble = e.target.closest('.message-bubble');
                    if (!bubble) return; // 如果不在，就退出

                    // 2. 【核心修正】在这里添加严格的筛选条件
                    // 必须是 AI 的消息 (.ai)
                    // 必须是转账类型 (.is-transfer)
                    // 必须是我们标记为"待处理"的 (data-status="pending")
                    if (bubble.classList.contains('ai') &&
                        bubble.classList.contains('is-transfer') &&
                        bubble.dataset.status === 'pending') {

                        // 3. 只有满足所有条件，才执行后续逻辑
                        const timestamp = parseInt(bubble.dataset.timestamp);
                        if (!isNaN(timestamp)) {
                            showTransferActionModal(timestamp);
                        }
                    }
                });
                // ▲▲▲ 转账卡片点击处理结束 ▲▲▲

                document.getElementById('listen-together-btn').addEventListener('click', handleListenTogetherClick);

                document.getElementById('music-exit-btn').addEventListener('click', () => endListenTogetherSession(true));
                document.getElementById('music-return-btn').addEventListener('click', returnToChat);

                // Add click-outside-to-close functionality for music player overlay
                document.getElementById('music-player-overlay').addEventListener('click', (e) => {
                    // Only close if clicking on the overlay background, not the music player window
                    if (e.target.id === 'music-player-overlay') {
                        returnToChat();
                    }
                });

                document.getElementById('music-play-pause-btn').addEventListener('click', togglePlayPause);

                // Initialize now playing bar
                initializeNowPlayingBar();
                initializeHomeNowPlayingBar();

                // Initialize meetup progress bar
                initializeMeetupProgressBar();

                // Handle app visibility changes for date session persistence
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'visible') {
                        // App became visible - restore date session if needed
                        if (!hasActiveDateSession()) {
                            restoreActiveDateSession();
                        }

                        // Show progress bar if there's an active session
                        if (hasActiveMeetupSession()) {
                            showMeetupProgressBar();
                        }
                    }
                });

                // Handle page unload to ensure session state is saved
                window.addEventListener('beforeunload', () => {
                    if (hasActiveMeetupSession()) {
                        localStorage.setItem('activeMeetupSession', JSON.stringify(window.activeMeetupSession));
                        localStorage.setItem('activeMeetupEventId', window.activeMeetupEventId);
                    }
                });

                // Cordova-specific app lifecycle events
                document.addEventListener('deviceready', () => {
                    // Handle app pause (backgrounding)
                    document.addEventListener('pause', () => {
                        if (hasActiveMeetupSession()) {
                            localStorage.setItem('activeMeetupSession', JSON.stringify(window.activeMeetupSession));
                            localStorage.setItem('activeMeetupEventId', window.activeMeetupEventId);
                        }
                    });

                    // Handle app resume (foregrounding)
                    document.addEventListener('resume', () => {
                        // Restore meetup session if needed
                        if (!hasActiveMeetupSession()) {
                            restoreActiveMeetupSession();
                        }

                        // Show progress bar if there's an active session
                        if (hasActiveMeetupSession()) {
                            showMeetupProgressBar();
                        }
                    });
                });
                document.getElementById('music-next-btn').addEventListener('click', playNext);
                document.getElementById('music-prev-btn').addEventListener('click', playPrev);
                document.getElementById('music-mode-btn').addEventListener('click', changePlayMode);
                document.getElementById('music-playlist-btn').addEventListener('click', () => { updatePlaylistUI(); document.getElementById('music-playlist-panel').classList.add('visible'); });
                document.getElementById('close-playlist-btn').addEventListener('click', () => document.getElementById('music-playlist-panel').classList.remove('visible'));
                document.getElementById('add-song-url-btn').addEventListener('click', addSongFromURL);
                document.getElementById('add-song-local-btn').addEventListener('click', () => document.getElementById('local-song-upload-input').click());
                document.getElementById('add-song-spotify-btn').addEventListener('click', addSongFromSpotify);
                document.getElementById('local-song-upload-input').addEventListener('change', addSongFromLocal);
                audioPlayer.addEventListener('ended', playNext);
                audioPlayer.addEventListener('pause', () => { if (musicState.isActive) { musicState.isPlaying = false; updatePlayerUI(); } });
                audioPlayer.addEventListener('play', () => { if (musicState.isActive) { musicState.isPlaying = true; updatePlayerUI(); } });
                audioPlayer.addEventListener('timeupdate', updateNowPlayingProgress);

                const chatInput = document.getElementById('chat-input');
                document.getElementById('send-btn').addEventListener('click', async () => {
                    const content = chatInput.value.trim();
                    if (!content || !state.activeChatId) return;

                    const chat = state.chats[state.activeChatId];
                    const msg = {
                        role: 'user',
                        content,
                        timestamp: Date.now()
                    };

                    // 检查当前是否处于引用回复模式
                    if (currentReplyContext) {
                        msg.quote = currentReplyContext; // 将引用信息附加到消息对象上
                    }

                    chat.history.push(msg);
                    await db.chats.put(chat);
                    appendMessage(msg, chat);
                    renderChatList();
                    chatInput.value = '';
                    chatInput.style.height = 'auto';
                    chatInput.focus();

                    // 发送后，取消引用模式
                    cancelReplyMode();
                });
                document.getElementById('wait-reply-btn').addEventListener('click', triggerAiResponse);
                chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); document.getElementById('send-btn').click(); } });
                chatInput.addEventListener('input', () => { chatInput.style.height = 'auto'; chatInput.style.height = (chatInput.scrollHeight) + 'px'; });

                document.getElementById('wallpaper-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await processImageUpload(file); newWallpaperBase64 = dataUrl; renderWallpaperScreen(); } });
                document.getElementById('save-wallpaper-btn').addEventListener('click', async () => { if (newWallpaperBase64) { state.globalSettings.wallpaper = newWallpaperBase64; await db.globalSettings.put(state.globalSettings); applyGlobalWallpaper(); newWallpaperBase64 = null; alert('壁纸已保存并应用！'); showScreen('home-screen'); } else alert('请先上传一张新壁纸。'); });

                // Charm CSS customization functionality
                const charmCssInput = document.getElementById('custom-charm-css-input');
                const resetCharmCssBtn = document.getElementById('reset-charm-css-btn');

                // Load saved charm CSS
                const savedCharmCss = localStorage.getItem('customCharmCss');
                if (savedCharmCss) {
                    charmCssInput.value = savedCharmCss;
                    applyCharmCss(savedCharmCss);
                }



                // Apply charm CSS on input change
                charmCssInput.addEventListener('input', () => {
                    const css = charmCssInput.value;
                    applyCharmCss(css);
                    localStorage.setItem('customCharmCss', css);
                });

                // Reset charm CSS button
                resetCharmCssBtn.addEventListener('click', () => {
                    // Reset CSS input to correct default
                    charmCssInput.value = `/* 自定义挂件样式 - 完整默认设置 */
.floating-phone-charm {
  position: fixed;
  top: 48px;
  right: -112px;
  width: 220px;
  height: 220px;
  background-image: url('https://files.catbox.moe/rhrobi.gif');
  background-size: contain;
  background-repeat: no-repeat;
  z-index: 1000;
  pointer-events: auto;
  cursor: grab;
  transition: transform 0.2s ease;
  user-select: none;
}`;

                    // Clear localStorage
                    localStorage.removeItem('customCharmCss');
                    localStorage.removeItem('phoneCharmPosition');

                    // Reset charm position
                    const charm = document.getElementById('floating-phone-charm');
                    if (charm) {
                        // Reset position
                        charm.style.top = '48px';
                        charm.style.right = '-112px';
                        charm.style.left = 'auto';
                        charm.style.bottom = 'auto';

                        // Update the charm instance's original position
                        if (window.floatingCharmInstance) {
                            window.floatingCharmInstance.storeOriginalPosition();
                        }
                    }

                    // Apply default CSS
                    applyCharmCss(charmCssInput.value);
                    alert('挂件样式已重置到默认状态！');
                });

                // Function to apply custom CSS to charm
                function applyCharmCss(css) {
                    let styleElement = document.getElementById('custom-charm-style');
                    if (!styleElement) {
                        styleElement = document.createElement('style');
                        styleElement.id = 'custom-charm-style';
                        document.head.appendChild(styleElement);
                    }
                    styleElement.textContent = css;
                }



                document.getElementById('save-api-settings-btn').addEventListener('click', async () => {
                    // ▼▼▼ 新增校验逻辑 ▼▼▼
                    const proxyUrlToCheck = document.getElementById('proxy-url').value.trim();
                    if (isApiUrlBanned(proxyUrlToCheck)) {
                        alert('此API地址无效或不受支持，请更换。');
                        return; // 命中黑名单，中断保存
                    }
                    // ▲▲▲ 校验逻辑结束 ▲▲▲

                    state.apiConfig.proxyUrl = proxyUrlToCheck;
                    state.apiConfig.apiKey = document.getElementById('api-key').value.trim();
                    state.apiConfig.model = document.getElementById('model-select').value;
                    await db.apiConfig.put(state.apiConfig);

                    // 在 'save-api-settings-btn' 的 click 事件监听器内部
                    // await db.apiConfig.put(state.apiConfig); 这行之后

                    // ▼▼▼ 将之前那段保存后台活动设置的逻辑，替换为下面这个增强版 ▼▼▼

                    const backgroundSwitch = document.getElementById('background-activity-switch');
                    const intervalInput = document.getElementById('background-interval-input');
                    const newEnableState = backgroundSwitch.checked;
                    const oldEnableState = state.globalSettings.enableBackgroundActivity || false;

                    // 只有在用户“从关到开”时，才弹出警告
                    if (newEnableState && !oldEnableState) {
                        const userConfirmed = confirm(
                            "【高费用警告】\n\n" +
                            "您正在启用“后台角色活动”功能。\n\n" +
                            "这会使您的AI角色们在您不和他们聊天时，也能“独立思考”并主动给您发消息或进行社交互动，极大地增强沉浸感。\n\n" +
                            "但请注意：\n" +
                            "这会【在后台自动、定期地调用API】，即使您不进行任何操作。根据您的角色数量和检测间隔，这可能会导致您的API费用显著增加。\n\n" +
                            "您确定要开启吗？"
                        );

                        if (!userConfirmed) {
                            backgroundSwitch.checked = false; // 用户取消，把开关拨回去
                            return; // 阻止后续逻辑
                        }
                    }

                    state.globalSettings.enableBackgroundActivity = newEnableState;
                    state.globalSettings.backgroundActivityInterval = parseInt(intervalInput.value) || 60;
                    state.globalSettings.blockCooldownHours = parseFloat(document.getElementById('block-cooldown-input').value) || 1;
                    state.globalSettings.aiActionCooldownMinutes = parseInt(document.getElementById('ai-cooldown-input').value) || 0;
                    await db.globalSettings.put(state.globalSettings);

                    // 动态启动或停止模拟器
                    stopBackgroundSimulation();
                    if (state.globalSettings.enableBackgroundActivity) {
                        startBackgroundSimulation();
                        console.log(`后台活动模拟已启动，间隔: ${state.globalSettings.backgroundActivityInterval}秒`);
                    } else {
                        console.log("后台活动模拟已停止。");
                    }
                    // ▲▲▲ 替换结束 ▲▲▲

                    alert('API设置已保存!');
                });
                document.getElementById('fetch-models-btn').addEventListener('click', async () => {
                    const url = document.getElementById('proxy-url').value.trim();
                    const key = document.getElementById('api-key').value.trim();

                    // ▼▼▼ 新增校验逻辑 ▼▼▼
                    if (isApiUrlBanned(url)) {
                        alert('此API地址无效或不受支持，请更换。');
                        return; // 命中黑名单，中断拉取
                    }
                    // ▲▲▲ 校验逻辑结束 ▲▲▲

                    if (!url || !key) return alert('请先填写反代地址和密钥');
                    try {
                        let response, data;
                        const modelSelect = document.getElementById('model-select');
                        modelSelect.innerHTML = '';

                        if (isGoogleGeminiAPI(url)) {
                            // Google Gemini API format
                            response = await fetch(`${url}/v1beta/models?key=${key}`);
                            if (!response.ok) throw new Error('无法获取Google模型列表');
                            data = await response.json();
                            // Google returns models in different format
                            data.models.forEach(model => {
                                const option = document.createElement('option');
                                option.value = model.name.replace('models/', '');
                                option.textContent = model.displayName || model.name.replace('models/', '');
                                if (option.value === state.apiConfig.model) option.selected = true;
                                modelSelect.appendChild(option);
                            });
                        } else {
                            // OpenAI-compatible API format (existing)
                            response = await fetch(`${url}/v1/models`, { headers: { 'Authorization': `Bearer ${key}` } });
                            if (!response.ok) throw new Error('无法获取模型列表');
                            data = await response.json();
                            data.data.forEach(model => {
                                const option = document.createElement('option');
                                option.value = model.id;
                                option.textContent = model.id;
                                if (model.id === state.apiConfig.model) option.selected = true;
                                modelSelect.appendChild(option);
                            });
                        }
                        alert('模型列表已更新');
                    } catch (error) {
                        alert(`拉取模型失败: ${error.message}`);
                    }
                });

                document.getElementById('add-world-book-btn').addEventListener('click', async () => { const name = await showCustomPrompt('创建世界书', '请输入书名'); if (name && name.trim()) { const newBook = { id: 'wb_' + Date.now(), name: name.trim(), content: '' }; await db.worldBooks.add(newBook); state.worldBooks.push(newBook); renderWorldBookScreen(); openWorldBookEditor(newBook.id); } });
                document.getElementById('save-world-book-btn').addEventListener('click', async () => { if (!editingWorldBookId) return; const book = state.worldBooks.find(wb => wb.id === editingWorldBookId); if (book) { const newName = document.getElementById('world-book-name-input').value.trim(); if (!newName) { alert('书名不能为空！'); return; } book.name = newName; book.content = document.getElementById('world-book-content-input').value; await db.worldBooks.put(book); document.getElementById('world-book-editor-title').textContent = newName; editingWorldBookId = null; renderWorldBookScreen(); showScreen('world-book-screen'); } });

                document.getElementById('chat-messages').addEventListener('click', (e) => {
                    // 处理已撤回消息的点击
                    const placeholder = e.target.closest('.recalled-message-placeholder');
                    if (placeholder) {
                        const wrapper = placeholder.closest('.message-wrapper');
                        if (wrapper) {
                            const timestamp = parseInt(wrapper.dataset.timestamp);
                            const chat = state.chats[state.activeChatId];
                            const recalledMsg = chat.history.find(m => m.timestamp === timestamp);

                            if (recalledMsg && recalledMsg.recalledData) {
                                let originalContentText = '';
                                const recalled = recalledMsg.recalledData;

                                if (recalled.originalType === 'text') {
                                    originalContentText = `原文: "${recalled.originalContent}"`;
                                } else {
                                    originalContentText = `撤回了一条[${recalled.originalType}]类型的消息`;
                                }
                                showCustomAlert('已撤回的消息', originalContentText);
                            }
                        }
                        return;
                    }

                    // 处理图片弹窗（逻辑保留）
                    const aiImage = e.target.closest('.ai-generated-image');
                    if (aiImage) {
                        const description = aiImage.dataset.description;
                        if (description) showCustomAlert('照片描述', description);
                        return;
                    }

                    // 【全新】处理语音点击展开/收起
                    const voiceBody = e.target.closest('.voice-message-body');
                    if (voiceBody) {
                        const bubble = voiceBody.closest('.message-bubble');
                        if (!bubble) return;

                        const transcript = bubble.querySelector('.voice-transcript');
                        const waveform = bubble.querySelector('.voice-waveform');

                        if (transcript && waveform) {
                            const isVisible = transcript.style.display === 'block';

                            if (isVisible) {
                                // --- 如果当前是展开的，现在要收起 ---
                                transcript.style.display = 'none';
                                // 恢复成最初始的5个波浪
                                waveform.innerHTML = '<div></div><div></div><div></div><div></div><div></div>';
                            } else {
                                // --- 如果当前是收起的，现在要展开 ---
                                transcript.style.display = 'block';

                                // 1. 获取语音时长
                                const duration = Math.max(1, Math.round((transcript.textContent || '').length / 5));

                                // 2. 根据新规则计算需要的波浪总数
                                let waveBars;
                                if (duration === 1) {
                                    waveBars = 5;  // 1s = 1组 = 5个
                                } else if (duration === 2) {
                                    waveBars = 15; // 2s = 3组 = 15个
                                } else {
                                    waveBars = 20; // 3s及以上 = 4组 = 20个
                                }

                                // 3. 动态生成波浪并修复动画延迟
                                waveform.innerHTML = ''; // 清空旧的波浪
                                for (let i = 0; i < waveBars; i++) {
                                    const waveDiv = document.createElement('div');
                                    // 【核心】为每一个波浪设置递增的、独一无二的动画延迟
                                    waveDiv.style.animationDelay = `${i * 0.2}s`;
                                    waveform.appendChild(waveDiv);
                                }
                            }
                        }
                        return; // 处理完语音点击后，直接返回

                    }
                });
                //【粘贴到这里结束】

                const chatSettingsModal = document.getElementById('chat-settings-modal');
                const worldBookSelectBox = document.querySelector('.custom-multiselect .select-box');
                const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');
                function updateWorldBookSelectionDisplay() { const checkedBoxes = worldBookCheckboxesContainer.querySelectorAll('input:checked'); const displayText = document.querySelector('.selected-options-text'); if (checkedBoxes.length === 0) { displayText.textContent = '-- 点击选择 --'; } else if (checkedBoxes.length > 2) { displayText.textContent = `已选择 ${checkedBoxes.length} 项`; } else { displayText.textContent = Array.from(checkedBoxes).map(cb => cb.parentElement.textContent.trim()).join(', '); } }

                worldBookSelectBox.addEventListener('click', (e) => { e.stopPropagation(); worldBookCheckboxesContainer.classList.toggle('visible'); worldBookSelectBox.classList.toggle('expanded'); });
                document.getElementById('world-book-checkboxes-container').addEventListener('change', updateWorldBookSelectionDisplay);
                window.addEventListener('click', (e) => { if (!document.querySelector('.custom-multiselect').contains(e.target)) { worldBookCheckboxesContainer.classList.remove('visible'); worldBookSelectBox.classList.remove('expanded'); } });

                // ▼▼▼ 请用这段【完整、全新的代码】替换旧的 chat-settings-btn 点击事件 ▼▼▼
                document.getElementById('chat-settings-btn').addEventListener('click', async () => {
                    if (!state.activeChatId) return;
                    const chat = state.chats[state.activeChatId];
                    const isGroup = chat.isGroup;

                    // --- 统一显示/隐藏控件 ---
                    document.getElementById('chat-name-group').style.display = 'block';
                    document.getElementById('my-persona-group').style.display = 'block';
                    document.getElementById('my-avatar-group').style.display = 'block';
                    document.getElementById('my-group-nickname-group').style.display = isGroup ? 'block' : 'none';
                    document.getElementById('group-avatar-group').style.display = isGroup ? 'block' : 'none';
                    document.getElementById('group-members-group').style.display = isGroup ? 'block' : 'none';
                    document.getElementById('ai-persona-group').style.display = isGroup ? 'none' : 'block';
                    document.getElementById('ai-avatar-group').style.display = isGroup ? 'none' : 'block';

                    // 【核心修改1】根据是否为群聊，显示或隐藏“好友分组”区域
                    document.getElementById('assign-group-section').style.display = isGroup ? 'none' : 'block';

                    // --- 加载表单数据 ---
                    document.getElementById('chat-name-input').value = chat.name;
                    document.getElementById('my-persona').value = chat.settings.myPersona;
                    document.getElementById('my-avatar-preview').src = chat.settings.myAvatar || (isGroup ? defaultMyGroupAvatar : defaultAvatar);
                    document.getElementById('max-memory').value = chat.settings.maxMemory;
                    // ▼▼▼ 【核心新增】读取开关状态 ▼▼▼
                    document.getElementById('background-activity-switch-chat').checked = chat.settings.isBackgroundActivityEnabled ?? true;

                    const bgPreview = document.getElementById('bg-preview');
                    const removeBgBtn = document.getElementById('remove-bg-btn');
                    if (chat.settings.background) {
                        bgPreview.src = chat.settings.background;
                        bgPreview.style.display = 'block';
                        removeBgBtn.style.display = 'inline-block';
                    } else {
                        bgPreview.style.display = 'none';
                        removeBgBtn.style.display = 'none';
                    }

                    if (isGroup) {
                        document.getElementById('my-group-nickname-input').value = chat.settings.myNickname || '';
                        document.getElementById('group-avatar-preview').src = chat.settings.groupAvatar || defaultGroupAvatar;
                        renderGroupMemberSettings(chat.members);
                    } else {
                        document.getElementById('ai-persona').value = chat.settings.aiPersona;
                        document.getElementById('ai-avatar-preview').src = chat.settings.aiAvatar || defaultAvatar;

                        // 【核心修改2】如果是单聊，就加载分组列表到下拉框
                        const select = document.getElementById('assign-group-select');
                        select.innerHTML = '<option value="">未分组</option>'; // 清空并设置默认选项
                        const groups = await db.qzoneGroups.toArray();
                        groups.forEach(group => {
                            const option = document.createElement('option');
                            option.value = group.id;
                            option.textContent = group.name;
                            // 如果当前好友已经有分组，就默认选中它
                            if (chat.groupId === group.id) {
                                option.selected = true;
                            }
                            select.appendChild(option);
                        });
                    }

                    // 加载世界书
                    const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');
                    worldBookCheckboxesContainer.innerHTML = '';
                    const linkedIds = chat.settings.linkedWorldBookIds || [];
                    if (state.worldBooks.length > 0) {
                        state.worldBooks.forEach(book => {
                            const isChecked = linkedIds.includes(book.id);
                            const label = document.createElement('label');
                            label.innerHTML = `<input type="checkbox" value="${book.id}" ${isChecked ? 'checked' : ''}> ${book.name}`;
                            worldBookCheckboxesContainer.appendChild(label);
                        });
                    }
                    updateWorldBookSelectionDisplay();

                    // 加载并更新所有预览相关控件
                    const themeRadio = document.querySelector(`input[name="theme-select"][value="${chat.settings.theme || 'default'}"]`);
                    if (themeRadio) themeRadio.checked = true;
                    const fontSizeSlider = document.getElementById('font-size-slider');
                    fontSizeSlider.value = chat.settings.fontSize || 13;
                    document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
                    const customCssInput = document.getElementById('custom-css-input');
                    customCssInput.value = chat.settings.customCss || '';

                    updateSettingsPreview();
                    document.getElementById('chat-settings-modal').classList.add('visible');
                });
                // ▲▲▲ 替换结束 ▲▲▲

                function renderGroupMemberSettings(members) { const container = document.getElementById('group-members-settings'); container.innerHTML = ''; members.forEach(member => { const div = document.createElement('div'); div.className = 'member-editor'; div.dataset.memberId = member.id; div.innerHTML = `<img src="${member.avatar}" alt="${member.name}"><div class="member-name">${member.name}</div>`; div.addEventListener('click', () => openMemberEditor(member.id)); container.appendChild(div); }); }
                function openMemberEditor(memberId) { editingMemberId = memberId; const chat = state.chats[state.activeChatId]; const member = chat.members.find(m => m.id === memberId); document.getElementById('member-name-input').value = member.name; document.getElementById('member-persona-input').value = member.persona; document.getElementById('member-avatar-preview').src = member.avatar; document.getElementById('member-settings-modal').classList.add('visible'); }

                document.getElementById('cancel-member-settings-btn').addEventListener('click', () => { document.getElementById('member-settings-modal').classList.remove('visible'); editingMemberId = null; });
                document.getElementById('save-member-settings-btn').addEventListener('click', () => { if (!editingMemberId) return; const chat = state.chats[state.activeChatId]; const member = chat.members.find(m => m.id === editingMemberId); member.name = document.getElementById('member-name-input').value; member.persona = document.getElementById('member-persona-input').value; member.avatar = document.getElementById('member-avatar-preview').src; renderGroupMemberSettings(chat.members); document.getElementById('member-settings-modal').classList.remove('visible'); });
                document.getElementById('reset-theme-btn').addEventListener('click', () => { document.getElementById('theme-default').checked = true; });
                document.getElementById('cancel-chat-settings-btn').addEventListener('click', () => { chatSettingsModal.classList.remove('visible'); });

                document.getElementById('save-chat-settings-btn').addEventListener('click', async () => {
                    if (!state.activeChatId) return;
                    const chat = state.chats[state.activeChatId];
                    const newName = document.getElementById('chat-name-input').value.trim();
                    if (!newName) return alert('备注名/群名不能为空！');
                    chat.name = newName;
                    const selectedThemeRadio = document.querySelector('input[name="theme-select"]:checked');
                    chat.settings.theme = selectedThemeRadio ? selectedThemeRadio.value : 'default';

                    chat.settings.fontSize = parseInt(document.getElementById('font-size-slider').value);
                    chat.settings.customCss = document.getElementById('custom-css-input').value.trim();

                    chat.settings.myPersona = document.getElementById('my-persona').value;
                    chat.settings.myAvatar = document.getElementById('my-avatar-preview').src;
                    const checkedBooks = document.querySelectorAll('#world-book-checkboxes-container input[type="checkbox"]:checked');
                    chat.settings.linkedWorldBookIds = Array.from(checkedBooks).map(cb => cb.value);
                    chat.settings.isBackgroundActivityEnabled = document.getElementById('background-activity-switch-chat').checked;

                    if (chat.isGroup) {
                        chat.settings.myNickname = document.getElementById('my-group-nickname-input').value.trim();
                        chat.settings.groupAvatar = document.getElementById('group-avatar-preview').src;
                    } else {
                        chat.settings.aiPersona = document.getElementById('ai-persona').value;
                        chat.settings.aiAvatar = document.getElementById('ai-avatar-preview').src;
                        const selectedGroupId = document.getElementById('assign-group-select').value;
                        chat.groupId = selectedGroupId ? parseInt(selectedGroupId) : null;
                    }

                    chat.settings.maxMemory = parseInt(document.getElementById('max-memory').value) || 10;
                    await db.chats.put(chat);

                    applyScopedCss(chat.settings.customCss, '#chat-messages', 'custom-bubble-style');

                    chatSettingsModal.classList.remove('visible');
                    renderChatInterface(state.activeChatId);
                    renderChatList();
                });
                document.getElementById('clear-chat-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const confirmed = await showCustomConfirm('清空聊天记录', '此操作将永久删除此聊天的所有消息，无法恢复。确定要清空吗？', { confirmButtonClass: 'btn-danger' }); if (confirmed) { chat.history = []; await db.chats.put(chat); renderChatInterface(state.activeChatId); renderChatList(); chatSettingsModal.classList.remove('visible'); } });

                const setupFileUpload = (inputId, callback) => { document.getElementById(inputId).addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); callback(dataUrl); event.target.value = null; } }); };
                setupFileUpload('ai-avatar-input', (base64) => document.getElementById('ai-avatar-preview').src = base64);
                setupFileUpload('my-avatar-input', (base64) => document.getElementById('my-avatar-preview').src = base64);
                setupFileUpload('group-avatar-input', (base64) => document.getElementById('group-avatar-preview').src = base64);
                setupFileUpload('member-avatar-input', (base64) => document.getElementById('member-avatar-preview').src = base64);
                setupFileUpload('bg-input', (base64) => { if (state.activeChatId) { state.chats[state.activeChatId].settings.background = base64; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = base64; bgPreview.style.display = 'block'; document.getElementById('remove-bg-btn').style.display = 'inline-block'; } });
                setupFileUpload('preset-avatar-input', (base64) => document.getElementById('preset-avatar-preview').src = base64);
                document.getElementById('remove-bg-btn').addEventListener('click', () => { if (state.activeChatId) { state.chats[state.activeChatId].settings.background = ''; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = ''; bgPreview.style.display = 'none'; document.getElementById('remove-bg-btn').style.display = 'none'; } });

                const stickerPanel = document.getElementById('sticker-panel');
                document.getElementById('open-sticker-panel-btn').addEventListener('click', () => { 
                    // Set current pack to first pack in saved order
                    const savedOrder = state.globalSettings?.stickerPackOrder || Object.keys(stickerPackData);
                    if (savedOrder.length > 0) {
                        currentStickerPack = savedOrder[0];
                    }
                    renderStickerPanel(); 
                    stickerPanel.classList.add('visible'); 
                    initializeStickerPackTabs(); 
                });
                // Close button handler is managed dynamically in arrange mode
                document.getElementById('close-sticker-panel-btn').onclick = () => stickerPanel.classList.remove('visible');
                // Set initial edit button handler
                document.getElementById('edit-sticker-pack-btn').onclick = openStickerPackEditModal;
                // No additional event listeners needed - handled in the add square click handler
                document.getElementById('sticker-upload-input').addEventListener('change', async (event) => {
                    const file = event.target.files[0]; if (!file) return; const base64Url = await processImageUpload(file); const name = await showCustomPrompt("命名表情", "请为这个表情命名 (例如：好耶、疑惑)"); if (name && name.trim()) {
                        const newSticker = {
                            id: 'sticker_' + Date.now(),
                            url: base64Url,
                            name: name.trim(),
                            order: state.userStickers.length,
                            packId: currentStickerPack
                        }; await db.userStickers.add(newSticker); state.userStickers.push(newSticker); document.getElementById('sticker-panel').classList.add('visible'); renderStickerPanel();
                    } else if (name !== null) alert("表情名不能为空！"); event.target.value = null;
                });

                document.getElementById('upload-image-btn').addEventListener('click', () => document.getElementById('image-upload-input').click());
                document.getElementById('image-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (!file || !state.activeChatId) return; const base64Url = await processImageUpload(file); const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content: [{ type: 'image_url', image_url: { url: base64Url } }], timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); event.target.value = null; });
                document.getElementById('voice-message-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const text = await showCustomPrompt("发送语音", "请输入你想说的内容："); if (text && text.trim()) { const chat = state.chats[state.activeChatId]; const msg = { role: 'user', type: 'voice_message', content: text.trim(), timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); } });
                document.getElementById('send-photo-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const description = await showCustomPrompt("发送照片", "请用文字描述您要发送的照片："); if (description && description.trim()) { const chat = state.chats[state.activeChatId]; const msg = { role: 'user', type: 'user_photo', content: description.trim(), timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); } });

                // ▼▼▼ 【全新】外卖请求功能事件绑定 ▼▼▼
                const waimaiModal = document.getElementById('waimai-request-modal');
                document.getElementById('send-waimai-request-btn').addEventListener('click', () => {
                    waimaiModal.classList.add('visible');
                });

                document.getElementById('waimai-cancel-btn').addEventListener('click', () => {
                    waimaiModal.classList.remove('visible');
                });

                document.getElementById('waimai-confirm-btn').addEventListener('click', async () => {
                    if (!state.activeChatId) return;

                    const productInfoInput = document.getElementById('waimai-product-info');
                    const amountInput = document.getElementById('waimai-amount');

                    const productInfo = productInfoInput.value.trim();
                    const amount = parseFloat(amountInput.value);

                    if (!productInfo) {
                        alert('请输入商品信息！');
                        return;
                    }
                    if (isNaN(amount) || amount <= 0) {
                        alert('请输入有效的代付金额！');
                        return;
                    }

                    const chat = state.chats[state.activeChatId];
                    const now = Date.now();

                    // 【核心修正】在这里获取用户自己的昵称
                    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';

                    const msg = {
                        role: 'user',
                        // 【核心修正】将获取到的昵称，作为 senderName 添加到消息对象中
                        senderName: myNickname,
                        type: 'waimai_request',
                        productInfo: productInfo,
                        amount: amount,
                        status: 'pending',
                        countdownEndTime: now + 15 * 60 * 1000,
                        timestamp: now
                    };

                    chat.history.push(msg);
                    await db.chats.put(chat);
                    appendMessage(msg, chat);
                    renderChatList();

                    productInfoInput.value = '';
                    amountInput.value = '';
                    waimaiModal.classList.remove('visible');
                });
                document.getElementById('open-persona-library-btn').addEventListener('click', openPersonaLibrary);
                document.getElementById('close-persona-library-btn').addEventListener('click', closePersonaLibrary);
                document.getElementById('add-persona-preset-btn').addEventListener('click', openPersonaEditorForCreate);
                document.getElementById('cancel-persona-editor-btn').addEventListener('click', closePersonaEditor);
                document.getElementById('save-persona-preset-btn').addEventListener('click', savePersonaPreset);
                document.getElementById('preset-action-edit').addEventListener('click', () => {
                    if (editingMemoryId) {
                        editMemory();
                    } else {
                        openPersonaEditorForEdit();
                    }
                });
                document.getElementById('preset-action-delete').addEventListener('click', () => {
                    if (editingMemoryId) {
                        deleteMemory();
                    } else {
                        deletePersonaPreset();
                    }
                });
                document.getElementById('preset-action-cancel').addEventListener('click', () => {
                    if (editingMemoryId) {
                        hideMemoryActions();
                    } else {
                        hidePresetActions();
                    }
                });

                document.getElementById('selection-cancel-btn').addEventListener('click', exitSelectionMode);

                // ▼▼▼ 【最终加强版】用这块代码替换旧的 selection-delete-btn 事件监听器 ▼▼▼
                document.getElementById('selection-delete-btn').addEventListener('click', async () => {
                    if (selectedMessages.size === 0) return;
                    const confirmed = await showCustomConfirm('删除消息', `确定要删除选中的 ${selectedMessages.size} 条消息吗？这将改变AI的记忆。`, { confirmButtonClass: 'btn-danger' });
                    if (confirmed) {
                        const chat = state.chats[state.activeChatId];

                        // 1. 【核心加强】在删除前，检查被删除的消息中是否包含投票
                        let deletedPollsInfo = [];
                        for (const timestamp of selectedMessages) {
                            const msg = chat.history.find(m => m.timestamp === timestamp);
                            if (msg && msg.type === 'poll') {
                                deletedPollsInfo.push(`关于“${msg.question}”的投票(时间戳: ${msg.timestamp})`);
                            }
                        }

                        // 2. 更新后端的历史记录
                        chat.history = chat.history.filter(msg => !selectedMessages.has(msg.timestamp));

                        // 3. 【核心加强】构建更具体的“遗忘指令”
                        let forgetReason = "一些之前的消息已被用户删除。";
                        if (deletedPollsInfo.length > 0) {
                            forgetReason += ` 其中包括以下投票：${deletedPollsInfo.join('；')}。`;
                        }
                        forgetReason += " 你应该像它们从未存在过一样继续对话，并相应地调整你的记忆和行为，不要再提及这些被删除的内容。";



                        // 4. 将包含“遗忘指令”的、更新后的chat对象存回数据库
                        await db.chats.put(chat);

                        // 5. 最后才更新UI
                        renderChatInterface(state.activeChatId);
                        renderChatList();
                    }
                });
                // ▲▲▲ 替换结束 ▲▲▲

                // 为聊天设置里的“更换头像框”按钮添加点击事件
                document.getElementById('chat-settings-modal').addEventListener('click', (e) => {
                    if (e.target.classList.contains('change-frame-btn')) {
                        // 'chat' 这个参数是告诉函数，这次是为“我/对方”这对组合更换头像框
                        openFrameSelectorModal('chat');
                    }
                });

                // 为成员设置里的“更换头像框”按钮添加点击事件
                document.getElementById('member-settings-modal').addEventListener('click', (e) => {
                    // 【修正】将 .contents 修改为 .contains
                    if (e.target.classList.contains('change-frame-btn')) {
                        // 'member' 这个参数是告诉函数，这次是为单个群成员更换头像框
                        openFrameSelectorModal('member');
                    }
                });

                // ▲▲▲ 粘贴结束 ▲▲▲

                const fontUrlInput = document.getElementById('font-url-input');
                fontUrlInput.addEventListener('input', () => {
                    // Clear uploaded font when typing URL
                    if (fontUrlInput.value.trim()) {
                        window.uploadedFontData = null;
                        window.uploadedFontName = null;
                        document.getElementById('font-file-name').textContent = '未选择文件';
                    }
                    applyCustomFont(fontUrlInput.value.trim(), true);
                });

                // Font upload handler
                document.getElementById('font-upload-input').addEventListener('change', (e) => {
                    console.log('File input changed, files:', e.target.files);
                    const file = e.target.files[0];
                    if (file) {
                        console.log('File selected for upload:', file);
                        handleFontUpload(file);
                    } else {
                        console.log('No file selected');
                    }
                });


                document.getElementById('save-font-btn').addEventListener('click', saveFontSettings);
                document.getElementById('reset-font-btn').addEventListener('click', resetToDefaultFont);

                document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => { item.addEventListener('click', () => switchToChatListView(item.dataset.view)); });
                document.getElementById('qzone-back-btn').addEventListener('click', () => showScreen('home-screen'));
                document.getElementById('qzone-nickname').addEventListener('click', async () => { const newNickname = await showCustomPrompt("修改昵称", "请输入新的昵称", state.qzoneSettings.nickname); if (newNickname && newNickname.trim()) { state.qzoneSettings.nickname = newNickname.trim(); await saveQzoneSettings(); renderQzoneScreen(); } });
                document.getElementById('qzone-avatar-container').addEventListener('click', () => document.getElementById('qzone-avatar-input').click());
                document.getElementById('qzone-banner-container').addEventListener('click', () => document.getElementById('qzone-banner-input').click());
                document.getElementById('qzone-avatar-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await processImageUpload(file); state.qzoneSettings.avatar = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });
                document.getElementById('qzone-banner-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await processImageUpload(file); state.qzoneSettings.banner = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });

                // ▼▼▼ 【修正后】的“说说”按钮事件 ▼▼▼
                document.getElementById('create-shuoshuo-btn').addEventListener('click', async () => {
                    // 1. 重置并获取模态框
                    resetCreatePostModal();
                    const modal = document.getElementById('create-post-modal');

                    // 2. 设置为“说说”模式
                    modal.dataset.mode = 'shuoshuo';

                    // 3. 隐藏与图片/文字图相关的部分
                    modal.querySelector('.post-mode-switcher').style.display = 'none';
                    modal.querySelector('#image-mode-content').style.display = 'none';
                    modal.querySelector('#text-image-mode-content').style.display = 'none';

                    // 4. 修改主输入框的提示语，使其更符合“说说”的场景
                    modal.querySelector('#post-public-text').placeholder = '分享新鲜事...';

                    // 5. 准备并显示模态框
                    const visibilityGroupsContainer = document.getElementById('post-visibility-groups');
                    visibilityGroupsContainer.innerHTML = '';
                    const groups = await db.qzoneGroups.toArray();
                    if (groups.length > 0) {
                        groups.forEach(group => {
                            const label = document.createElement('label');
                            label.style.display = 'block';
                            label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
                            visibilityGroupsContainer.appendChild(label);
                        });
                    } else {
                        visibilityGroupsContainer.innerHTML = '<p style="color: var(--text-secondary);">没有可用的分组</p>';
                    }
                    modal.classList.add('visible');
                });

                // ▼▼▼ 【修正后】的“动态”（图片）按钮事件 ▼▼▼
                document.getElementById('create-post-btn').addEventListener('click', async () => {
                    // 1. 重置并获取模态框
                    resetCreatePostModal();
                    const modal = document.getElementById('create-post-modal');

                    // 2. 设置为“复杂动态”模式
                    modal.dataset.mode = 'complex';

                    // 3. 确保与图片/文字图相关的部分是可见的
                    modal.querySelector('.post-mode-switcher').style.display = 'flex';
                    // 显式激活“上传图片”模式...
                    modal.querySelector('#image-mode-content').classList.add('active');
                    // ...同时确保“文字图”模式是隐藏的
                    modal.querySelector('#text-image-mode-content').classList.remove('active');

                    // 4. 恢复主输入框的默认提示语
                    modal.querySelector('#post-public-text').placeholder = '分享新鲜事...（非必填的公开文字）';

                    // 5. 准备并显示模态框（与“说说”按钮的逻辑相同）
                    const visibilityGroupsContainer = document.getElementById('post-visibility-groups');
                    visibilityGroupsContainer.innerHTML = '';
                    const groups = await db.qzoneGroups.toArray();
                    if (groups.length > 0) {
                        groups.forEach(group => {
                            const label = document.createElement('label');
                            label.style.display = 'block';
                            label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
                            visibilityGroupsContainer.appendChild(label);
                        });
                    } else {
                        visibilityGroupsContainer.innerHTML = '<p style="color: var(--text-secondary);">没有可用的分组</p>';
                    }
                    modal.classList.add('visible');
                });
                document.getElementById('open-album-btn').addEventListener('click', async () => { await renderAlbumList(); showScreen('album-screen'); });
                document.getElementById('album-back-btn').addEventListener('click', () => { showScreen('chat-list-screen'); switchToChatListView('qzone-screen'); });

                // ▼▼▼ 【全新】QZone添加按钮和模态框事件处理 ▼▼▼
                document.getElementById('qzone-add-post-btn').addEventListener('click', () => {
                    document.getElementById('qzone-add-options-modal').classList.add('visible');
                });

                document.getElementById('cancel-qzone-add-btn').addEventListener('click', () => {
                    document.getElementById('qzone-add-options-modal').classList.remove('visible');
                });

                // 复用现有的事件处理函数
                document.getElementById('modal-create-shuoshuo-btn').addEventListener('click', async () => {
                    document.getElementById('qzone-add-options-modal').classList.remove('visible');
                    document.getElementById('create-shuoshuo-btn').click();
                });

                document.getElementById('modal-create-post-btn').addEventListener('click', async () => {
                    document.getElementById('qzone-add-options-modal').classList.remove('visible');
                    document.getElementById('create-post-btn').click();
                });

                document.getElementById('modal-open-album-btn').addEventListener('click', async () => {
                    document.getElementById('qzone-add-options-modal').classList.remove('visible');
                    document.getElementById('open-album-btn').click();
                });

                // --- ↓↓↓ 从这里开始复制 ↓↓↓ ---

                document.getElementById('album-photos-back-btn').addEventListener('click', () => {
                    state.activeAlbumId = null;
                    showScreen('album-screen');
                });

                document.getElementById('album-upload-photo-btn').addEventListener('click', () => document.getElementById('album-photo-input').click());

                document.getElementById('album-photo-input').addEventListener('change', async (event) => {
                    if (!state.activeAlbumId) return;
                    const files = event.target.files;
                    if (!files.length) return;

                    const album = await db.qzoneAlbums.get(state.activeAlbumId);

                    for (const file of files) {
                        const dataUrl = await processImageUpload(file);
                        await db.qzonePhotos.add({ albumId: state.activeAlbumId, url: dataUrl, createdAt: Date.now() });
                    }

                    const photoCount = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).count();
                    const updateData = { photoCount };

                    if (!album.photoCount || album.coverUrl.includes('placeholder')) {
                        const firstPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
                        if (firstPhoto) updateData.coverUrl = firstPhoto.url;
                    }

                    await db.qzoneAlbums.update(state.activeAlbumId, updateData);
                    await renderAlbumPhotosScreen();
                    await renderAlbumList();

                    event.target.value = null;
                    alert('照片上传成功！');
                });

                // --- ↑↑↑ 复制到这里结束 ↑↑↑ ---

                // --- ↓↓↓ 从这里开始复制，完整替换掉旧的 photos-grid-page 监听器 ↓↓↓ ---

                document.getElementById('photos-grid-page').addEventListener('click', async (e) => {
                    const deleteBtn = e.target.closest('.photo-delete-btn');
                    const photoThumb = e.target.closest('.photo-thumb');

                    if (deleteBtn) {
                        e.stopPropagation(); // 阻止事件冒泡到图片上
                        const photoId = parseInt(deleteBtn.dataset.photoId);
                        const confirmed = await showCustomConfirm(
                            '删除照片',
                            '确定要删除这张照片吗？此操作不可恢复。',
                            { confirmButtonClass: 'btn-danger' }
                        );

                        if (confirmed) {
                            const deletedPhoto = await db.qzonePhotos.get(photoId);
                            if (!deletedPhoto) return;

                            await db.qzonePhotos.delete(photoId);

                            const album = await db.qzoneAlbums.get(state.activeAlbumId);
                            const photoCount = (album.photoCount || 1) - 1;
                            const updateData = { photoCount };

                            if (album.coverUrl === deletedPhoto.url) {
                                const nextPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
                                updateData.coverUrl = nextPhoto ? nextPhoto.url : 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
                            }

                            await db.qzoneAlbums.update(state.activeAlbumId, updateData);
                            await renderAlbumPhotosScreen();
                            await renderAlbumList();
                            alert('照片已删除。');
                        }
                    }
                    else if (photoThumb) {
                        // 这就是恢复的图片点击放大功能！
                        openPhotoViewer(photoThumb.src);
                    }
                });

                // 恢复图片查看器的控制事件
                document.getElementById('photo-viewer-close-btn').addEventListener('click', closePhotoViewer);
                document.getElementById('photo-viewer-next-btn').addEventListener('click', showNextPhoto);
                document.getElementById('photo-viewer-prev-btn').addEventListener('click', showPrevPhoto);

                // 恢复键盘左右箭头和ESC键的功能
                document.addEventListener('keydown', (e) => {
                    if (!photoViewerState.isOpen) return;

                    if (e.key === 'ArrowRight') {
                        showNextPhoto();
                    } else if (e.key === 'ArrowLeft') {
                        showPrevPhoto();
                    } else if (e.key === 'Escape') {
                        closePhotoViewer();
                    }
                });

                // --- ↑↑↑ 复制到这里结束 ↑↑↑ ---

                document.getElementById('create-album-btn-page').addEventListener('click', async () => { const albumName = await showCustomPrompt("创建新相册", "请输入相册名称"); if (albumName && albumName.trim()) { const newAlbum = { name: albumName.trim(), coverUrl: 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png', photoCount: 0, createdAt: Date.now() }; await db.qzoneAlbums.add(newAlbum); await renderAlbumList(); alert(`相册 "${albumName}" 创建成功！`); } else if (albumName !== null) { alert("相册名称不能为空！"); } });

                document.getElementById('cancel-create-post-btn').addEventListener('click', () => document.getElementById('create-post-modal').classList.remove('visible'));
                document.getElementById('post-upload-local-btn').addEventListener('click', () => document.getElementById('post-local-image-input').click());
                document.getElementById('post-local-image-input').addEventListener('change', (event) => { const file = event.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (e) => { document.getElementById('post-image-preview').src = e.target.result; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; }; reader.readAsDataURL(file); } });
                document.getElementById('post-use-url-btn').addEventListener('click', async () => { const url = await showCustomPrompt("输入图片URL", "请输入网络图片的链接", "", "url"); if (url) { document.getElementById('post-image-preview').src = url; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; } });
                document.getElementById('post-remove-image-btn').addEventListener('click', () => resetCreatePostModal());
                const imageModeBtn = document.getElementById('switch-to-image-mode');
                const textImageModeBtn = document.getElementById('switch-to-text-image-mode');
                const imageModeContent = document.getElementById('image-mode-content');
                const textImageModeContent = document.getElementById('text-image-mode-content');
                imageModeBtn.addEventListener('click', () => { imageModeBtn.classList.add('active'); textImageModeBtn.classList.remove('active'); imageModeContent.classList.add('active'); textImageModeContent.classList.remove('active'); });
                textImageModeBtn.addEventListener('click', () => { textImageModeBtn.classList.add('active'); imageModeBtn.classList.remove('active'); textImageModeContent.classList.add('active'); imageModeContent.classList.remove('active'); });

                // ▼▼▼ 【最终修正版】的“发布”按钮事件，已修复权限漏洞 ▼▼▼
                document.getElementById('confirm-create-post-btn').addEventListener('click', async () => {
                    const modal = document.getElementById('create-post-modal');
                    const mode = modal.dataset.mode;

                    // --- 1. 获取通用的可见性设置 ---
                    const visibilityMode = document.querySelector('input[name="visibility"]:checked').value;
                    let visibleGroupIds = null;

                    if (visibilityMode === 'include') {
                        visibleGroupIds = Array.from(document.querySelectorAll('input[name="visibility_group"]:checked')).map(cb => parseInt(cb.value));
                    }

                    let newPost = {};
                    const basePostData = {
                        timestamp: Date.now(),
                        authorId: 'user',
                        // 【重要】在这里就把权限信息存好
                        visibleGroupIds: visibleGroupIds,
                        isPinned: false,
                    };

                    // --- 2. 根据模式构建不同的 post 对象 ---
                    if (mode === 'shuoshuo') {
                        const content = document.getElementById('post-public-text').value.trim();
                        if (!content) {
                            alert('说说内容不能为空哦！');
                            return;
                        }
                        newPost = {
                            ...basePostData,
                            type: 'shuoshuo',
                            content: content,
                        };

                    } else { // 处理 'complex' 模式 (图片/文字图)
                        const publicText = document.getElementById('post-public-text').value.trim();
                        const isImageModeActive = document.getElementById('image-mode-content').classList.contains('active');

                        if (isImageModeActive) {
                            const imageUrl = document.getElementById('post-image-preview').src;
                            const imageDescription = document.getElementById('post-image-description').value.trim();
                            if (!imageUrl || !(imageUrl.startsWith('http') || imageUrl.startsWith('data:'))) {
                                alert('请先添加一张图片再发布动态哦！');
                                return;
                            }
                            if (!imageDescription) {
                                alert('请为你的图片添加一个简单的描述（必填，给AI看的）！');
                                return;
                            }
                            newPost = {
                                ...basePostData,
                                type: 'image_post',
                                publicText: publicText,
                                imageUrl: imageUrl,
                                imageDescription: imageDescription,
                            };
                        } else { // 文字图模式
                            const hiddenText = document.getElementById('post-hidden-text').value.trim();
                            const decorativeImageUrl = document.getElementById('text-image-decorative-url').value.trim();
                            if (!hiddenText) {
                                alert('请输入文字图描述！');
                                return;
                            }
                            newPost = {
                                ...basePostData,
                                type: 'text_image',
                                publicText: publicText,
                                hiddenContent: hiddenText,
                                decorativeImageUrl: decorativeImageUrl || null, // IMPORTANT: This field is purely decorative and must never be sent to API
                            };
                        }
                    }

                    // --- 3. 保存到数据库 ---
                    const newPostId = await db.qzonePosts.add(newPost);
                    let postSummary = newPost.content || newPost.publicText || newPost.imageDescription || newPost.hiddenContent || "（无文字内容）";
                    postSummary = postSummary.substring(0, 50) + (postSummary.length > 50 ? '...' : '');

                    // --- 4. 【核心修正】带有权限检查的通知循环 ---
                    for (const chatId in state.chats) {
                        const chat = state.chats[chatId];
                        if (chat.isGroup) continue; // 跳过群聊

                        let shouldNotify = false;
                        const postVisibleGroups = newPost.visibleGroupIds;

                        // 判断条件1：如果动态是公开的 (没有设置任何可见分组)
                        if (!postVisibleGroups || postVisibleGroups.length === 0) {
                            shouldNotify = true;
                        }
                        // 判断条件2：如果动态设置了部分可见，并且当前角色在可见分组内
                        else if (chat.groupId && postVisibleGroups.includes(chat.groupId)) {
                            shouldNotify = true;
                        }

                        // 只有满足条件的角色才会被通知
                        if (shouldNotify) {
                            const historyMessage = {
                                role: 'system',
                                content: `[系统提示：用户刚刚发布了一条动态(ID: ${newPostId})，内容摘要是：“${postSummary}”。你现在可以对这条动态进行评论了。]`,
                                timestamp: Date.now(),
                                isHidden: true
                            };
                            chat.history.push(historyMessage);
                            await db.chats.put(chat);
                        }
                    }
                    // --- 修正结束 ---

                    await renderQzonePosts();
                    modal.classList.remove('visible');
                    alert('动态发布成功！');
                });

                // ▼▼▼ COMMENTED OUT: Swipe left to delete post functionality ▼▼▼
                /*
                const postsList = document.getElementById('qzone-posts-list');
                let swipeState = { isDragging: false, startX: 0, startY: 0, currentX: 0, activeContainer: null, swipeDirection: null, isClick: true };

                function resetAllSwipes(exceptThisOne = null) {
                    document.querySelectorAll('.qzone-post-container').forEach(container => {
                        if (container !== exceptThisOne) {
                            container.querySelector('.qzone-post-item').classList.remove('swiped');
                        }
                    });
                }

                const handleSwipeStart = (e) => {
                    const targetContainer = e.target.closest('.qzone-post-container');
                    if (!targetContainer) return;

                    resetAllSwipes(targetContainer);
                    swipeState.activeContainer = targetContainer;
                    swipeState.isDragging = true;
                    swipeState.isClick = true;
                    swipeState.swipeDirection = null;
                    swipeState.startX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
                    swipeState.startY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
                    swipeState.activeContainer.querySelector('.qzone-post-item').style.transition = 'none';
                };

                const handleSwipeMove = (e) => {
                    if (!swipeState.isDragging || !swipeState.activeContainer) return;

                    const currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
                    const currentY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
                    const diffX = currentX - swipeState.startX;
                    const diffY = currentY - swipeState.startY;
                    const absDiffX = Math.abs(diffX);
                    const absDiffY = Math.abs(diffY);
                    const clickThreshold = 5;

                    if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
                        swipeState.isClick = false;
                    }

                    if (swipeState.swipeDirection === null) {
                        if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
                            if (absDiffX > absDiffY) {
                                swipeState.swipeDirection = 'horizontal';
                            } else {
                                swipeState.swipeDirection = 'vertical';
                            }
                        }
                    }
                    if (swipeState.swipeDirection === 'vertical') {
                        handleSwipeEnd(e);
                        return;
                    }
                    if (swipeState.swipeDirection === 'horizontal') {
                        e.preventDefault();
                        swipeState.currentX = currentX;
                        let translation = diffX;
                        if (translation > 0) translation = 0;
                        if (translation < -90) translation = -90;
                        swipeState.activeContainer.querySelector('.qzone-post-item').style.transform = `translateX(${translation}px)`;
                    }
                };

                const handleSwipeEnd = (e) => {
                    if (swipeState.isClick) {
                        swipeState.isDragging = false;
                        swipeState.activeContainer = null;
                        return;
                    }
                    if (!swipeState.isDragging || !swipeState.activeContainer) return;

                    const postItem = swipeState.activeContainer.querySelector('.qzone-post-item');
                    postItem.style.transition = 'transform 0.3s ease';

                    const finalX = e.type.includes('touchend') ? e.changedTouches[0].pageX : e.pageX;
                    const diffX = finalX - swipeState.startX;
                    const swipeThreshold = -40;

                    if (swipeState.swipeDirection === 'horizontal' && diffX < swipeThreshold) {
                        postItem.classList.add('swiped');
                        postItem.style.transform = '';
                    } else {
                        postItem.classList.remove('swiped');
                        postItem.style.transform = '';
                    }

                    swipeState.isDragging = false;
                    swipeState.startX = 0;
                    swipeState.startY = 0;
                    swipeState.currentX = 0;
                    swipeState.activeContainer = null;
                    swipeState.swipeDirection = null;
                    swipeState.isClick = true;
                };

                // --- 绑定所有滑动事件 ---
                postsList.addEventListener('mousedown', handleSwipeStart);
                document.addEventListener('mousemove', handleSwipeMove);
                document.addEventListener('mouseup', handleSwipeEnd);
                postsList.addEventListener('touchstart', handleSwipeStart, { passive: false });
                postsList.addEventListener('touchmove', handleSwipeMove, { passive: false });
                postsList.addEventListener('touchend', handleSwipeEnd);
                */
                // ▲▲▲ END COMMENTED OUT: Swipe left to delete post functionality ▲▲▲

                const postsList = document.getElementById('qzone-posts-list');

                // --- 绑定所有点击事件 ---
                postsList.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const target = e.target;

                    const commentItem = target.closest('.comment-item');
                    if (commentItem) {
                        // Comment clicks are handled by long press, so we just return here
                        return;
                    }

                    if (target.classList.contains('post-actions-btn')) {
                        const container = target.closest('.qzone-post-container');
                        if (container && container.dataset.postId) {
                            showPostActions(parseInt(container.dataset.postId));
                        }
                        return;
                    }

                    // COMMENTED OUT: Delete action click handler for swipe functionality
                    /*
                    if (target.closest('.qzone-post-delete-action')) {
                        const container = target.closest('.qzone-post-container');
                        if (!container) return;

                        const postIdToDelete = parseInt(container.dataset.postId);
                        if (isNaN(postIdToDelete)) return;

                        const confirmed = await showCustomConfirm('删除动态', '确定要永久删除这条动态吗？', { confirmButtonClass: 'btn-danger' });

                        if (confirmed) {
                            container.style.transition = 'all 0.3s ease';
                            container.style.transform = 'scale(0.8)';
                            container.style.opacity = '0';

                            setTimeout(async () => {
                                await db.qzonePosts.delete(postIdToDelete);

                                // 删除所有聊天记录中引用此动态的系统消息
                                const allChats = await db.chats.toArray();
                                for (const chat of allChats) {
                                    const originalLength = chat.history.length;
                                    chat.history = chat.history.filter(msg => {
                                        // 删除引用此动态ID的系统消息
                                        if (msg.role === 'system' && msg.isHidden && msg.content.includes(`(ID: ${postIdToDelete})`)) {
                                            return false;
                                        }
                                        return true;
                                    });
                                    
                                    // 只有在历史记录发生变化时才更新数据库
                                    if (chat.history.length !== originalLength) {
                                        await db.chats.put(chat);
                                        // 更新内存中的状态
                                        if (state.chats[chat.id]) {
                                            state.chats[chat.id].history = chat.history;
                                        }
                                    }
                                }

                                await renderQzonePosts();
                                
                                // 如果当前正在查看某个聊天界面，刷新它
                                if (state.activeChatId && document.getElementById('chat-interface-screen').classList.contains('active')) {
                                    renderChatInterface(state.activeChatId);
                                }
                                
                                alert('动态已删除。');
                            }, 300);
                        }
                        return;
                    }
                    */

                    if ((target.tagName === 'IMG' || target.tagName === 'SPAN') && target.dataset.hiddenText) {
                        const hiddenText = target.dataset.hiddenText;
                        showCustomAlert("图片内容", hiddenText.replace(/<br>/g, '\n'));
                        return;
                    }
                    const icon = target.closest('.action-icon');
                    if (icon) {
                        const postContainer = icon.closest('.qzone-post-container');
                        if (!postContainer) return;
                        const postId = parseInt(postContainer.dataset.postId);
                        if (isNaN(postId)) return;
                        if (icon.classList.contains('like')) {
                            const post = await db.qzonePosts.get(postId);
                            if (!post) return;
                            if (!post.likes) post.likes = [];
                            const userNickname = state.qzoneSettings.nickname;
                            const userLikeIndex = post.likes.indexOf(userNickname);
                            if (userLikeIndex > -1) {
                                post.likes.splice(userLikeIndex, 1);
                            } else {
                                post.likes.push(userNickname);
                                icon.classList.add('animate-like');
                                icon.addEventListener('animationend', () => icon.classList.remove('animate-like'), { once: true });
                            }
                            await db.qzonePosts.update(postId, { likes: post.likes });
                        }
                        if (icon.classList.contains('favorite')) {
                            const existingFavorite = await db.favorites.where({ type: 'qzone_post', 'content.id': postId }).first();
                            if (existingFavorite) {
                                await db.favorites.delete(existingFavorite.id);
                                await showCustomAlert('提示', '已取消收藏');
                            } else {
                                const postToSave = await db.qzonePosts.get(postId);
                                if (postToSave) {
                                    await db.favorites.add({ type: 'qzone_post', content: postToSave, timestamp: Date.now() });
                                    await showCustomAlert('提示', '收藏成功！');
                                }
                            }
                        }
                        await renderQzonePosts();
                        return;
                    }
                    const sendBtn = target.closest('.comment-send-btn');
                    if (sendBtn) {
                        const postContainer = sendBtn.closest('.qzone-post-container');
                        if (!postContainer) return;
                        const postId = parseInt(postContainer.dataset.postId);
                        const commentInput = postContainer.querySelector('.comment-input');
                        const commentText = commentInput.value.trim();
                        if (!commentText) return alert('评论内容不能为空哦！');
                        const post = await db.qzonePosts.get(postId);
                        if (!post) return;
                        if (!post.comments) post.comments = [];
                        const newComment = {
                            commenterName: state.qzoneSettings.nickname,
                            text: commentText,
                            timestamp: Date.now()
                        };
                        post.comments.push(newComment);
                        await db.qzonePosts.update(postId, { comments: post.comments });

                        // 【核心修改】在这里触发AI对评论的响应
                        // 遍历所有非群聊的AI
                        for (const chatId in state.chats) {
                            const chat = state.chats[chatId];
                            if (!chat.isGroup) {
                                // 如果是动态作者，给他发送特殊提示
                                if (post.authorId === chatId) {
                                    chat.history.push({
                                        role: 'system',
                                        content: `[系统提示：'${state.qzoneSettings.nickname}' 刚刚评论了你的动态 (ID: ${postId})：“${commentText}”。请你回复。]`,
                                        timestamp: Date.now(),
                                        isHidden: true
                                    });
                                }
                                // 如果不是作者，但有权限看到这条动态，也给他发个通知
                                else {
                                    let isVisible = false;
                                    const visibleGroups = post.visibleGroupIds;
                                    if (!visibleGroups || visibleGroups.length === 0) {
                                        isVisible = true; // 公开
                                    } else if (chat.groupId && visibleGroups.includes(chat.groupId)) {
                                        isVisible = true; // 在指定分组内
                                    }
                                    if (isVisible) {
                                        chat.history.push({
                                            role: 'system',
                                            content: `[系统提示：用户'${state.qzoneSettings.nickname}' 评论了动态 (ID: ${postId})。]`,
                                            timestamp: Date.now(),
                                            isHidden: true
                                        });
                                    }
                                }
                                await db.chats.put(chat);
                            }
                        }

                        commentInput.value = '';
                        await renderQzonePosts();
                        return;
                    }

                    // 处理AI回复按钮点击
                    const aiReplyBtn = target.closest('.call-ai-reply-btn');
                    if (aiReplyBtn) {
                        const postContainer = aiReplyBtn.closest('.qzone-post-container');
                        if (!postContainer) return;
                        const postId = parseInt(postContainer.dataset.postId);
                        showAiReplyModal(postId);
                        return;
                    }
                });


                // ▼▼▼ 在 init() 函数的事件监听器区域，粘贴下面这两行 ▼▼▼

                // 绑定动态页和收藏页的返回按钮
                document.getElementById('qzone-back-btn').addEventListener('click', () => showScreen('home-screen'));
                document.getElementById('favorites-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));

                // ▲▲▲ 添加结束 ▲▲▲

                // ▼▼▼ 在 init() 函数的事件监听器区域，检查并确保你有这段完整的代码 ▼▼▼

                // 收藏页搜索功能
                const searchInput = document.getElementById('favorites-search-input');
                const searchClearBtn = document.getElementById('favorites-search-clear-btn');

                searchInput.addEventListener('input', () => {
                    const searchTerm = searchInput.value.trim().toLowerCase();

                    // 控制清除按钮的显示/隐藏
                    searchClearBtn.style.display = searchTerm ? 'block' : 'none';

                    if (!searchTerm) {
                        displayFilteredFavorites(allFavoriteItems); // 如果搜索框为空，显示所有
                        return;
                    }

                    // 筛选逻辑
                    const filteredItems = allFavoriteItems.filter(item => {
                        let contentToSearch = '';
                        let authorToSearch = '';

                        if (item.type === 'qzone_post') {
                            const post = item.content;
                            contentToSearch += (post.publicText || '') + ' ' + (post.content || '');
                            if (post.authorId === 'user') {
                                authorToSearch = state.qzoneSettings.nickname;
                            } else if (state.chats[post.authorId]) {
                                authorToSearch = state.chats[post.authorId].name;
                            }
                        } else if (item.type === 'chat_message') {
                            const msg = item.content;
                            if (typeof msg.content === 'string') {
                                contentToSearch = msg.content;
                            }
                            const chat = state.chats[item.chatId];
                            if (chat) {
                                if (msg.role === 'user') {
                                    authorToSearch = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
                                } else {
                                    authorToSearch = chat.isGroup ? msg.senderName : chat.name;
                                }
                            }
                        }

                        // 同时搜索内容和作者，并且不区分大小写
                        return contentToSearch.toLowerCase().includes(searchTerm) ||
                            authorToSearch.toLowerCase().includes(searchTerm);
                    });

                    displayFilteredFavorites(filteredItems);
                });

                // 清除按钮的点击事件
                searchClearBtn.addEventListener('click', () => {
                    searchInput.value = '';
                    searchClearBtn.style.display = 'none';
                    displayFilteredFavorites(allFavoriteItems);
                    searchInput.focus();
                });

                // ▲▲▲ 代码检查结束 ▲▲▲

                // ▼▼▼ 新增/修改的事件监听器 ▼▼▼

                // 为聊天界面的批量收藏按钮绑定事件
                // 为聊天界面的批量收藏按钮绑定事件 (已修正)
                document.getElementById('selection-favorite-btn').addEventListener('click', async () => {
                    if (selectedMessages.size === 0) return;
                    const chat = state.chats[state.activeChatId];
                    if (!chat) return;

                    const favoritesToAdd = [];
                    const timestampsToFavorite = [...selectedMessages];

                    for (const timestamp of timestampsToFavorite) {
                        // 【核心修正1】使用新的、高效的索引进行查询
                        const existing = await db.favorites.where('originalTimestamp').equals(timestamp).first();

                        if (!existing) {
                            const messageToSave = chat.history.find(msg => msg.timestamp === timestamp);
                            if (messageToSave) {
                                favoritesToAdd.push({
                                    type: 'chat_message',
                                    content: messageToSave,
                                    chatId: state.activeChatId,
                                    timestamp: Date.now(), // 这是收藏操作发生的时间
                                    originalTimestamp: messageToSave.timestamp // 【核心修正2】保存原始消息的时间戳到新字段
                                });
                            }
                        }
                    }

                    if (favoritesToAdd.length > 0) {
                        await db.favorites.bulkAdd(favoritesToAdd);
                        allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray(); // 更新全局收藏缓存
                        await showCustomAlert('收藏成功', `已成功收藏 ${favoritesToAdd.length} 条消息。`);
                    } else {
                        await showCustomAlert('提示', '选中的消息均已收藏过。');
                    }

                    exitSelectionMode();
                });

                // 收藏页面的"编辑"按钮事件 (已修正)
                const favoritesEditBtn = document.getElementById('favorites-edit-btn');
                const favoritesView = document.getElementById('favorites-view');
                const favoritesActionBar = document.getElementById('favorites-action-bar');
                const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // 获取主导航栏
                const favoritesList = document.getElementById('favorites-list'); // 获取收藏列表

                favoritesEditBtn.addEventListener('click', () => {
                    isFavoritesSelectionMode = !isFavoritesSelectionMode;
                    favoritesView.classList.toggle('selection-mode', isFavoritesSelectionMode);

                    if (isFavoritesSelectionMode) {
                        // --- 进入编辑模式 ---
                        favoritesEditBtn.textContent = '完成';
                        favoritesActionBar.style.display = 'block'; // 显示删除操作栏
                        mainBottomNav.style.display = 'none'; // ▼ 新增：隐藏主导航栏
                        favoritesList.style.paddingBottom = '80px'; // ▼ 新增：给列表底部增加空间
                    } else {
                        // --- 退出编辑模式 ---
                        favoritesEditBtn.textContent = '编辑';
                        favoritesActionBar.style.display = 'none'; // 隐藏删除操作栏
                        mainBottomNav.style.display = 'flex';  // ▼ 新增：恢复主导航栏
                        favoritesList.style.paddingBottom = ''; // ▼ 新增：恢复列表默认padding

                        // 退出时清空所有选择
                        selectedFavorites.clear();
                        document.querySelectorAll('.favorite-item-card.selected').forEach(card => card.classList.remove('selected'));
                        document.getElementById('favorites-delete-selected-btn').textContent = `删除 (0)`;
                    }
                });

                // ▼▼▼ 将它【完整替换】为下面这段修正后的代码 ▼▼▼
                // 收藏列表的点击选择事件 (事件委托)
                document.getElementById('favorites-list').addEventListener('click', (e) => {
                    const target = e.target;
                    const card = target.closest('.favorite-item-card');

                    // 【新增】处理文字图点击，这段逻辑要放在最前面，保证任何模式下都生效
                    if ((target.tagName === 'IMG' || target.tagName === 'SPAN') && target.dataset.hiddenText) {
                        const hiddenText = target.dataset.hiddenText;
                        showCustomAlert("图片内容", hiddenText.replace(/<br>/g, '\n'));
                        return; // 处理完就退出，不继续执行选择逻辑
                    }

                    // 如果不在选择模式，则不执行后续的选择操作
                    if (!isFavoritesSelectionMode) return;

                    // --- 以下是原有的选择逻辑，保持不变 ---
                    if (!card) return;

                    const favId = parseInt(card.dataset.favid);
                    if (isNaN(favId)) return;

                    // 切换选择状态
                    if (selectedFavorites.has(favId)) {
                        selectedFavorites.delete(favId);
                        card.classList.remove('selected');
                    } else {
                        selectedFavorites.add(favId);
                        card.classList.add('selected');
                    }

                    // 更新底部删除按钮的计数
                    document.getElementById('favorites-delete-selected-btn').textContent = `删除 (${selectedFavorites.size})`;
                });

                // ▼▼▼ 将它【完整替换】为下面这段修正后的代码 ▼▼▼
                // 收藏页面批量删除按钮事件
                document.getElementById('favorites-delete-selected-btn').addEventListener('click', async () => {
                    if (selectedFavorites.size === 0) return;

                    const confirmed = await showCustomConfirm(
                        '确认删除',
                        `确定要从收藏夹中移除这 ${selectedFavorites.size} 条内容吗？`,
                        { confirmButtonClass: 'btn-danger' }
                    );

                    if (confirmed) {
                        const idsToDelete = [...selectedFavorites];
                        await db.favorites.bulkDelete(idsToDelete);
                        await showCustomAlert('删除成功', '选中的收藏已被移除。');

                        // 【核心修正1】从前端缓存中也移除被删除的项
                        allFavoriteItems = allFavoriteItems.filter(item => !idsToDelete.includes(item.id));

                        // 【核心修正2】使用更新后的缓存，立即重新渲染列表
                        displayFilteredFavorites(allFavoriteItems);

                        // 最后，再退出编辑模式
                        favoritesEditBtn.click(); // 模拟点击"完成"按钮来退出编辑模式
                    }
                });

                // ▼▼▼ 在 init() 函数末尾添加 ▼▼▼
                if (state.globalSettings.enableBackgroundActivity) {
                    startBackgroundSimulation();
                    console.log("后台活动模拟已自动启动。");
                }
                // ▲▲▲ 添加结束 ▲▲▲

                // ▼▼▼ 【这是最终的正确代码】请粘贴这段代码到 init() 的事件监听器区域末尾 ▼▼▼

                // --- 统一处理所有影响预览的控件的事件 ---

                // 1. 监听主题选择
                document.querySelectorAll('input[name="theme-select"]').forEach(radio => {
                    radio.addEventListener('change', updateSettingsPreview);
                });

                // 2. 监听字体大小滑块
                const fontSizeSlider = document.getElementById('font-size-slider');
                fontSizeSlider.addEventListener('input', () => {
                    // a. 实时更新数值显示
                    document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
                    // b. 更新预览
                    updateSettingsPreview();
                });

                // 3. 监听自定义CSS输入框
                const customCssInputForPreview = document.getElementById('custom-css-input');
                customCssInputForPreview.addEventListener('input', updateSettingsPreview);

                // 4. 监听重置按钮
                document.getElementById('reset-theme-btn').addEventListener('click', () => {
                    document.getElementById('theme-default').checked = true;
                    updateSettingsPreview();
                });

                document.getElementById('reset-custom-css-btn').addEventListener('click', () => {
                    document.getElementById('custom-css-input').value = '';
                    updateSettingsPreview();
                });

                // ▲▲▲ 粘贴结束 ▲▲▲

                // ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
                document.querySelectorAll('input[name="visibility"]').forEach(radio => {
                    radio.addEventListener('change', function () {
                        const groupsContainer = document.getElementById('post-visibility-groups');
                        if (this.value === 'include' || this.value === 'exclude') {
                            groupsContainer.style.display = 'block';
                        } else {
                            groupsContainer.style.display = 'none';
                        }
                    });
                });
                // ▲▲▲ 新代码粘贴结束 ▲▲▲

                // ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
                document.getElementById('manage-groups-btn').addEventListener('click', openGroupManager);
                document.getElementById('close-group-manager-btn').addEventListener('click', () => {
                    document.getElementById('group-management-modal').classList.remove('visible');
                    // 刷新聊天设置里的分组列表
                    const chatSettingsBtn = document.getElementById('chat-settings-btn');
                    if (document.getElementById('chat-settings-modal').classList.contains('visible')) {
                        chatSettingsBtn.click(); // 再次点击以重新打开
                    }
                });

                document.getElementById('add-new-group-btn').addEventListener('click', addNewGroup);
                document.getElementById('existing-groups-list').addEventListener('click', (e) => {
                    if (e.target.classList.contains('delete-group-btn')) {
                        const groupId = parseInt(e.target.dataset.id);
                        deleteGroup(groupId);
                    }
                });
                // ▲▲▲ 新代码粘贴结束 ▲▲▲

                // ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
                // 消息操作菜单的按钮事件
                document.getElementById('cancel-message-action-btn').addEventListener('click', hideMessageActions);
                document.getElementById('quote-message-btn').addEventListener('click', startReplyToMessage);
                document.getElementById('recall-message-btn').addEventListener('click', handleRecallClick);

                // Chat actions event handlers
                document.getElementById('cancel-chat-action-btn').addEventListener('click', hideChatActions);
                document.getElementById('pin-chat-btn').addEventListener('click', async () => {
                    if (!activeChatId) return;
                    const chat = state.chats[activeChatId];
                    if (!chat) return;

                    chat.isPinned = true;
                    await db.chats.put(chat);
                    renderChatList();
                    hideChatActions();
                });
                document.getElementById('unpin-chat-btn').addEventListener('click', async () => {
                    if (!activeChatId) return;
                    const chat = state.chats[activeChatId];
                    if (!chat) return;

                    chat.isPinned = false;
                    await db.chats.put(chat);
                    renderChatList();
                    hideChatActions();
                });
                document.getElementById('delete-chat-btn').addEventListener('click', async () => {
                    if (!activeChatId) return;
                    const chat = state.chats[activeChatId];
                    if (!chat) return;

                    hideChatActions();
                    const confirmed = await showCustomConfirm('删除对话', `确定要删除与 "${chat.name}" 的整个对话吗？此操作不可撤销。`, { confirmButtonClass: 'btn-danger' });
                    if (confirmed) {
                        if (musicState.isActive && musicState.activeChatId === chat.id) await endListenTogetherSession(false);
                        delete state.chats[chat.id];
                        if (state.activeChatId === chat.id) state.activeChatId = null;
                        await db.chats.delete(chat.id);
                        renderChatList();
                    }
                });
                // 绑定回复预览栏中的"取消"按钮
                document.getElementById('cancel-reply-btn').addEventListener('click', cancelReplyMode);
                // ▼▼▼ 【修正】使用新的编辑器入口 ▼▼▼
                document.getElementById('edit-message-btn').addEventListener('click', () => {
                    // Check if we're in meetup screen
                    const isInMeetup = document.getElementById('meetup-screen').classList.contains('active');

                    if (isInMeetup) {
                        // Use date mode edit
                        const timestampToEdit = activeMessageTimestamp;
                        editMeetupMessage(timestampToEdit);
                    } else {
                        // Check if it's a location message
                        const chat = state.chats[state.activeChatId];
                        const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);

                        if (message && message.type === 'location_share') {
                            editLocationMessage(activeMessageTimestamp);
                        } else {
                            // Use regular chat edit
                            openAdvancedMessageEditor();
                        }
                    }
                });
                // ▲▲▲ 替换结束 ▲▲▲

                // ▼▼▼ 请用这段【修正后】的代码替换旧的 select-message-btn 事件监听器 ▼▼▼
                document.getElementById('select-message-btn').addEventListener('click', () => {
                    // 【核心修复】在关闭菜单前，先捕获时间戳
                    const timestampToSelect = activeMessageTimestamp;
                    hideMessageActions();

                    // Check if we're in meetup screen
                    const isInMeetup = document.getElementById('meetup-screen').classList.contains('active');

                    if (timestampToSelect) {
                        if (isInMeetup) {
                            // Use meetup selection
                            enterMeetupSelectionMode(timestampToSelect);
                        } else {
                            // Use regular chat selection
                            enterSelectionMode(timestampToSelect);
                        }
                    }
                });
                // ▲▲▲ 替换结束 ▲▲▲

                // ▼▼▼ 在 init() 函数的事件监听器区域末尾添加 ▼▼▼

                // 动态操作菜单的按钮事件
                document.getElementById('pin-post-btn').addEventListener('click', pinPost);
                document.getElementById('unpin-post-btn').addEventListener('click', unpinPost);
                document.getElementById('edit-post-btn').addEventListener('click', openPostEditor);
                document.getElementById('copy-post-btn').addEventListener('click', copyPostContent);
                document.getElementById('delete-post-btn').addEventListener('click', deletePost);
                document.getElementById('cancel-post-action-btn').addEventListener('click', hidePostActions);

                // 评论操作菜单的按钮事件
                document.getElementById('edit-comment-btn').addEventListener('click', editComment);
                document.getElementById('delete-comment-btn').addEventListener('click', deleteComment);
                document.getElementById('cancel-comment-action-btn').addEventListener('click', hideCommentActions);

                // AI回复模态框的按钮事件
                document.getElementById('close-ai-reply-modal').addEventListener('click', hideAiReplyModal);
                document.getElementById('cancel-ai-reply').addEventListener('click', hideAiReplyModal);
                document.getElementById('confirm-ai-reply').addEventListener('click', confirmAiReply);
                document.getElementById('select-all-ais').addEventListener('click', selectAllAis);
                document.getElementById('deselect-all-ais').addEventListener('click', deselectAllAis);

                // AI发动态模态框的按钮事件
                document.getElementById('close-ai-post-modal').addEventListener('click', hideAiPostModal);
                document.getElementById('cancel-ai-post').addEventListener('click', hideAiPostModal);
                document.getElementById('confirm-ai-post').addEventListener('click', confirmAiPost);
                document.getElementById('ai-post-btn').addEventListener('click', showAiPostModal);

                // 移动表情包模态框的按钮事件
                document.getElementById('close-move-sticker-modal').addEventListener('click', hideMoveStickerModal);
                document.getElementById('cancel-move-sticker').addEventListener('click', hideMoveStickerModal);
                document.getElementById('confirm-move-sticker').addEventListener('click', confirmMoveSticker);

                // ▲▲▲ 添加结束 ▲▲▲

                // ▼▼▼ 【新增】联系人选择器事件绑定 ▼▼▼
                document.getElementById('cancel-contact-picker-btn').addEventListener('click', () => {
                    showScreen('chat-list-screen');
                });

                document.getElementById('contact-picker-list').addEventListener('click', (e) => {
                    const item = e.target.closest('.contact-picker-item');
                    if (!item) return;

                    const contactId = item.dataset.contactId;
                    item.classList.toggle('selected');

                    if (selectedContacts.has(contactId)) {
                        selectedContacts.delete(contactId);
                    } else {
                        selectedContacts.add(contactId);
                    }
                    updateContactPickerConfirmButton();
                });

                // ▼▼▼ 【新增】绑定“管理群成员”按钮事件 ▼▼▼
                document.getElementById('manage-members-btn').addEventListener('click', () => {
                    // 在切换屏幕前，先隐藏当前的聊天设置弹窗
                    document.getElementById('chat-settings-modal').classList.remove('visible');
                    // 然后再打开成员管理屏幕
                    openMemberManagementScreen();
                });
                // ▲▲▲ 新增代码结束 ▲▲▲

                // ▼▼▼ 【最终完整版】群成员管理功能事件绑定 ▼▼▼
                document.getElementById('back-from-member-management').addEventListener('click', () => {

                    showScreen('chat-interface-screen');
                    document.getElementById('chat-settings-btn').click();
                });
                // ▲▲▲ 替换结束 ▲▲▲

                document.getElementById('member-management-list').addEventListener('click', (e) => {
                    // 【已恢复】移除成员的事件
                    if (e.target.classList.contains('remove-member-btn')) {
                        removeMemberFromGroup(e.target.dataset.memberId);
                    }
                });

                document.getElementById('add-existing-contact-btn').addEventListener('click', async () => {
                    // 【已恢复】从好友列表添加的事件
                    // 【关键】为“完成”按钮绑定“拉人入群”的逻辑
                    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
                    // 使用克隆节点方法清除旧的事件监听器，防止重复绑定
                    const newConfirmBtn = confirmBtn.cloneNode(true);
                    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
                    newConfirmBtn.addEventListener('click', handleAddMembersToGroup);

                    await openContactPickerForAddMember();
                });

                document.getElementById('create-new-member-btn').addEventListener('click', createNewMemberInGroup);
                // ▲▲▲ 替换结束 ▲▲▲

                // ▼▼▼ 【全新】视频通话功能事件监听器 ▼▼▼

                // 绑定单聊和群聊的发起按钮
                document.getElementById('video-call-btn').addEventListener('click', handleInitiateCall);
                document.getElementById('group-video-call-btn').addEventListener('click', handleInitiateCall);

                // 绑定“挂断”按钮
                document.getElementById('hang-up-btn').addEventListener('click', endVideoCall);

                // 绑定“取消呼叫”按钮
                document.getElementById('cancel-call-btn').addEventListener('click', () => {
                    videoCallState.isAwaitingResponse = false;
                    showScreen('chat-interface-screen');
                });

                // 【全新】绑定“加入通话”按钮
                document.getElementById('join-call-btn').addEventListener('click', handleUserJoinCall);

                // ▼▼▼ 用这个【已修复并激活旁观模式】的版本替换旧的 decline-call-btn 事件监听器 ▼▼▼
                // 绑定来电请求的“拒绝”按钮
                document.getElementById('decline-call-btn').addEventListener('click', async () => {
                    hideIncomingCallModal();
                    const chat = state.chats[videoCallState.activeChatId];
                    if (!chat) return;

                    // 【核心修正】在这里，我们将拒绝的逻辑与API调用连接起来
                    if (videoCallState.isGroupCall) {
                        videoCallState.isUserParticipating = false; // 标记用户为旁观者

                        // 1. 创建一条隐藏消息，通知AI用户拒绝了
                        const systemNote = {
                            role: 'system',
                            content: `[系统提示：用户拒绝了通话邀请，但你们可以自己开始。请你们各自决策是否加入。]`,
                            timestamp: Date.now(),
                            isHidden: true
                        };
                        chat.history.push(systemNote);
                        await db.chats.put(chat);

                        // 2. 【关键】触发AI响应，让它们自己决定要不要开始群聊
                        // 这将会在后台处理，如果AI们决定开始，最终会调用 startVideoCall()
                        await triggerAiResponse();

                    } else { // 单聊拒绝逻辑保持不变
                        const declineMessage = { role: 'user', content: '我拒绝了你的视频通话请求。', timestamp: Date.now() };
                        chat.history.push(declineMessage);
                        await db.chats.put(chat);

                        // 回到聊天界面并显示拒绝消息
                        showScreen('chat-interface-screen');
                        appendMessage(declineMessage, chat);

                        // 让AI对你的拒绝做出回应
                        triggerAiResponse();
                    }

                    // 清理状态，以防万一
                    videoCallState.isAwaitingResponse = false;
                });
                // ▲▲▲ 替换结束 ▲▲▲

                // ▼▼▼ 用这个【已修复重复头像BUG】的版本替换旧的 accept-call-btn 事件监听器 ▼▼▼
                // 绑定来电请求的“接听”按钮
                document.getElementById('accept-call-btn').addEventListener('click', async () => {
                    hideIncomingCallModal();

                    videoCallState.initiator = 'ai';
                    videoCallState.isUserParticipating = true;
                    videoCallState.activeChatId = state.activeChatId;

                    // 【核心修正】我们在这里不再手动添加用户到 participants 列表
                    if (videoCallState.isGroupCall) {
                        // 对于群聊，我们只把【发起通话的AI】加入参与者列表
                        const chat = state.chats[videoCallState.activeChatId];
                        const requester = chat.members.find(m => m.name === videoCallState.callRequester);
                        if (requester) {
                            // 清空可能存在的旧数据，然后只添加发起者
                            videoCallState.participants = [requester];
                        } else {
                            videoCallState.participants = []; // 如果找不到发起者，就清空
                        }
                    }

                    // 无论单聊还是群聊，直接启动通话界面！
                    startVideoCall();
                });
                // ▲▲▲ 替换结束 ▲▲▲


                // ▼▼▼ 请用这个【已增加用户高亮】的全新版本，完整替换旧的 user-speak-btn 事件监听器 ▼▼▼
                // 绑定用户在通话中发言的按钮
                document.getElementById('user-speak-btn').addEventListener('click', async () => {
                    if (!videoCallState.isActive) return;

                    // ★★★★★ 核心新增：在弹出输入框前，先找到并高亮用户头像 ★★★★★
                    const userAvatar = document.querySelector('.participant-avatar-wrapper[data-participant-id="user"] .participant-avatar');
                    if (userAvatar) {
                        userAvatar.classList.add('speaking');
                    }

                    const userInput = await showCustomPrompt('你说', '请输入你想说的话...');

                    // ★★★★★ 核心新增：无论用户是否输入，只要关闭输入框就移除高亮 ★★★★★
                    if (userAvatar) {
                        userAvatar.classList.remove('speaking');
                    }

                    if (userInput && userInput.trim()) {
                        triggerAiInCallAction(userInput.trim());
                    }
                });
                // ▲▲▲ 替换结束 ▲▲▲

                // ▼▼▼ 【新增】回忆录相关事件绑定 ▼▼▼
                // 1. 将“回忆”页签和它的视图连接起来
                document.querySelector('.nav-item[data-view="memories-view"]').addEventListener('click', () => {
                    // 在切换前，确保"收藏"页面的编辑模式已关闭
                    if (isFavoritesSelectionMode) {
                        document.getElementById('favorites-edit-btn').click();
                    }
                    switchToChatListView('memories-view');
                    renderMemoriesScreen(); // 点击时渲染
                });

                // 2. 绑定回忆录界面的返回按钮
                document.getElementById('memories-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));

                // ▲▲▲ 新增结束 ▲▲▲

                // 【全新】约定/倒计时功能事件绑定 - 修改为选择模态框
                document.getElementById('add-countdown-btn').addEventListener('click', () => {
                    document.getElementById('add-memory-type-modal').classList.add('visible');
                });
                document.getElementById('cancel-create-countdown-btn').addEventListener('click', () => {
                    document.getElementById('create-countdown-modal').classList.remove('visible');
                });
                document.getElementById('confirm-create-countdown-btn').addEventListener('click', async () => {
                    const title = document.getElementById('countdown-title-input').value.trim();
                    const dateValue = document.getElementById('countdown-date-input').value;

                    if (!title || !dateValue) {
                        alert('请填写完整的约定标题和日期！');
                        return;
                    }

                    const targetDate = new Date(dateValue);
                    if (isNaN(targetDate)) {
                        alert('请输入一个有效的日期！');
                        return;
                    }

                    if (editingMemoryId) {
                        // Edit mode - update existing memory
                        const memory = await db.memories.get(editingMemoryId);
                        if (memory) {
                            memory.description = title;
                            memory.targetDate = targetDate.getTime();
                            await db.memories.put(memory);
                        }
                        editingMemoryId = null;
                        // Reset modal title
                        document.querySelector('#create-countdown-modal .modal-header span').textContent = '新建约定';
                    } else {
                        // Create mode - add new memory
                        const newCountdown = {
                            chatId: null, // 用户创建的，不属于任何特定AI
                            authorName: '我',
                            description: title,
                            timestamp: Date.now(),
                            type: 'countdown',
                            targetDate: targetDate.getTime()
                        };
                        await db.memories.add(newCountdown);
                    }

                    document.getElementById('create-countdown-modal').classList.remove('visible');
                    renderMemoriesScreen();
                    renderCalendarScreen();
                });

                // 【全新】添加类型选择模态框事件绑定
                document.getElementById('cancel-add-type-btn').addEventListener('click', () => {
                    document.getElementById('add-memory-type-modal').classList.remove('visible');
                });

                document.getElementById('add-memory-btn').addEventListener('click', () => {
                    document.getElementById('add-memory-type-modal').classList.remove('visible');
                    document.getElementById('create-memory-modal').classList.add('visible');
                    // 设置默认时间为当前时间
                    const now = new Date();
                    const localDateTime = new Date(now.getTime() - now.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
                    document.getElementById('memory-date-input').value = localDateTime;
                });

                document.getElementById('add-event-btn').addEventListener('click', () => {
                    document.getElementById('add-memory-type-modal').classList.remove('visible');
                    document.getElementById('create-countdown-modal').classList.add('visible');
                });

                // 【全新】添加回忆模态框事件绑定
                document.getElementById('cancel-create-memory-btn').addEventListener('click', () => {
                    document.getElementById('create-memory-modal').classList.remove('visible');
                });

                document.getElementById('confirm-create-memory-btn').addEventListener('click', async () => {
                    const description = document.getElementById('memory-description-input').value.trim();
                    const dateTime = document.getElementById('memory-date-input').value;

                    if (!description) {
                        alert('请输入回忆内容');
                        return;
                    }

                    if (!dateTime) {
                        alert('请选择回忆日期');
                        return;
                    }

                    const memoryDate = new Date(dateTime);

                    if (editingMemoryId) {
                        // Edit mode - update existing memory
                        const memory = await db.memories.get(editingMemoryId);
                        if (memory) {
                            memory.description = description;
                            memory.timestamp = memoryDate.getTime();
                            await db.memories.put(memory);
                        }
                        editingMemoryId = null;
                        // Reset modal title
                        document.querySelector('#create-memory-modal .modal-header span').textContent = '新建回忆';
                    } else {
                        // Create mode - add new memory
                        const newMemory = {
                            chatId: 'manual', // 手动添加的回忆
                            authorName: '我', // 用户添加的回忆
                            description: description,
                            timestamp: memoryDate.getTime(),
                            type: 'ai_generated' // 使用相同类型以在日历中显示
                        };
                        await db.memories.add(newMemory);
                    }

                    document.getElementById('create-memory-modal').classList.remove('visible');

                    // 清空表单
                    document.getElementById('memory-description-input').value = '';
                    document.getElementById('memory-date-input').value = '';

                    renderMemoriesScreen();
                    renderCalendarScreen();
                });

                // 【全新】拉黑功能事件绑定
                document.getElementById('block-chat-btn').addEventListener('click', async () => {
                    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) return;

                    const chat = state.chats[state.activeChatId];
                    const confirmed = await showCustomConfirm(
                        '确认拉黑',
                        `确定要拉黑“${chat.name}”吗？拉黑后您将无法向其发送消息，直到您将Ta移出黑名单，或等待Ta重新申请好友。`,
                        { confirmButtonClass: 'btn-danger' }
                    );

                    if (confirmed) {
                        chat.relationship.status = 'blocked_by_user';
                        chat.relationship.blockedTimestamp = Date.now();
                        await db.chats.put(chat);

                        // 关闭设置弹窗，并刷新聊天界面
                        document.getElementById('chat-settings-modal').classList.remove('visible');
                        renderChatInterface(state.activeChatId);
                        // 刷新聊天列表，可能会有UI变化
                        renderChatList();
                    }
                });

                document.getElementById('chat-lock-overlay').addEventListener('click', async (e) => {
                    const chat = state.chats[state.activeChatId];
                    if (!chat) return;

                    if (e.target.id === 'force-apply-check-btn') {
                        alert("正在手动触发好友申请流程，请稍后...\n如果API调用成功，将弹出提示。如果失败，也会有错误提示。如果长时间无反应，说明AI可能决定暂时不申请。");
                        await triggerAiFriendApplication(chat.id);
                        renderChatInterface(chat.id);
                        return;
                    }

                    if (e.target.id === 'unblock-btn') {
                        chat.relationship.status = 'friend';
                        chat.relationship.blockedTimestamp = null;
                        await db.chats.put(chat);
                        renderChatInterface(chat.id);
                        renderChatList();
                    }
                    else if (e.target.id === 'accept-friend-btn') {
                        chat.relationship.status = 'friend';
                        chat.relationship.applicationReason = '';
                        await db.chats.put(chat);
                        renderChatInterface(chat.id);
                        renderChatList();
                        const msg = { role: 'user', content: '我通过了你的好友请求', timestamp: Date.now() };
                        chat.history.push(msg);
                        await db.chats.put(chat);
                        appendMessage(msg, chat);
                        triggerAiResponse();
                    }
                    else if (e.target.id === 'reject-friend-btn') {
                        chat.relationship.status = 'blocked_by_user';
                        chat.relationship.blockedTimestamp = Date.now();
                        chat.relationship.applicationReason = '';
                        await db.chats.put(chat);
                        renderChatInterface(chat.id);
                    }
                    // 【新增】处理申请好友按钮的点击事件
                    else if (e.target.id === 'apply-friend-btn') {
                        const reason = await showCustomPrompt(
                            '发送好友申请',
                            `请输入你想对“${chat.name}”说的申请理由：`,
                            "我们和好吧！"
                        );
                        // 只有当用户输入了内容并点击“确定”后才继续
                        if (reason !== null) {
                            // 更新关系状态为“等待AI批准”
                            chat.relationship.status = 'pending_ai_approval';
                            chat.relationship.applicationReason = reason;
                            await db.chats.put(chat);

                            // 刷新UI，显示“等待通过”的界面
                            renderChatInterface(chat.id);
                            renderChatList();

                            // 【关键】触发AI响应，让它去处理这个好友申请
                            triggerAiResponse();
                        }
                    }
                });

                // ▼▼▼ 【全新】红包功能事件绑定 ▼▼▼

                // 1. 将原有的转账按钮(￥)的点击事件，重定向到新的总入口函数
                document.getElementById('transfer-btn').addEventListener('click', handlePaymentButtonClick);

                // 2. 红包模态框内部的控制按钮
                document.getElementById('cancel-red-packet-btn').addEventListener('click', () => {
                    document.getElementById('red-packet-modal').classList.remove('visible');
                });
                document.getElementById('send-group-packet-btn').addEventListener('click', sendGroupRedPacket);
                document.getElementById('send-direct-packet-btn').addEventListener('click', sendDirectRedPacket);

                // 3. 红包模态框的页签切换逻辑
                const rpTabGroup = document.getElementById('rp-tab-group');
                const rpTabDirect = document.getElementById('rp-tab-direct');
                const rpContentGroup = document.getElementById('rp-content-group');
                const rpContentDirect = document.getElementById('rp-content-direct');

                rpTabGroup.addEventListener('click', () => {
                    rpTabGroup.classList.add('active');
                    rpTabDirect.classList.remove('active');
                    rpContentGroup.style.display = 'block';
                    rpContentDirect.style.display = 'none';
                });
                rpTabDirect.addEventListener('click', () => {
                    rpTabDirect.classList.add('active');
                    rpTabGroup.classList.remove('active');
                    rpContentDirect.style.display = 'block';
                    rpContentGroup.style.display = 'none';
                });

                // 4. 实时更新红包金额显示
                document.getElementById('rp-group-amount').addEventListener('input', (e) => {
                    const amount = parseFloat(e.target.value) || 0;
                    document.getElementById('rp-group-total').textContent = `¥ ${amount.toFixed(2)}`;
                });
                document.getElementById('rp-direct-amount').addEventListener('input', (e) => {
                    const amount = parseFloat(e.target.value) || 0;
                    document.getElementById('rp-direct-total').textContent = `¥ ${amount.toFixed(2)}`;
                });

                // ▲▲▲ 新事件绑定结束 ▲▲▲

                // ▼▼▼ 【全新添加】使用事件委托处理红包点击，修复失效问题 ▼▼▼
                document.getElementById('chat-messages').addEventListener('click', (e) => {
                    // 1. 找到被点击的红包卡片
                    const packetCard = e.target.closest('.red-packet-card');
                    if (!packetCard) return; // 如果点击的不是红包，就什么也不做

                    // 2. 从红包卡片的父级.message-bubble获取时间戳
                    const messageBubble = packetCard.closest('.message-bubble');
                    if (!messageBubble || !messageBubble.dataset.timestamp) return;

                    // 3. 调用我们现有的处理函数
                    const timestamp = parseInt(messageBubble.dataset.timestamp);
                    handlePacketClick(timestamp);
                });
                // ▲▲▲ 新增代码结束 ▲▲▲

                // ▼▼▼ 【全新】投票功能事件监听器 ▼▼▼
                // 在输入框工具栏添加按钮
                document.getElementById('send-poll-btn').addEventListener('click', openCreatePollModal);

                // 投票创建模态框的按钮
                document.getElementById('add-poll-option-btn').addEventListener('click', addPollOptionInput);
                document.getElementById('cancel-create-poll-btn').addEventListener('click', () => {
                    document.getElementById('create-poll-modal').classList.remove('visible');
                });
                document.getElementById('confirm-create-poll-btn').addEventListener('click', sendPoll);

                // 使用事件委托处理投票卡片内的所有点击事件
                document.getElementById('chat-messages').addEventListener('click', (e) => {
                    const pollCard = e.target.closest('.poll-card');
                    if (!pollCard) return;

                    const timestamp = parseInt(pollCard.dataset.pollTimestamp);
                    if (isNaN(timestamp)) return;

                    // 点击了选项
                    const optionItem = e.target.closest('.poll-option-item');
                    if (optionItem && !pollCard.classList.contains('closed')) {
                        handleUserVote(timestamp, optionItem.dataset.option);
                        return;
                    }

                    // 点击了动作按钮（结束投票/查看结果）
                    const actionBtn = e.target.closest('.poll-action-btn');
                    if (actionBtn) {
                        if (pollCard.classList.contains('closed')) {
                            showPollResults(timestamp);
                        } else {
                            endPoll(timestamp);
                        }
                        return;
                    }

                    // 如果是已结束的投票，点击卡片任何地方都可以查看结果
                    if (pollCard.classList.contains('closed')) {
                        showPollResults(timestamp);
                    }
                });
            }


            function openChat(chatId) {
                state.activeChatId = chatId;
                const chat = state.chats[chatId];
                if (!chat) return;
                if (chat.status === 'unread') {
                    chat.status = 'read';
                    db.chats.put(chat);
                }
                renderChatInterface(chatId);
                showScreen('chat-interface-screen');
                window.updateListenTogetherIconProxy(state.activeChatId);
                toggleCallButtons(chat.isGroup || false);
                // 【核心新增】打开聊天时，立即更新状态并启动计时器
                updateChatHeaderStatus(chat);
                manageInactivityTimer(chat);
                if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                    console.log(`检测到好友申请待处理状态，为角色 "${chat.name}" 自动触发AI响应...`);
                    triggerAiResponse();
                }

                document.getElementById('send-poll-btn').style.display = chat.isGroup ? 'flex' : 'none';
                document.getElementById('open-bulletin-board-btn').style.display = chat.isGroup ? 'flex' : 'none';

            }
            // ==========================================================
            // --- 云端备份与恢复 (V2 - 版本选择) ---
            // ==========================================================

            /**
             * 【V2版】备份数据到服务器，并标记备份类型
             * @param {('manual'|'auto')} backupType - 备份的类型
             * @param {boolean} showAlert - 是否显示成功/失败弹窗
             */
            async function backupDataToServer(backupType = 'auto', showAlert = false) {
                console.log(`[云同步V2] 开始备份，类型: ${backupType}`);
                try {
                    const tablesToBackup = [
                        'chats', 'apiConfig', 'globalSettings', 'userStickers',
                        'worldBooks', 'musicLibrary', 'personaPresets',
                        'qzoneSettings', 'qzonePosts', 'qzoneAlbums', 'qzonePhotos',
                        'favorites', 'qzoneGroups', 'memories'
                    ];
                    const data = {};
                    const existingTables = tablesToBackup.filter(tableName => db.table(tableName));

                    await db.transaction('r', existingTables, async () => {
                        for (const table of existingTables) {
                            const tableData = await db.table(table).toArray();
                            if (tableData) {
                                data[table] = tableData;
                            }
                        }
                    });

                    // 增加一个设备ID元数据
                    let deviceId = localStorage.getItem('ephone-device-id');
                    if (!deviceId) {
                        deviceId = `device_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
                        localStorage.setItem('ephone-device-id', deviceId);
                    }

                    const backupPayload = {
                        metadata: {
                            timestamp: Date.now(),
                            sourceDeviceId: deviceId,
                            type: backupType
                        },
                        data: data
                    };

                    const response = await fetch(`/api/data?type=${backupType}`, { // 在URL中传递类型
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(backupPayload)
                    });

                    if (!response.ok) {
                        throw new Error(`服务器返回错误: ${response.status} ${response.statusText}`);
                    }

                    console.log(`[云同步V2] ${backupType} 备份成功!`);
                    if (showAlert) {
                        showCustomAlert('☁️ 手动备份成功', '您的数据已安全保存到云端。');
                    }
                } catch (err) {
                    console.error(`[云同步V2] ${backupType} 备份失败:`, err);
                    if (showAlert) {
                        showCustomAlert('❌ 云端备份失败', err.message || '未知错误');
                    }
                }
            }

            /**
             * 【V2版】从服务器恢复指定的备份版本
             * @param {('manual'|'auto')} backupType - 要恢复的备份类型
             */
            async function restoreDataFromServer(backupType) {
                try {
                    const confirmed = await showCustomConfirm(
                        '严重警告！',
                        `即将从云端恢复【${backupType === 'manual' ? '手动' : '自动'}】备份。<br><br>此操作将完全覆盖您当前设备上的所有数据，且不可撤销！`,
                        { confirmButtonClass: 'btn-danger' }
                    );
                    if (!confirmed) return;

                    const res = await fetch(`/api/data?type=${backupType}`); // 从指定URL获取
                    if (!res.ok) {
                        if (res.status === 404) {
                            showCustomAlert('恢复失败', `未在云端找到【${backupType === 'manual' ? '手动' : '自动'}】备份文件。`);
                            return;
                        }
                        throw new Error(`服务器响应错误: ${res.status} ${res.statusText}`);
                    }

                    const backupPayload = await res.json();
                    const data = backupPayload.data;

                    if (!data || typeof data !== 'object' || Object.keys(data).length === 0) {
                        showCustomAlert('恢复中止', '云端备份数据为空或格式不正确。');
                        return;
                    }

                    const tablesToRestore = Object.keys(data);
                    const existingTables = tablesToRestore.filter(tableName => db.table(tableName));

                    await db.transaction('rw', existingTables, async () => {
                        for (const table of existingTables) {
                            await db.table(table).clear();
                            if (data[table] && Array.isArray(data[table])) {
                                await db.table(table).bulkPut(data[table]);
                            }
                        }
                    });

                    await showCustomAlert('☁️ 云端恢复成功', '数据已从服务器还原，应用即将刷新。');
                    setTimeout(() => location.reload(), 1500);
                } catch (err) {
                    console.error(`[云同步V2] 恢复 ${backupType} 备份失败:`, err);
                    showCustomAlert('❌ 云端恢复失败', err.message || '未知错误');
                }
            }


            /**
             * 【全新】打开并渲染备份版本选择模态框
             */
            async function openRestoreVersionSelector() {
                const modal = document.getElementById('restore-version-modal');
                const listEl = document.getElementById('restore-version-list');

                modal.classList.add('visible');
                listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">正在从云端获取备份信息...</p>';

                try {
                    const response = await fetch('/api/data/list');
                    if (!response.ok) {
                        throw new Error(`获取备份列表失败: ${response.status}`);
                    }
                    const versions = await response.json();
                    listEl.innerHTML = ''; // 清空加载提示

                    const createCard = (type, info) => {
                        const card = document.createElement('div');
                        card.className = 'list-item'; // 复用现有的列表项样式
                        card.style.cursor = 'pointer';

                        const typeText = type === 'manual' ? '手动备份' : '自动备份';
                        const date = new Date(info.timestamp);
                        const dateString = date.toLocaleString('zh-CN', {
                            year: 'numeric', month: '2-digit', day: '2-digit',
                            hour: '2-digit', minute: '2-digit'
                        });
                        const sizeString = (info.size / 1024).toFixed(1) + ' KB';
                        const deviceId = info.sourceDeviceId ? info.sourceDeviceId.substring(0, 15) + '...' : '未知设备';

                        card.innerHTML = `
                <div class="item-title" style="display:flex; justify-content:space-between;">
                    <span>☁️ ${typeText}</span>
                    <span style="font-weight:normal; font-size:14px; color:var(--text-secondary);">${sizeString}</span>
                </div>
                <div class="item-content">
                    备份于 ${dateString}<br>
                    来自设备: ${deviceId}
                </div>
            `;
                        card.addEventListener('click', () => {
                            modal.classList.remove('visible');
                            restoreDataFromServer(type);
                        });
                        return card;
                    };

                    if (versions.manual && versions.manual.timestamp) {
                        listEl.appendChild(createCard('manual', versions.manual));
                    }
                    if (versions.auto && versions.auto.timestamp) {
                        listEl.appendChild(createCard('auto', versions.auto));
                    }

                    if ((!versions.manual || !versions.manual.timestamp) && (!versions.auto || !versions.auto.timestamp)) {
                        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">云端没有任何备份文件。</p>';
                    }

                } catch (err) {
                    listEl.innerHTML = `<p style="text-align:center; color: #ff3b30;">获取备份信息失败: ${err.message}</p>`;
                }
            }


            /**
             * 智能节流备份（15秒无操作后自动保存）
             */
            let backupTimer = null;
            function markForBackup() {
                if (backupTimer) clearTimeout(backupTimer);
                backupTimer = setTimeout(() => {
                    // 自动备份总是调用 'auto' 类型
                    backupDataToServer('auto', false)
                        .catch(e => console.warn('[云同步V2] 自动备份失败:', e));
                }, 15000);
            }

            // --- 事件绑定 ---
            // 手动备份按钮
            document.getElementById('cloud-backup-manual-btn').addEventListener('click', () => backupDataToServer('manual', true));

            // 从云端恢复按钮（打开选择器）
            document.getElementById('cloud-restore-select-btn').addEventListener('click', openRestoreVersionSelector);

            // 备份版本选择弹窗的取消按钮
            document.getElementById('cancel-restore-version-btn').addEventListener('click', () => {
                document.getElementById('restore-version-modal').classList.remove('visible');
            });

            // 启动自动备份的监听 - DISABLED FOR DEVELOPMENT
            // ['input', 'change', 'click'].forEach(event => {
            //     document.addEventListener(event, markForBackup, { passive: true });
            // });

            // ===================================================================
            // 5. 启动！
            // ===================================================================
            showScreen('home-screen');
            init();

            // Enable background mode to prevent database connection issues
            document.addEventListener('deviceready', function () {
                if (window.cordova && cordova.plugins && cordova.plugins.backgroundMode) {
                    cordova.plugins.backgroundMode.enable();
                    console.log('Background mode enabled to maintain database connections');
                }
            }, false);
        });
    </script>

    <script>
        // Floating Phone Charm Functionality
        class FloatingPhoneCharm {
            constructor() {
                this.charm = document.getElementById('floating-phone-charm');
                this.isDragging = false;
                this.longPressTimer = null;
                this.longPressDelay = 1000; // 1000ms for long press
                this.dragStartX = 0;
                this.dragStartY = 0;
                this.charmStartX = 0;
                this.charmStartY = 0;
                this.originalPosition = null; // Store original position for bounce back

                this.init();
            }

            init() {
                // Load saved position
                this.loadPosition();

                // Store original position after loading
                this.storeOriginalPosition();

                // Add event listeners
                this.charm.addEventListener('touchstart', this.handleStart.bind(this), { passive: false });
                document.addEventListener('touchmove', this.handleMove.bind(this), { passive: false });
                document.addEventListener('touchend', this.handleEnd.bind(this), { passive: false });

                // Mouse events for desktop testing
                this.charm.addEventListener('mousedown', this.handleStart.bind(this));
                document.addEventListener('mousemove', this.handleMove.bind(this));
                document.addEventListener('mouseup', this.handleEnd.bind(this));

                // Prevent context menu
                this.charm.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            storeOriginalPosition() {
                const rect = this.charm.getBoundingClientRect();
                this.originalPosition = {
                    left: rect.left,
                    top: rect.top
                };
            }

            handleStart(e) {
                e.preventDefault();

                const touch = e.touches ? e.touches[0] : e;
                this.dragStartX = touch.clientX;
                this.dragStartY = touch.clientY;

                // Get charm's current position
                const rect = this.charm.getBoundingClientRect();
                this.charmStartX = rect.left;
                this.charmStartY = rect.top;

                // Start long press timer
                this.longPressTimer = setTimeout(() => {
                    this.startDrag();
                }, this.longPressDelay);
            }

            handleMove(e) {
                if (!this.isDragging) {
                    // Cancel long press if moved too much before long press completes
                    const touch = e.touches ? e.touches[0] : e;
                    const deltaX = Math.abs(touch.clientX - this.dragStartX);
                    const deltaY = Math.abs(touch.clientY - this.dragStartY);

                    if (deltaX > 10 || deltaY > 10) {
                        clearTimeout(this.longPressTimer);
                    }
                    return;
                }

                e.preventDefault();
                const touch = e.touches ? e.touches[0] : e;

                // Calculate how much the finger has moved from the start
                const deltaX = touch.clientX - this.dragStartX;
                const deltaY = touch.clientY - this.dragStartY;

                // Update charm position relative to where it started
                const newLeft = this.charmStartX + deltaX;
                const newTop = this.charmStartY + deltaY;

                this.charm.style.left = newLeft + 'px';
                this.charm.style.top = newTop + 'px';
                this.charm.style.right = 'auto';
                this.charm.style.bottom = 'auto';
            }

            handleEnd(e) {
                clearTimeout(this.longPressTimer);

                if (this.isDragging) {
                    this.endDrag();
                }
            }

            startDrag() {
                this.isDragging = true;
                this.charm.classList.add('dragging');

                // Add visual feedback
                if (navigator.vibrate) {
                    navigator.vibrate(50); // Haptic feedback
                }
            }

            endDrag() {
                this.isDragging = false;
                this.charm.classList.remove('dragging');

                // Check if charm is off-screen and bounce back if needed
                if (this.isOffScreen()) {
                    this.bounceBack();
                } else {
                    // Save current position if it's valid
                    this.savePosition();
                    this.storeOriginalPosition(); // Update original position
                }
            }

            isOffScreen() {
                const rect = this.charm.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const minVisible = 50; // Minimum pixels that should remain visible

                return (
                    rect.right < minVisible || // Too far left
                    rect.left > viewportWidth - minVisible || // Too far right
                    rect.bottom < minVisible || // Too far up
                    rect.top > viewportHeight - minVisible // Too far down
                );
            }

            bounceBack() {
                // Add bounce animation
                this.charm.style.transition = 'all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55)';

                // Return to original position
                this.charm.style.left = this.originalPosition.left + 'px';
                this.charm.style.top = this.originalPosition.top + 'px';

                // Remove transition after animation
                setTimeout(() => {
                    this.charm.style.transition = 'transform 0.2s ease';
                }, 300);
            }

            savePosition() {
                const rect = this.charm.getBoundingClientRect();
                const position = {
                    left: rect.left,
                    top: rect.top
                };
                localStorage.setItem('phoneCharmPosition', JSON.stringify(position));
            }

            loadPosition() {
                const saved = localStorage.getItem('phoneCharmPosition');
                if (saved) {
                    try {
                        const position = JSON.parse(saved);
                        this.charm.style.left = position.left + 'px';
                        this.charm.style.top = position.top + 'px';
                        this.charm.style.right = 'auto';
                        this.charm.style.bottom = 'auto';
                    } catch (e) {
                        console.log('Failed to load charm position:', e);
                    }
                }
            }
        }

        // Initialize floating charm when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            window.floatingCharmInstance = new FloatingPhoneCharm();

            // Initialize charm visibility from localStorage
            const savedVisibility = localStorage.getItem('charmVisibility');
            const isVisible = savedVisibility !== 'false'; // Default to true

            // Check if function exists before calling
            if (typeof window.toggleCharmVisibility === 'function') {
                window.toggleCharmVisibility(isVisible);
            } else {
                console.error('DEBUG - toggleCharmVisibility function not found');
            }
        });
    </script>
</body>

</html>