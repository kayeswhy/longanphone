<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>EPhone - Browser Version</title>
    
    <!-- PWA Manifest and Meta Tags -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#000000">
    <meta name="background-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="EPhone">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="EPhone">
    <meta name="msapplication-TileColor" content="#000000">
    <meta name="msapplication-tap-highlight" content="no">
    
    <!-- Apple Touch Icons -->
    <link rel="apple-touch-icon" href="res/icon/android/hdpi.png">
    <link rel="apple-touch-icon" sizes="72x72" href="res/icon/android/hdpi.png">
    <link rel="apple-touch-icon" sizes="96x96" href="res/icon/android/xhdpi.png">
    <link rel="apple-touch-icon" sizes="144x144" href="res/icon/android/xxhdpi.png">
    <link rel="apple-touch-icon" sizes="192x192" href="res/icon/android/xxxhdpi.png">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="32x32" href="res/icon/android/mdpi.png">
    <link rel="icon" type="image/png" sizes="16x16" href="res/icon/android/ldpi.png">
    <link rel="shortcut icon" href="res/icon/android/mdpi.png">
    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>
    
    <!-- Browser Compatibility Layer - Load BEFORE Cordova scripts -->
    <script src="js/browser-compatibility.js"></script>
    
    <!-- Enhanced Spotify OAuth Fix for Browsers -->
    <script>
        console.log('ğŸµ Loading Spotify OAuth browser fix...');
        
        // Enhanced Spotify OAuth handling for browsers
        (function() {
            // Check for Spotify callback on page load
            function handleSpotifyCallback() {
                const urlParams = new URLSearchParams(window.location.search);
                const code = urlParams.get('code');
                const error = urlParams.get('error');
                
                if (code || error) {
                    console.log('ğŸµ Spotify OAuth callback detected');
                    
                    // Clean up URL
                    const cleanUrl = window.location.origin + window.location.pathname;
                    window.history.replaceState({}, document.title, cleanUrl);
                    
                    if (error) {
                        console.error('ğŸµ Spotify OAuth error:', error);
                        alert('Spotifyæˆæƒå¤±è´¥: ' + error);
                        return;
                    }
                    
                    if (code) {
                        console.log('ğŸµ Spotify authorization code received:', code.substring(0, 20) + '...');
                        
                        // Try to find and call the token exchange function
                        if (window.exchangeCodeForToken) {
                            window.exchangeCodeForToken(code);
                        } else if (window.handleSpotifyCallback) {
                            window.handleSpotifyCallback(code);
                        } else {
                            // Store the code for later use
                            localStorage.setItem('spotify_auth_code', code);
                            console.log('ğŸµ Stored Spotify code for later processing');
                        }
                    }
                }
            }
            
            // Override window.open to fix Spotify OAuth URLs
            const originalWindowOpen = window.open;
            window.open = function(url, target, features) {
                console.log('ğŸµ window.open called with:', url);
                
                if (url && typeof url === 'string' && url.includes('accounts.spotify.com/authorize')) {
                    console.log('ğŸµ Detected Spotify OAuth URL, fixing redirect URI...');
                    
                    // Replace custom scheme with browser-compatible redirect
                    const browserRedirectUri = window.location.origin + window.location.pathname;
                    const fixedUrl = url.replace(
                        /redirect_uri=[^&]+/,
                        'redirect_uri=' + encodeURIComponent(browserRedirectUri)
                    );
                    
                    console.log('ğŸµ Original URL:', url);
                    console.log('ğŸµ Fixed URL:', fixedUrl);
                    
                    return originalWindowOpen.call(this, fixedUrl, target, features);
                }
                
                return originalWindowOpen.call(this, url, target, features);
            };
            
            // Also intercept location.href assignments
            let originalLocationHref = window.location.href;
            Object.defineProperty(window.location, 'href', {
                get: function() {
                    return originalLocationHref;
                },
                set: function(url) {
                    if (url && url.includes('accounts.spotify.com/authorize') && url.includes('lycheephone://')) {
                        console.log('ğŸµ Fixing Spotify redirect in location.href');
                        const browserRedirectUri = window.location.origin + window.location.pathname;
                        const fixedUrl = url.replace(
                            /redirect_uri=[^&]+/,
                            'redirect_uri=' + encodeURIComponent(browserRedirectUri)
                        );
                        originalLocationHref = fixedUrl;
                        window.location.replace(fixedUrl);
                    } else {
                        originalLocationHref = url;
                        window.location.replace(url);
                    }
                }
            });
            
            // Check for callback immediately and on DOM ready
            handleSpotifyCallback();
            
            document.addEventListener('DOMContentLoaded', function() {
                setTimeout(handleSpotifyCallback, 100);
            });
            
            // Make callback handler globally available
            window.handleSpotifyOAuthCallback = handleSpotifyCallback;
            
        })();
    </script>
    
    <!-- Browser-only mode - no cordova.js needed -->
    <script>
        console.log('ğŸŒ Browser mode - skipping cordova.js');
    </script>
    <script src="js/export.js"></script>
    <script src="https://sdk.scdn.co/spotify-player.js"></script>
    <style>
        :root {
            --secondary-bg: #ffffff;
            --border-color: #e0e0e0;
            --text-primary: #1f1f1f;
            --text-secondary: #8a8a8a;
            --accent-color: #007bff;
        }

        html {
            height: 100%;
            overflow: hidden;
        }

        body {
            height: 100%;
            overflow: hidden;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-weight: normal;
            background-color: var(--secondary-bg);
            display: block;
            box-sizing: border-box;
        }

        /* Disable all tap feedback and highlights */
        /* Disable tap feedback and highlights */
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }

        /* Disable text selection only for UI elements */
        .header,
        .back-btn,
        .action-btn,
        .save-btn,
        .app-icon,
        .nav-item,
        button,
        .form-button,
        .chat-action-icon-btn,
        .call-action-btn,
        .control-btn,
        .transfer-actions button,
        .music-controls button {
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Disable text selection specifically for modal dialogs */
        .modal,
        .modal-content,
        .modal-header,
        .modal-body,
        .modal-footer,
        #custom-modal-overlay,
        #custom-modal,
        .custom-modal-header,
        .custom-modal-body,
        .custom-modal-footer,
        .custom-modal-body p,
        .custom-modal-body span,
        .custom-modal-body div,
        .modal-body p,
        .modal-body span,
        .modal-body div {
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Ensure text selection is enabled for content areas */
        .message-bubble .content,
        .chat-messages,
        #chat-messages,
        .list-item,
        .world-book-content,
        .qzone-post-content,
        .favorite-item-content,
        input,
        textarea,
        p,
        span,
        div {
            -webkit-user-select: text;
            -khtml-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        #phone-frame {
            width: 100%;
            height: 100%;
            padding: 0;
            background-color: transparent;
            border-radius: 0;
            box-shadow: none;
            position: relative;
        }

        .notch {
            display: none;
        }

        #phone-screen {
            width: 100%;
            height: 100%;
            background-color: transparent;
            border-radius: 0;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        #status-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            z-index: 10;
            font-size: 14px;
            box-sizing: border-box;
            pointer-events: none;
        }

        #status-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            z-index: 10;
            font-size: 14px;
            box-sizing: border-box;
            pointer-events: none;
        }

        #status-bar-time {
            font-weight: 600;
        }

        .battery-container {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .battery-icon {
            width: 25px;
            height: 12px;
            border: 1px solid white;
            border-radius: 3px;
            position: relative;
            padding: 1px;
        }

        .battery-icon::after {
            content: '';
            position: absolute;
            right: -3px;
            top: 2px;
            width: 2px;
            height: 6px;
            background-color: white;
            border-radius: 0 1px 1px 0;
        }

        .battery-level {
            height: 100%;
            background-color: white;
            border-radius: 1px;
            transition: width 0.5s ease;
        }

        .battery-container.charging .battery-level {
            background-color: #4cd964;
            animation: charge-breath 2s infinite;
        }

        .battery-container.charging .battery-text {
            color: #4cd964;
        }

        @keyframes charge-breath {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }
        }

        .screen {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .screen.active {
            opacity: 1;
            visibility: visible;
            z-index: 1;
        }

        .header {
            position: relative;
            z-index: 15;
            flex-shrink: 0;
            padding: 15px 12px;
            padding-top: 15px;
            background-color: rgba(247, 247, 247, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 18px;
            font-weight: 600;
        }

        .header .header-actions {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .header .back-btn,
        .header .action-btn {
            font-size: 24px;
            cursor: pointer;
            width: 30px;
            text-align: center;
            color: var(--accent-color);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header .action-btn {
            font-size: 16px;
            /* ä¸“é—¨ä¸ºâ€œä¸Šä¼ â€ã€â€œ+â€ç­‰æ–‡å­—æŒ‰é’®ç¼©å°å­—å· */
            font-weight: 600;
            /* å¯ä»¥åŠ ç²—ä¸€ç‚¹è®©å®ƒæ›´æ¸…æ™° */
        }

        .header .action-btn img {
            height: 26px;
        }

        .header .save-btn {
            font-size: 16px;
            color: var(--accent-color);
            font-weight: 600;
            cursor: pointer;
        }

        #home-screen {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            padding: 20px;
            padding-top: 88px;
            padding-bottom: 50px;
            box-sizing: border-box;
            background-size: cover;
            background-position: center;
        }

        #clock-container {
            text-align: center;
            color: white;
            text-shadow: 0 3px 8px rgba(0, 0, 0, 0.4);
            margin-bottom: 20px;
            flex-shrink: 0;
        }

        #main-time {
            font-size: 80px;
            font-weight: 200;
        }

        #main-date {
            font-size: 18px;
            font-weight: 500;
        }

        #app-grid {
            margin-top: auto;
            margin-bottom: -24px;
            /* Move 24px closer to bottom edge */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
            padding: 20px;
        }

        .app-row {
            display: flex;
            justify-content: center;
            gap: 22px;
            width: 100%;
            position: relative;
        }

        /* iPhone-style blur dock container */
        .app-dock-blur {
            position: absolute;
            top: -20px;
            bottom: -12px;
            left: 50%;
            transform: translateX(-50%);
            width: 370px;
            /* 4 apps (240px) + 3 gaps (66px) + 32px left + 32px right = 370px */
            background-color: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 25px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: -1;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .app-icon {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            color: white;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
            font-size: 14px;
            font-weight: 500;
            text-align: center;
        }

        .app-icon .icon-bg {
            width: 65px;
            height: 65px;
            border-radius: 18px;
            background-color: rgb(247, 247, 247);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 32px;
            margin-bottom: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            /* transition: transform 0.2s ease; - Removed to disable tap feedback */
            overflow: hidden;
            opacity: 1;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        .app-icon:active .icon-bg {
            /* Tap feedback removed */
        }

        .app-icon .icon-bg img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .app-icon .label {
            color: white;
        }

        .form-container,
        .list-container {
            padding: 20px;
            overflow-y: auto;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        /* Specific alignment fix for appearance settings screen only */
        #appearance-settings-screen .form-group label {
            margin-left: -20px;
        }

        /* Toggle Switch Component */
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: var(--accent-color);
        }

        input:checked+.slider:before {
            transform: translateX(26px);
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 16px;
            box-sizing: border-box;
        }

        .form-group textarea {
            min-height: 80px;
            resize: vertical;
        }

        #world-book-content-input {
            height: calc(100% - 120px);
        }

        .form-button {
            width: 100%;
            padding: 15px;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 10px;
        }

        .form-button-secondary {
            background-color: #f0f0f0;
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        /* Toggle switch styles */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 28px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked+.toggle-slider {
            background-color: var(--accent-color);
        }

        input:checked+.toggle-slider:before {
            transform: translateX(22px);
        }

        #wallpaper-screen .form-container {
            align-items: center;
        }

        /* App icon customization styles */
        #app-icon-customization-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: calc(100vw - 40px);
            margin-left: -20px;
            margin-right: -20px;
        }

        .app-icon-item {
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--secondary-bg);
            box-sizing: border-box;
        }

        .app-icon-preview {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .app-icon-preview img {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            object-fit: cover;
        }

        .app-icon-preview span {
            font-weight: 500;
            color: var(--text-primary);
        }

        .app-icon-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            background: var(--primary-bg);
            color: var(--text-primary);
            box-sizing: border-box;
        }

        .app-icon-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .app-icon-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .app-icon-btn.primary {
            background: var(--accent-color);
            color: white;
        }

        .app-icon-btn.secondary {
            background: #6c757d;
            color: white;
        }

        #wallpaper-preview {
            width: 180px;
            height: 320px;
            border: 2px dashed var(--border-color);
            background-color: #f0f2f5;
            margin-bottom: 20px;
            background-size: cover;
            background-position: center;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--text-secondary);
        }

        #wallpaper-upload-input {
            display: none;
        }

        /* ä¿®æ”¹åçš„ #world-book-list æ ·å¼ */
        #world-book-list {
            flex-grow: 1;
            overflow-y: auto;
            background-color: var(--secondary-bg);
            padding-top: 60px;
            margin-top: -60px;
        }

        /* ä¿®æ”¹åçš„ #chat-list æ ·å¼ï¼Œå»æ‰äº† padding å’Œ margin */
        #chat-list {
            flex-grow: 1;
            background-color: var(--secondary-bg);
            padding-top: 52px;
            padding-bottom: 50px;
            /* ä¸ºåº•éƒ¨å¯¼èˆªæ ç•™å‡ºç©ºé—´ */
            box-sizing: border-box;
        }

        .list-item {
            display: flex;
            flex-direction: column;
            padding: 12px 20px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
        }

        .list-item:hover {
            background-color: #f5f5f5;
        }

        .list-item.no-hover:hover {
            background-color: transparent;
        }

        .list-item .item-title {
            font-weight: 500;
            font-size: 16px;
            margin-bottom: 5px;
        }

        .list-item .item-content {
            font-size: 14px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .list-item.loading {
            opacity: 0.5 !important;
            pointer-events: none !important;
            position: relative;
        }

        /* Loading Hourglass for World Book */
        .worldbook-loading-hourglass {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 24px;
            z-index: 10;
        }

        @keyframes spin {
            0% { transform: translateY(-50%) rotate(0deg); }
            100% { transform: translateY(-50%) rotate(360deg); }
        }



        .chat-list-item {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            position: relative;
        }

        .chat-list-item:hover {
            background-color: #f5f5f5;
        }

        .chat-list-item .avatar {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            margin-right: 12px;
            object-fit: cover;
            background-color: #ccc;
        }

        .chat-list-item .info {
            flex-grow: 1;
            overflow: hidden;
        }

        .chat-list-item .name-line {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 2px;
        }

        .chat-list-item .name {
            font-weight: 500;
            color: var(--text-primary);
        }

        .chat-list-item .group-tag {
            font-size: 10px;
            color: var(--accent-color);
            background-color: #e7f3ff;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
            flex-shrink: 0;
        }

        .chat-list-item .last-msg {
            font-size: 13px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            /* max-width å°†ç”±flexboxè‡ªåŠ¨ç®¡ç†ï¼Œä¸å†éœ€è¦å›ºå®šå€¼ */
        }

        /* ---ã€å…¨æ–°ã€‘å³ä¾§å…ƒä¿¡æ¯åŒºï¼šæ—¶é—´å’ŒçŠ¶æ€ç¯ --- */
        .chat-list-item .meta {
            margin-left: 10px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            /* å†…éƒ¨å…ƒç´ é å³å¯¹é½ */
        }

        .chat-list-item .timestamp {
            font-size: 12px;
            color: #b0b0b0;
            margin-bottom: 8px;
        }

        .chat-list-item .status-light {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .chat-list-item .status-light.unread {
            background-color: #ff3b30;
            /* çº¢è‰² */
        }

        .chat-list-item .status-light.generating {
            background-color: #ffcc00;
            /* é»„è‰² */
            animation: pulse 1.5s infinite;
        }

        /* Pinned chat styling */
        .chat-list-item.pinned {
            background-color: #f8f9fa;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.4;
            }

            100% {
                opacity: 1;
            }
        }

        #chat-interface-screen {
            background-size: cover;
            background-position: center;
            position: relative;
        }

        #selection-cancel-btn,
        #selection-delete-btn {
            font-size: 16px;
            color: var(--accent-color);
            cursor: pointer;
            padding: 5px;
        }

        #selection-delete-btn {
            color: #ff3b30;
        }

        /* â–¼â–¼â–¼ ç”¨è¿™å—ä»£ç æ›¿æ¢æ‰ä½ åŸæ¥çš„ #chat-messages æ ·å¼ â–¼â–¼â–¼ */
        #chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            overflow-x: hidden;
            /* æ ¸å¿ƒä¿®æ­£1: å¼ºåˆ¶ç¦æ­¢æ°´å¹³æ»šåŠ¨/æ‹–åŠ¨ */
            padding: 10px 15px;
            /* æ ¸å¿ƒä¿®æ­£2: å°†å·¦å³å†…è¾¹è·å¢åŠ åˆ°15pxï¼Œæä¾›æ›´å¤šå‘¼å¸ç©ºé—´ */
            padding-top: 110px;
            margin-top: -80px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-sizing: border-box;
            /* ç¡®ä¿å†…è¾¹è·è®¡ç®—æ­£ç¡® */
        }

        /* â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–² */
        #load-more-btn {
            text-align: center;
            padding: 10px;
            color: var(--accent-color);
            font-size: 14px;
            cursor: pointer;
            background-color: transparent;
            border: none;
            width: 100%;
        }

        #load-more-btn:hover {
            text-decoration: underline;
        }

        .sender-name {
            font-size: 11px;
            color: #666;
            margin-bottom: 3px;
        }

        .message-wrapper.ai .sender-name {
            margin-left: 50px;
            /* ç¨å¾®è°ƒæ•´ï¼Œä¸å¤´åƒå¯¹é½ */
            margin-bottom: 3px;
            position: absolute;
            /* è®©å®ƒè„±ç¦»æµï¼Œé¿å…å½±å“æ°”æ³¡å¯¹é½ */
            top: -16px;
            /* å®šä½åˆ°æ°”æ³¡ä¸Šæ–¹ */
            left: 0;
        }

        /* === ã€å…¨æ–°ã€‘æ¶ˆæ¯å¸ƒå±€ä¸æ—¶é—´æˆ³æ ·å¼ === */

        /* 1. æ¶ˆæ¯å•å…ƒçš„æ€»å®¹å™¨ (é‡æ„) */
        .message-wrapper {
            display: flex;
            /* ä½¿ç”¨Flexå¸ƒå±€ */
            gap: 8px;
            /* æ°”æ³¡å’Œæ—¶é—´æˆ³ä¹‹é—´çš„é—´è· */
            align-items: flex-end;
            /* æ ¸å¿ƒï¼šè®©æ°”æ³¡å’Œæ—¶é—´æˆ³åº•éƒ¨å¯¹é½ */
            position: relative;
            max-width: 90%;
            /* å¯ä»¥ç¨å¾®æ”¾å®½ä¸€ç‚¹ï¼Œå› ä¸ºæ—¶é—´æˆ³ç°åœ¨åœ¨å¤–é¢äº† */
        }

        /* 2. AIæ¶ˆæ¯å•å…ƒé å·¦ */
        .message-wrapper.ai {
            align-self: flex-start;
            flex-direction: row;
            /* å¤´åƒã€æ°”æ³¡ã€æ—¶é—´æˆ³ï¼Œä»å·¦åˆ°å³æ’åˆ— */
        }

        /* 3. ç”¨æˆ·æ¶ˆæ¯å•å…ƒé å³ */
        .message-wrapper.user {
            align-self: flex-end;
            flex-direction: row-reverse;
            /* æ—¶é—´æˆ³ã€æ°”æ³¡ã€å¤´åƒï¼Œä»å³åˆ°å·¦æ’åˆ— */
        }

        /* 4. æ°”æ³¡å’Œå¤´åƒçš„ç›´æ¥å®¹å™¨ (ä¿æŒä¸å˜) */
        .message-bubble {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            max-width: 100%;
        }

        .timestamp {
            /* ç§»é™¤æ—§çš„ position: absolute */
            font-size: 11px;
            color: #999;
            text-shadow: 0 0 3px rgba(255, 255, 255, 0.6);
            white-space: nowrap;
            /* é˜²æ­¢æ—¶é—´æ¢è¡Œ */
            margin-bottom: 5px;
            /* è®©å®ƒå’Œæ°”æ³¡åº•éƒ¨æœ‰è½»å¾®çš„å¯¹é½åç§»ï¼Œæ›´ç¾è§‚ */
            flex-shrink: 0;
            /* é˜²æ­¢è¢«å‹ç¼© */
        }

        .message-bubble.selected::after {
            content: 'âœ”';
            position: absolute;
            left: -10px;
            top: 50%;
            transform: translateY(-50%);
            background-color: var(--accent-color);
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .message-bubble.user.selected::after {
            left: auto;
            right: -10px;
        }

        .message-bubble.user {
            flex-direction: row-reverse;
        }

        #typing-indicator {
            align-self: flex-start;
            display: none;
            margin: 0 10px 10px;
            color: var(--text-secondary);
        }

        #meetup-typing-indicator {
            align-self: center;
            display: none;
            margin: 0 10px 10px;
            color: var(--text-secondary);
            font-size: 14px;
            opacity: 0.7;
            text-align: center;
        }

        #chat-input-area {
            flex-shrink: 0;
            padding: 8px;
            background-color: rgba(247, 247, 247, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        /* å›å¤é¢„è§ˆæ æ ·å¼ */
        #reply-preview-bar {
            display: none;
            background-color: #f0f0f0;
            padding: 8px 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            border-left: 3px solid var(--accent-color);
            justify-content: space-between;
            align-items: flex-start;
        }

        #reply-preview-bar .reply-preview-content {
            flex-grow: 1;
        }

        #reply-preview-bar .sender {
            font-size: 12px;
            color: var(--accent-color);
            font-weight: 600;
            margin-bottom: 2px;
        }

        #reply-preview-bar .text {
            font-size: 14px;
            color: var(--text-secondary);
            max-height: 40px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #reply-preview-bar #cancel-reply-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            padding: 0;
            margin-left: 8px;
        }

        #chat-input-main-row {
            display: flex;
            align-items: flex-end;
            gap: 8px;
            width: 100%;
        }

        #chat-input {
            flex-grow: 1;
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            background-color: var(--secondary-bg);
            font-size: 16px;
            max-height: 100px;
            resize: none;
        }

        .action-button {
            border: none;
            color: white;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            flex-shrink: 0;
        }

        #send-btn {
            background-color: var(--accent-color);
            height: 40px;
            padding: 0 15px;
        }

        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .modal.visible {
            display: flex;
        }

        .modal-content {
            width: 90%;
            max-height: 90%;
            background-color: white;
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .modal-header {
            padding: 15px;
            font-weight: 600;
            border-bottom: 1px solid var(--border-color);
            text-align: center;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .modal-body {
            padding: 15px;
            overflow-y: auto;
        }

        .modal-footer {
            padding: 15px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-around;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .modal-footer button {
            width: 45%;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid var(--accent-color);
            cursor: pointer;
            font-size: 16px;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .modal-footer .save {
            background-color: var(--accent-color);
            color: white;
        }

        .modal-footer .cancel {
            background-color: white;
            color: var(--accent-color);
        }

        .avatar-upload {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .avatar-upload img {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            background-color: #eee;
        }

        .avatar-upload button {
            padding: 8px 12px;
            border: 1px solid #ccc;
            background-color: #f0f0f0;
            border-radius: 5px;
            cursor: pointer;
        }

        #open-persona-library-btn {
            font-size: 14px;
            padding: 6px 10px;
            margin-left: auto;
        }

        .avatar-upload input[type="file"] {
            display: none;
        }

        /* Border Preview Component */
        .border-preview-container {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f9f9f9;
            margin-right: 15px;
        }

        .border-preview {
            width: 50px;
            height: 50px;
            object-fit: contain;
        }

        .no-border-text {
            font-size: 12px;
            color: #999;
            text-align: center;
        }

        .theme-selector label {
            display: inline-flex;
            align-items: center;
            margin-right: 15px;
            margin-bottom: 5px;
            cursor: pointer;
        }

        #reset-theme-btn {
            background: none;
            border: 1px solid #ccc;
            color: #555;
            font-size: 12px;
            padding: 2px 8px;
            border-radius: 5px;
            cursor: pointer;
            margin-left: 10px;
        }

        #group-members-settings {
            display: flex;
            overflow-x: auto;
            padding-bottom: 10px;
            gap: 15px;
        }

        .member-editor {
            text-align: center;
            cursor: pointer;
        }

        .member-editor img {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            background-color: #eee;
            margin-bottom: 5px;
        }

        .member-editor .member-name {
            font-size: 12px;
        }

        #notification-bar {
            position: absolute;
            top: 40px;
            left: 50%;
            width: 90%;
            z-index: 500;
            background-color: rgba(250, 250, 250, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            transform: translateX(-50%) translateY(-150%);
            transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            visibility: hidden;
        }

        #notification-bar.visible {
            /* å…³é”®ï¼šåœ¨Yè½´å›åˆ°åŸä½çš„åŒæ—¶ï¼Œä¿æŒXè½´çš„å±…ä¸­å˜æ¢ */
            transform: translateX(-50%) translateY(0);
            visibility: visible;
        }

        #notification-avatar {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            object-fit: cover;
        }

        #notification-content .name {
            font-weight: 600;
            font-size: 15px;
            color: #000;
        }

        #notification-content .message {
            font-size: 14px;
            color: #555;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
        }

        .sticker-image {
            max-width: 100px;
            max-height: 100px;
            display: block;
            object-fit: contain;
        }

        /* Enhanced sticker bubble styles - completely immune to custom bubble CSS */
        .message-bubble.is-sticker {
            background: none !important;
            border: none !important;
            box-shadow: none !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
            padding: 0 !important;
            margin: 0 !important;
            border-radius: 0 !important;
        }

        .message-bubble.is-sticker .content,
        .message-bubble.is-voice-message .content {
            padding: 0 !important;
            background-color: transparent !important;
            box-shadow: none !important;
            border: none !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
            border-radius: 0 !important;
        }

        /* â–¼â–¼â–¼ ã€å…¨æ–°ã€‘æ’¤å›æ¶ˆæ¯æ ·å¼ â–¼â–¼â–¼ */

        /* 1. æ’¤å›æ¶ˆæ¯çš„å ä½ç¬¦æ ·å¼ */
        .recalled-message-placeholder {
            align-self: center;
            /* å±…ä¸­æ˜¾ç¤º */
            padding: 4px 12px;
            margin: 5px 0;
            background-color: rgba(0, 0, 0, 0.1);
            color: var(--text-secondary);
            font-size: 12px;
            border-radius: 10px;
            text-align: center;
            max-width: 80%;
            cursor: pointer;
            /* è®©å®ƒçœ‹èµ·æ¥å¯ä»¥ç‚¹å‡» */
        }

        /* 2. å¤œé—´æ¨¡å¼ä¸‹çš„é€‚é… */
        #phone-screen.dark-mode .recalled-message-placeholder {
            background-color: rgba(255, 255, 255, 0.15);
        }

        /* 3. AIæ’¤å›æ¶ˆæ¯æ—¶çš„åŠ¨ç”»æ•ˆæœ */
        @keyframes recall-animation {
            from {
                opacity: 1;
                transform: scale(1);
            }

            to {
                opacity: 0;
                transform: scale(0.8);
            }
        }

        .message-wrapper.recalled-animation {
            animation: recall-animation 0.3s ease-out forwards;
        }

        /* å¼ºåˆ¶æ’¤å›æ¶ˆæ¯çš„å ä½ç¬¦ä¸æ¢è¡Œï¼Œå¹¶ä¿æŒå†…å®¹å±…ä¸­ */
        .recalled-message-placeholder {
            white-space: nowrap;
            /* æ ¸å¿ƒï¼šç¦æ­¢æ–‡æœ¬æ¢è¡Œ */
            display: inline-block;
            /* è®©èƒŒæ™¯æ ¹æ®å†…å®¹è‡ªé€‚åº”å®½åº¦ */
            padding: 4px 12px;
        }

        /* â–²â–²â–² æ’¤å›æ¶ˆæ¯æ ·å¼ç»“æŸ â–²â–²â–² */

        /* å¼•ç”¨æ¶ˆæ¯æ ·å¼ */
        .quoted-message {
            background-color: rgba(0, 123, 255, 0.1);
            border-left: 3px solid var(--accent-color);
            padding: 8px;
            margin-bottom: 8px;
            border-radius: 4px;
            font-size: 13px;
        }

        .quoted-sender {
            color: var(--accent-color);
            font-weight: 600;
            margin-bottom: 2px;
        }

        .quoted-content {
            color: var(--text-secondary);
        }

        #chat-input-actions-top {
            display: flex;
            gap: 8px;
            padding: 0 5px;
        }

        .chat-action-icon-btn {
            font-size: 24px;
            padding: 0;
            width: 38px;
            height: 38px;
            line-height: 38px;
            text-align: center;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.5);
            color: var(--text-primary);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid rgba(0, 0, 0, 0.05);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Override action-button font-size for chat action buttons */
        #chat-input-actions-top .action-button {
            font-size: 24px;
        }

        /* Ensure consistent BUTTON sizing only - no icon changes */
        #chat-input-actions-top .chat-action-icon-btn {
            width: 38px;
            height: 38px;
            box-sizing: border-box;
        }

        #sticker-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 50%;
            background-color: rgba(242, 242, 247, 0.85);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-top: 1px solid var(--border-color);
            border-radius: 20px 20px 0 0;
            z-index: 200;
            display: flex;
            flex-direction: column;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            visibility: hidden;
        }

        #sticker-panel.visible {
            transform: translateY(0);
            visibility: visible;
        }

        #sticker-panel-header {
            padding: 10px 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
            border-bottom: 1px solid var(--border-color);
            position: relative;
        }

        #sticker-panel-header .panel-btn {
            font-size: 16px;
            padding: 5px 10px;
            cursor: pointer;
            color: var(--accent-color);
            position: absolute;
        }

        #sticker-panel-header .panel-btn:first-child {
            left: 20px;
        }

        #sticker-panel-header .panel-btn:last-child,
        #sticker-panel-header #edit-sticker-pack-btn,
        #sticker-panel-header #exit-pack-arrange-btn {
            right: 20px;
            left: auto;
        }

        #sticker-panel-header .title {
            font-weight: 600;
        }

        #sticker-grid {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
            padding-bottom: 10px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 15px;
        }

        .sticker-item {
            position: relative;
            aspect-ratio: 1 / 1;
            border-radius: 10px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            cursor: pointer;
        }

        .sticker-item .delete-btn {
            display: none;
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            background-color: #ff3b30;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 20px;
            font-size: 14px;
            cursor: pointer;
            border: 2px solid white;
        }

        /* Sticker Pack Tabs */
        #sticker-pack-tabs {
            display: flex;
            align-items: center;
            padding: 8px 15px;
            background-color: rgba(255, 255, 255, 0.3);
            border-top: 1px solid var(--border-color);
            flex-shrink: 0;
            overflow-x: auto;
            gap: 8px;
        }

        .sticker-pack-tab {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background-color: transparent;
            cursor: pointer;
            transition: all 0.2s ease;
            flex-shrink: 0;
            border: 1px solid transparent;
        }

        .sticker-pack-tab:hover {
            background-color: rgba(221, 221, 221, 0.5);
        }

        .sticker-pack-tab.active {
            background-color: #dddddd;
            border-color: transparent;
        }

        .sticker-pack-tab .pack-icon {
            font-size: 32px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sticker-pack-tab .pack-icon svg {
            width: 24px;
            height: 24px;
        }

        .sticker-pack-tab .pack-icon img {
            width: 32px;
            height: 32px;
            border-radius: 4px;
            object-fit: cover;
        }

        .sticker-pack-tab.active .pack-icon {
            filter: none;
        }

        .sticker-pack-tab.active .pack-icon img {
            filter: none;
            border: none;
        }

        /* Add Pack Button */
        .sticker-pack-tab.add-pack-btn {
            background-color: #cccccc;
        }

        .sticker-pack-tab.add-pack-btn:hover {
            background-color: #bbbbbb;
        }

        /* Hide scrollbar for pack tabs */
        #sticker-pack-tabs::-webkit-scrollbar {
            display: none;
        }

        #sticker-pack-tabs {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* Add Sticker Square */
        .add-sticker-square {
            position: relative;
            aspect-ratio: 1 / 1;
            background-color: #cccccc;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
        }

        .add-sticker-square:hover {
            background-color: #bbbbbb;
        }

        .add-sticker-square svg {
            width: 24px;
            height: 24px;
            color: #666666;
        }



        #input-actions-wrapper {
            position: static;
            display: flex;
            align-items: flex-end;
            gap: 8px;
            flex-shrink: 0;
        }

        #wait-reply-btn {
            position: static;
            bottom: auto;
            right: auto;
            width: auto;
            height: 40px;
            padding: 0 10px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid rgba(0, 0, 0, 0.08);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            transition: opacity 0.2s, transform 0.1s;
            cursor: pointer;
        }

        #wait-reply-btn:hover {
            opacity: 0.8;
        }

        #wait-reply-btn:active {
            /* Tap feedback removed */
        }

        #wait-reply-btn img {
            height: 22px;
            display: block;
            margin: auto;
        }

        .chat-image {
            max-width: 100%;
            border-radius: 10px;
            display: block;
        }

        .qzone-post-item .chat-image {
            max-width: 50%;
            height: auto;
        }


        .message-bubble.has-image .content {
            padding: 5px;
        }

        #custom-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }

        #custom-modal-overlay.visible {
            display: flex;
            opacity: 1;
        }

        #custom-modal {
            background-color: #fff;
            width: 280px;
            border-radius: 14px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            transform: scale(0.95);
            transition: transform 0.2s ease-in-out;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        #custom-modal-overlay.visible #custom-modal {
            transform: scale(1);
        }

        .custom-modal-header {
            padding: 16px;
            font-size: 17px;
            font-weight: 600;
            text-align: center;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .custom-modal-body {
            padding: 0 16px 16px;
            text-align: center;
            font-size: 14px;
            color: #333;
            line-height: 1.5;
        }

        .custom-modal-body p {
            margin: 0;
            margin-bottom: 12px;
        }

        .custom-modal-body input {
            width: 100%;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #ccc;
            font-size: 14px;
            box-sizing: border-box;
        }

        .custom-modal-footer {
            display: flex;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .custom-modal-footer button {
            flex: 1;
            background: none;
            border: none;
            padding: 12px;
            font-size: 17px;
            cursor: pointer;
            color: var(--accent-color);
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .custom-modal-footer button:first-child {}

        .custom-modal-footer .confirm-btn {
            font-weight: 600;
        }

        .custom-modal-footer .confirm-btn.btn-danger {
            color: #ff3b30;
        }

        #preset-actions-modal .custom-modal-footer {
            flex-direction: column;
        }

        #preset-actions-modal .custom-modal-footer button {
            width: 100%;
            border: none;
            padding: 14px;
            font-size: 18px;
        }

        #preset-actions-modal .custom-modal-footer button:last-child {
            border-bottom: none;
        }

        /* Message actions modal - vertical layout for better fit */
        #message-actions-modal .custom-modal-footer {
            flex-direction: column;
        }

        #message-actions-modal .custom-modal-footer button {
            width: 100%;
            border: none;
            padding: 14px;
            font-size: 18px;
        }

        #message-actions-modal .custom-modal-footer button:last-child {
            border-bottom: none;
        }

        /* Post actions modal - vertical layout for better fit */
        #post-actions-modal .custom-modal-footer {
            flex-direction: column;
        }

        #post-actions-modal .custom-modal-footer button {
            width: 100%;
            border: none;
            padding: 14px;
            font-size: 18px;
        }

        #post-actions-modal .custom-modal-footer button:last-child {
            border-bottom: none;
        }

        /* Comment actions modal - vertical layout for better fit */
        #comment-actions-modal .custom-modal-footer {
            flex-direction: column;
        }

        #comment-actions-modal .custom-modal-footer button {
            width: 100%;
            border: none;
            padding: 14px;
            font-size: 18px;
        }

        #comment-actions-modal .custom-modal-footer button:last-child {
            border-bottom: none;
        }

        /* Bulletin actions modal - vertical layout for better fit */
        #bulletin-actions-modal .custom-modal-footer {
            flex-direction: column;
        }

        #bulletin-actions-modal .custom-modal-footer button {
            width: 100%;
            border: none;
            padding: 14px;
            font-size: 18px;
        }

        #bulletin-actions-modal .custom-modal-footer button:last-child {
            border-bottom: none;
        }

        /* Chat actions modal - vertical layout for better fit */
        #chat-actions-modal .custom-modal-footer {
            flex-direction: column;
        }

        #chat-actions-modal .custom-modal-footer button {
            width: 100%;
            border: none;
            padding: 14px;
            font-size: 18px;
        }

        #chat-actions-modal .custom-modal-footer button:last-child {
            border-bottom: none;
        }

        .custom-multiselect {
            position: relative;
            user-select: none;
        }

        .select-box {
            display: flex;
            align-items: center;
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 16px;
            box-sizing: border-box;
            background-color: #fff;
            cursor: pointer;
        }

        .select-box .selected-options-text {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: var(--text-primary);
        }

        .select-box .arrow-down {
            margin-left: auto;
            font-size: 10px;
            color: var(--text-secondary);
            transition: transform 0.2s;
        }

        .select-box.expanded .arrow-down {
            transform: rotate(180deg);
        }

        .checkboxes-container {
            display: none;
            position: absolute;
            /* æ ¸å¿ƒä¿®æ”¹ï¼šä¸å†ä½¿ç”¨ topï¼Œè€Œæ˜¯ç”¨ margin-top æ¥åˆ›é€ é—´è·ï¼Œæ›´ç¨³å®š */
            top: 100%;
            margin-top: 5px;
            /* <-- æ–°å¢ï¼šå‘ä¸‹æ¨å¼€5åƒç´ çš„è·ç¦» */
            left: 0;
            right: 0;
            max-height: 150px;
            overflow-y: auto;
            background-color: #fff;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            z-index: 101;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .checkboxes-container.visible {
            display: block;
        }

        .checkboxes-container label {
            display: block;
            padding: 10px 12px;
            cursor: pointer;
            font-weight: normal;
            color: var(--text-primary);
        }

        .checkboxes-container label {
            display: block;
            padding: 12px 15px;
            /* <-- ä¿®æ”¹ï¼šå¢åŠ äº†ä¸Šä¸‹å’Œå·¦å³çš„å†…è¾¹è·ï¼Œè®©æ¯ä¸€è¡Œæ›´é«˜æ›´å®½ */
            cursor: pointer;
            font-weight: normal;
            color: var(--text-primary);
            font-size: 15px;
            /* <-- æ–°å¢ï¼šå°†å­—ä½“å¤§å°ä»é»˜è®¤å€¼æ”¾å¤§åˆ°15px */
        }

        .checkboxes-container input {
            margin-right: 10px;
            vertical-align: middle;
        }

        .bg-upload-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .bg-preview-img {
            max-width: 120px;
            max-height: 80px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            object-fit: cover;
            display: none;
        }

        #remove-bg-btn {
            padding: 8px 12px;
            border: 1px solid #ff3b30;
            color: #ff3b30;
            background-color: #fff;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            display: none;
        }

        .message-bubble.is-ai-image .content {
            padding: 5px;
            background: transparent;
            box-shadow: none;
            border: none;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }

        .ai-generated-image {
            max-width: 180px;
            border-radius: 12px;
            display: block;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .ai-generated-image:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .voice-message-body {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 8px 12px;
            min-width: 80px;
            max-width: 200px;
        }

        .voice-waveform {
            display: flex;
            align-items: center;
            height: 20px;
            gap: 2px;
            flex-grow: 1;
            margin: 0 10px;
        }

        .voice-waveform div {
            width: 3px;
            background-color: currentColor;
            border-radius: 2px;
            animation: wave-quiet 1.5s ease-in-out infinite;
        }

        @keyframes wave-quiet {

            0%,
            100% {
                height: 2px;
            }

            50% {
                height: 10px;
            }
        }

        .voice-waveform div:nth-child(2) {
            animation-delay: 0.2s;
        }

        .voice-waveform div:nth-child(3) {
            animation-delay: 0.4s;
        }

        .voice-waveform div:nth-child(4) {
            animation-delay: 0.6s;
        }

        .voice-waveform div:nth-child(5) {
            animation-delay: 0.8s;
        }

        .voice-duration {
            /* --- æ ¸å¿ƒä¿®æ­£ --- */
            font-size: var(--chat-font-size, 13px);
            /* --- ä¿®æ­£ç»“æŸ --- */
            font-weight: 500;
            color: var(--text-secondary);
        }


        /* â–¼â–¼â–¼ ã€è¯­éŸ³æ¶ˆæ¯ä¼˜åŒ–Â·æœ€ç»ˆæ ·å¼ v3ã€‘ç²˜è´´åˆ°è¿™é‡Œ â–¼â–¼â–¼ */
        /* 1. ä½¿è¯­éŸ³æ°”æ³¡å†…å®¹å‚ç›´æ’åˆ—ï¼Œç¡®ä¿è¯­éŸ³æ¡å’Œæ–‡å­—åŒºç­‰å®½ (æ— å˜åŒ–) */
        .is-voice-message .content {
            display: flex;
            flex-direction: column;
            padding: 0;
        }

        /* 2. è¯­éŸ³æ¶ˆæ¯ä¸»ä½“æ ·å¼ (æ— å˜åŒ–) */
        .voice-message-body {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 8px 12px;
        }

        .message-bubble.user .voice-message-body {
            flex-direction: row-reverse;
        }

        /* 3. æ³¢å½¢å®¹å™¨ï¼šã€æ ¸å¿ƒä¿®æ”¹ã€‘å¢åŠ  justify-content ä½¿å…¶å‡åŒ€åˆ†å¸ƒ */
        .voice-waveform {
            display: flex;
            align-items: center;
            height: 20px;
            gap: 2px;
            flex-grow: 1;
            margin: 0 10px;
            /* æ‚¨å¯ä»¥éšæ—¶è°ƒæ•´æ­¤å¤„çš„ 10px */
        }

        /* 4. æ³¢å½¢æœ¬èº« (æ— å˜åŒ–) */
        .voice-waveform div {
            width: 3px;
            background-color: currentColor;
            border-radius: 2px;
            animation: wave-quiet 1.5s ease-in-out infinite;
        }

        /* 5. æ—¶é•¿ (æ— å˜åŒ–) */
        .message-bubble.user .voice-duration {}

        /* 6. è¯­éŸ³è½¬æ–‡å­—å®¹å™¨æ ·å¼ï¼šã€æ ¸å¿ƒä¿®æ”¹ã€‘å­—ä½“å¤§å°æ”¹ä¸ºåŠ¨æ€è®¡ç®— */
        .voice-transcript {
            display: none;
            padding: 8px 12px;
            margin: 0 5px 5px 5px;
            border-top: 1px solid rgba(0, 0, 0, 0.06);
            font-size: calc(var(--font-size) - 1px);
            /* ä¿®æ”¹ï¼šå…³è”ç³»ç»Ÿå­—ä½“å¤§å° */
            color: var(--text-secondary);
            line-height: 1.5;
            background-color: rgba(0, 0, 0, 0.03);
            border-radius: 8px;
            white-space: pre-wrap;
            word-break: break-word;
        }

        /* â–²â–²â–² æ ·å¼ç²˜è´´ç»“æŸ â–²â–²â–² */


        /* â–¼â–¼â–¼ ç”¨è¿™å—ä»£ç æ›¿æ¢æ‰ä½ åŸæ¥çš„ .message-bubble .content æ ·å¼ â–¼â–¼â–¼ */
        /* é€šç”¨å†…å®¹åŒºæ ·å¼ï¼Œä¸ºæ—¶é—´æˆ³å’Œå­—ä½“å¤§å°åšå‡†å¤‡ */
        .message-bubble .content {
            position: relative;
            font-size: var(--chat-font-size, 16px);
            padding: 8px 12px;
            line-height: 1.5;
            word-break: break-word;
            /* æ ¸å¿ƒä¿®æ­£: å¼ºåˆ¶é•¿å•è¯æˆ–URLæ¢è¡Œï¼Œé˜²æ­¢æ’‘ç ´æ°”æ³¡ */
        }

        /* â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–² */

        /* === æ°”æ³¡ä¸»é¢˜æ ·å¼ === */
        .message-bubble.user .content {
            background-color: rgba(255, 255, 255, 0.75);
            color: #585858;
            border-radius: 8px 2px 8px 8px;
        }

        .message-bubble.ai .content {
            background-color: rgba(255, 255, 255, 0.7);
            color: #585858;
            border-radius: 2px 8px 8px 8px;
        }

        #chat-messages[data-theme="pink_blue"] .message-bubble.user .content {
            background-color: #fff0f6;
            color: #432531;
        }

        #chat-messages[data-theme="pink_blue"] .message-bubble.ai .content {
            background-color: #eff7ff;
            color: #263a4e;
        }

        #chat-messages[data-theme="blue_white"] .message-bubble.user .content {
            background-color: #eff7ff;
            color: #263a4e;
        }

        #chat-messages[data-theme="blue_white"] .message-bubble.ai .content {
            background-color: #f8f9fa;
            color: #383d41;
        }

        #chat-messages[data-theme="purple_yellow"] .message-bubble.user .content {
            background-color: #faf7ff;
            color: #827693;
        }

        #chat-messages[data-theme="purple_yellow"] .message-bubble.ai .content {
            background-color: #fffde4;
            color: #5C4033;
        }

        #chat-messages[data-theme="black_white"] .message-bubble.user .content {
            background-color: #343a40;
            color: #f8f9fa;
        }

        #chat-messages[data-theme="black_white"] .message-bubble.ai .content {
            background-color: #f8f9fa;
            color: #343a40;
        }

        #chat-messages[data-theme="yellow_white"] .message-bubble.user .content {
            background-color: #FFEB3B;
            color: #5D4037;
        }

        #chat-messages[data-theme="yellow_white"] .message-bubble.ai .content {
            background-color: #f8f9fa;
            color: #383d41;
        }

        #chat-messages[data-theme="red_black"] .message-bubble.user .content {
            background-color: #C62828;
            color: #FFFFFF;
        }

        #chat-messages[data-theme="red_black"] .message-bubble.ai .content {
            background-color: #212121;
            color: #FFFFFF;
        }

        #chat-messages[data-theme="blue_yellow"] .message-bubble.user .content {
            background-color: #A0D2EB;
            color: #153243;
        }

        #chat-messages[data-theme="blue_yellow"] .message-bubble.ai .content {
            background-color: #FEF9E7;
            color: #5D4037;
        }

        #chat-messages[data-theme="pink_yellow"] .message-bubble.user .content {
            background-color: #fff0f6;
            color: #432531;
        }

        #chat-messages[data-theme="pink_yellow"] .message-bubble.ai .content {
            background-color: #FEF9E7;
            color: #5D4037;
        }

        #chat-messages[data-theme="pink_purple"] .message-bubble.user .content {
            background-color: #fff0f6;
            color: #a78396;
        }

        #chat-messages[data-theme="pink_purple"] .message-bubble.ai .content {
            background-color: #faf7ff;
            color: #827693;
        }

        #chat-messages[data-theme="gray_white"] .message-bubble.user .content {
            background-color: #e9ecef;
            color: #495057;
        }

        #chat-messages[data-theme="gray_white"] .message-bubble.ai .content {
            background-color: #f8f9fa;
            color: #383d41;
        }

        #chat-messages[data-theme="blue_green"] .message-bubble.user .content {
            background-color: #d1ecf1;
            color: #0c5460;
        }

        #chat-messages[data-theme="blue_green"] .message-bubble.ai .content {
            background-color: #d4edda;
            color: #155724;
        }

        #chat-messages[data-theme="pink_white"] .message-bubble.user .content {
            background-color: #fff0f6;
            color: #a78396;
        }

        #chat-messages[data-theme="pink_white"] .message-bubble.ai .content {
            background-color: #f8f9fa;
            color: #383d41;
        }

        #chat-messages[data-theme="pink_black"] .message-bubble.user .content {
            background-color: #F8BBD0;
            color: #5B2C6F;
        }

        #chat-messages[data-theme="pink_black"] .message-bubble.ai .content {
            background-color: #343a40;
            color: #f8f9fa;
        }

        #chat-messages[data-theme="pink_green"] .message-bubble.user .content {
            background-color: #F8BBD0;
            color: #5B2C6F;
        }

        #chat-messages[data-theme="pink_green"] .message-bubble.ai .content {
            background-color: #C8E6C9;
            color: #1B5E20;
        }

        #chat-messages[data-theme="green_black"] .message-bubble.user .content {
            background-color: #d4edda;
            color: #155724;
        }

        #chat-messages[data-theme="green_black"] .message-bubble.ai .content {
            background-color: #343a40;
            color: #f8f9fa;
        }

        #transfer-btn {
            font-weight: bold;
        }

        #transfer-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1001;
        }

        #transfer-modal.visible {
            display: flex;
        }

        .transfer-content {
            background-color: #fff0f5;
            border-radius: 20px;
            width: 290px;
            padding: 20px;
            box-shadow: 0 5px 25px rgba(255, 105, 180, 0.3);
            text-align: center;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100" opacity="0.05"><path d="M50,4 C35,4 28,15 28,24 C28,33 35,32 35,40 C35,48 28,49 28,57 C28,65 35,66 35,74 C35,82 28,83 28,91 C28,99 35,100 50,100 C65,100 72,99 72,91 C72,83 65,82 65,74 C65,66 72,65 72,57 C72,49 65,48 65,40 C65,32 72,33 72,24 C72,15 65,4 50,4 Z" fill="%23FF69B4"/></svg>');
            background-repeat: no-repeat;
            background-position: top right;
            background-size: 80px;
        }

        .transfer-header {
            font-size: 20px;
            font-weight: bold;
            color: #a35c7b;
            margin-bottom: 20px;
        }

        .transfer-input-group {
            margin-bottom: 15px;
            text-align: left;
        }

        .transfer-input-group label {
            display: block;
            font-size: 14px;
            color: #ff85b3;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .transfer-input-group input {
            width: 100%;
            padding: 12px;
            border-radius: 10px;
            border: 2px solid #ffcce0;
            background-color: #fff;
            font-size: 16px;
            box-sizing: border-box;
        }

        .transfer-input-group input:focus {
            border-color: #ff85b3;
            outline: none;
        }

        .transfer-actions {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        .transfer-actions button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            /* transition: transform 0.2s; - Removed to disable tap feedback */
        }

        .transfer-actions button:active {
            /* Tap feedback removed */
        }

        #transfer-cancel-btn {
            background-color: #ffdde9;
            color: #a35c7b;
        }

        #transfer-confirm-btn {
            background-color: #ff85b3;
            color: white;
        }

        .message-bubble.is-transfer .content {
            padding: 0;
            background: transparent;
            box-shadow: none;
            border: none;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            cursor: pointer;
        }

        .transfer-card {
            width: 200px;
            border-radius: 12px;
            padding: 12px;
            color: white;
            position: relative;
            overflow: hidden;
        }

        .transfer-card::before {
            content: 'ğŸ¾';
            position: absolute;
            right: 10px;
            top: 5px;
            font-size: 30px;
            opacity: 0.2;
            transform: rotate(15deg);
        }

        .message-bubble.user .transfer-card {
            background: radial-gradient(circle at top left, #ffc5d5, #ff85b3);
        }

        .message-bubble.ai .transfer-card {
            background: radial-gradient(circle at top left, #a1c4fd, #c2e9fb);
        }

        .transfer-title {
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 8px;
        }

        .transfer-amount {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .transfer-note {
            font-size: 13px;
            opacity: 0.9;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            padding-top: 8px;
            margin-top: 8px;
            word-break: break-all;
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        #listen-together-btn img.rotating {
            animation: spin 2s linear infinite;
        }

        #listen-together-btn img.paused {
            animation-play-state: paused;
        }

        #music-player-overlay {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            z-index: 200 !important;
            /* Lower than playlist panel (210) but higher than other elements */
            display: none;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.5) !important;
            /* Darker background to see if it appears */
        }

        #music-player-overlay.visible {
            display: flex;
        }

        /* Now Playing Bar Styles - Matching App Dock */
        .now-playing-bar {
            position: fixed;
            top: calc(var(--header-height, 60px) + 8px);
            left: 12px;
            right: 12px;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 50px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            z-index: 45;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
            cursor: pointer;
        }

        .now-playing-bar.hidden {
            transform: translateY(-100%);
            opacity: 0;
            pointer-events: none;
        }

        /* Home Screen Now Playing Bar - Fixed positioning */
        .home-screen-bar {
            position: fixed !important;
            top: 16px !important;
            bottom: auto !important;
            left: 50% !important;
            right: auto !important;
            transform: translateX(-50%) !important;
            width: 370px !important;
            /* Same width as the dock blur (370px) */
            margin: 0;
            z-index: 1000;
            pointer-events: auto !important;
            /* Ensure clicks work when visible */
            cursor: pointer;
        }

        .home-screen-bar.hidden {
            transform: translateX(-50%) translateY(100%);
            opacity: 0;
            pointer-events: none;
        }

        /* Only show home screen bar when on home screen */
        #home-screen:not(.active) .home-screen-bar {
            display: none;
        }

        .now-playing-content {
            display: flex;
            align-items: center;
            padding: 8px;
            box-sizing: border-box;
        }

        .np-album-art {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            overflow: hidden;
            background: linear-gradient(135deg, #f0f0f0, #e0e0e0);
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
        }

        .np-album-art img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .np-album-art .default-icon {
            font-size: 20px;
            color: white;
        }

        .np-song-info {
            flex: 1;
            min-width: 0;
        }

        .np-song-title {
            font-size: 14px;
            font-weight: 600;
            color: white;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1;
            margin: 0;
            padding: 0;
        }

        .np-song-artist {
            font-size: 12px;
            color: white;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1;
            margin: 0;
            padding: 0;
        }

        .np-right-section {
            display: flex;
            align-items: center;
            flex-shrink: 0;
        }

        .np-playback-controls {
            display: flex;
            align-items: center;
            gap: 4px;
            flex-shrink: 0;
            margin-right: 8px;
        }

        .np-control-btn {
            width: 36px;
            height: 36px;
            border: none;
            background: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
            color: white;
            transition: background-color 0.2s ease;
            flex-shrink: 0;
        }

        .np-control-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .np-control-btn.play-pause {
            width: 40px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 18px;
        }

        .np-control-btn.play-pause:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .np-partner-avatar {
            width: 38px;
            height: 38px;
            border-radius: 50%;
            overflow: hidden;
            flex-shrink: 0;
        }

        .np-partner-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .np-progress-bar {
            position: absolute;
            bottom: 0;
            left: 28px;
            right: 28px;
            height: 2px;
            background-color: rgba(255, 255, 255, 0.2);
            overflow: hidden;
        }

        .np-progress-fill {
            height: 100%;
            background-color: white;
            width: 0%;
            transition: width 0.1s ease-out;
        }

        /* Album Art Rotation Animation */
        .np-album-art img.rotating {
            animation: rotate 16s linear infinite;
        }

        .home-screen-bar .np-album-art img.rotating {
            animation: rotate 16s linear infinite;
        }

        .np-album-art img.rotating.paused {
            animation-play-state: paused;
        }

        @keyframes rotate {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        /* Meetup Progress Bar Styles - Purple gradient with blur effects */
        .meetup-progress-bar {
            position: fixed;
            top: calc(var(--header-height, 60px) + 8px);
            left: 12px;
            right: 12px;
            height: 40px;
            /* 32px avatar + 4px top padding + 4px bottom padding */
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.6), rgba(118, 75, 162, 0.6));
            /* Semi-transparent purple gradient for blur effect */
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 100px;
            /* Fully rounded corners on all sides */
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            z-index: 46;
            /* Above music bar */
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
            cursor: pointer;
        }

        /* When both meetup and music bars are visible, adjust positioning */
        .has-meetup-progress .now-playing-bar {
            top: calc(var(--header-height, 60px) + 56px);
            /* 8px + 40px (date bar height) + 8px spacing */
        }

        .meetup-progress-bar.hidden {
            transform: translateY(-100%);
            opacity: 0;
            pointer-events: none;
        }

        /* Home Screen Meetup Progress Bar */
        .meetup-progress-bar.home-screen-bar {
            position: fixed !important;
            top: 16px !important;
            bottom: auto !important;
            left: 50% !important;
            right: auto !important;
            transform: translateX(-50%) !important;
            width: 370px !important;
            margin: 0;
            z-index: 1001;
            /* Above music bar */
            pointer-events: auto !important;
            cursor: pointer;
            border-radius: 100px;
            /* Fully rounded corners on all sides */
        }

        /* When both meetup and music bars are visible on home screen, adjust music bar position */
        #home-screen.has-meetup-progress .home-screen-bar:not(.meetup-progress-bar) {
            top: 64px !important;
            /* 16px + 40px (date bar height) + 8px spacing */
        }

        .meetup-progress-bar.home-screen-bar.hidden {
            transform: translateX(-50%) translateY(-100%);
            opacity: 0;
            pointer-events: none !important;
        }

        /* Only show home screen meetup bar when on home screen */
        #home-screen:not(.active) .meetup-progress-bar.home-screen-bar {
            display: none;
        }

        .meetup-progress-content {
            display: flex;
            align-items: center;
            padding: 4px;
            /* All paddings on all sides 4px */
            box-sizing: border-box;
            height: 100%;
        }

        .meetup-ai-avatar {
            width: 32px;
            /* Increased by 8px */
            height: 32px;
            border-radius: 50%;
            overflow: hidden;
            background: linear-gradient(135deg, #f0f0f0, #e0e0e0);
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 8px;
        }

        .meetup-ai-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .meetup-progress-info {
            flex: 1;
            min-width: 0;
        }

        .meetup-progress-text {
            font-size: 16px;
            /* Same as chat message text */
            font-weight: 500;
            color: white;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1;
            margin: 0;
            padding: 0;
        }

        .meetup-separator {
            color: rgba(255, 255, 255, 0.75);
            /* 75% opacity */
            font-size: 16px;
            font-weight: 500;
        }

        .meetup-clock-icon {
            display: inline-block;
            vertical-align: middle;
            margin: 0 2px 0 4px;
            /* Closer to time, normal spacing from separator */
            flex-shrink: 0;
        }

        .meetup-elapsed-text {
            font-size: 14px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.75);
            /* 75% opacity */
            white-space: nowrap;
            line-height: 1;
            margin: 0;
            padding: 0;
            display: inline;
        }



        /* Chat messages offset when now playing bar is visible */
        #chat-interface-screen.has-now-playing #chat-messages {
            padding-top: 80px;
        }

        .music-player-window {
            width: calc(100% - 24px);
            margin: 0 12px;
            background-color: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 20px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
            padding: 25px;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #1f1f1f;
            position: relative;
        }

        #music-playlist-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 24px;
            cursor: pointer;
            color: #333;
        }

        #music-time-counter {
            font-size: 12px;
            color: #555;
            margin-bottom: 20px;
        }

        #music-player-song-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 5px;
            text-align: center;
        }

        #music-player-artist {
            font-size: 14px;
            color: #666;
            margin-bottom: 25px;
        }

        .music-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            width: 100%;
            margin-bottom: 30px;
        }

        .music-controls button {
            background: none;
            border: none;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            color: #333;
            width: 44px;
            height: 44px;
            display: flex;
            justify-content: center;
            align-items: center;
            /* transition: transform 0.2s; - Removed to disable tap feedback */
        }

        .music-controls button:active {
            /* Tap feedback removed */
        }

        .music-controls .play-pause-btn {
            font-size: 24px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.05);
        }

        .music-bottom-actions {
            display: flex;
            justify-content: space-between;
            width: 100%;
        }

        .music-bottom-actions button {
            flex: 1;
            padding: 12px 0;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
        }

        #music-exit-btn {
            background-color: rgba(255, 100, 100, 0.7);
            color: white;
            margin-right: 5px;
        }

        #music-return-btn {
            background-color: rgba(0, 123, 255, 0.7);
            color: white;
            margin-left: 5px;
        }

        #music-playlist-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 70%;
            background-color: rgba(242, 242, 247, 0.9);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-top: 1px solid var(--border-color);
            border-radius: 20px 20px 0 0;
            z-index: 210;
            display: flex;
            flex-direction: column;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            visibility: hidden;
        }

        #music-playlist-panel.visible {
            transform: translateY(0);
            visibility: visible;
        }

        .playlist-header {
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
        }

        .playlist-header .panel-btn {
            font-size: 16px;
            cursor: pointer;
            color: var(--accent-color);
        }

        .playlist-body {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px 0;
        }

        .playlist-item {
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }

        .playlist-item.playing {
            background-color: rgba(0, 123, 255, 0.1);
        }

        .playlist-item-info .title {
            font-weight: 500;
            font-size: 15px;
        }

        .playlist-item-info .artist {
            font-size: 12px;
            color: #666;
        }

        .playlist-item .delete-track-btn {
            color: #ff3b30;
            font-size: 20px;
            padding: 5px;
        }

        /* Persona Library Styles */
        #persona-library-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            padding: 10px;
        }

        .persona-preset-item {
            aspect-ratio: 1 / 1;
            border-radius: 12px;
            background-size: cover;
            background-position: center;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .persona-preset-item:hover {
            transform: scale(1.08);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .modal-header .action-button {
            font-size: 16px;
            color: var(--accent-color);
            font-weight: 600;
            cursor: pointer;
            background: none;
            border: none;
            padding: 5px;
        }

        /* Battery Alert Modal Styles */
        #battery-alert-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #battery-alert-modal.visible {
            display: flex;
            opacity: 1;
        }

        .battery-alert-content {
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            width: 280px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            text-align: center;
            padding: 20px;
            cursor: pointer;
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        #battery-alert-modal.visible .battery-alert-content {
            transform: scale(1);
        }

        #battery-alert-image {
            max-width: 100px;
            max-height: 100px;
            margin-bottom: 15px;
        }

        #battery-alert-text {
            font-size: 16px;
            font-weight: 500;
            color: #333;
            margin: 0;
            line-height: 1.4;
        }

        /* è¿™æ˜¯ä½ è¦æ·»åŠ çš„æ–°æ ·å¼ */
        #font-preview {
            transition: font-family 0.3s ease;
        }

        /* === èŠå¤©åˆ—è¡¨ç•Œé¢æ–°å¢æ ·å¼ (è¿™æ˜¯æ–°æ·»åŠ çš„) === */
        #chat-list-screen {}

        .chat-list-view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 1;
        }

        .chat-list-view.active {
            opacity: 1;
            visibility: visible;
            z-index: 2;
        }

        #messages-view {
            overflow-y: auto;
        }

        /* åº•éƒ¨å¯¼èˆªæ æ ·å¼ */
        #chat-list-bottom-nav {
            position: absolute;
            /* è®©å®ƒå›ºå®šåœ¨åº•éƒ¨ */
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 15;
            /* ç¡®ä¿å®ƒåœ¨è§†å›¾ä¹‹ä¸Š */
            display: flex;
            border-top: 1px solid var(--border-color);
            background-color: rgba(247, 247, 247, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .nav-item {
            flex: 1;
            text-align: center;
            padding: 12px 0;
            font-size: 14px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: color 0.2s;
        }

        .nav-item.active {
            color: var(--accent-color);
            font-weight: 600;
        }

        /* === åŠ¨æ€ç•Œé¢ (QZone) æ ·å¼ (è¿™æ˜¯æ–°æ·»åŠ çš„) === */
        #qzone-screen {
            background-color: #f0f2f5;
        }

        .qzone-header {
            /* position: absolute;  <-- æŠŠè¿™ä¸ªæ”¹æˆ relative */
            position: relative;
            z-index: 10;
            /* z-index ä¿æŒï¼Œæˆ–è€…å¯ä»¥æ›´é«˜ */
            flex-shrink: 0;
            /* é˜²æ­¢è¢«å‹ç¼© */
            padding: 15px 12px;
            padding-top: 16px;
            background-color: rgba(247, 247, 247, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 18px;
            font-weight: 600;
            text-align: center;
        }

        .qzone-header .back-btn {
            font-size: 24px;
            cursor: pointer;
            color: var(--accent-color);
            margin-left: 8px;
            /* Add spacing to match other screens */
        }

        .qzone-header .ai-post-btn {
            position: absolute;
            right: 20px;
            font-size: 20px;
            cursor: pointer;
            color: var(--accent-color);
            transition: opacity 0.2s;
        }

        .qzone-header .ai-post-btn:hover {
            opacity: 0.8;
        }

        /* Position the add button (first ai-post-btn) */
        .qzone-header #qzone-add-post-btn {
            right: 72px;
        }

        /* Position the AI button (second ai-post-btn) */
        .qzone-header #ai-post-btn {
            right: 20px;
        }

        .qzone-header span:nth-child(2) {
            /* "å¥½å‹åŠ¨æ€"æ–‡å­— */
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        .qzone-content {
            flex-grow: 1;
            overflow-y: auto;
            /* padding-top: 80px;  <-- åˆ é™¤è¿™ä¸ªï¼Œå› ä¸ºheaderä¸å†æ˜¯absoluteäº† */
        }

        .qzone-profile-header {
            position: relative;
            margin-bottom: 20px;
        }

        .qzone-banner-container {
            width: 100%;
            height: 240px;
            /* èƒŒæ™¯æ¿é«˜åº¦ */
            position: relative;
        }

        #qzone-banner-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 0 0 16px 16px;
        }

        .qzone-user-info {
            position: absolute;
            bottom: -40px;
            /* è®©å¤´åƒå’Œæ˜µç§°åŒºåŸŸå‘ä¸‹åç§»ï¼Œä¸€åŠåœ¨èƒŒæ™¯æ¿å†…ï¼Œä¸€åŠåœ¨å¤– */
            left: 18px;
            display: flex;
            align-items: flex-start;
            /* Changed from center to flex-start to allow independent positioning */
            gap: 12px;
        }

        .qzone-user-text {
            display: flex;
            flex-direction: column;
            gap: 26px;
            padding-top: 16px;
            transform: translateY(4px);
        }

        .qzone-avatar-container {
            position: relative;
            flex-shrink: 0;
            width: 92px;
            height: 92px;
        }

        #qzone-avatar-img {
            width: 92px;
            height: 92px;
            border-radius: 50%;
            object-fit: cover;
            transform: translateY(2px);
            box-shadow: 0 0 0 2px #f0f2f5;
        }

        /* QZone avatar with frame support - overlay approach */
        #qzone-avatar-container .avatar {
            width: 92px;
            height: 92px;
            border-radius: 50%;
            object-fit: cover;
            transform: translateY(2px);
            box-shadow: 0 0 0 2px #f0f2f5;
        }

        /* When borders are enabled, decrease avatar size by 16px but keep container size */
        #qzone-avatar-container.borders-enabled #qzone-avatar-img,
        #qzone-avatar-container.borders-enabled .avatar {
            width: 76px;
            height: 76px;
            /* Center the smaller avatar within the same container */
            position: relative;
            left: 8px;
            top: 10px;
            transform: translateY(0px);
            /* Reset transform for border mode */
        }

        .qzone-avatar-frame {
            position: absolute;
            width: 153px;
            height: 153px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 2;
        }

        /* Adjust border frame size and position when avatar is smaller */
        #qzone-avatar-container.borders-enabled .qzone-avatar-frame {
            width: 131px;
            height: 131px;
            top: calc(50% + 0px);
            /* Move border down 1px more */
        }

        #qzone-nickname {
            font-size: 20px;
            font-weight: 600;
            color: #000;
            text-shadow: 2px 2px 8px rgba(255, 255, 255, 0.9);
        }

        #qzone-status {
            font-size: 14px;
            color: #333;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        /* Only move text left when borders are enabled */
        .qzone-avatar-container.borders-enabled~.qzone-user-text #qzone-nickname {
            position: relative;
            left: -4px;
        }

        .qzone-avatar-container.borders-enabled~.qzone-user-text #qzone-status {
            position: relative;
            left: -4px;
        }

        #qzone-status:hover {
            opacity: 0.8;
        }

        /* ç¼–è¾‘æŒ‰é’®çš„é€šç”¨æ ·å¼ */
        .qzone-edit-btn {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.4);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        #change-qzone-banner-btn {
            bottom: 10px;
            right: 10px;
        }

        #change-qzone-avatar-btn {
            bottom: 5px;
            right: 5px;
        }

        #change-qzone-nickname-btn {
            font-size: 14px;
            padding: 2px 6px;
            margin-left: 5px;
            /* ä¸æ˜µç§°çš„é—´è· */
            color: var(--text-primary);
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 5px;
            position: relative;
            /* è„±ç¦»flexå¸ƒå±€çš„å¯¹é½ */
            bottom: 5px;
            /* å¾®è°ƒå‚ç›´ä½ç½® */
        }

        /* === è®©ç¼–è¾‘åŠŸèƒ½æ›´â€œéšå½¢â€ === */
        #qzone-banner-container,
        #qzone-avatar-container,
        #qzone-nickname,
        #qzone-status {
            cursor: pointer;
            /* é¼ æ ‡æ‚¬åœæ—¶æ˜¾ç¤ºä¸ºå¯ç‚¹å‡»æ‰‹åŠ¿ */
            transition: opacity 0.2s;
        }

        #qzone-banner-container:hover,
        #qzone-avatar-container:hover,
        #qzone-nickname:hover,
        #qzone-status:hover {
            opacity: 0.85;
            /* æ‚¬åœæ—¶ç¨å¾®å˜æš—ï¼Œç»™ç”¨æˆ·åé¦ˆ */
        }

        /* éšè—æ‰æ—§çš„ã€ç‹¬ç«‹çš„ç¼–è¾‘æŒ‰é’® */
        .qzone-edit-btn {
            display: none;
        }

        /* === æ§åˆ¶ Header å’Œ Bottom Nav çš„æ˜¾éš === */
        /* é»˜è®¤éšè—åŠ¨æ€ç•Œé¢çš„ Header */
        #qzone-screen .qzone-header {
            display: none;
        }

        /* å½“åŠ¨æ€è§†å›¾æ¿€æ´»æ—¶ï¼Œæ˜¾ç¤ºå®ƒçš„Header */
        #qzone-screen.active .qzone-header {
            display: flex;
        }

        /* å½“è¿›å…¥åŠ¨æ€è§†å›¾æ—¶ï¼Œéšè—ä¸»Headerå’Œåº•éƒ¨å¯¼èˆªæ  */
        #chat-list-screen.in-qzone-view>.header,
        #chat-list-screen.in-qzone-view>#chat-list-bottom-nav {
            display: none;
        }

        .chat-list-item:first-child,
        .chat-group-container:first-child {
            margin-top: 10px;
        }

        /* â–²â–²â–² æ–°æ ·å¼æ›¿æ¢ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ æŠŠæ‰€æœ‰è¿™äº›æ–°æ ·å¼ç²˜è´´åˆ° <style> çš„æœ«å°¾ â–¼â–¼â–¼ */

        /* === åŠ¨æ€åŠŸèƒ½æ æ ·å¼ === */
        .qzone-actions-bar {
            display: flex;
            justify-content: space-around;
            padding: 10px 0;
            margin: 50px 15px 15px 15px;
            /* ä¸Šè¾¹è·æ›´å¤§ï¼Œä¸ºæµ®åŠ¨çš„å¤´åƒç•™å‡ºç©ºé—´ */
            background-color: var(--secondary-bg);
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .action-item {
            flex: 1;
            text-align: center;
            font-size: 15px;
            font-weight: 500;
            color: var(--text-primary);
            cursor: pointer;
            padding: 8px 0;
            position: relative;
        }

        /* ç”¨ä¼ªå…ƒç´ åˆ›å»ºåˆ†éš”çº¿ */
        .action-item:not(:last-child)::after {
            content: '';
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 1px;
            height: 20px;
            background-color: var(--border-color);
        }

        /* === åŠ¨æ€å¸–å­åˆ—è¡¨æ ·å¼ === */
        #qzone-posts-list {
            padding: 32px 15px 20px 15px;
            /* ä¸Šæ–¹32pxé—´è·ï¼Œå·¦å³å’Œåº•éƒ¨ç•™å‡ºè¾¹è· */
            display: flex;
            flex-direction: column;
            gap: 20px;
            /* å¸–å­ä¹‹é—´çš„é—´è· */
        }

        .qzone-post-item {
            background-color: var(--secondary-bg);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
        }

        .post-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .post-header .post-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
        }

        /* Post avatar with frame support - overlay approach */
        .post-header .avatar-container {
            position: relative;
            width: 40px;
            height: 40px;
            flex-shrink: 0;
        }

        .post-header .avatar-container .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
        }

        .post-header .avatar-container .avatar-frame {
            position: absolute;
            width: 67px;
            height: 67px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 2;
        }

        .post-info {
            display: flex;
            flex-direction: column;
        }

        .post-info .post-nickname {
            font-weight: 600;
            font-size: 15px;
            color: var(--text-primary);
        }

        .post-info .post-timestamp {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .post-content {
            font-size: 14px;
            line-height: 1.6;
            color: #333;
            white-space: pre-wrap;
            /* è®©æ¢è¡Œç¬¦ç”Ÿæ•ˆ */
            word-break: break-word;
            /* é˜²æ­¢é•¿å•è¯æº¢å‡º */
        }

        /* â–²â–²â–² æ–°æ ·å¼ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ æ–°æ ·å¼ç²˜è´´åˆ°æœ«å°¾ â–¼â–¼â–¼ */

        /* === å‘å¸ƒåŠ¨æ€æ¨¡æ€æ¡†æ ·å¼ === */
        #post-public-text {
            min-height: 80px;
            /* ç¡®ä¿æ–‡æœ¬åŸŸæœ‰è¶³å¤Ÿçš„é«˜åº¦ */
            resize: vertical;
        }

        .post-image-preview-container {
            position: relative;
            width: 100%;
            aspect-ratio: 16 / 9;
            /* ä¿æŒ16:9çš„é¢„è§ˆæ¯”ä¾‹ */
            background-color: #f0f2f5;
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            margin-bottom: 15px;
            display: none;
            /* é»˜è®¤éšè— */
            justify-content: center;
            align-items: center;
        }

        .post-image-preview-container.visible {
            display: flex;
            /* ä¸Šä¼ åæ˜¾ç¤º */
        }

        #post-image-preview {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 6px;
        }

        #post-remove-image-btn {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: #ff3b30;
            color: white;
            border: 2px solid white;
            font-size: 16px;
            line-height: 20px;
            text-align: center;
            cursor: pointer;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
        }

        .post-image-upload-options {
            display: flex;
            gap: 10px;
        }

        .post-image-upload-options button {
            flex: 1;
            margin-top: 0;
        }

        /* â–²â–²â–² æ–°æ ·å¼ç»“æŸ â–²â–²â–² */
        /* â–¼â–¼â–¼ ã€å…¨æ–°ã€‘èƒ¶å›Šå¼€å…³æ ·å¼ - è¯·å°†è¿™æ®µCSSç²˜è´´åˆ°æ ·å¼è¡¨æœ«å°¾ â–¼â–¼â–¼ */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 51px;
            height: 31px;
            flex-shrink: 0;
            /* é˜²æ­¢è¢«å‹ç¼© */
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-switch .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
        }

        .toggle-switch .slider:before {
            position: absolute;
            content: "";
            height: 27px;
            width: 27px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
        }

        .toggle-switch input:checked+.slider {
            background-color: var(--accent-color);
        }

        .toggle-switch input:focus+.slider {
            box-shadow: 0 0 1px var(--accent-color);
        }

        .toggle-switch input:checked+.slider:before {
            transform: translateX(20px);
        }

        /* åœ†è§’æ ·å¼ */
        .toggle-switch .slider.round {
            border-radius: 34px;
        }

        .toggle-switch .slider.round:before {
            border-radius: 50%;
        }

        /* â–²â–²â–² æ–°CSSç²˜è´´ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ æ–°æ ·å¼ â–¼â–¼â–¼ */

        /* === å‘å¸ƒåŠ¨æ€æ¨¡æ€æ¡† - æ¨¡å¼åˆ‡æ¢æ ·å¼ === */
        .post-mode-switcher {
            display: flex;
            margin-bottom: 20px;
            background-color: #e9ecef;
            border-radius: 8px;
            padding: 4px;
        }

        .mode-btn {
            flex: 1;
            padding: 8px;
            border: none;
            background-color: transparent;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }

        .mode-btn.active {
            background-color: var(--secondary-bg);
            color: var(--text-primary);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .post-mode-content {
            display: none;
            /* é»˜è®¤éƒ½éšè— */
        }

        .post-mode-content.active {
            display: block;
            /* æ¿€æ´»çš„æ‰æ˜¾ç¤º */
        }

        /* â–²â–²â–² æ–°æ ·å¼ç»“æŸ â–²â–²â–² */

        /* === ç›¸å†Œé¡µé¢èƒŒæ™¯è‰² === */
        #album-screen {
            background-color: #f0f2f5;
            /* ä½¿ç”¨ä¸€ä¸ªæŸ”å’Œçš„æµ…ç°è‰²ï¼Œæ¯”çº¯ç™½æ›´æŠ¤çœ¼ */
        }

        /* === ç›¸å†Œé¡µé¢ç½‘æ ¼å¸ƒå±€ === */
        #album-grid-page {
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            /* æ¯è¡Œæ˜¾ç¤º2ä¸ªç›¸å†Œ */
            gap: 15px;
        }

        /* === ç›¸å†Œé¡¹ç›®æ ·å¼ (ç¾åŒ–) === */
        .album-item {
            display: flex;
            flex-direction: column;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            border-radius: 8px;
            /* ç»™æ•´ä¸ªé¡¹ç›®ä¹ŸåŠ ä¸ªåœ†è§’ */
        }

        .album-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.1);
        }

        .album-cover {
            aspect-ratio: 1 / 1;
            /* ä¿æŒå°é¢ä¸ºæ­£æ–¹å½¢ */
            background-size: cover;
            background-position: center;
            border-radius: 8px;
            margin-bottom: 8px;
            background-color: #f0f2f5;
            /* å°é¢åŠ è½½å‰çš„å ä½é¢œè‰² */
        }

        .album-info {
            text-align: center;
        }

        .album-name {
            font-weight: 500;
            margin: 0 0 4px 0;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            /* é˜²æ­¢é•¿åå­—æ¢è¡Œ */
        }

        .album-count {
            font-size: 12px;
            color: var(--text-secondary);
            margin: 0;
        }

        /* â–²â–²â–² æ–°çš„ CSS ç²˜è´´ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ è¯·å°†è¿™äº›æ–°æ ·å¼ç²˜è´´åˆ° <style> çš„æœ«å°¾ â–¼â–¼â–¼ */

        /* === ç›¸å†Œç…§ç‰‡è¯¦æƒ…é¡µ === */
        #album-photos-screen {
            background-color: #f0f2f5;
        }

        #photos-grid-page {
            padding: 15px;
            display: grid;
            /* æ¯è¡Œæ˜¾ç¤º3å¼ ç…§ç‰‡ï¼Œå¹¶ä¿æŒé—´è· */
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .photo-item {
            position: relative;
            /* ä¸ºäº†å®šä½åˆ é™¤æŒ‰é’® */
            aspect-ratio: 1 / 1;
            /* ä¿æŒç…§ç‰‡ä¸ºæ­£æ–¹å½¢ */
            border-radius: 6px;
            overflow: hidden;
            /* é˜²æ­¢å›¾ç‰‡æº¢å‡ºåœ†è§’ */
            background-color: #e9ecef;
            /* å›¾ç‰‡åŠ è½½å‰çš„å ä½ç¬¦é¢œè‰² */
        }

        .photo-item .photo-thumb {
            width: 100%;
            height: 100%;
            object-fit: cover;
            /* ä¿è¯å›¾ç‰‡å¡«æ»¡å®¹å™¨ä¸”ä¸å˜å½¢ */
            cursor: pointer;
        }

        /* åˆ é™¤æŒ‰é’®çš„æ ·å¼ */
        .photo-item .photo-delete-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 22px;
            height: 22px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 16px;
            line-height: 22px;
            text-align: center;
            cursor: pointer;
            opacity: 0;
            /* é»˜è®¤éšè— */
            transition: opacity 0.2s ease;
        }

        /* é¼ æ ‡æ‚¬åœåœ¨ç…§ç‰‡ä¸Šæ—¶æ˜¾ç¤ºåˆ é™¤æŒ‰é’® */
        .photo-item:hover .photo-delete-btn {
            opacity: 1;
        }

        /* â–²â–²â–² æ–°æ ·å¼ç²˜è´´ç»“æŸ â–²â–²â–² */

        /* === å›¾ç‰‡æŸ¥çœ‹å™¨æ¨¡æ€æ¡†æ ·å¼ === */
        #photo-viewer-modal {
            background-color: rgba(0, 0, 0, 0.85);
            z-index: 1002;
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
        }

        .photo-viewer-content {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        #photo-viewer-image {
            max-width: 90vw;
            /* å›¾ç‰‡æœ€å¤§å®½åº¦ä¸ºè§†å£çš„90% */
            max-height: 85vh;
            /* å›¾ç‰‡æœ€å¤§é«˜åº¦ä¸ºè§†å£çš„85% */
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            /* ä¸ºå›¾ç‰‡çš„åˆ‡æ¢æ·»åŠ ä¸€ç‚¹å¹³æ»‘çš„æ·¡å…¥æ·¡å‡ºæ•ˆæœ */
            transition: opacity 0.2s ease-in-out;
        }

        /* å…³é—­æŒ‰é’® */
        #photo-viewer-close-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: white;
            font-size: 40px;
            font-weight: 200;
            cursor: pointer;
            line-height: 1;
            text-shadow: 0 0 5px black;
        }

        /* å·¦å³å¯¼èˆªç®­å¤´ */
        #photo-viewer-modal .nav-arrow {
            position: absolute;
            /* ç°åœ¨æˆ‘ä»¬ç”¨ç»å¯¹å®šä½æ¥æ§åˆ¶ç®­å¤´ */
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 50px;
            /* åœ¨æ‰‹æœºå±å¹•ä¸Šï¼Œå¯ä»¥ç¨å¾®å°ä¸€ç‚¹ */
            font-weight: 100;
            cursor: pointer;
            padding: 10px;
            /* è°ƒæ•´å†…è¾¹è· */
            user-select: none;
            transition: color 0.2s;
            z-index: 1003;
            /* ç¡®ä¿ç®­å¤´åœ¨æœ€ä¸Šå±‚ */
        }

        #photo-viewer-prev-btn {
            left: 5px;
            /* å®šä½å·¦ç®­å¤´ */
        }

        #photo-viewer-next-btn {
            right: 5px;
            /* å®šä½å³ç®­å¤´ */
        }

        #photo-viewer-modal .nav-arrow:hover {
            color: white;
        }

        /* å½“ç®­å¤´è¢«ç¦ç”¨æ—¶ï¼ˆæ¯”å¦‚ç¬¬ä¸€å¼ æˆ–æœ€åä¸€å¼ ï¼‰ */
        #photo-viewer-modal .nav-arrow:disabled {
            color: rgba(255, 255, 255, 0.2);
            cursor: default;
        }

        /* â–²â–²â–² æ–°æ ·å¼ç²˜è´´ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ è¯·å°†è¿™äº›æ–°æ ·å¼ç²˜è´´åˆ° <style> çš„æœ«å°¾ â–¼â–¼â–¼ */

        /* â–¼â–¼â–¼ è¯·ç”¨è¿™å—æ–°CSSæ›¿æ¢æ‰ä¸Šä¸€ç‰ˆçš„äº¤äº’åŒºCSS â–¼â–¼â–¼ */

        /* === å¸–å­å†…å®¹åŒº - ç›¸å¯¹å®šä½å®¹å™¨ === */
        /* === å¸–å­å†…å®¹åŒº === */
        .post-main-content {
            /* å®ƒç°åœ¨åªæ˜¯ä¸€ä¸ªæ™®é€šçš„å†…å®¹å®¹å™¨ï¼Œä¸å†éœ€è¦ç‰¹æ®Šæ ·å¼äº† */
        }

        /* === å¸–å­äº’åŠ¨å›¾æ ‡åŒº (æ–°æ ·å¼) === */
        .post-feedback-icons {
            display: flex;
            justify-content: flex-start;
            /* è®©å›¾æ ‡é å·¦å¯¹é½ */
            align-items: center;
            gap: 12px;
            padding: 8px 0;
            /* æ ¸å¿ƒä¿®æ”¹ï¼šç»™å›¾æ ‡åŒºåŸŸä¸Šä¸‹å„8pxçš„ç•™ç™½ */
        }

        .action-icon {
            cursor: pointer;
            color: var(--text-secondary);
            /* é»˜è®¤ç°è‰² */
            transition: all 0.2s ease-in-out;
        }

        .action-icon svg {
            width: 18px;
            height: 18px;
            fill: none;
            stroke: currentColor;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        /* å›¾æ ‡æ¿€æ´»(ç‚¹èµ/æ”¶è—å)çš„æ ·å¼ */
        .action-icon.active {
            color: #ff5252;
            /* æ¿€æ´»åå˜çº¢è‰² */
            transform: scale(1.1);
            /* è½»å¾®æ”¾å¤§ */
        }

        .action-icon.active.favorite {
            color: #ffc107;
            /* æ”¶è—ç”¨é»„è‰² */
        }

        .action-icon.active svg {
            fill: currentColor;
            /* æ¿€æ´»åå¡«å……é¢œè‰² */
        }

        /* ç‚¹å‡»æ—¶çš„åŠ¨ç”»æ•ˆæœ */
        .animate-like {
            animation: like-bounce 0.4s ease-in-out;
        }

        @keyframes like-bounce {
            0% {
                transform: scale(1);
            }

            25% {
                transform: scale(0.8);
            }

            50% {
                transform: scale(1.2);
            }

            75% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1.1);
            }
        }


        /* === å¸–å­åº•éƒ¨è¯„è®ºåŒºæ ·å¼ (ç°åœ¨æ˜¯ç‹¬ç«‹éƒ¨åˆ†) === */
        .post-footer {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #f0f0f0;
            /* ç”¨ä¸€æ¡æµ…è‰²çº¿åˆ†éš” */
            display: flex;
            align-items: center;
            gap: 8px;
            /* è°ƒæ•´æ•´ä½“é—´è· */
        }

        /* è¯„è®ºåŒºå®¹å™¨ */
        .comment-section {
            flex-grow: 1;
            /* å æ®å¤§éƒ¨åˆ†ç©ºé—´ */
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .comment-section .comment-avatar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            object-fit: cover;
            flex-shrink: 0;
        }

        .comment-section .comment-input {
            width: 100%;
            padding: 8px 12px;
            border: none;
            background-color: #f0f2f5;
            border-radius: 14px;
            font-size: 13px;
            outline: none;
        }

        /* æ–°å¢çš„å‘é€æŒ‰é’®æ ·å¼ */
        .comment-send-btn {
            flex-shrink: 0;
            /* é˜²æ­¢è¢«å‹ç¼© */
            padding: 8px 15px;
            border: none;
            background-color: var(--accent-color);
            color: white;
            border-radius: 14px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
        }

        /* AIå›å¤æŒ‰é’®æ ·å¼ */
        .call-ai-reply-btn {
            flex-shrink: 0;
            padding: 8px 12px;
            background-color: rgba(255, 255, 255, 0.8);
            color: #666;
            border: 1px solid #ddd;
            border-radius: 14px;
            font-size: 16px;
            cursor: pointer;
            margin-left: 5px;
            transition: all 0.2s ease;
        }

        .call-ai-reply-btn:hover {
            background-color: rgba(255, 255, 255, 1);
            border-color: var(--accent-color);
            color: var(--accent-color);
        }

        /* AIé€‰æ‹©åˆ—è¡¨æ ·å¼ */
        .ai-selection-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .ai-selection-item:hover {
            background-color: #f8f9fa;
        }

        .ai-selection-item input[type="checkbox"] {
            margin-right: 12px;
            width: 18px;
            height: 18px;
        }

        .ai-selection-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 12px;
            object-fit: cover;
            background-color: #eee;
        }

        .ai-selection-info {
            flex-grow: 1;
        }

        .ai-selection-name {
            font-weight: 500;
            margin-bottom: 2px;
        }

        .ai-selection-status {
            font-size: 12px;
            color: #666;
        }

        /* è¡¨æƒ…åŒ…é€‰æ‹©åˆ—è¡¨æ ·å¼ */
        .pack-selection-item {
            display: flex;
            align-items: center;
            padding: 12px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
        }

        .pack-selection-item:hover {
            background-color: #f8f9fa;
        }

        .pack-selection-item input[type="radio"] {
            margin-right: 12px;
            width: 18px;
            height: 18px;
        }

        .pack-selection-info {
            flex-grow: 1;
        }

        .pack-selection-name {
            font-weight: 500;
            margin-bottom: 2px;
        }

        /* â–²â–²â–² æ–°æ ·å¼ç²˜è´´ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ è¯·å°†è¿™æ®µæ–°æ ·å¼ç²˜è´´åˆ° <style> çš„æœ«å°¾ â–¼â–¼â–¼ */

        /* === æœªè¯»æ¶ˆæ¯å°çº¢ç‚¹é€šç”¨æ ·å¼ === */
        .unread-indicator {
            position: absolute;
            top: -8px;
            right: -15px;
            min-width: 18px;
            height: 18px;
            padding: 0 5px;
            background-color: #ff3b30;
            color: white;
            font-size: 11px;
            font-weight: bold;
            line-height: 18px;
            text-align: center;
            border-radius: 9px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            display: none;
            z-index: 1;
        }

        /* èŠå¤©ç•Œé¢è¿”å›æŒ‰é’®ä¸Šçš„å°çº¢ç‚¹ (åªæ˜¾ç¤ºç‚¹ï¼Œä¸æ˜¾ç¤ºæ•°å­—) */
        .back-btn-indicator {
            top: 0;
            right: -8px;
            /* æ”¾åˆ°è¿”å›ç®­å¤´å³ä¸Šè§’ */
            width: 10px;
            height: 10px;
            min-width: 10px;
            padding: 0;
            border-radius: 50%;
        }

        /* â–²â–²â–² æ–°æ ·å¼ç²˜è´´ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ è¯·å°†è¿™æ®µæ–°æ ·å¼ç²˜è´´åˆ° <style> çš„æœ«å°¾ â–¼â–¼â–¼ */

        /* === è¯„è®ºåˆ—è¡¨å®¹å™¨ === */
        .post-comments-container {
            padding: 10px 0;
            /* ä¸Šä¸‹ç•™ç™½ */
            display: flex;
            flex-direction: column;
            gap: 8px;
            /* è¯„è®ºä¹‹é—´çš„é—´è· */
            font-size: 13px;
            /* ç»Ÿä¸€è¯„è®ºåŒºå­—ä½“å¤§å° */
        }

        /* æ¯ä¸€æ¡è¯„è®º */
        .comment-item {
            line-height: 1.5;
        }

        /* è¯„è®ºè€…çš„åå­—ï¼ŒåŠ ç²—å¹¶ä½¿ç”¨ä¸»é¢˜è‰² */
        .comment-item .commenter-name {
            font-weight: 600;
            color: var(--accent-color);
            cursor: pointer;
            margin-right: 5px;
            /* å’Œè¯„è®ºå†…å®¹ä¹‹é—´ç•™ç‚¹ç©ºéš™ */
        }

        /* è¯„è®ºå†…å®¹ */
        .comment-item .comment-text {
            color: var(--text-primary);
            word-break: break-word;
        }

        /* â–²â–²â–² æ–°æ ·å¼ç²˜è´´ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ è¯·å°†è¿™æ®µæ–°æ ·å¼ç²˜è´´åˆ° <style> çš„æœ«å°¾ â–¼â–¼â–¼ */

        /* === å¸–å­ç‚¹èµåŒºåŸŸæ ·å¼ === */
        .post-likes-section {
            display: flex;
            align-items: center;
            gap: 6px;
            /* å›¾æ ‡å’Œæ–‡å­—çš„é—´è· */
            padding: 8px 10px;
            /* å†…è¾¹è· */
            font-size: 13px;
            color: var(--accent-color);
            /* ä½¿ç”¨ä¸»é¢˜è“è‰² */
            background-color: #f0f5fa;
            /* ç»™ä¸€ä¸ªæ·¡æ·¡çš„èƒŒæ™¯è‰² */
            border-top: 1px solid #e9eef3;
            border-bottom: 1px solid #e9eef3;
            margin-top: 5px;
            /* å’Œä¸Šæ–¹çš„å›¾æ ‡ä¿æŒä¸€ç‚¹è·ç¦» */
        }

        .post-likes-section .like-icon {
            width: 16px;
            height: 16px;
            fill: currentColor;
            /* è®©SVGå›¾æ ‡ç»§æ‰¿çˆ¶å…ƒç´ çš„é¢œè‰² */
            flex-shrink: 0;
            /* é˜²æ­¢å›¾æ ‡è¢«å‹ç¼© */
        }

        /* â–²â–²â–² æ–°æ ·å¼ç²˜è´´ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ è¯·å°†è¿™æ®µæ–°æ ·å¼ç²˜è´´åˆ° <style> çš„æœ«å°¾ â–¼â–¼â–¼ */

        /* === @æåŠ å¼¹å‡ºèœå•æ ·å¼ === */
        .at-mention-popup {
            position: absolute;
            /* ç›¸å¯¹äºçˆ¶å…ƒç´ å®šä½ */
            bottom: 100%;
            /* æ˜¾ç¤ºåœ¨è¾“å…¥æ¡†çš„ä¸Šæ–¹ */
            left: 40px;
            /* å’Œè¾“å…¥æ¡†å·¦ä¾§å¯¹é½ (è€ƒè™‘äº†å¤´åƒå®½åº¦) */
            width: calc(100% - 40px);
            /* å®½åº¦å’Œè¾“å…¥æ¡†å·®ä¸å¤š */
            max-height: 120px;
            overflow-y: auto;
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.1);
            z-index: 10;
            display: none;
            /* é»˜è®¤éšè— */
        }

        .at-mention-item {
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            color: var(--text-primary);
            border-bottom: 1px solid #f0f0f0;
        }

        .at-mention-item:last-child {
            border-bottom: none;
        }

        .at-mention-item:hover {
            background-color: #f5f5f5;
        }

        /* â–²â–²â–² æ–°æ ·å¼ç²˜è´´ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ è¯·å°†è¿™æ®µæ–°æ ·å¼ç²˜è´´åˆ° <style> çš„æœ«å°¾ â–¼â–¼â–¼ */

        /* â–¼â–¼â–¼ è¯·ç”¨ä¸‹é¢è¿™æ®µã€æ–°æ ·å¼ã€‘æ›¿æ¢æ‰ä½ ç°æœ‰çš„ #favorites-list æ ·å¼ â–¼â–¼â–¼ */

        /* è®©æ”¶è—è§†å›¾æˆä¸ºä¸€ä¸ªflexå®¹å™¨, ä»ä¸Šåˆ°ä¸‹æ’åˆ— */
        #favorites-view {
            display: flex;
            flex-direction: column;
        }

        /* ç¡®ä¿æ”¶è—é¡µçš„headeré«˜åº¦å›ºå®šï¼Œä¸è¢«å‹ç¼© */
        #favorites-view>.header {
            flex-shrink: 0;
        }

        /* === æ”¶è—åˆ—è¡¨æ ·å¼ (ä¿®æ­£å) === */
        #favorites-list {
            flex-grow: 1;
            overflow-y: auto;
            overflow-x: hidden;
            /* <-- æ–°å¢è¿™è¡Œï¼Œç¦æ­¢æ°´å¹³æ»šåŠ¨ */
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–² */

        .favorite-item-card {
            background-color: var(--secondary-bg);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
            position: relative;
            /* ä¸ºäº†å®šä½åˆ é™¤æŒ‰é’® */
        }

        /* å¡ç‰‡å¤´éƒ¨ï¼ŒåŒ…å«å¤´åƒã€åå­—å’Œæ¥æº */
        .fav-card-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .fav-card-header .avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            object-fit: cover;
        }

        .fav-card-header .info {
            flex-grow: 1;
        }

        .fav-card-header .name {
            font-weight: 600;
            font-size: 15px;
        }

        .fav-card-header .source {
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* å¡ç‰‡å†…å®¹ */
        .fav-card-content {
            font-size: 14px;
            line-height: 1.6;
            color: #333;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .fav-card-content .chat-image {
            margin-top: 8px;
            /* å›¾ç‰‡å’Œæ–‡å­—çš„é—´è· */
        }

        /* åˆ é™¤æŒ‰é’® */
        .fav-delete-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 28px;
            height: 28px;
            background: #f0f2f5;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            color: var(--text-secondary);
            line-height: 28px;
            text-align: center;
        }

        .fav-delete-btn:hover {
            background-color: #e9ecef;
            color: #ff3b30;
        }

        /* â–²â–²â–² æ–°æ ·å¼ç²˜è´´ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ è¯·å°†è¿™æ®µæ–°æ ·å¼ç²˜è´´åˆ° <style> çš„æœ«å°¾ â–¼â–¼â–¼ */

        /* === æœç´¢æ æ ·å¼ === */
        .search-bar-container {
            padding: 10px 15px;
            background-color: #f9f9f9;
            /* å’Œåˆ—è¡¨èƒŒæ™¯è‰²ä¿æŒä¸€è‡´ */
            position: relative;
            /* ä¸ºäº†å®šä½æ¸…é™¤æŒ‰é’® */
            flex-shrink: 0;
        }

        #favorites-search-input {
            width: 100%;
            padding: 10px 30px 10px 15px;
            /* å³ä¾§ç•™å‡ºæ¸…é™¤æŒ‰é’®çš„ä½ç½® */
            font-size: 14px;
            border: 1px solid var(--border-color);
            border-radius: 18px;
            /* åœ†è§’çŸ©å½¢ï¼Œæ›´ç°ä»£åŒ– */
            background-color: var(--secondary-bg);
            box-sizing: border-box;
            outline: none;
        }

        #favorites-search-input:focus {
            border-color: var(--accent-color);
        }

        .search-clear-btn {
            position: absolute;
            right: 25px;
            top: 50%;
            transform: translateY(-50%);
            background: #ccc;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            line-height: 20px;
            text-align: center;
            font-size: 16px;
            cursor: pointer;
        }

        /* â–²â–²â–² æ–°æ ·å¼ç²˜è´´ç»“æŸ â–²â–²â–² */

        /* === èŠå¤©ç•Œé¢å¤šé€‰æ“ä½œæ ä¼˜åŒ– === */
        #chat-interface-screen .header .selection-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        #chat-interface-screen .selection-controls .action-btn {
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            padding: 5px;
        }

        /* === æ”¶è—é¡µé¢å¤šé€‰æ¨¡å¼æ ·å¼ === */
        #favorites-view.selection-mode .favorite-item-card {
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        /* é€‰æ‹©æ¡†çš„æ ·å¼ */
        .favorite-item-card::before {
            content: '';
            position: absolute;
            left: -25px;
            /* æŠŠå®ƒæ”¾åœ¨å¡ç‰‡å·¦è¾¹å¤–é¢ */
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            border: 2px solid #ccc;
            border-radius: 50%;
            background-color: white;
            transition: all 0.2s ease;
            opacity: 0;
            /* é»˜è®¤éšè— */
        }

        /* è¿›å…¥é€‰æ‹©æ¨¡å¼æ—¶ï¼Œå¡ç‰‡å‘å³ç§»åŠ¨ï¼Œéœ²å‡ºé€‰æ‹©æ¡† */
        #favorites-view.selection-mode .favorite-item-card {
            transform: translateX(35px);
        }

        #favorites-view.selection-mode .favorite-item-card::before {
            opacity: 1;
        }

        /* é€‰ä¸­åçš„æ ·å¼ */
        #favorites-view.selection-mode .favorite-item-card.selected::before {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            content: 'âœ”';
            color: white;
            font-size: 14px;
            text-align: center;
            line-height: 20px;
        }

        /* åº•éƒ¨æ“ä½œæ  (ç»ˆæä¿®æ­£ç‰ˆ) */
        #favorites-action-bar {
            position: absolute;
            /* â˜… æ”¹ä¸º absoluteï¼Œç›¸å¯¹äº #phone-screen å®šä½ */
            bottom: 0;
            left: 0;
            right: 0;
            /* â˜… æ–°å¢ right: 0ï¼Œå’Œ left: 0 ä¸€èµ·æ’‘æ»¡å®½åº¦ */
            width: auto;
            /* â˜… æ”¹ä¸º autoï¼Œè®© left/right å†³å®šå®½åº¦ */
            padding: 10px 15px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            /* é€‚é…iPhoneåº•éƒ¨å®‰å…¨åŒº */
            background-color: rgba(247, 247, 247, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-top: 1px solid var(--border-color);
            box-sizing: border-box;
            z-index: 5;
            display: none;
            /* max-width å·²ç»ä¸éœ€è¦äº†ï¼Œå› ä¸ºçˆ¶å…ƒç´ å·²ç»é™åˆ¶äº†å®½åº¦ */
        }

        #favorites-action-bar .action-bar-btn {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: none;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            background-color: #ff3b30;
            color: white;
        }

        /* === ã€ä¿®æ­£ã€‘èŠå¤©ç•Œé¢å¤´éƒ¨æ§ä»¶åˆ‡æ¢é€»è¾‘ === */

        /* é»˜è®¤çŠ¶æ€ï¼šéšè—å¤šé€‰æ§ä»¶ */
        #chat-interface-screen .header .selection-controls {
            display: none;
        }

        /* é»˜è®¤çŠ¶æ€ï¼šæ˜¾ç¤ºé»˜è®¤æ§ä»¶ï¼Œå¹¶è®©å®ƒæ’‘æ»¡æ•´ä¸ªå¤´éƒ¨ */
        #chat-interface-screen .header .default-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        /* å½“è¿›å…¥å¤šé€‰æ¨¡å¼æ—¶ï¼šéšè—é»˜è®¤æ§ä»¶ */
        #chat-interface-screen.selection-mode .header .default-controls {
            display: none;
        }

        /* å½“è¿›å…¥å¤šé€‰æ¨¡å¼æ—¶ï¼šæ˜¾ç¤ºå¤šé€‰æ§ä»¶ï¼Œå¹¶è®©å®ƒæ’‘æ»¡æ•´ä¸ªå¤´éƒ¨ */
        #chat-interface-screen.selection-mode .header .selection-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        /* â–¼â–¼â–¼ è¯·å°†è¿™æ®µæ–°æ ·å¼ç²˜è´´åˆ° <style> çš„æœ«å°¾ â–¼â–¼â–¼ */

        /* === ä¿®æ­£ï¼šæ”¾å¤§æ‰€æœ‰ä¸»è¦çš„â€œ+â€å·æŒ‰é’® === */
        #add-chat-btn,
        #add-world-book-btn,
        #create-album-btn-page {
            font-size: 28px;
            /* æ˜¾è‘—å¢å¤§å­—ä½“å¤§å°ï¼Œä½¿å…¶è§†è§‰ä¸Šä¸æ—è¾¹çš„å›¾æ ‡åŒ¹é… */
            font-weight: 300;
            /* ä½¿ç”¨æ›´ç»†çš„å­—é‡ï¼Œè®©åŠ å·çœ‹èµ·æ¥æ›´æ¸…çˆ½ï¼Œä¸æ˜¾ç²—ç¬¨ */
            position: relative;
            /* å…è®¸è¿›è¡Œä½ç½®å¾®è°ƒ */
            top: -1px;
            /* å­—ä½“æ”¾å¤§åï¼Œé€šå¸¸éœ€è¦ç¨å¾®å‘ä¸Šç§»åŠ¨ä¸€ç‚¹ï¼Œä½¿å…¶è§†è§‰ä¸Šæ›´å±…ä¸­ */
        }

        /* â–²â–²â–² æ–°æ ·å¼ç²˜è´´ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ è¯·å°†è¿™äº›æ–°æ ·å¼ç²˜è´´åˆ° <style> çš„æœ«å°¾ â–¼â–¼â–¼ */

        /* é¢„è§ˆåŒºå®¹å™¨æ ·å¼ */
        #settings-preview-area {
            width: 100%;
            height: 180px;
            /* ç»™ä¸€ä¸ªå›ºå®šçš„é«˜åº¦ */
            background-color: #f0f2f5;
            border-radius: 8px;
            padding: 15px;
            box-sizing: border-box;
            overflow: hidden;
            /* é˜²æ­¢å†…å®¹æº¢å‡º */
            display: flex;
            flex-direction: column;
            gap: 10px;
            /* é¢„è§ˆæ°”æ³¡ä¹‹é—´çš„é—´è· */
            border: 1px solid var(--border-color);
            position: relative;
            /* ä¸ºäº†å®šä½èƒŒæ™¯ */
        }

        /* é¢„è§ˆåŒºçš„èƒŒæ™¯ï¼Œå¯ä»¥å’ŒçœŸå®èŠå¤©ç•Œé¢åŒæ­¥ */
        #settings-preview-area::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            z-index: 1;
            opacity: 0.8;
        }

        /* è®©é¢„è§ˆæ°”æ³¡åœ¨èƒŒæ™¯ä¹‹ä¸Š */
        #settings-preview-area .message-wrapper {
            position: relative;
            z-index: 2;
        }

        /* é¢„è§ˆåŒºå†…ä½¿ç”¨çš„å¤´åƒè¦å°ä¸€ç‚¹ */
        #settings-preview-area .message-bubble .avatar {
            width: 30px;
            height: 30px;
        }

        #settings-preview-area .avatar-with-frame {
            width: 30px;
            height: 30px;
        }

        #settings-preview-area .avatar-with-frame .avatar-frame {
            width: 44px;
            height: 44px;
            top: -7px;
            left: -7px;
        }

        #settings-preview-area .message-bubble .timestamp {
            display: none;
            /* é¢„è§ˆåŒºä¸éœ€è¦æ˜¾ç¤ºæ—¶é—´æˆ³ */
        }

        /* â–²â–²â–² æ–°æ ·å¼ç²˜è´´ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ è¯·å°†è¿™æ®µæ–°CSSç²˜è´´åˆ° <style> çš„æœ«å°¾ â–¼â–¼â–¼ */
        .existing-group-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .existing-group-item .group-name {
            font-weight: 500;
        }

        .existing-group-item .delete-group-btn {
            color: #ff3b30;
            font-size: 20px;
            cursor: pointer;
            padding: 5px;
        }

        /* â–²â–²â–² æ–°CSSç²˜è´´ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ è¯·å°†è¿™æ®µæ–°CSSç²˜è´´åˆ° <style> çš„æœ«å°¾ â–¼â–¼â–¼ */
        .chat-group-container {
            border-bottom: 1px solid var(--border-color);
        }

        .chat-group-container:first-child {
            border-top: 1px solid var(--border-color);
        }

        .chat-group-header {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            cursor: pointer;
            background-color: #f7f7f7;
        }

        .chat-group-header .arrow {
            font-size: 14px;
            margin-right: 8px;
            transition: transform 0.2s ease;
        }

        .chat-group-header.collapsed .arrow {
            transform: rotate(-90deg);
        }

        .chat-group-header .group-name {
            font-weight: 600;
            font-size: 15px;
        }

        .chat-group-content {
            max-height: 1000px;
            /* ä¸€ä¸ªè¶³å¤Ÿå¤§çš„å€¼ */
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
        }

        .chat-group-content.collapsed {
            max-height: 0;
        }

        /* â–²â–²â–² æ–°CSSç²˜è´´ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ è¯·å°†è¿™æ®µæ–°CSSç²˜è´´åˆ° <style> çš„æœ«å°¾ â–¼â–¼â–¼ */

        /* æ ¼å¼åŠ©æ‰‹æŒ‰é’®çš„å®¹å™¨ */
        .format-helpers {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            /* ä¸ä¸‹æ–¹çš„æ–‡æœ¬æ¡†æ‹‰å¼€è·ç¦» */
            flex-wrap: wrap;
            /* å¦‚æœæŒ‰é’®å¤ªå¤šå¯ä»¥æ¢è¡Œ */
        }

        /* å•ä¸ªæ ¼å¼åŠ©æ‰‹æŒ‰é’®çš„æ ·å¼ */
        .format-btn {
            background-color: #e9ecef;
            color: var(--text-primary);
            border: none;
            padding: 6px 12px;
            border-radius: 16px;
            /* èƒ¶å›Šå½¢çŠ¶ï¼Œæ›´å‹å¥½ */
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .format-btn:hover {
            background-color: #dcdfe3;
        }

        /* â–²â–²â–² æ–°CSSç²˜è´´ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ è¯·å°†è¿™æ®µæ–°CSSç²˜è´´åˆ° <style> çš„æœ«å°¾ â–¼â–¼â–¼ */

        /* â€œâ€¦â€æŒ‰é’®çš„æ ·å¼ */
        .post-actions-btn {
            margin-left: auto;
            /* å…³é”®ï¼šè®©å®ƒè‡ªåŠ¨é åˆ°æœ€å³è¾¹ */
            padding: 5px 10px;
            font-size: 24px;
            font-weight: bold;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 50%;
            line-height: 1;
            transition: none;
        }

        .post-actions-btn:hover {
            background-color: #f0f0f0;
        }

        .post-actions-btn:active {
            background-color: #f0f0f0;
        }

        /* åŠ¨æ€ç¼–è¾‘æ¨¡æ€æ¡†çš„æ ·å¼ (å®ƒå°†å¤ç”¨ç°æœ‰çš„æ“ä½œèœå•æ ·å¼) */
        #post-actions-modal .custom-modal-footer button {
            width: 100%;
            border: none;
            border-bottom: 1px solid #dbdbdb;
            padding: 14px;
            font-size: 18px;
        }

        #post-actions-modal .custom-modal-footer button:last-child {
            border-bottom: none;
        }

        #post-actions-modal #cancel-post-action-btn {
            margin-top: 8px;
            border-radius: 8px;
            background-color: #f0f0f0;
        }

        /* â–²â–²â–² æ–°CSSç²˜è´´ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ Share Link Functionality Styles â–¼â–¼â–¼ */
        /* 1. Browser interface background and content area styles */
        #browser-screen {
            background-color: #f8f9fa;
        }

        #browser-content {
            padding: 20px;
            font-size: 16px;
            line-height: 1.8;
            color: #333;
            overflow-y: auto;
            background-color: #f8f9fa;
        }

        #browser-content .article-title {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        #browser-content .article-meta {
            font-size: 13px;
            color: #8a8a8a;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e0e0e0;
        }

        #browser-content .article-body {
            white-space: pre-wrap;
            word-break: break-word;
        }

        #browser-content .article-body p {
            margin-bottom: 1em;
        }

        /* 2. Link card styles in chat bubbles */
        .message-bubble.is-link-share .content {
            padding: 0;
            background: transparent;
            box-shadow: none;
            border: none;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }

        .link-share-card {
            width: 210px;
            background-color: #fff;
            border-radius: 10px;
            border: 1px solid #e0e0e0;
            padding: 12px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .link-share-card:hover {
            background-color: #f9f9f9;
        }

        .link-share-card .title {
            font-weight: 600;
            font-size: 15px;
            line-height: 1.4;
            color: #1f1f1f;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .link-share-card .description {
            font-size: 13px;
            color: #8a8a8a;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .link-share-card .footer {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        .link-share-card .footer-icon {
            width: 14px;
            height: 14px;
            flex-shrink: 0;
        }

        /* â–²â–²â–² Share Link Styles End â–²â–²â–² */

        /* â–¼â–¼â–¼ Location Share Message Styles â–¼â–¼â–¼ */
        .message-bubble.is-location-share .content {
            padding: 4px;
            margin: 0;
        }

        .location-share-content {
            display: flex;
            flex-direction: row;
            gap: 12px;
            width: 240px;
            min-height: 64px;
        }

        .location-map-image {
            position: relative;
            width: 64px;
            height: 64px;
            border-radius: 4px;
            overflow: hidden;
            flex-shrink: 0;
        }

        .location-map-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .location-map-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .location-pin-icon {
            width: 20px;
            height: 20px;
        }

        .location-details {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
            justify-content: center;
        }

        .location-details .location-name {
            font-weight: 600;
            font-size: 15px;
            line-height: 1.4;
            color: #1f1f1f;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .location-details .location-address {
            font-size: 13px;
            color: #666;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* â–²â–²â–² Location Share Card Styles End â–²â–²â–² */

        /* â–¼â–¼â–¼ Meetup Screen Styles â–¼â–¼â–¼ */
        #meetup-screen {
            background: linear-gradient(135deg, #ffeef8, #f0f8ff);
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        #meetup-context-bar {
            background: rgba(255, 255, 255, 0.9);
            padding: 12px 20px;
            border-bottom: 1px solid #e0e0e0;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .context-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .event-location,
        .event-time,
        .event-phase {
            font-size: 13px;
            color: #666;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .end-date-button {
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
            color: white;
            border: none;
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 2px 8px rgba(255, 107, 107, 0.3);
        }

        .end-date-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 107, 107, 0.4);
        }

        .event-phase {
            color: #8e44ad;
            font-weight: 500;
        }

        .meetup-messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        /* Meetup uses regular chat message styling, but we override text colors with higher specificity */
        #meetup-messages .message-bubble.user .content,
        #meetup-messages .message-bubble.ai .content {
            color: var(--text-primary);
        }

        .behavioral-notation {
            color: #888888;
            font-style: italic;
        }

        .event-context-indicator {
            background: rgba(142, 68, 173, 0.1);
            border: 1px solid rgba(142, 68, 173, 0.3);
            border-radius: 12px;
            padding: 8px 12px;
            margin: 8px 0;
            text-align: center;
            font-size: 13px;
            color: #8e44ad;
            font-style: italic;
        }

        .phase-transition {
            background: linear-gradient(135deg, #ff9a9e, #fecfef);
            border-radius: 12px;
            padding: 10px 16px;
            margin: 12px 0;
            text-align: center;
            font-size: 14px;
            color: #8e44ad;
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(255, 154, 158, 0.3);
        }

        .meetup-input-container {
            flex-shrink: 0;
            padding: 8px;
            background-color: rgba(247, 247, 247, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        #meetup-input-main-row {
            display: flex;
            align-items: flex-end;
            gap: 8px;
        }

        #meetup-input {
            flex-grow: 1;
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            background-color: var(--secondary-bg);
            font-size: 16px;
            max-height: 100px;
            resize: none;
        }

        #meetup-input::placeholder {
            color: #999;
            font-style: italic;
        }

        .meetup-actions-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        #meetup-wait-reply-btn {
            background: none;
            border: none;
            padding: 4px;
            cursor: pointer;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        #meetup-wait-reply-btn:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        #meetup-wait-reply-btn img {
            width: 24px;
            height: 24px;
        }

        #meetup-send-btn {
            background: linear-gradient(135deg, #ff6b9d, #c44569);
            color: white;
            border: none;
            border-radius: 16px;
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        #meetup-send-btn:hover {
            opacity: 0.9;
        }

        #meetup-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Meetup header styles - match chat interface */
        #meetup-screen .header .default-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        #meetup-screen .header .selection-controls {
            display: none;
            width: 100%;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }

        #meetup-screen.selection-mode .header .default-controls {
            display: none;
        }

        #meetup-screen.selection-mode .header .selection-controls {
            display: flex;
        }

        #meetup-selection-cancel-btn {
            color: var(--text-primary);
            cursor: pointer;
            font-size: 16px;
        }

        #meetup-selection-count {
            color: var(--text-primary);
            font-size: 16px;
            font-weight: 500;
        }

        /* â–²â–²â–² Meetup Screen Styles End â–²â–²â–² */

        /* â–¼â–¼â–¼ Meetup History Screen Styles (Same as Meetup) â–¼â–¼â–¼ */
        /* History mode should look exactly like meetup screen - no background changes needed */
        /* â–²â–²â–² Meetup History Screen Styles End â–²â–²â–² */

        /* â–¼â–¼â–¼ ã€å…¨æ–°ã€‘ç²¾è‡´ç‰ˆè½¬è´¦æ“ä½œå¼¹çª—æ ·å¼ â–¼â–¼â–¼ */
        .transfer-actions-content {
            background-color: #fff0f5;
            /* ç²‰å«©çš„èƒŒæ™¯è‰² */
            border-radius: 20px;
            width: 290px;
            padding: 20px;
            box-shadow: 0 5px 25px rgba(255, 105, 180, 0.3);
            /* ç²‰è‰²é˜´å½± */
            text-align: center;
            position: relative;
            border: 1px solid #ffcce0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        .transfer-actions-header {
            font-size: 20px;
            font-weight: bold;
            color: #a35c7b;
            /* æ·±ç²‰è‰²æ ‡é¢˜ */
            margin-bottom: 15px;
        }

        .transfer-actions-body p {
            font-size: 15px;
            color: #666;
            margin-bottom: 20px;
            line-height: 1.4;
        }

        .transfer-actions-footer {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .transfer-actions-footer .action-btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
        }

        .transfer-actions-footer .action-btn.accept {
            background: linear-gradient(135deg, #ff85b3, #ff6b9d);
            box-shadow: 0 4px 15px rgba(255, 107, 157, 0.4);
        }

        .transfer-actions-footer .action-btn.accept:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 157, 0.6);
        }

        .transfer-actions-footer .action-btn.decline {
            background: linear-gradient(135deg, #c2c2c2, #a0a0a0);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .transfer-actions-content .cancel-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: none;
            background-color: rgba(0, 0, 0, 0.1);
            color: #a35c7b;
            font-size: 20px;
            line-height: 28px;
            cursor: pointer;
        }

        /* â–²â–²â–² æ–°CSSç²˜è´´ç»“æŸ â–²â–²â–² */

        /* ç»Ÿä¸€é‡ç½®è½¬è´¦å¡ç‰‡å†…æ‰€æœ‰æ–‡å­—çš„ç‰¹æ•ˆå’Œé¢œè‰² */
        #chat-messages .transfer-card .transfer-title,
        #chat-messages .transfer-card .transfer-amount,
        #chat-messages .transfer-card .transfer-note {
            text-shadow: none !important;
            /* å¼ºåˆ¶ç§»é™¤ä»»ä½•å‘å…‰æˆ–é˜´å½±æ•ˆæœ */
            color: white !important;
            /* å¼ºåˆ¶é”å®šæ–‡å­—é¢œè‰²ä¸ºç™½è‰² */
        }

        /* åˆ†åˆ«é”å®šå„è‡ªçš„å­—ä½“å¤§å°å’Œå­—é‡ï¼Œé˜²æ­¢è¢«ç¯¡æ”¹ */
        #chat-messages .transfer-card .transfer-title {
            font-size: 16px !important;
            font-weight: 600 !important;
        }

        #chat-messages .transfer-card .transfer-amount {
            font-size: 28px !important;
            font-weight: bold !important;
        }

        #chat-messages .transfer-card .transfer-note {
            font-size: 13px !important;
            opacity: 0.9 !important;
        }

        /* â–¼â–¼â–¼ è¯·ç”¨ä¸‹é¢è¿™ã€ä¸€æ•´å—ã€‘å…¨æ–°çš„è‡ªé€‚åº”ä»£ç ï¼Œæ›¿æ¢æ‰æ‰€æœ‰æ—§çš„å¤´åƒç›¸å…³æ ·å¼ â–¼â–¼â–¼ */

        /* 1. å¤´åƒå®¹å™¨çš„ã€é»˜è®¤/æ— æ¡†ã€‘çŠ¶æ€ */
        .avatar-group {
            width: 34px;
            /* é»˜è®¤å®½åº¦ï¼Œå’Œå¤´åƒå›¾ç‰‡ä¸€æ ·å®½ */
            flex-shrink: 0;
            position: relative;
            transition: width 0.2s ease;
            /* æ·»åŠ ä¸€ä¸ªå¹³æ»‘çš„å®½åº¦å˜åŒ–åŠ¨ç”» */
        }

        /* 2. å½“ã€æœ‰æ¡†ã€‘æ—¶ï¼Œå¤´åƒå®¹å™¨è‡ªåŠ¨å˜å®½ */
        .avatar-group.has-frame {
            width: 42px;
            /* å˜å¾—æ›´å®½ï¼Œä¸ºæ›´å¤§çš„å¤´åƒå›¾ç‰‡å’Œæ¡†ç•™å‡ºç©ºé—´ */
        }

        /* 3. æ™®é€šå¤´åƒï¼ˆæ— æ¡†æ—¶ï¼‰çš„æ ·å¼ */
        .message-bubble .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            flex-shrink: 0;
        }

        /* 4. å¸¦æ¡†å¤´åƒçš„å®¹å™¨ã€é»˜è®¤ã€‘å¤§å° */
        .avatar-with-frame {
            position: relative;
            width: 40px;
            /* é»˜è®¤å’Œæ™®é€šå¤´åƒä¸€æ ·å¤§ */
            height: 40px;
            margin: 0 auto;
            transition: all 0.2s ease;
            /* ä¸ºå¤§å°å˜åŒ–æ·»åŠ åŠ¨ç”» */
            flex-shrink: 0;
        }

        /* 5. å½“ã€æœ‰æ¡†ã€‘æ—¶ï¼Œå¸¦æ¡†å¤´åƒçš„å®¹å™¨è‡ªåŠ¨ã€å˜å¤§ã€‘ï¼Œè§£å†³æ‚¨è¯´çš„â€œå›¾å°æ¡†å¤§â€é—®é¢˜ï¼ */
        .avatar-group.has-frame .avatar-with-frame {
            width: 67px;
            /* å›¾ç‰‡å®¹å™¨å˜å¤§ */
            height: 67px;
        }

        /* 6. å¤´åƒå›¾ç‰‡æœ¬èº«ï¼Œæ°¸è¿œæ’‘æ»¡å®ƒçš„å®¹å™¨ */
        .avatar-with-frame .avatar-img {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            object-fit: cover;
            z-index: 1;
        }

        /* 7. å¤´åƒæ¡†ï¼Œæ°¸è¿œåŸºäºå®ƒçš„çˆ¶å®¹å™¨å±…ä¸­ */
        .avatar-with-frame .avatar-frame {
            position: absolute;
            width: 67px;
            height: 67px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
            pointer-events: none;
        }

        /* â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ è¿™æ˜¯æ–°å¢çš„æ ·å¼ï¼Œç”¨äºä¿®æ­£æ‰€æœ‰å¤´éƒ¨æ ‡é¢˜çš„å±…ä¸­é—®é¢˜ â–¼â–¼â–¼ */
        .header>span:nth-child(2),
        #chat-header-title,
        #meetup-title {
            position: absolute;
            left: 50%;
            transform: translateX(calc(-50% - 2px));
            /* åœ¨-50%çš„åŸºç¡€ä¸Šï¼Œå†å‘å·¦æ¨2åƒç´  */

            /* (å¯é€‰ä½†æ¨è) é˜²æ­¢é•¿æ ‡é¢˜ä¸ä¸¤è¾¹æŒ‰é’®é‡å  */
            max-width: 60%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* â–²â–²â–² ç²˜è´´ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ ã€å…¨æ–°ã€‘å¯è§†åŒ–æ¶ˆæ¯ç¼–è¾‘å™¨æ ·å¼ â–¼â–¼â–¼ */
        #message-editor-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .message-editor-block {
            background-color: #f9f9f9;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
        }

        .message-editor-block textarea {
            width: 100%;
            min-height: 60px;
            resize: vertical;
            border: 1px solid #ccc;
            border-radius: 6px;
            padding: 8px;
            font-size: 14px;
            box-sizing: border-box;
        }

        .message-editor-block .format-helpers {
            margin-top: 8px;
            margin-bottom: 0;
            /* è¦†ç›–é»˜è®¤çš„ margin-bottom */
        }

        .message-editor-block .delete-block-btn {
            float: right;
            margin-top: -5px;
            background: none;
            border: none;
            color: #ff3b30;
            font-size: 20px;
            cursor: pointer;
        }

        /* â–²â–²â–² æ–°CSSç²˜è´´ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ ã€å…¨æ–°ã€‘è”ç³»äººé€‰æ‹©å™¨æ ·å¼ â–¼â–¼â–¼ */
        .contact-picker-item {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
        }

        .contact-picker-item .checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid #ccc;
            border-radius: 50%;
            margin-right: 15px;
            transition: all 0.2s ease;
        }

        .contact-picker-item.selected .checkbox {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            content: 'âœ”';
            color: white;
            font-size: 14px;
            text-align: center;
            line-height: 20px;
        }

        .contact-picker-item .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 12px;
        }

        .contact-picker-item .name {
            font-weight: 500;
        }

        /* â–²â–²â–² æ–°CSSç²˜è´´ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ ã€å…¨æ–°ã€‘ä¿®å¤è”ç³»äººé€‰æ‹©å™¨â€œå–æ¶ˆâ€æŒ‰é’®å­—ä½“å¤§å° â–¼â–¼â–¼ */
        #cancel-contact-picker-btn {
            font-size: 16px;
            /* è¦†ç›– .back-btn çš„ 24pxï¼Œä¸å³ä¾§â€œå®Œæˆâ€æŒ‰é’®ä¿æŒä¸€è‡´ */
            font-weight: 600;
            /* åŒæ ·è®¾ç½®å­—é‡ä»¥ä¿è¯è§†è§‰ç»Ÿä¸€ */
            width: auto;
            /* è¦†ç›– .back-btn å›ºå®šçš„30pxå®½åº¦ï¼Œè®©å…¶å®½åº¦è‡ªé€‚åº”â€œå–æ¶ˆâ€äºŒå­— */
            padding: 0 5px;
            /* å¢åŠ ä¸€ç‚¹å·¦å³å†…è¾¹è·ï¼Œè®©æ–‡å­—ä¸æ˜¾å¾—æ‹¥æŒ¤ */
        }

        /* â–²â–²â–² æ–°CSSç²˜è´´ç»“æŸ â–²â–²â–² */


        /* â–¼â–¼â–¼ ã€å…¨æ–°ã€‘ç¾¤æˆå‘˜ç®¡ç†ç•Œé¢æ ·å¼ â–¼â–¼â–¼ */
        #member-management-list {
            padding: 0;
            /* ç§»é™¤é»˜è®¤paddingï¼Œè®©åˆ—è¡¨é¡¹æ’‘æ»¡ */
        }

        .member-management-item {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .member-management-item .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 12px;
        }

        .member-management-item .name {
            flex-grow: 1;
            font-weight: 500;
        }

        .member-management-item .remove-member-btn {
            background-color: #ff3b30;
            color: white;
            border: none;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            font-size: 20px;
            line-height: 28px;
            text-align: center;
            cursor: pointer;
            flex-shrink: 0;
        }

        #member-management-actions {
            flex-shrink: 0;
            padding: 15px;
            border-top: 1px solid var(--border-color);
            background-color: #f7f7f7;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #member-management-actions button {
            width: 100%;
            padding: 15px;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }

        #member-management-actions #create-new-member-btn {
            background-color: #4cd964;
            /* æ–°å»ºç”¨ç»¿è‰²ï¼Œä»¥ç¤ºåŒºåˆ† */
        }

        /* â–²â–²â–² æ–°CSSç²˜è´´ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ ã€å…¨æ–°ã€‘å¤–å–ä»£ä»˜å¡ç‰‡æ ·å¼ â–¼â–¼â–¼ */
        .message-bubble.is-waimai-request .content {
            padding: 0;
            background: transparent;
            box-shadow: none;
            border: none;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }

        .waimai-card {
            width: 240px;
            border-radius: 12px;
            overflow: hidden;
            background-color: #fff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        .waimai-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            border-bottom: 1px solid #f0f0f0;
        }

        .waimai-header .icon {
            width: 20px;
            height: 20px;
        }

        .waimai-header .title-group {
            display: flex;
            align-items: baseline;
            font-size: 14px;
            color: #8a8a8a;
        }

        .waimai-header .title-group .brand {
            font-weight: 600;
            color: #555;
            margin-right: 5px;
        }

        .waimai-header .title-group .separator {
            margin: 0 5px;
        }

        .waimai-catchphrase {
            font-size: 13px;
            color: #1f1f1f;
            padding: 12px;
        }

        .waimai-main {
            background-color: #FFD66B;
            /* æ©™é»„è‰²èƒŒæ™¯ */
            padding: 12px;
            text-align: center;
        }

        .waimai-main .request-title {
            font-size: 12px;
            color: #856404;
            margin-bottom: 8px;
        }

        .waimai-main .payment-box {
            background-color: #fff;
            border-radius: 8px;
            padding: 15px 10px;
        }

        .waimai-main .payment-label {
            font-size: 13px;
            color: #8a8a8a;
        }

        .waimai-main .amount {
            font-size: 32px;
            font-weight: 700;
            color: #1f1f1f;
            margin: 4px 0 12px 0;
        }

        .waimai-main .countdown-label {
            font-size: 13px;
            color: #8a8a8a;
        }

        .waimai-main .countdown-timer {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            margin-left: 5px;
        }

        .waimai-main .countdown-timer span {
            background-color: #333;
            color: white;
            padding: 2px 4px;
            border-radius: 2px;
            font-weight: bold;
            font-size: 12px;
        }

        .waimai-details-btn {
            width: 100%;
            padding: 10px 0;
            margin-top: 15px;
            border: none;
            border-radius: 6px;
            background-color: #FFC33A;
            color: #49380a;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }

        /* â–²â–²â–² æ–°CSSç²˜è´´ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ ã€å…¨æ–°ã€‘å¤–å–å“åº”çŠ¶æ€æ ·å¼ â–¼â–¼â–¼ */

        /* === åŒæ„æ”¯ä»˜åçš„æ ·å¼ === */
        .message-bubble.status-paid .waimai-card {
            border: 2px solid #28a745;
            /* ç»¿è‰²è¾¹æ¡† */
        }

        .message-bubble.status-paid .waimai-main .request-title::before {
            content: 'âœ…  ';
        }

        .message-bubble.status-paid .waimai-main .request-title {
            color: #155724;
            font-weight: 600;
            /* é‡å†™ request-title çš„å†…å®¹ */
            content: "æˆ‘å·²ä¸ºæ‚¨ä¹°å•ï¼Œè¯·å°½æƒ…äº«ç”¨å§ï½" !important;
            display: block;
            margin-bottom: 15px;
        }

        .message-bubble.status-paid .payment-box {
            display: none;
            /* éšè—æ”¯ä»˜è¯¦æƒ… */
        }

        .message-bubble.status-paid .waimai-details-btn {
            background-color: #28a745;
            color: white;
        }

        /* === æ‹’ç»æ”¯ä»˜åçš„æ ·å¼ === */
        .message-bubble.status-rejected .waimai-card {
            border: 2px solid #dc3545;
            /* çº¢è‰²è¾¹æ¡† */
            opacity: 0.8;
        }

        .message-bubble.status-rejected .waimai-main {
            background-color: #e9ecef;
        }

        .message-bubble.status-rejected .waimai-main .request-title::before {
            content: 'âŒ ';
        }

        .message-bubble.status-rejected .waimai-main .request-title {
            color: #721c24;
            font-weight: 600;
            /* é‡å†™ request-title çš„å†…å®¹ */
            content: "æˆ‘æ‹’ç»äº†æ‚¨çš„ä»£ä»˜è¯·æ±‚" !important;
            display: block;
            margin-bottom: 15px;
        }

        .message-bubble.status-rejected .payment-box {
            display: none;
            /* éšè—æ”¯ä»˜è¯¦æƒ… */
        }

        .message-bubble.status-rejected .waimai-details-btn {
            background-color: #6c757d;
            color: white;
        }

        /* å¼ºåˆ¶é‡å†™ request-title å†…å®¹çš„æŠ€å·§ */
        .message-bubble[class*="status-"] .request-title {
            font-size: 0;
            /* éšè—åŸå§‹æ–‡æœ¬ */
        }

        .message-bubble[class*="status-"] .request-title::after {
            font-size: 14px;
            /* è®©ä¼ªå…ƒç´ æ˜¾ç¤ºæ–°æ–‡æœ¬ */
        }

        .message-bubble.status-paid .request-title::after {
            content: "æˆ‘å·²ä¸ºæ‚¨ä¹°å•ï¼Œè¯·å°½æƒ…äº«ç”¨å§ï½";
        }

        .message-bubble.status-rejected .request-title::after {
            content: "æˆ‘æ‹’ç»äº†æ‚¨çš„ä»£ä»˜è¯·æ±‚";
        }

        /* â–²â–²â–² æ–°CSSç²˜è´´ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ ã€å…¨æ–°ã€‘å¤–å–è¯·æ±‚çš„ç”¨æˆ·æ“ä½œæŒ‰é’®æ ·å¼ â–¼â–¼â–¼ */
        .waimai-user-actions {
            display: flex;
            gap: 10px;
            padding: 0 12px 12px 12px;
            /* åœ¨å¡ç‰‡åº•éƒ¨ç•™å‡ºç©ºé—´ */
            background-color: #fff;
        }

        .waimai-user-actions button {
            flex: 1;
            padding: 10px;
            border-radius: 8px;
            border: 1.5px solid;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .waimai-pay-btn {
            background-color: #28a745;
            border-color: #1f7a33;
            color: white;
        }

        .waimai-pay-btn:hover {
            background-color: #218838;
        }

        .waimai-decline-btn {
            background-color: #f8f9fa;
            border-color: #ced4da;
            color: #495057;
        }

        .waimai-decline-btn:hover {
            background-color: #e2e6ea;
        }

        /* â–²â–²â–² æ–°CSSç²˜è´´ç»“æŸ â–²â–²â–² */

        /* === ã€æ–°å¢ã€‘ç»Ÿä¸€è®¾ç½®é¡µé¢çš„èƒŒæ™¯è‰² (å·²ä¿®æ­£) === */
        #api-settings-screen,
        #appearance-settings-screen,
        #memories-view,
        #contact-picker-screen,
        /* <-- æ–°å¢è¿™è¡Œ */
        #member-management-screen {
            /* <-- æ–°å¢è¿™è¡Œ */
            background-color: var(--secondary-bg);
        }

        /* ç¡®ä¿è¿™äº›é¡µé¢çš„å†…å®¹åŒºèƒ½æ­£ç¡®æ»šåŠ¨ */
        #api-settings-screen .form-container,
        #appearance-settings-screen .form-container {
            padding-top: 100px;
            margin-top: -80px;
            background-color: var(--secondary-bg);
        }

        /* è®¾ç½®é¡µé¢çš„é¢„è§ˆåŒºæ¯”è¾ƒç‰¹æ®Šï¼Œéœ€è¦é¢å¤–è°ƒæ•´ */
        #appearance-settings-screen .form-container {
            align-items: center;
            /* ä¿æŒå†…å®¹å±…ä¸­ */
        }




        /* ç¡®ä¿å£çº¸é¢„è§ˆä¸è¢«å‹ç¼©ä¸”å¯è§ */
        #appearance-settings-screen #wallpaper-preview {
            flex-shrink: 0;
            margin-bottom: 20px;
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        /* ç¡®ä¿åˆ†éš”çº¿åœ¨å¤–è§‚è®¾ç½®é¡µé¢ä¸­å¯è§ */
        #appearance-settings-screen hr {
            display: block !important;
            width: 100% !important;
            border: 0;
            border-top: 1px solid #000;
            align-self: stretch !important;
        }

        /* Calendar app styles */
        .calendar-month-view-no-card {
            padding: 8px 0;
            margin-bottom: 20px;
        }

        .calendar-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 8px;
        }

        .calendar-nav-btn {
            background: none;
            border: none;
            font-size: 24px;
            color: var(--accent-color);
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .calendar-nav-btn:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        .calendar-month-year {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
            margin-left: 8px;
        }

        .calendar-weekdays {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 4px;
            margin-bottom: 10px;
        }

        .weekday {
            text-align: center;
            padding: 8px;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 4px;
        }

        .calendar-date {
            text-align: center;
            cursor: pointer;
            font-size: 16px;
            color: var(--text-primary);
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            margin: 0 auto;
        }

        .calendar-date:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        .calendar-date.other-month {
            color: var(--text-secondary);
            opacity: 0.5;
        }

        .calendar-date.selected {
            background: transparent;
            color: white;
            position: relative;
        }

        .calendar-date.selected::before {
            content: '';
            position: absolute;
            top: calc(50% - 1px);
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            background: var(--accent-color);
            border-radius: 50%;
            z-index: -1;
        }

        .calendar-date.today.selected {
            color: white;
        }

        .calendar-date.today {
            background: rgba(var(--accent-color-rgb), 0.1);
            color: var(--accent-color);
            font-weight: 600;
        }

        /* Memory indicators on calendar dates */
        .calendar-date {
            position: relative;
        }

        .memory-indicators {
            position: absolute;
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2px;
        }

        .memory-indicator {
            width: 4px;
            height: 4px;
            border-radius: 50%;
        }

        .memory-indicator.user-memory {
            background: #007AFF;
            /* Blue for user's manual memories */
        }

        .memory-indicator.ai-memory {
            background: #FF8C00;
            /* Darker yellow/orange for AI-generated memories */
        }

        .memory-indicator.countdown {
            background: #9370DB;
            /* Lighter purple for countdown events */
        }

        .memory-indicator.meetup {
            background: #FF3B30;
            /* Red for meetup events */
        }

        .calendar-events-section {
            background: rgb(247, 247, 247);
            padding: 20px;
            margin: 0 -20px -20px -20px;
            /* Negative margins to bleed to edges: top=0, right=-20px, bottom=-20px, left=-20px */
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        .calendar-events-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .calendar-events-header #selected-date-display {
            margin-left: 8px;
        }

        .calendar-events-list {
            flex: 1;
            min-height: 100px;
            /* Removed padding-bottom: 24px; - using spacer div instead */
        }

        .no-events-message {
            text-align: center;
            color: var(--text-secondary);
            font-style: italic;
            padding: 20px;
        }

        /* NEW: Calendar memory item styles - copying qzone post styling */
        .calendar-memory-item {
            padding: 12px;
            margin-bottom: 16px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .calendar-memory-item:last-child {
            margin-bottom: 44px !important;
            /* 20px to offset negative margin + 24px extra spacing */
        }

        /* Memory type styling */
        .calendar-memory-item.memory-type {
            background-color: #fffaf0;
            /* Pale yellow for memories */
        }

        .calendar-memory-item.countdown-type {
            background: linear-gradient(135deg, #667eea, #764ba2);
            /* Purple gradient for events */
            color: white;
        }

        .calendar-memory-item.countdown-type .memory-header,
        .calendar-memory-item.countdown-type .memory-content,
        .calendar-memory-item.countdown-type .memory-nickname,
        .calendar-memory-item.countdown-type .memory-timestamp,
        .calendar-memory-item.countdown-type .post-actions-btn {
            color: white !important;
        }

        /* Meetup type styling */
        .calendar-memory-item.meetup-type {
            background: linear-gradient(135deg, #667eea, #764ba2);
            /* Purple gradient for meetup (same as countdown) */
            color: white;
        }

        .calendar-memory-item.meetup-type .memory-header,
        .calendar-memory-item.meetup-type .memory-content,
        .calendar-memory-item.meetup-type .memory-nickname,
        .calendar-memory-item.meetup-type .memory-timestamp,
        .calendar-memory-item.meetup-type .post-actions-btn {
            color: white !important;
        }

        /* Clickable meetup events */
        .calendar-memory-item.meetup-type[style*="cursor: pointer"]:hover,
        .calendar-memory-item.countdown-type[style*="cursor: pointer"]:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            transition: all 0.2s ease;
        }

        /* Meetup status indicators */
        .meetup-status-indicator {
            font-size: 12px;
            font-weight: 600;
            margin-right: 8px;
            padding: 2px 6px;
            border-radius: 10px;
            white-space: nowrap;
        }

        .meetup-status-indicator.active {
            background-color: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
        }

        .meetup-status-indicator.template {
            background-color: rgba(102, 126, 234, 0.2);
            color: #667eea;
        }

        /* Ensure status indicators are visible on purple gradient backgrounds */
        .calendar-memory-item.countdown-type .meetup-status-indicator.template,
        .calendar-memory-item.meetup-type .meetup-status-indicator.template {
            background-color: rgba(255, 255, 255, 0.3);
            color: white;
        }

        .calendar-memory-item.countdown-type .meetup-status-indicator.active,
        .calendar-memory-item.meetup-type .meetup-status-indicator.active {
            background-color: rgba(255, 255, 255, 0.3);
            color: #90EE90;
        }

        /* Memory actions container - positioned in top right */
        .memory-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }



        /* Meetup indicator styling */
        .meetup-indicator {
            display: flex;
            align-items: center;
            opacity: 0.9;
        }

        .meetup-indicator svg {
            color: white;
        }

        /* Copy exact post-header styling */
        .memory-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .memory-header .memory-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
        }

        .memory-info {
            display: flex;
            flex-direction: column;
            flex: 1;
        }

        .memory-info .memory-nickname {
            font-weight: 600;
            font-size: 15px;
            color: var(--text-primary);
        }

        .memory-info .memory-timestamp {
            font-size: 12px;
            color: var(--text-secondary);
        }



        .memory-content {
            font-size: 14px;
            line-height: 1.6;
            color: #333;
            white-space: pre-wrap;
            word-break: break-word;
        }

        /* â–¼â–¼â–¼ ã€å…¨æ–°ã€‘æ¥ç”µè¯·æ±‚ä¸è§†é¢‘é€šè¯ç•Œé¢æ ·å¼ â–¼â–¼â–¼ */

        /* --- æ¥ç”µè¯·æ±‚æ¨¡æ€æ¡† --- */
        #incoming-call-modal .incoming-call-content {
            background-color: rgba(40, 40, 40, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 20px;
            width: 280px;
            padding: 30px 20px;
            text-align: center;
            color: white;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .caller-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 12px;
            border: 3px solid rgba(255, 255, 255, 0.5);
        }

        .caller-name {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .caller-text {
            font-size: 14px;
            color: #ccc;
            margin-bottom: 30px;
        }

        .incoming-call-actions {
            display: flex;
            justify-content: space-around;
            align-items: center;
        }

        .action-button-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #e0e0e0;
        }

        .call-action-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            background-size: 50%;
            background-repeat: no-repeat;
            background-position: center;
            /* transition: transform 0.2s, box-shadow 0.2s; - Removed to disable tap feedback */
            transition: box-shadow 0.2s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .call-action-btn:active {
            /* Tap feedback removed */
        }

        .call-action-btn.decline {
            background-color: #ff3b30;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 16.5L3 6m18 6l-5.6-5.6a1.2 1.2 0 0 0-1.7 0L3 18.2a1.2 1.2 0 0 0-.3 1.2l1.2 3.6a1.2 1.2 0 0 0 1.2.9h15.6a1.2 1.2 0 0 0 1.2-1.2V7.7a1.2 1.2 0 0 0-.3-1.1z"/></svg>');
        }

        .call-action-btn.accept {
            background-color: #4cd964;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>');
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(76, 217, 100, 0.7);
            }

            70% {
                box-shadow: 0 0 0 15px rgba(76, 217, 100, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(76, 217, 100, 0);
            }
        }

        /* --- è§†é¢‘é€šè¯ç•Œé¢ --- */
        /* â–¼â–¼â–¼ è¯·ç”¨è¿™ä¸€æ•´å—ã€æœ€ç»ˆä¿®æ­£ç‰ˆã€‘çš„ä»£ç ï¼Œæ›¿æ¢æ‰€æœ‰æ—§çš„ video-call ç›¸å…³CSS â–¼â–¼â–¼ */

        /* 1. é€šè¯å±å¹•æ€»å®¹å™¨ (ä¿æŒä¸å˜) */
        #video-call-screen {
            background-color: #1c1c1e;
            color: white;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* 2. é¡¶éƒ¨æ å’Œåº•éƒ¨æ§åˆ¶æ  (ä¿æŒä¸å˜) */
        .video-call-top-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px 20px;
            padding-top: 50px;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.5), transparent);
            z-index: 10;
            text-align: center;
            box-sizing: border-box;
            pointer-events: none;
        }

        #call-timer {
            font-size: 16px;
            font-weight: 500;
            letter-spacing: 1px;
        }

        .video-call-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 20px;
            padding-bottom: 40px;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.5), transparent);
            z-index: 10;
            box-sizing: border-box;
        }

        /* 3. å‚ä¸è€…å¤´åƒæ˜¾ç¤ºåŒº (ä¿æŒä¸å˜) */
        .video-call-avatar-area {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            padding-top: 80px;
            /* ç¡®ä¿é¡¶éƒ¨æœ‰è¶³å¤Ÿç©ºé—´ */
            box-sizing: border-box;
            overflow-y: auto;
            /* â˜… æ–°å¢ï¼šå¦‚æœå¤´åƒå¤ªå¤šï¼Œå…è®¸æ­¤åŒºåŸŸæ»šåŠ¨ */
        }

        /* 4. å¤´åƒç½‘æ ¼å®¹å™¨ (ä¿æŒä¸å˜) */
        #participant-avatars-grid {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 15px;
            /* â˜… ç¨å¾®å‡å°å¤´åƒé—´è· */
            max-width: 100%;
        }

        /* 5. å•ä¸ªå‚ä¸è€…çš„å¤´åƒå®¹å™¨ (å¤´åƒç¼©å°) */
        .participant-avatar-wrapper {
            position: relative;
            text-align: center;
            flex-shrink: 0;
        }

        .participant-avatar {
            width: 70px;
            /* â˜… ä» 80px ç¼©å°åˆ° 70px */
            height: 70px;
            /* â˜… ä» 80px ç¼©å°åˆ° 70px */
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        .participant-name {
            margin-top: 8px;
            font-size: 12px;
            color: #ccc;
        }

        /* 6. å‘è¨€è€…å¤´åƒé«˜äº®æ•ˆæœ (ä¿æŒä¸å˜) */
        .participant-avatar.speaking {
            border-color: #4cd964;
            box-shadow: 0 0 20px rgba(76, 217, 100, 0.6);
            transform: scale(1.05);
        }

        /* 7. ã€æœ€ç»ˆç‰ˆã€‘å¯¹è¯æ¡†åŒºåŸŸ */
        #video-call-main {
            flex-shrink: 0;
            height: 30%;
            /* â˜… æ ¸å¿ƒä¿®æ”¹ï¼šé«˜åº¦ä»35%å‡å°åˆ°30% */
            margin: 15px 15px 130px 15px;
            /* â˜… æ ¸å¿ƒä¿®æ”¹ï¼šåº•éƒ¨è¾¹è·ä»120pxå¢åŠ åˆ°130pxï¼Œåˆ›é€ æ˜æ˜¾ç©ºéš™ */
            overflow-y: auto;
            padding: 15px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-sizing: border-box;
        }

        /* 8. æ§åˆ¶æŒ‰é’®æ ·å¼ (ä¿æŒä¸å˜) */
        .control-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            background-repeat: no-repeat;
            background-position: center;
            /* transition: transform 0.2s, background-color 0.2s; - Removed to disable tap feedback */
            transition: background-color 0.2s;
        }

        .control-btn:active {
            /* Tap feedback removed */
        }

        .control-btn.speak-btn {
            background-color: rgba(255, 255, 255, 0.2);
            background-size: 55%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>');
        }

        .control-btn.hangup-btn {
            background-color: #ff3b30;
            background-size: 50%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 16.5L3 6m18 6l-5.6-5.6a1.2 1.2 0 0 0-1.7 0L3 18.2a1.2 1.2 0 0 0-.3 1.2l1.2 3.6a1.2 1.2 0 0 0 1.2.9h15.6a1.2 1.2 0 0 0 1.2-1.2V7.7a1.2 1.2 0 0 0-.3-1.1z"/></svg>');
        }

        .control-btn.join-btn {
            background-color: #007bff;
            background-size: 50%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="17" y1="11" x2="23" y2="11"></line></svg>');
        }

        /* â–²â–²â–² æ–°CSSæ›¿æ¢ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ ã€å…¨æ–°ã€‘è§†é¢‘é€šè¯å¯¹è¯æ°”æ³¡æ ·å¼ â–¼â–¼â–¼ */
        .call-message-bubble {
            padding: 10px 15px;
            border-radius: 12px;
            max-width: 85%;
            line-height: 1.6;
            word-break: break-word;
            white-space: pre-wrap;
        }

        .call-message-bubble.ai-speech {
            background-color: rgba(255, 255, 255, 0.15);
            align-self: flex-start;
            /* AIå‘è¨€é å·¦ */
        }

        .call-message-bubble.user-speech {
            background-color: #4cd964;
            /* ç”¨æˆ·å‘è¨€ç”¨ç»¿è‰²ï¼Œç±»ä¼¼å¾®ä¿¡ */
            align-self: flex-end;
            /* ç”¨æˆ·å‘è¨€é å³ */
            text-align: left;
            /* ç¡®ä¿ç”¨æˆ·æ°”æ³¡å†…çš„æ–‡å­—æ˜¯å·¦å¯¹é½çš„ */
        }

        /* â–²â–²â–² æ–°å¢CSSç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ ã€å…¨æ–°æ·»åŠ ã€‘æ­£åœ¨å‘¼å«ç•Œé¢æ ·å¼ â–¼â–¼â–¼ */
        #outgoing-call-screen {
            background-color: #1c1c1e;
            color: white;
            justify-content: center;
            /* å‚ç›´å±…ä¸­ */
            align-items: center;
            /* æ°´å¹³å±…ä¸­ */
        }

        .outgoing-call-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .outgoing-call-actions {
            margin-top: 50px;
            /* å’Œä¸Šæ–¹æ–‡å­—æ‹‰å¼€è·ç¦» */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #e0e0e0;
        }

        /* â–²â–²â–² æ·»åŠ ç»“æŸ â–²â–²â–² */

        /* 1. åŠ¨æ€å¸–å­çš„å¤–å±‚å®¹å™¨ï¼Œæˆ‘ä»¬éœ€è¦å®ƒæ¥å®šä½å’Œè£å‰ª */
        .qzone-post-container {
            position: relative;
            /* è®©å†…éƒ¨çš„åˆ é™¤æŒ‰é’®å¯ä»¥ç›¸å¯¹äºå®ƒå®šä½ */
            overflow: hidden;
            /* éšè—æ‰è¶…å‡ºéƒ¨åˆ†çš„åˆ é™¤æŒ‰é’® */
            border-radius: 12px;
            /* å’Œå†…éƒ¨å¡ç‰‡ä¿æŒä¸€è‡´çš„åœ†è§’ */
        }

        /* 2. å¯æ»‘åŠ¨çš„å†…å®¹å¡ç‰‡ï¼Œå¢åŠ ä¸€ä¸ªå¹³æ»‘çš„è¿‡æ¸¡æ•ˆæœ */
        .qzone-post-item {
            transition: transform 0.3s ease;
            background-color: var(--secondary-bg);
            /* ç¡®ä¿å®ƒæœ‰èƒŒæ™¯è‰²ï¼Œèƒ½ç›–ä½ä¸‹é¢çš„åˆ é™¤æŒ‰é’® */
            position: relative;
            /* ç¡®ä¿å®ƒåœ¨æœ€ä¸Šå±‚ */
            z-index: 2;
        }

        /* 3. ã€æ ¸å¿ƒã€‘è¿™å°±æ˜¯é‚£ä¸ªâ€œåˆ é™¤â€æŒ‰é’®çš„æ ·å¼ï¼*/
        .qzone-post-delete-action {
            position: absolute;
            /* ç»å¯¹å®šä½ï¼Œè„±ç¦»æ–‡æ¡£æµ */
            top: 0;
            right: 0;
            bottom: 0;
            width: 90px;
            /* åˆ é™¤æŒ‰é’®çš„å®½åº¦ */
            background-color: #ff3b30;
            /* æ‚¨æƒ³è¦çš„çº¢è‰²èƒŒæ™¯ */
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 500;
            cursor: pointer;
            z-index: 1;
            /* ç¡®ä¿å®ƒåœ¨å¡ç‰‡ä¸‹é¢ */
        }

        /* 4. å½“å¡ç‰‡å·¦æ»‘æ—¶ï¼ŒæŠŠå®ƒå‘å·¦ç§»åŠ¨ï¼Œéœ²å‡ºåˆ é™¤æŒ‰é’® */
        .qzone-post-item.swiped {
            transform: translateX(-90px);
            /* ç§»åŠ¨çš„è·ç¦»å’Œåˆ é™¤æŒ‰é’®çš„å®½åº¦ä¸€è‡´ */
        }

        /* â–²â–²â–² ç²˜è´´ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ è¯·å°†è¿™ã€ä¸€æ•´å—ã€‘å…¨æ–°çš„â€œæ‹ä¸€æ‹â€æ ·å¼ï¼Œç²˜è´´åˆ° <style> çš„æœ«å°¾ â–¼â–¼â–¼ */

        /* 1. â€œæ‹ä¸€æ‹â€çš„å±å¹•éœ‡åŠ¨åŠ¨ç”» */


        /* 2. â€œæ‹ä¸€æ‹â€ç³»ç»Ÿæç¤ºæ¶ˆæ¯çš„æ ·å¼ */
        .system-message {
            align-self: center;
            /* å±…ä¸­æ˜¾ç¤º */
            padding: 4px 12px;
            margin: 5px 0;
            background-color: rgba(0, 0, 0, 0.1);
            color: var(--text-secondary);
            font-size: 12px;
            border-radius: 10px;
            text-align: center;
            max-width: 80%;
        }

        /* â–²â–²â–² æ–°æ ·å¼ç²˜è´´ç»“æŸ â–²â–²â–² */

        /* è®©â€œæ‹ä¸€æ‹â€ç±»å‹çš„ wrapper å±…ä¸­ */
        .message-wrapper.system-pat {
            justify-content: center;
            align-self: center;
            margin: 5px 0;
            max-width: 80%;
        }

        /* â€œæ‹ä¸€-æ‹â€æ¶ˆæ¯æ°”æ³¡çš„æ ·å¼ */
        .message-bubble.system-bubble {
            background-color: rgba(0, 0, 0, 0.1);
            color: var(--text-secondary);
            font-size: 12px;
            padding: 4px 12px;
            border-radius: 10px;
        }

        /* â–¼â–¼â–¼ è¯·å°†è¿™æ®µæ–°CSSç²˜è´´åˆ° <style> çš„æœ«å°¾ â–¼â–¼â–¼ */

        /* === ä¿®æ­£ï¼šè®©é¡¶éƒ¨æ“ä½œæ å¯ä»¥æ¨ªå‘æ»šåŠ¨ === */
        #chat-input-actions-top {
            display: flex;
            gap: 8px;
            padding: 0 5px;

            /* --- æ ¸å¿ƒä»£ç å¼€å§‹ --- */
            overflow-x: auto;
            flex-wrap: nowrap;
            -webkit-overflow-scrolling: touch;

            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        #chat-input-actions-top::-webkit-scrollbar {
            display: none;
        }

        /* â–²â–²â–² æ–°CSSç²˜è´´ç»“æŸ â–²â–²â–² */

        /* === ã€å…¨æ–°ã€‘èŠå¤©ç•Œé¢å¤´éƒ¨çŠ¶æ€æ æ ·å¼ === */

        /* 1. æ ‡é¢˜å’ŒçŠ¶æ€çš„æ€»å®¹å™¨ï¼Œä½¿ç”¨flexå¸ƒå±€è®©å®ƒä»¬å‚ç›´æ’åˆ— */
        #chat-header-title-wrapper {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            /* å·¦å¯¹é½ */
            gap: 2px;
            /* æ ‡é¢˜å’ŒçŠ¶æ€ä¹‹é—´çš„å¾®å°é—´è· */

            /* ç§»åŠ¨åˆ°å·¦ä¾§ï¼Œç´§é‚»è¿”å›æŒ‰é’® */
            position: static;
            max-width: 60%;
            flex: 1;
            /* è®©æ ‡é¢˜åŒºåŸŸå æ®å‰©ä½™ç©ºé—´ */
        }

        /* 2. ä¸»æ ‡é¢˜çš„æ ·å¼å¾®è°ƒ */
        #chat-header-title {
            font-size: 16px;
            /* å¯ä»¥ç¨å¾®ç¼©å°ä¸€ç‚¹ï¼Œç»™çŠ¶æ€æ ç•™å‡ºç©ºé—´ */
            font-weight: 600;
            position: static;
            /* è¦†ç›–æ‰æ—§çš„absoluteå®šä½ */
            transform: none;
            /* è¦†ç›–æ‰æ—§çš„transform */
            /* ä¿è¯é•¿æ ‡é¢˜ä¹Ÿèƒ½æ­£ç¡®æ˜¾ç¤ºçœç•¥å· */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        /* 3. çŠ¶æ€æ å®¹å™¨ */
        #chat-header-status {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 11px;
            color: var(--text-secondary);
            transition: all 0.3s ease;
        }

        /* 4. çŠ¶æ€å°åœ†ç‚¹ */
        .status-dot {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            background-color: #4cd964;
            /* é»˜è®¤ç»¿è‰²ï¼Œä»£è¡¨åœ¨çº¿ */
            transition: background-color 0.3s ease;
        }

        /* å½“AIçŠ¶æ€ä¸ºâ€œå¿™ç¢Œâ€æˆ–â€œç¦»å¼€â€æ—¶ï¼Œè®©åœ†ç‚¹å˜ç°è‰² */
        #chat-header-status.busy .status-dot {
            background-color: #cccccc;
        }

        /* 5. çŠ¶æ€æ–‡æœ¬ */
        .status-text {
            font-weight: 500;
        }

        /* === ã€å…¨æ–°ç¾åŒ–ç‰ˆã€‘å›å¿†å¡ç‰‡æ ·å¼ === */

        /* 1. å¡ç‰‡æ€»å®¹å™¨ï¼šè¿™é‡Œè´Ÿè´£å®šä¹‰æ•´ä½“çš„èƒŒæ™¯è‰²å’Œè¾¹æ¡† */
        .memory-card {
            background-color: #fffaf0;
            /* ç»Ÿä¸€çš„ã€æ¸©æš–çš„ç±³é»„è‰²èƒŒæ™¯ */
            border-radius: 12px;
            padding: 15px;
            /* åœ¨å¡ç‰‡å››å‘¨ç•™å‡ºå†…è¾¹è· */
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.07);
            border-left: 5px solid #ffb74d;
            display: flex;
            /* è®©å®ƒæˆä¸ºflexå®¹å™¨ï¼Œæ–¹ä¾¿å†…éƒ¨å…ƒç´ æ’åˆ— */
            flex-direction: column;
            /* è®©å¤´éƒ¨å’Œå†…å®¹å‚ç›´å †å  */
            gap: 8px;
            /* åœ¨å¤´éƒ¨å’Œå†…å®¹ä¹‹é—´åˆ›é€ ä¸€ä¸ªè‡ªç„¶çš„é—´è· */
        }

        /* 2. å¤´éƒ¨å®¹å™¨ï¼šç°åœ¨åªè´Ÿè´£å¸ƒå±€å’Œåˆ†å‰²çº¿ */
        .memory-card .header {
            border-bottom: 1px solid rgba(217, 129, 0, 0.15);
            /* åˆ†å‰²çº¿é¢œè‰²å¯ä»¥ç¨å¾®åŠ æ·±ä¸€ç‚¹ */
            padding-bottom: 8px;
        }

        /* 3. æ—¥æœŸæ ·å¼ (ä¿æŒä¸å˜) */
        .memory-card .header .date {
            font-size: 11px;
            color: #a1887f;
            margin-bottom: 4px;
        }

        /* 4. ä½œè€…æ ·å¼ (ä¿æŒä¸å˜) */
        .memory-card .header .author {
            font-weight: 600;
            color: #d98100;
            font-size: 15px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* 5. å†…å®¹åŒºæ ·å¼ (ä¿æŒä¸å˜) */
        .memory-card .content {
            font-size: 14px;
            line-height: 1.7;
            color: #5d4037;
            white-space: pre-wrap;
        }

        /* === ã€å…¨æ–°ã€‘çº¦å®š/å€’è®¡æ—¶å¡ç‰‡æ ·å¼ === */
        .countdown-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(118, 75, 162, 0.4);
            text-align: center;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
        }

        .countdown-card::before {
            content: 'âœ¨';
            position: absolute;
            top: -10px;
            left: -10px;
            font-size: 50px;
            opacity: 0.1;
            transform: rotate(-15deg);
        }

        .countdown-card .title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
        }

        .countdown-card .timer {
            font-size: 28px;
            font-weight: 300;
            letter-spacing: 2px;
            margin-bottom: 15px;
        }

        .countdown-card .target-date {
            font-size: 12px;
            opacity: 0.8;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            padding-top: 10px;
        }

        /* === ã€å…¨æ–°ã€‘èŠå¤©é”å®šé®ç½©å±‚æ ·å¼ === */
        #chat-lock-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(247, 247, 247, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 150;
            /* æ¯”è¾“å…¥æ¡†é«˜ï¼Œæ¯”è´´çº¸é¢æ¿ä½ */
            display: none;
            /* é»˜è®¤éšè— */
            align-items: center;
            justify-content: center;
            padding: 20px;
            box-sizing: border-box;
            border-top: 1px solid var(--border-color);
            text-align: center;
        }

        #chat-lock-content {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #chat-lock-content .lock-text {
            color: var(--text-secondary);
            font-size: 14px;
        }

        #chat-lock-content .lock-action-btn {
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid var(--accent-color);
            background-color: var(--accent-color);
            color: white;
            cursor: pointer;
        }

        #chat-lock-content .lock-action-btn.secondary {
            background-color: transparent;
            color: var(--accent-color);
        }

        /* â–¼â–¼â–¼ ã€å…¨æ–°ã€‘çº¢åŒ…å¡ç‰‡æ ·å¼ â–¼â–¼â–¼ */
        .message-bubble.is-red-packet .content {
            padding: 0;
            background: transparent;
            box-shadow: none;
            border: none;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }

        .red-packet-card {
            width: 220px;
            border-radius: 8px;
            background: linear-gradient(160deg, #F96259, #E44D44);
            color: #ffd700;
            /* é‡‘è‰²æ–‡å­— */
            padding: 12px;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }

        .red-packet-card.opened {
            background: linear-gradient(160deg, #d3c4a0, #c4b693);
            cursor: default;
        }

        .red-packet-card::before {
            content: 'ğŸ§§';
            position: absolute;
            top: -5px;
            left: -5px;
            font-size: 30px;
            opacity: 0.2;
            transform: rotate(-10deg);
        }

        .rp-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .rp-icon {
            width: 20px;
            height: 20px;
        }

        .rp-greeting {
            font-size: 15px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .rp-type {
            font-size: 11px;
            color: white;
            opacity: 0.8;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            padding-top: 8px;
            margin-top: 8px;
        }

        .rp-claimed-info {
            font-size: 13px;
            color: white;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
        }

        /* â–²â–²â–² æ–°CSSç²˜è´´ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ ã€å…¨æ–°ã€‘çº¢åŒ…è¯¦æƒ…åˆ—è¡¨æ ·å¼ â–¼â–¼â–¼ */
        .rp-details-item {
            display: flex;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }

        .rp-details-item:last-child {
            border-bottom: none;
        }

        .rp-details-item .name {
            flex-grow: 1;
            font-weight: 500;
            color: #333;
        }

        .rp-details-item .amount {
            font-weight: 500;
            color: #555;
        }

        .rp-details-item .lucky-king-tag {
            font-size: 10px;
            background-color: #ffd700;
            color: #a67c00;
            padding: 2px 5px;
            border-radius: 4px;
            margin-left: 8px;
            font-weight: bold;
        }

        /* â–²â–²â–² æ–°CSSç²˜è´´ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ ã€å…¨æ–°ã€‘æŠ•ç¥¨åŠŸèƒ½æ ·å¼ â–¼â–¼â–¼ */

        /* æŠ•ç¥¨å¡ç‰‡åœ¨æ¶ˆæ¯æ°”æ³¡ä¸­çš„æ ·å¼ */
        .message-bubble.is-poll .content {
            padding: 0;
            background: transparent;
            box-shadow: none;
            border: none;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }

        /* æŠ•ç¥¨å¡ç‰‡ä¸»ä½“ */
        .poll-card {
            width: 250px;
            background-color: #f9f9f9;
            border-radius: 10px;
            border: 1px solid #e0e0e0;
            padding: 12px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        .poll-card.closed {
            background-color: #e9ecef;
            /* ç»“æŸåå˜ç° */
        }

        /* æŠ•ç¥¨é—®é¢˜ */
        .poll-question {
            font-weight: 600;
            font-size: 15px;
            margin-bottom: 12px;
            line-height: 1.4;
            word-break: break-word;
        }

        /* æŠ•ç¥¨é€‰é¡¹åˆ—è¡¨ */
        .poll-options-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        /* å•ä¸ªæŠ•ç¥¨é€‰é¡¹ */
        .poll-option-item {
            background-color: white;
            border: 1px solid #dcdcdc;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: background-color 0.2s;
        }

        .poll-card:not(.closed) .poll-option-item:hover {
            background-color: #f0f8ff;
        }

        /* ç”¨æˆ·å·²æŠ•ç¥¨çš„é€‰é¡¹æ ·å¼ */
        .poll-option-item.voted {
            border-color: var(--accent-color);
            background-color: #e7f3ff;
            font-weight: 500;
        }

        /* æŠ•ç¥¨è¿›åº¦æ¡ */
        .poll-option-bar {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background-color: rgba(0, 123, 255, 0.1);
            z-index: 1;
            transition: width 0.3s ease-in-out;
        }

        /* é€‰é¡¹å†…å®¹ï¼ˆæ–‡å­—å’Œç¥¨æ•°ï¼‰ï¼Œç¡®ä¿åœ¨è¿›åº¦æ¡ä¹‹ä¸Š */
        .poll-option-content {
            position: relative;
            z-index: 2;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .poll-option-text {
            font-size: 14px;
        }

        .poll-option-votes {
            font-size: 13px;
            color: #8a8a8a;
            font-weight: 500;
        }

        /* æŠ•ç¥¨å¡ç‰‡åº•éƒ¨ */
        .poll-footer {
            margin-top: 12px;
            padding-top: 8px;
            border-top: 1px solid #e9e9e9;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .poll-total-votes {
            font-weight: 500;
        }

        .poll-action-btn {
            background: none;
            border: 1px solid var(--accent-color);
            color: var(--accent-color);
            padding: 4px 10px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 12px;
        }

        .poll-card.closed .poll-action-btn {
            background-color: #6c757d;
            color: white;
            border-color: #6c757d;
        }

        /* åˆ›å»ºæŠ•ç¥¨æ¨¡æ€æ¡†çš„é€‰é¡¹è¾“å…¥ */
        .poll-option-input-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .poll-option-input-wrapper input {
            flex-grow: 1;
        }

        .poll-option-input-wrapper .remove-option-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background-color: #f0f0f0;
            color: #ff3b30;
            border: none;
            cursor: pointer;
            font-size: 18px;
            line-height: 28px;
            text-align: center;
            flex-shrink: 0;
        }

        /* â–²â–²â–² æ–°CSSç²˜è´´ç»“æŸ â–²â–²â–² */

        /* â–¼â–¼â–¼ ã€å…¨æ–°ã€‘èŠå¤©ç•Œé¢å¤´éƒ¨çŠ¶æ€é€»è¾‘æ ·å¼ â–¼â–¼â–¼ */
        #chat-header-status.typing .status-dot {
            animation: dot-pulse 1.5s infinite;
        }

        @keyframes dot-pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }

            100% {
                opacity: 1;
            }
        }

        /* â–²â–²â–² ç²˜è´´ç»“æŸ â–²â–²â–² */




        /* â–¼â–¼â–¼ ã€å…¨æ–°ã€‘å…¬å‘Šæ¿åŠŸèƒ½æ ·å¼ - è¯·å°†æ•´å—ä»£ç ç²˜è´´åˆ° <style> æ ‡ç­¾æœ«å°¾ â–¼â–¼â–¼ */

        /* å…¬å‘Šæ¿æŒ‰é’®ä¸Šæœªè¯»æ¶ˆæ¯çš„å°çº¢ç‚¹ */
        #open-bulletin-board-btn {
            position: relative;
            /* ä¸ºäº†å®šä½å°çº¢ç‚¹ */
        }

        /* å…¬å‘Šæ¿æ¨¡æ€æ¡† */
        #bulletin-board-modal {
            z-index: 250;
            /* æ¯”è´´çº¸é¢æ¿é«˜ä¸€ç‚¹ */
        }

        /* â–¼â–¼â–¼ ã€ä¿®å¤1ã€‘æå‡å…¬å‘Šæ“ä½œèœå•çš„å±‚çº§ â–¼â–¼â–¼ */
        #bulletin-actions-modal {
            z-index: 260;
            /* ç¡®ä¿æ¯”å…¬å‘Šæ¿æœ¬èº«(250)æ›´é«˜ */
        }

        /* â–²â–²â–² ä¿®å¤ç»“æŸ â–²â–²â–² */

        /* å…¬å‘Šæ¿å†…å®¹åŒº */
        #bulletin-board-modal .modal-body {
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            /* å¡ç‰‡ä¹‹é—´çš„é—´è· */
            background-color: #f0f2f5;
            /* ç»™åˆ—è¡¨ä¸€ä¸ªæµ…ç°è‰²èƒŒæ™¯ */
        }

        /* å…¬å‘Šå¡ç‰‡ï¼ˆå¤ç”¨åŠ¨æ€æ ·å¼ï¼Œä½†æ·»åŠ ä¸€äº›å¾®è°ƒï¼‰ */
        .bulletin-card {
            background-color: var(--secondary-bg);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
            position: relative;
            /* ä¸ºäº†å®šä½æ“ä½œæŒ‰é’® */
        }

        /* ç½®é¡¶å…¬å‘Šçš„ç‰¹æ®Šæ ·å¼ */
        .bulletin-card.pinned {
            border-left: 4px solid #ffc107;
            /* å·¦ä¾§æœ‰é‡‘è‰²çš„ç½®é¡¶æ ‡è®° */
            box-shadow: 0 4px 12px rgba(255, 193, 7, 0.3);
        }

        .bulletin-card.pinned::after {
            content: 'ğŸ“Œ';
            position: absolute;
            top: 10px;
            left: -2px;
            font-size: 16px;
            opacity: 0.7;
        }


        /* å…¬å‘Šå¡ç‰‡æ“ä½œæŒ‰é’® */
        .bulletin-actions-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            font-size: 20px;
            font-weight: bold;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 50%;
            line-height: 1;
        }

        .bulletin-actions-btn:hover {
            background-color: #f0f0f0;
        }

        /* èŠå¤©ç•Œé¢ä¸­çš„å…¬å‘Šæ¶ˆæ¯æ°”æ³¡ */
        .message-bubble.is-bulletin {
            /* å°† align-self åº”ç”¨åˆ°æ°”æ³¡æœ¬èº«ï¼Œè€Œä¸æ˜¯å®ƒçš„å†…å®¹åŒº */
            align-self: center;
        }

        .message-bubble.is-bulletin .content {
            padding: 0;
            background: transparent;
            box-shadow: none;
            border: none;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            max-width: 250px;
            /* é™åˆ¶å¡ç‰‡åœ¨èŠå¤©ä¸­çš„æœ€å¤§å®½åº¦ */
        }

        /* â–¼â–¼â–¼ ã€ä¿®å¤ã€‘ä¸ºå…¬å‘Šæ¿å¡ç‰‡æ·»åŠ è¯„è®ºåŒºæ ·å¼ â–¼â–¼â–¼ */
        .bulletin-card .post-footer {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #f0f0f0;
        }

        .bulletin-card .post-comments-container {
            padding: 5px 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-size: 13px;
            max-height: 150px;
            /* é™åˆ¶è¯„è®ºåŒºæœ€å¤§é«˜åº¦ */
            overflow-y: auto;
            /* è¶…å‡ºåˆ™æ»šåŠ¨ */
        }

        .bulletin-card .comment-item {
            line-height: 1.5;
        }

        .bulletin-card .comment-item .commenter-name {
            font-weight: 600;
            color: var(--accent-color);
            margin-right: 5px;
        }

        .bulletin-card .comment-item .comment-text {
            color: var(--text-primary);
            word-break: break-word;

        }

        #status-bar {
            display: none !important;
        }

        /* â–²â–²â–² ä¿®å¤ç»“æŸ â–²â–²â–² */
        /* â–²â–²â–² å…¬å‘Šæ¿åŠŸèƒ½æ ·å¼ç»“æŸ â–²â–²â–² */

        /* Floating phone charm */
        .floating-phone-charm {
            position: fixed;
            top: 48px;
            right: -112px;
            width: 220px;
            height: 220px;
            background-image: url('https://files.catbox.moe/rhrobi.gif');
            background-size: contain;
            background-repeat: no-repeat;
            z-index: 1000;
            pointer-events: auto;
            cursor: grab;
            transition: transform 0.2s ease;
            user-select: none;
        }

        .floating-phone-charm:active {
            cursor: grabbing;
        }

        .floating-phone-charm.dragging {
            opacity: 0.5;
            transition: none;
        }

        /* Export Progress Modal */
        #export-progress-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #export-progress-modal-overlay.visible {
            display: flex;
            opacity: 1;
        }

        #export-progress-modal {
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        #export-progress-modal-overlay.visible #export-progress-modal {
            transform: scale(1);
        }
    </style>
</head>

<body>
    <div id="phone-frame">
        <div class="notch"></div>
        <div id="phone-screen">
            <!-- Floating phone charm -->
            <div id="floating-phone-charm" class="floating-phone-charm"></div>

            <div id="status-bar">
                <span id="status-bar-time">12:00</span>
                <div id="status-bar-battery" class="battery-container">
                    <span class="battery-text">--%</span>
                    <div class="battery-icon">
                        <div class="battery-level"></div>
                    </div>
                </div>
            </div>
            <div id="notification-bar"><img id="notification-avatar" src="">
                <div id="notification-content">
                    <div class="name"></div>
                    <div class="message"></div>
                </div>
            </div>

            <div id="home-screen" class="screen active">
                <div id="clock-container">
                    <div id="main-time">12:00</div>
                    <div id="main-date">æ˜ŸæœŸä¸€, 1æœˆ1æ—¥</div>
                </div>
                <!-- Home Screen Now Playing Bar -->
                <div id="home-now-playing-bar" class="now-playing-bar home-screen-bar hidden">
                    <div class="now-playing-content">
                        <div class="np-album-art">
                            <img id="home-np-album-image" src="" alt="Album Art" style="display: none;">
                            <div class="np-default-icon">ğŸµ</div>
                        </div>
                        <div class="np-song-info">
                            <div id="home-np-song-title" class="np-song-title">æœªçŸ¥æ­Œæ›²</div>
                            <div id="home-np-song-artist" class="np-song-artist">æœªçŸ¥è‰ºæœ¯å®¶</div>
                        </div>
                        <div class="np-right-section">
                            <div class="np-playback-controls">
                                <button id="home-np-prev-btn" class="np-control-btn" title="ä¸Šä¸€é¦–">â®</button>
                                <button id="home-np-play-pause-btn" class="np-control-btn play-pause"
                                    title="æ’­æ”¾/æš‚åœ">â–¶</button>
                                <button id="home-np-next-btn" class="np-control-btn" title="ä¸‹ä¸€é¦–">â­</button>
                            </div>
                            <div class="np-partner-avatar">
                                <img id="home-np-partner-avatar" src="https://files.catbox.moe/q6z5fc.jpeg"
                                    alt="Partner">
                            </div>
                        </div>
                    </div>
                    <div class="np-progress-bar">
                        <div id="home-np-progress-fill" class="np-progress-fill"></div>
                    </div>
                </div>

                <!-- Home Screen Date Progress Bar -->
                <div id="home-meetup-progress-bar" class="meetup-progress-bar home-screen-bar hidden">
                    <div class="meetup-progress-content">
                        <div class="meetup-ai-avatar">
                            <img id="home-meetup-ai-avatar" src="" alt="AI Avatar">
                        </div>
                        <div class="meetup-progress-info">
                            <span id="home-meetup-progress-text" class="meetup-progress-text">ä¸AIåœ¨åœ°ç‚¹</span>
                            <span class="meetup-separator"> | </span>
                            <svg class="meetup-clock-icon" width="12" height="12" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg">
                                <circle cx="12" cy="12" r="10" stroke="rgba(255,255,255,0.75)" stroke-width="2" />
                                <polyline points="12,6 12,12 16,14" stroke="rgba(255,255,255,0.75)" stroke-width="2"
                                    stroke-linecap="round" stroke-linejoin="round" />
                            </svg>
                            <span id="home-meetup-elapsed-text" class="meetup-elapsed-text">00:00:00</span>
                        </div>
                    </div>
                </div>

                <div id="app-grid">
                    <!-- ç¬¬ä¸€è¡Œï¼šç©ºç½® -->
                    <div class="app-row">
                    </div>
                    <!-- ç¬¬äºŒè¡Œï¼šæ”¾4ä¸ªå›¾æ ‡ -->
                    <div class="app-row">
                        <!-- Blur container behind the icons -->
                        <div class="app-dock-blur"></div>
                        <div class="app-icon" onclick="showScreen('chat-list-screen')">
                            <div class="icon-bg"><img src="https://files.catbox.moe/janu1z.png" alt="QQ"></div><span
                                class="label">QQ</span>
                        </div>
                        <div class="app-icon"
                            onclick="showScreen('chat-list-screen'); document.querySelector('.nav-item[data-view=qzone-screen]').click()">
                            <div class="icon-bg"><img src="https://files.catbox.moe/65cdyc.png" alt="æœ‹å‹åœˆ"></div><span
                                class="label">æœ‹å‹åœˆ</span>
                        </div>

                        <div class="app-icon" onclick="showScreen('calendar-screen')">
                            <div class="icon-bg"><img src="https://files.catbox.moe/2i4irb.png" alt="æ—¥å†"></div><span
                                class="label">æ—¥å†</span>
                        </div>

                        <div class="app-icon" onclick="showScreen('settings-screen')">
                            <div class="icon-bg"><img src="https://files.catbox.moe/xmo1uf.png" alt="è®¾ç½®"></div><span
                                class="label">è®¾ç½®</span>
                        </div>
                    </div>
                </div>
            </div>



            <div id="world-book-screen" class="screen">
                <div class="header"><span class="back-btn"
                        onclick="showScreen('settings-screen')">â€¹</span><span>ä¸–ç•Œä¹¦</span><span class="action-btn"
                        id="add-world-book-btn">+</span></div>
                <div id="world-book-list"></div>
            </div>

            <div id="settings-screen" class="screen">
                <div class="header"><span class="back-btn"
                        onclick="showScreen('home-screen')">â€¹</span><span>è®¾ç½®</span><span style="width: 30px;"></span>
                </div>
                <div id="settings-list"></div>
            </div>
            <div id="world-book-editor-screen" class="screen">
                <div class="header">
                    <span class="back-btn" onclick="showScreen('world-book-screen')">â€¹</span>
                    <span id="world-book-editor-title">ç¼–è¾‘ä¸–ç•Œä¹¦</span>
                    <span class="save-btn" id="save-world-book-btn">ä¿å­˜</span>
                </div>
                <div class="form-container">
                    <div class="form-group">
                        <label for="world-book-name-input">ä¹¦å</label>
                        <input type="text" id="world-book-name-input" placeholder="è¯·è¾“å…¥ä¸–ç•Œä¹¦çš„åç§°...">
                    </div>
                    <div class="form-group" style="height: 100%;">
                        <label for="world-book-content-input">å†…å®¹</label>
                        <textarea id="world-book-content-input" placeholder="åœ¨æ­¤å¤„è¾“å…¥è¯¦ç»†çš„ä¸–ç•Œè§‚è®¾å®š..."></textarea>
                    </div>
                </div>
            </div>

            <div id="api-settings-screen" class="screen">
                <div class="header"><span class="back-btn" onclick="showScreen('settings-screen')">â€¹</span><span>API
                        è®¾ç½®</span><span style="width: 30px;"></span></div>
                <div class="form-container">
                    <p
                        style="font-size: 14px; color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 8px;">
                        æç¤º: è‹¥è¦ä½¿ç”¨â€œå‘é€å›¾ç‰‡â€åŠŸèƒ½, è¯·åŠ¡å¿…é€‰æ‹©æ”¯æŒVision(è§†è§‰)çš„æ¨¡å‹, å¦‚<code
                            style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4o</code>æˆ–<code
                            style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4-vision-preview</code>ã€‚
                    </p>
                    <div class="form-group"><label for="proxy-url">åä»£åœ°å€ (ä¸éœ€è¦æ·»åŠ /v1å™¢~)</label><input type="text"
                            id="proxy-url" placeholder="ä¾‹å¦‚: https://api.openai.com"></div>
                    <div class="form-group"><label for="api-key">å¯†é’¥ (API Key)</label><input type="password" id="api-key"
                            placeholder="sk-..."></div>
                    <div class="form-group"><label for="model-select">æ¨¡å‹</label><select id="model-select"></select>
                    </div><button class="form-button" id="fetch-models-btn">æ‹‰å–æ¨¡å‹</button>

                    <!-- â–¼â–¼â–¼ å°†è¿™æ®µä»£ç ç²˜è´´åˆ° API è®¾ç½®é¡µé¢çš„â€œä¿å­˜è®¾ç½®â€æŒ‰é’®ä¸Šæ–¹ â–¼â–¼â–¼ -->
                    <hr style="margin:20px 0; opacity:.3">
                    <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                        <label for="background-activity-switch" style="margin-bottom: 0;">
                            å¯ç”¨åå°è§’è‰²æ´»åŠ¨
                            <p style="font-size: 12px; font-weight: normal; color: #ff6b6b; margin-top: 5px;">
                                è­¦å‘Šï¼šæ­¤åŠŸèƒ½ä¼šæ˜¾è‘—å¢åŠ APIè°ƒç”¨å’Œè´¹ç”¨ï¼
                            </p>
                        </label>
                        <input type="checkbox" id="background-activity-switch" style="width: auto; height: 20px;">
                    </div>
                    <!-- â–²â–²â–² ç²˜è´´ç»“æŸ â–²â–²â–² -->

                    <!-- â–¼â–¼â–¼ å°†è¿™æ®µä»£ç ç²˜è´´åˆ°â€œå¯ç”¨åå°è§’è‰²æ´»åŠ¨â€å¼€å…³çš„ä¸‹æ–¹ â–¼â–¼â–¼ -->
                    <div class="form-group"
                        style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                        <label for="background-interval-input" style="margin-bottom: 0;">
                            åå°æ´»åŠ¨æ£€æµ‹é—´éš” (ç§’)
                            <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                                å»ºè®®å€¼ 60-300ã€‚å€¼è¶Šå¤§ï¼Œè´¹ç”¨è¶Šä½ï¼Œä½†è§’è‰²ååº”è¶Šæ…¢ã€‚
                            </p>
                        </label>
                        <input type="number" id="background-interval-input" min="30" value="60"
                            style="width: 80px; text-align: center;">
                    </div>
                    <!-- â–²â–²â–² ç²˜è´´ç»“æŸ â–²â–²â–² -->
                    <!-- â–¼â–¼â–¼ åœ¨è¿™é‡Œæ–°å¢ â–¼â–¼â–¼ -->
                    <div class="form-group"
                        style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                        <label for="ai-cooldown-input" style="margin-bottom: 0;">
                            AIå‘è¨€å†·é™æœŸ (åˆ†é’Ÿ)
                            <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                                AIä¸»åŠ¨å‘èµ·è¡ŒåŠ¨å‰éœ€ç­‰å¾…çš„æ—¶é—´ã€‚0ä¸ºæ— é™åˆ¶ã€‚
                            </p>
                        </label>
                        <input type="number" id="ai-cooldown-input" min="0" step="1" value="5"
                            style="width: 80px; text-align: center;">
                    </div>
                    <!-- â–²â–²â–² æ–°å¢ç»“æŸ â–²â–²â–² -->
                    <!-- â–¼â–¼â–¼ åœ¨è¿™é‡Œæ–°å¢ â–¼â–¼â–¼ -->
                    <div class="form-group"
                        style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                        <label for="block-cooldown-input" style="margin-bottom: 0;">
                            AIè¢«æ‹‰é»‘åå†·é™æœŸ (å°æ—¶)
                            <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                                è¢«æ‹‰é»‘è¶…è¿‡è¿™ä¸ªæ—¶é—´åï¼ŒAIæ‰æœ‰å‡ ç‡é‡æ–°ç”³è¯·å¥½å‹ã€‚
                            </p>
                        </label>
                        <input type="number" id="block-cooldown-input" min="0.1" step="0.1" value="1"
                            style="width: 80px; text-align: center;">
                    </div>
                    <!-- â–²â–²â–² æ–°å¢ç»“æŸ â–²â–²â–² -->

                    <button class="form-button" id="save-api-settings-btn">ä¿å­˜è®¾ç½®</button>

                </div>

            </div>
            <!-- â–¼â–¼â–¼ ç”¨ä¸‹é¢è¿™æ®µä»£ç ï¼Œå®Œæ•´æ›¿æ¢æ‰ä½ åŸæ¥çš„ chat-list-screen â–¼â–¼â–¼ -->
            <div id="chat-list-screen" class="screen">

                <!-- ä¸»å¤´éƒ¨ (åªåœ¨æ¶ˆæ¯åˆ—è¡¨æ˜¾ç¤º) -->
                <div class="header" id="main-chat-list-header">
                    <span class="back-btn" onclick="showScreen('home-screen')">â€¹</span>
                    <span>æ¶ˆæ¯</span>
                    <div class="header-actions">
                        <span class="action-btn" id="add-group-chat-btn" title="åˆ›å»ºç¾¤èŠ"><svg width="24" height="24"
                                viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path
                                    d="M17.5 17.5C19.1569 17.5 20.5 16.1569 20.5 14.5C20.5 12.8431 19.1569 11.5 17.5 11.5C15.8431 11.5 14.5 12.8431 14.5 14.5C14.5 16.1569 15.8431 17.5 17.5 17.5Z"
                                    stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round" />
                                <path d="M21 21L19 19" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round" />
                                <path
                                    d="M8.5 11.5C10.1569 11.5 11.5 10.1569 11.5 8.5C11.5 6.84315 10.1569 5.5 8.5 5.5C6.84315 5.5 5.5 6.84315 5.5 8.5C5.5 10.1569 6.84315 11.5 8.5 11.5Z"
                                    stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round" />
                                <path d="M12.5 14.5H4.5C3.39543 14.5 2.5 15.3954 2.5 16.5V18.5H12.5"
                                    stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round" />
                            </svg></span>
                        <span class="action-btn" id="add-chat-btn">+</span>
                    </div>
                </div>

                <!-- æ¶ˆæ¯åˆ—è¡¨è§†å›¾ -->
                <div id="messages-view" class="chat-list-view active">
                    <div id="chat-list">
                        <!-- JSä¼šåœ¨è¿™é‡Œç”ŸæˆèŠå¤©åˆ—è¡¨ -->
                    </div>
                </div>

                <!-- åŠ¨æ€ç•Œé¢è§†å›¾ -->
                <div id="qzone-screen" class="chat-list-view">
                    <div class="qzone-header">
                        <span class="back-btn" id="qzone-back-btn">â€¹</span> <!-- è¿™ä¸ªæŒ‰é’®ç°åœ¨åªè´Ÿè´£ä»åŠ¨æ€è¿”å› -->
                        <span>æœ‹å‹åœˆ</span>
                        <span class="ai-post-btn" id="qzone-add-post-btn" title="æ·»åŠ å†…å®¹">+</span>
                        <span class="ai-post-btn" id="ai-post-btn" title="è®©AIå‘åŠ¨æ€">ğŸ¤–</span>
                    </div>
                    <div class="qzone-content">
                        <div class="qzone-profile-header">
                            <div id="qzone-banner-container" class="qzone-banner-container">
                                <img id="qzone-banner-img" src="https://files.catbox.moe/r5heyt.gif" alt="èƒŒæ™¯">
                                <input type="file" id="qzone-banner-input" accept="image/*" hidden>
                            </div>
                            <div class="qzone-user-info">
                                <div id="qzone-avatar-container" class="qzone-avatar-container">
                                    <img id="qzone-avatar-img" src="https://files.catbox.moe/q6z5fc.jpeg" alt="å¤´åƒ"
                                        class="avatar">
                                    <input type="file" id="qzone-avatar-input" accept="image/*" hidden>
                                </div>
                                <div class="qzone-user-text">
                                    <span id="qzone-nickname">{{user}}</span>
                                    <span id="qzone-status">è¿™ä¸ªç”¨æˆ·å¾ˆæ‡’ï¼Œä»€ä¹ˆä¹Ÿæ²¡ç•™ä¸‹</span>
                                </div>
                            </div>
                        </div>
                        <div class="qzone-actions-bar" style="display: none;">
                            <div class="action-item" id="create-shuoshuo-btn"><span>è¯´è¯´</span></div>
                            <div class="action-item" id="create-post-btn"><span>åŠ¨æ€</span></div>
                            <div class="action-item" id="open-album-btn"><span>ç›¸å†Œ</span></div>
                        </div>
                        <div id="qzone-posts-list"></div>
                    </div>
                </div>

                <!-- æ”¶è—ç•Œé¢è§†å›¾ -->
                <div id="favorites-view" class="chat-list-view">
                    <div class="header">
                        <span class="back-btn" id="favorites-back-btn">â€¹</span>
                        <span>æˆ‘çš„æ”¶è—</span>
                        <!-- æ–°å¢çš„ç¼–è¾‘æŒ‰é’® -->
                        <span class="action-btn" id="favorites-edit-btn">ç¼–è¾‘</span>
                    </div>

                    <!-- ã€æ–°å¢ã€‘æœç´¢æ å®¹å™¨ -->
                    <div class="search-bar-container">
                        <input type="search" id="favorites-search-input" placeholder="æœç´¢æ”¶è—çš„æ ‡é¢˜ã€å†…å®¹æˆ–ä½œè€…...">
                        <button id="favorites-search-clear-btn" class="search-clear-btn"
                            style="display: none;">Ã—</button>
                    </div>

                    <div id="favorites-list" class="list-container">
                        <!-- æ”¶è—å†…å®¹å°†ç”±JSåŠ¨æ€ç”Ÿæˆåœ¨è¿™é‡Œ -->
                    </div>

                    <!-- æ–°å¢ï¼šæ”¶è—é¡µåº•éƒ¨æ“ä½œæ  -->
                    <div id="favorites-action-bar" style="display: none;">
                        <button id="favorites-delete-selected-btn" class="action-bar-btn">åˆ é™¤ (0)</button>
                    </div>

                </div>

                <!-- â–¼â–¼â–¼ ã€å…¨æ–°ã€‘å›å¿†å½•ç•Œé¢è§†å›¾ â–¼â–¼â–¼ -->
                <div id="memories-view" class="chat-list-view">
                    <div class="header">
                        <span class="back-btn" id="memories-back-btn">â€¹</span>
                        <span>æˆ‘ä»¬çš„å›å¿†</span>
                        <span class="action-btn" id="add-countdown-btn">+</span>
                    </div>
                    <div id="memories-list" class="list-container"
                        style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
                        <!-- å›å¿†å¡ç‰‡å°†ç”±JSåŠ¨æ€ç”Ÿæˆåœ¨è¿™é‡Œ -->
                    </div>
                </div>
                <!-- â–²â–²â–² æ–°å¢HTMLç»“æŸ â–²â–²â–² -->

                <!-- åº•éƒ¨å¯¼èˆªæ  -->
                <div id="chat-list-bottom-nav">
                    <div class="nav-item active" data-view="messages-view">
                        <span>æ¶ˆæ¯</span>
                    </div>
                    <div class="nav-item" data-view="qzone-screen" style="display: none;">
                        <span>åŠ¨æ€</span>
                    </div>
                    <!-- â–¼â–¼â–¼ åœ¨â€œåŠ¨æ€â€å’Œâ€œæ”¶è—â€ä¹‹é—´ï¼ŒåŠ å…¥è¿™ä¸ªæ–°é¡µç­¾ â–¼â–¼â–¼ -->
                    <div class="nav-item" data-view="memories-view">
                        <span>å›å¿†</span>
                    </div>
                    <!-- â–²â–²â–² æ·»åŠ ç»“æŸ â–²â–²â–² -->
                    <div class="nav-item" data-view="favorites-view">
                        <span>æ”¶è—</span>
                    </div>
                </div>
            </div>
            <!-- â–²â–²â–² æ›¿æ¢åŒºåŸŸç»“æŸ â–²â–²â–² -->

            <!-- â–¼â–¼â–¼ è¯·å°†è¿™æ®µæ–°çš„ HTML ç²˜è´´åˆ° id="chat-list-screen" çš„ div ä¹‹å â–¼â–¼â–¼ -->
            <div id="album-screen" class="screen">
                <!-- 1. é¡µé¢å¤´éƒ¨ï¼ŒåŒ…å«è¿”å›æŒ‰é’®å’Œæ ‡é¢˜ -->
                <div class="header">
                    <span class="back-btn" id="album-back-btn">â€¹</span>
                    <span>æˆ‘çš„ç›¸å†Œ</span>
                    <span class="action-btn" id="create-album-btn-page">+</span>
                </div>

                <!-- 2. é¡µé¢å†…å®¹å®¹å™¨ -->
                <div class="list-container">
                    <div id="album-grid-page">
                        <!-- ç›¸å†Œåˆ—è¡¨å°†ç”± JS åŠ¨æ€ç”Ÿæˆåœ¨è¿™é‡Œ -->
                    </div>
                </div>
            </div>
            <!-- â–²â–²â–² æ–°çš„ HTML ç²˜è´´ç»“æŸ â–²â–²â–² -->

            <!-- â–¼â–¼â–¼ è¯·å°†è¿™æ®µæ–°çš„ HTML ç²˜è´´åˆ° id="album-screen" çš„ div ä¹‹å â–¼â–¼â–¼ -->
            <div id="album-photos-screen" class="screen">
                <!-- 1. é¡µé¢å¤´éƒ¨ -->
                <div class="header">
                    <span class="back-btn" id="album-photos-back-btn">â€¹</span>
                    <span id="album-photos-title">ç›¸å†Œåç§°</span>
                    <span class="action-btn" id="album-upload-photo-btn">ä¸Šä¼ </span>
                </div>

                <!-- 2. é¡µé¢å†…å®¹å®¹å™¨ -->
                <div class="list-container">
                    <div id="photos-grid-page">
                        <!-- ç…§ç‰‡åˆ—è¡¨å°†ç”± JS åŠ¨æ€ç”Ÿæˆåœ¨è¿™é‡Œ -->
                    </div>

                    <!-- â–¼â–¼â–¼ è¯·å°†è¿™æ®µæ–°çš„ HTML ç²˜è´´åˆ°æ‰€æœ‰æ¨¡æ€æ¡†çš„æœ«å°¾ â–¼â–¼â–¼ -->
                    <div id="photo-viewer-modal" class="modal">
                        <!-- 1. å…³é—­æŒ‰é’® -->
                        <button id="photo-viewer-close-btn">Ã—</button>

                        <!-- 2. ä¸Šä¸€å¼ ç…§ç‰‡æŒ‰é’® -->
                        <button id="photo-viewer-prev-btn" class="nav-arrow">â€¹</button>

                        <!-- 3. å›¾ç‰‡å®¹å™¨ -->
                        <div class="photo-viewer-content">
                            <img id="photo-viewer-image" src="" alt="å…¨å±ç…§ç‰‡é¢„è§ˆ">
                        </div>

                        <!-- 4. ä¸‹ä¸€å¼ ç…§ç‰‡æŒ‰é’® -->
                        <button id="photo-viewer-next-btn" class="nav-arrow">â€º</button>
                    </div>
                    <!-- â–²â–²â–² æ–°çš„ HTML ç²˜è´´ç»“æŸ â–²â–²â–² -->

                </div>
            </div>
            <!-- â–²â–²â–² æ–°çš„ HTML ç²˜è´´ç»“æŸ â–²â–²â–² -->

            <!-- â–¼â–¼â–¼ ç²˜è´´åˆ° #album-photos-screen çš„ div ä¹‹å â–¼â–¼â–¼ -->
            <input type="file" id="album-photo-input" accept="image/*" multiple hidden>

            <!-- â–¼â–¼â–¼ è¯·ç”¨è¿™ã€ä¸€æ•´å—ã€‘å…¨æ–°çš„ä»£ç ï¼Œå®Œæ•´æ›¿æ¢æ‰æ‚¨æ–‡ä»¶ä¸­æ—§çš„ #chat-interface-screen åŠå…¶æ‰€æœ‰å†…å®¹ â–¼â–¼â–¼ -->
            <div id="chat-interface-screen" class="screen">

                <!-- ã€æœ€ç»ˆä¿®æ­£ç‰ˆã€‘Headerï¼Œå·²å°†çŠ¶æ€æ å’Œæœç´¢åŠŸèƒ½æ­£ç¡®æ•´åˆ -->
                <div class="header">
                    <!-- é»˜è®¤æ§ä»¶ï¼šåŒ…å«æ ‡é¢˜ã€çŠ¶æ€æ å’Œå¸¸è§„æŒ‰é’® -->
                    <div class="default-controls">
                        <span class="back-btn" id="back-to-list-btn">â€¹</span>

                        <!-- â–¼â–¼â–¼ ã€æ ¸å¿ƒæ–°å¢ã€‘æ ‡é¢˜å’ŒçŠ¶æ€çš„å®¹å™¨ â–¼â–¼â–¼ -->
                        <div id="chat-header-title-wrapper">
                            <span id="chat-header-title">èŠå¤©å¯¹è±¡</span>
                            <div id="chat-header-status">
                                <span class="status-dot"></span>
                                <span class="status-text">åœ¨çº¿</span>
                            </div>
                        </div>
                        <!-- â–²â–²â–² æ–°å¢ç»“æŸ â–²â–²â–² -->

                        <div class="header-actions">
                            <span class="action-btn" id="chat-search-btn" title="æœç´¢æ¶ˆæ¯"><svg width="24" height="24"
                                    viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <circle cx="20" cy="20" r="14" stroke="currentColor" stroke-width="4"
                                        stroke-linecap="round" stroke-linejoin="round" />
                                    <path d="m30.5 30.5 9.5 9.5" stroke="currentColor" stroke-width="4"
                                        stroke-linecap="round" stroke-linejoin="round" />
                                </svg></span>
                            <!-- è¯·å°†è¿™ä¸¤è¡Œæ–°ä»£ç ç²˜è´´åˆ°ä¸Šé¢åˆ é™¤çš„ä½ç½® -->
                            <span class="action-btn" id="listen-together-btn" title="ä¸€èµ·å¬"><svg width="24" height="24"
                                    viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path
                                        d="M10 36V24C10 16.268 16.268 10 24 10C31.732 10 38 16.268 38 24V36M10 26H6C4.89543 26 4 26.8954 4 28V36C4 37.1046 4.89543 38 6 38H10V26ZM38 26H42C43.1046 26 44 26.8954 44 28V36C44 37.1046 43.1046 38 42 38H38V26Z"
                                        stroke="currentColor" stroke-width="4" stroke-linecap="round"
                                        stroke-linejoin="round" />
                                    <path d="M16 32H20L22 26L26 38L28 32H32" stroke="currentColor" stroke-width="4"
                                        stroke-linecap="round" stroke-linejoin="round" />
                                </svg></span>
                            <span class="action-btn" id="meetup-btn" title="è§é¢æ¨¡å¼"><svg width="24" height="24"
                                    viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <rect x="6" y="10" width="36" height="32" rx="2" stroke="currentColor"
                                        stroke-width="4" stroke-linejoin="round" />
                                    <path d="M14 6V14" stroke="currentColor" stroke-width="4" stroke-linecap="round"
                                        stroke-linejoin="round" />
                                    <path d="M34 6V14" stroke="currentColor" stroke-width="4" stroke-linecap="round"
                                        stroke-linejoin="round" />
                                    <path d="M6 18H42" stroke="currentColor" stroke-width="4" stroke-linecap="round"
                                        stroke-linejoin="round" />
                                    <circle cx="16" cy="28" r="2" fill="currentColor" />
                                    <circle cx="24" cy="28" r="2" fill="currentColor" />
                                    <circle cx="32" cy="28" r="2" fill="currentColor" />
                                    <path d="M20 32C20 30 22 30 24 32C26 30 28 30 28 32" stroke="currentColor"
                                        stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                                </svg></span>
                            <span class="action-btn" id="chat-settings-btn" title="èŠå¤©è®¾ç½®"><svg width="24" height="24"
                                    viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M41.5 10H35.5" stroke="currentColor" stroke-width="4"
                                        stroke-linecap="round" stroke-linejoin="round" />
                                    <path d="M27.5 6V14" stroke="currentColor" stroke-width="4" stroke-linecap="round"
                                        stroke-linejoin="round" />
                                    <path d="M27.5 10L5.5 10" stroke="currentColor" stroke-width="4"
                                        stroke-linecap="round" stroke-linejoin="round" />
                                    <path d="M13.5 24H5.5" stroke="currentColor" stroke-width="4" stroke-linecap="round"
                                        stroke-linejoin="round" />
                                    <path d="M21.5 20V28" stroke="currentColor" stroke-width="4" stroke-linecap="round"
                                        stroke-linejoin="round" />
                                    <path d="M43.5 24H21.5" stroke="currentColor" stroke-width="4"
                                        stroke-linecap="round" stroke-linejoin="round" />
                                    <path d="M41.5 38H35.5" stroke="currentColor" stroke-width="4"
                                        stroke-linecap="round" stroke-linejoin="round" />
                                    <path d="M27.5 34V42" stroke="currentColor" stroke-width="4" stroke-linecap="round"
                                        stroke-linejoin="round" />
                                    <path d="M27.5 38H5.5" stroke="currentColor" stroke-width="4" stroke-linecap="round"
                                        stroke-linejoin="round" />
                                </svg></span>
                        </div>
                    </div>

                    <!-- å¤šé€‰æ¨¡å¼æ§ä»¶ (ä¿æŒä¸å˜) -->
                    <div class="selection-controls">
                        <span id="selection-cancel-btn">å–æ¶ˆ</span>
                        <span id="selection-count"></span>
                        <div class="header-actions">
                            <span id="selection-favorite-btn" class="action-btn">æ”¶è—</span>
                            <span id="selection-delete-btn" class="action-btn" style="color: #ff3b30;">åˆ é™¤</span>
                        </div>
                    </div>
                </div>

                <!-- Now Playing Bar -->
                <div id="now-playing-bar" class="now-playing-bar hidden">
                    <div class="now-playing-content">
                        <div class="np-album-art">
                            <img id="np-album-image" src="" alt="Album Art" style="display: none;">
                            <div class="default-icon">â™ª</div>
                        </div>
                        <div class="np-song-info">
                            <div class="np-song-title" id="np-song-title">è¯·æ·»åŠ æ­Œæ›²</div>
                            <div class="np-song-artist" id="np-song-artist">æš‚æ— æ’­æ”¾</div>
                        </div>
                        <div class="np-right-section">
                            <div class="np-playback-controls">
                                <button id="np-prev-btn" class="np-control-btn" title="ä¸Šä¸€é¦–">â®</button>
                                <button id="np-play-pause-btn" class="np-control-btn play-pause"
                                    title="æ’­æ”¾/æš‚åœ">â–¶</button>
                                <button id="np-next-btn" class="np-control-btn" title="ä¸‹ä¸€é¦–">â­</button>
                            </div>
                            <div class="np-partner-avatar">
                                <img id="np-partner-avatar" src="" alt="Listening Partner">
                            </div>
                        </div>
                    </div>
                    <div class="np-progress-bar">
                        <div id="np-progress-fill" class="np-progress-fill"></div>
                    </div>
                </div>

                <!-- Date Progress Bar -->
                <div id="meetup-progress-bar" class="meetup-progress-bar hidden">
                    <div class="meetup-progress-content">
                        <div class="meetup-ai-avatar">
                            <img id="meetup-ai-avatar" src="" alt="AI Avatar">
                        </div>
                        <div class="meetup-progress-info">
                            <span id="meetup-progress-text" class="meetup-progress-text">ä¸AIåœ¨åœ°ç‚¹</span>
                            <span class="meetup-separator"> | </span>
                            <svg class="meetup-clock-icon" width="12" height="12" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg">
                                <circle cx="12" cy="12" r="10" stroke="rgba(255,255,255,0.75)" stroke-width="2" />
                                <polyline points="12,6 12,12 16,14" stroke="rgba(255,255,255,0.75)" stroke-width="2"
                                    stroke-linecap="round" stroke-linejoin="round" />
                            </svg>
                            <span id="meetup-elapsed-text" class="meetup-elapsed-text">00:00:00</span>
                        </div>
                    </div>
                </div>

                <!-- èŠå¤©æ¶ˆæ¯åŒºåŸŸ (ä¿æŒä¸å˜) -->
                <div id="chat-messages">
                    <div id="typing-indicator">å¯¹æ–¹æ­£åœ¨è¾“å…¥...</div>
                </div>

                <!-- è¾“å…¥åŒºåŸŸ (ä¿æŒä¸å˜) -->
                <div id="chat-input-area">
                    <div id="chat-input-actions-top">
                        <button id="open-sticker-panel-btn" class="chat-action-icon-btn action-button"
                            title="è¡¨æƒ…é¢æ¿">
                            <svg width="26" height="26" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="10"/>
                                <path d="M8 14s1.5 2 4 2 4-2 4-2"/>
                                <line x1="9" y1="9" x2="9.01" y2="9"/>
                                <line x1="15" y1="9" x2="15.01" y2="9"/>
                            </svg>
                        </button>
                        <button id="send-photo-btn" class="chat-action-icon-btn action-button" title="å‘é€ç…§ç‰‡"><svg
                                width="24" height="24" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2"
                                stroke-linecap="round" stroke-linejoin="round">
                                <path
                                    d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z" />
                                <circle cx="12" cy="13" r="4" />
                            </svg></button>
                        <button id="upload-image-btn" class="chat-action-icon-btn action-button" title="ä¸Šä¼ å›¾ç‰‡"><svg
                                width="24" height="24" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg" style="color: var(--text-primary);">
                                <path
                                    d="M21 3.5H3C2.44772 3.5 2 3.94772 2 4.5V19.5C2 20.0523 2.44772 20.5 3 20.5H21C21.5523 20.5 22 20.0523 22 19.5V4.5C22 3.94772 21.5523 3.5 21 3.5Z"
                                    stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round" />
                                <path
                                    d="M16.5 13.5C17.6046 13.5 18.5 12.6046 18.5 11.5C18.5 10.3954 17.6046 9.5 16.5 9.5C15.3954 9.5 14.5 10.3954 14.5 11.5C14.5 12.6046 15.3954 13.5 16.5 13.5Z"
                                    stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round" />
                                <path d="M22 14.5L18 10.5L10.3333 18.5M12.5 16L9 12.5L2 19.5" stroke="currentColor"
                                    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                            </svg></button>
                        <button id="transfer-btn" class="chat-action-icon-btn action-button" title="è½¬è´¦">ï¿¥</button>
                        <button id="voice-message-btn" class="chat-action-icon-btn action-button" title="å‘é€è¯­éŸ³"><svg
                                width="24" height="24" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2"
                                stroke-linecap="round" stroke-linejoin="round">
                                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z" />
                                <path d="M19 10v2a7 7 0 0 1-14 0v-2" />
                                <path d="M12 19v4" />
                                <path d="M8 23h8" />
                            </svg></button>
                        <!-- â–¼â–¼â–¼ å°†è¿™è¡Œæ–°ä»£ç ç²˜è´´åˆ°â€œå‘é€è¯­éŸ³â€æŒ‰é’®çš„åé¢ â–¼â–¼â–¼ -->
                        <button id="send-waimai-request-btn" class="chat-action-icon-btn action-button"
                            title="å‘èµ·å¤–å–è¯·æ±‚"><svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2"
                                stroke-linecap="round" stroke-linejoin="round">
                                <path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z" />
                                <line x1="3" y1="6" x2="21" y2="6" />
                                <path d="M16 10a4 4 0 0 1-8 0" />
                            </svg></button>
                        <!-- â–²â–²â–² æ–°ä»£ç ç²˜è´´ç»“æŸ â–²â–²â–² -->
                        <!-- â–¼â–¼â–¼ ã€æ–°å¢ã€‘è§†é¢‘é€šè¯æŒ‰é’® â–¼â–¼â–¼ -->
                        <button id="video-call-btn" class="chat-action-icon-btn action-button" title="è§†é¢‘é€šè¯"><svg
                                width="24" height="24" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2"
                                stroke-linecap="round" stroke-linejoin="round">
                                <polygon points="23 7 16 12 23 17 23 7"></polygon>
                                <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
                            </svg></button>
                        <!-- â–²â–²â–² æ–°å¢ç»“æŸ â–²â–²â–²
<!-- â–¼â–¼â–¼ç¾¤è§†é¢‘é€šè¯æŒ‰é’® â–¼â–¼â–¼ -->
                        <button id="group-video-call-btn" class="chat-action-icon-btn action-button" title="ç¾¤è§†é¢‘é€šè¯"><svg
                                width="24" height="24" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2"
                                stroke-linecap="round" stroke-linejoin="round">
                                <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                                <circle cx="9" cy="7" r="4"></circle>
                                <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                                <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                            </svg></button>
                        <!-- â–²â–²â–² å…¨æ–°æ·»åŠ ç»“æŸ â–²â–²â–² -->
                        <!-- â–¼â–¼â–¼å‘èµ·æŠ•ç¥¨æŒ‰é’®â–¼â–¼â–¼ -->
                        <button id="send-poll-btn" class="chat-action-icon-btn action-button" title="å‘èµ·æŠ•ç¥¨"><svg
                                width="24" height="24" viewBox="0 0 48 48" fill="none"
                                xmlns="http://www.w3.org/2000/svg">
                                <path
                                    d="M42 20V39C42 40.6569 40.6569 42 39 42H9C7.34315 42 6 40.6569 6 39V9C6 7.34315 7.34315 6 9 6H30"
                                    stroke="currentColor" stroke-width="4" stroke-linecap="round"
                                    stroke-linejoin="round" />
                                <path d="M16 20L26 28L41 7" stroke="currentColor" stroke-width="4"
                                    stroke-linecap="round" stroke-linejoin="round" />
                            </svg></button>

                        <button id="open-bulletin-board-btn" class="chat-action-icon-btn action-button" title="å…¬å‘Šæ¿"><svg
                                width="24" height="24" viewBox="0 0 48 48" fill="none"
                                xmlns="http://www.w3.org/2000/svg">
                                <rect x="4" y="15" width="40" height="26" rx="2" fill="none" stroke="currentColor"
                                    stroke-width="4" stroke-linejoin="round" />
                                <path d="M24 7L16 15H32L24 7Z" fill="none" stroke="currentColor" stroke-width="4"
                                    stroke-linecap="round" stroke-linejoin="round" />
                                <path d="M12 24H30" stroke="currentColor" stroke-width="4" stroke-linecap="round"
                                    stroke-linejoin="round" />
                                <path d="M12 32H20" stroke="currentColor" stroke-width="4" stroke-linecap="round"
                                    stroke-linejoin="round" />
                            </svg></button>

                        <!-- â–¼â–¼â–¼ Share Link Button â–¼â–¼â–¼ -->
                        <button id="share-link-btn" class="chat-action-icon-btn action-button" title="åˆ†äº«é“¾æ¥"><svg
                                width="24" height="24" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2"
                                stroke-linecap="round" stroke-linejoin="round">
                                <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path>
                                <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path>
                            </svg></button>
                        <!-- â–²â–²â–² Share Link Button End â–²â–²â–² -->

                        <!-- â–¼â–¼â–¼ Location Share Button â–¼â–¼â–¼ -->
                        <button id="share-location-btn" class="chat-action-icon-btn action-button" title="åˆ†äº«ä½ç½®"><svg
                                width="24" height="24" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2"
                                stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                                <circle cx="12" cy="10" r="3"></circle>
                            </svg></button>
                        <!-- â–²â–²â–² Location Share Button End â–²â–²â–² -->

                        <!-- â–¼â–¼â–¼ Regenerate AI Response Button â–¼â–¼â–¼ -->
                        <button id="regenerate-ai-btn" class="chat-action-icon-btn action-button" title="é‡æ–°ç”ŸæˆAIå›å¤">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
                                <path d="M21 3v5h-5"/>
                                <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
                                <path d="M3 21v-5h5"/>
                            </svg>
                        </button>
                        <!-- â–²â–²â–² Regenerate AI Response Button End â–²â–²â–² -->

                        <!-- â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–² -->
                    </div>

                    <div id="reply-preview-bar">
                        <div class="reply-preview-content">
                            <div class="sender">å›å¤ xxx:</div>
                            <div class="text">è¢«å¼•ç”¨çš„æ¶ˆæ¯å†…å®¹...</div>
                        </div>
                        <span id="cancel-reply-btn">Ã—</span>
                    </div>

                    <div id="chat-input-main-row">
                        <textarea id="chat-input" rows="1" placeholder="è¾“å…¥æ¶ˆæ¯..."></textarea>
                        <div id="input-actions-wrapper">
                            <button id="wait-reply-btn" title="ç­‰å¾…å›å¤"><img
                                    src="https://i.postimg.cc/2SwjsfZQ/IMG-6913.gif" alt="ç­‰å¾…å›å¤"></button>
                            <button id="send-btn" class="action-button">å‘é€</button>
                        </div>
                    </div>
                </div>

                <!-- â–¼â–¼â–¼ åœ¨è¿™é‡Œæ–°å¢ â–¼â–¼â–¼ -->
                <div id="chat-lock-overlay">
                    <div id="chat-lock-content"></div>
                </div>
                <!-- â–²â–²â–² æ–°å¢ç»“æŸ â–²â–²â–² -->

                <!-- è¡¨æƒ…é¢æ¿ (ä¿æŒä¸å˜) -->
                <div id="sticker-panel">
                    <div id="sticker-panel-header">
                        <span class="panel-btn" id="close-sticker-panel-btn">å–æ¶ˆ</span>
                        <span class="title">æˆ‘çš„è¡¨æƒ…</span>
                        <span class="panel-btn" id="edit-sticker-pack-btn">ç¼–è¾‘</span>
                    </div>
                    <div id="sticker-grid"></div>
                    <div id="sticker-pack-tabs">
                        <div class="sticker-pack-tab add-pack-btn" id="add-pack-btn">
                            <div class="pack-icon">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                    xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2"
                                    stroke-linecap="round" stroke-linejoin="round">
                                    <line x1="12" y1="5" x2="12" y2="19"></line>
                                    <line x1="5" y1="12" x2="19" y2="12"></line>
                                </svg>
                            </div>
                        </div>
                        <div class="sticker-pack-tab active" data-pack="all">
                            <div class="pack-icon">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                    xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2"
                                    stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="10" />
                                    <path d="M8 14s1.5 2 4 2 4-2 4-2" />
                                    <line x1="9" y1="9" x2="9.01" y2="9" />
                                    <line x1="15" y1="9" x2="15.01" y2="9" />
                                </svg>
                            </div>
                        </div>
                        <div class="sticker-pack-tab" data-pack="pack1">
                            <div class="pack-icon">
                                <img src="https://files.catbox.moe/r1khrr.gif" alt="Pack 1">
                            </div>
                        </div>
                    </div>
                </div>



                <input type="file" id="sticker-upload-input" accept="image/*" style="display: none;">
                <input type="file" id="image-upload-input" accept="image/*" style="display: none;">

                <!-- éŸ³ä¹æ’­æ”¾å™¨ (ä¿æŒä¸å˜) -->
                <div id="music-player-overlay">
                    <div class="music-player-window">
                        <span id="music-playlist-btn">â˜°</span>
                        <div id="music-time-counter">å·²ç»ä¸€èµ·å¬äº†0.0å°æ—¶</div>
                        <div id="music-player-song-title">è¯·æ·»åŠ æ­Œæ›²</div>
                        <div id="music-player-artist">...</div>
                        <div class="music-controls">
                            <button id="music-prev-btn">â®</button>
                            <button id="music-play-pause-btn" class="play-pause-btn">â–¶</button>
                            <button id="music-next-btn">â­</button>
                            <button id="music-mode-btn">é¡ºåº</button>
                        </div>
                        <div class="music-bottom-actions">
                            <button id="music-exit-btn">é€€å‡ºä¸€èµ·å¬</button>
                            <button id="music-return-btn">è¿”å›èŠå¤©</button>
                        </div>
                    </div>
                </div>

                <div id="music-playlist-panel">
                    <div class="playlist-header">
                        <span class="panel-btn" id="close-playlist-btn">è¿”å›</span>
                        <span>æ’­æ”¾åˆ—è¡¨</span>
                        <span style="width: 30px;"></span>
                    </div>
                    <div style="display: flex; border-bottom: 1px solid var(--border-color);">
                        <div class="main-playlist-tab active" onclick="switchMainPlaylistTab('songs')"
                            style="flex: 1; padding: 15px; text-align: center; cursor: pointer; border-bottom: 2px solid var(--accent-color);">
                            Songs</div>
                        <div class="main-playlist-tab" onclick="switchMainPlaylistTab('playlists')"
                            style="flex: 1; padding: 15px; text-align: center; cursor: pointer; border-bottom: 2px solid transparent;">
                            Playlists</div>
                    </div>
                    <div id="main-songs-tab" class="main-playlist-tab-content">
                        <div
                            style="padding: 15px; border-bottom: 1px solid var(--border-color); display: flex; gap: 10px;">
                            <span class="panel-btn" id="add-song-local-btn">æœ¬åœ°</span>
                            <span class="panel-btn" id="add-song-url-btn">URL</span>
                            <span class="panel-btn" id="add-song-spotify-btn">Spotify</span>
                        </div>
                        <div class="playlist-body" id="playlist-body"></div>
                    </div>
                    <div id="main-playlists-tab" class="main-playlist-tab-content" style="display: none;">
                        <div id="main-playlists-list" style="overflow-y: auto; max-height: 400px;"></div>
                        <div id="main-playlist-view" style="display: none;">
                            <div
                                style="padding: 15px; border-bottom: 1px solid var(--border-color); display: flex; align-items: center;">
                                <span onclick="showMainSpotifyPlaylists()"
                                    style="cursor: pointer; margin-right: 10px;">â€¹</span>
                                <span id="main-current-playlist-name" style="font-weight: 600;"></span>
                            </div>
                            <div id="main-playlist-tracks" style="overflow-y: auto; max-height: 350px;"></div>
                        </div>
                    </div>
                </div>
            </div>
            <input type="file" id="local-song-upload-input" accept="audio/*" multiple style="display: none;">
        </div>
        <!-- â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–² -->

        <div id="appearance-settings-screen" class="screen">
            <div class="header"><span class="back-btn"
                    onclick="showScreen('settings-screen')">â€¹</span><span>å¤–è§‚è®¾ç½®</span><span style="width: 30px;"></span>
            </div>
            <div class="form-container">
                <div class="form-group">
                    <div id="wallpaper-preview">ç‚¹å‡»ä¸‹æ–¹ä¸Šä¼ </div><button class="form-button"
                        onclick="document.getElementById('wallpaper-upload-input').click();">ä¸Šä¼ å£çº¸</button><input
                        type="file" id="wallpaper-upload-input" accept="image/*"><button class="form-button"
                        id="save-wallpaper-btn">ä¿å­˜å¹¶åº”ç”¨</button>
                </div>
                <hr style="margin:20px 0; opacity:.3">
                <!-- App Icon customization section -->
                <div class="form-group">
                    <label>åº”ç”¨å›¾æ ‡è‡ªå®šä¹‰</label>
                    <div id="app-icon-customization-list">
                        <!-- App icon customization fields will be populated here -->
                    </div>
                </div>
                <hr style="margin:20px 0; opacity:.3">
                <!-- Charm customization section -->
                <div class="form-group">
                    <div
                        style="display: flex; justify-content: space-between; align-items: center; width: calc(100% + 40px); margin-bottom: 10px; margin-left: -20px;">
                        <span>
                            è‡ªå®šä¹‰æŒ‚ä»¶æ ·å¼ (CSS)
                            <button id="reset-charm-css-btn" type="button"
                                style="background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px;">é‡ç½®</button>
                        </span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="charm-visibility-toggle" checked>
                            <span class="slider round"></span>
                        </label>
                    </div>
                    <textarea id="custom-charm-css-input" rows="15"
                        style="width: calc(100vw - 40px); margin-left: -20px; margin-right: -20px; padding: 12px; box-sizing: border-box; font-family: monospace; font-size: 12px; resize: vertical;">/* è‡ªå®šä¹‰æŒ‚ä»¶æ ·å¼ - å®Œæ•´é»˜è®¤è®¾ç½® */
.floating-phone-charm {
  position: fixed;
  top: 48px;
  right: -112px;
  width: 220px;
  height: 220px;
  background-image: url('https://files.catbox.moe/rhrobi.gif');
  background-size: contain;
  background-repeat: no-repeat;
  z-index: 1000;
  pointer-events: auto;
  cursor: grab;
  transition: transform 0.2s ease;
  user-select: none;
}</textarea>
                </div>
                <hr style="margin:20px 0; opacity:.3">
                <!-- Font settings section -->
                <div class="form-group">
                    <label for="font-url-input">å­—ä½“æ–‡ä»¶URL (.ttf, .otf, .woffç­‰)</label>
                    <input type="text" id="font-url-input" placeholder="https://..../font.ttf"
                        style="width: calc(100vw - 40px); margin-left: -20px; margin-right: -20px; padding: 12px; box-sizing: border-box;">
                </div>

                <div class="form-group">
                    <label>æˆ–è€…ä¸Šä¼ å­—ä½“æ–‡ä»¶</label>
                    <div
                        style="display: flex; align-items: center; gap: 10px; width: calc(100vw - 40px); margin-left: -20px; margin-right: -20px;">
                        <button class="form-button form-button-secondary"
                            onclick="document.getElementById('font-upload-input').click();"
                            style="flex: 1;">é€‰æ‹©å­—ä½“æ–‡ä»¶</button>
                        <span id="font-file-name" style="font-size: 14px; color: var(--text-secondary);">æœªé€‰æ‹©æ–‡ä»¶</span>
                    </div>
                    <input type="file" id="font-upload-input" accept="*/*" style="display: none;">
                </div>

                <div class="form-group">
                    <label>å®æ—¶é¢„è§ˆ</label>
                    <div id="font-preview"
                        style="width: calc(100vw - 40px); margin-left: -20px; margin-right: -20px; padding: 20px; border: 1px solid var(--border-color); border-radius: 8px; background-color: #f9f9f9; box-sizing: border-box;">
                        <p style="font-size: 20px; margin: 0 0 10px 0;">ä½ å¥½ä¸–ç•Œ Hello World</p>
                        <p style="margin: 0;">è¿™æ˜¯å­—ä½“é¢„è§ˆæ•ˆæœï¼Œ12345ã€‚</p>
                    </div>
                </div>

                <button class="form-button" id="save-font-btn">ä¿å­˜å¹¶åº”ç”¨</button>
                <button class="form-button form-button-secondary" id="reset-font-btn">æ¢å¤é»˜è®¤å­—ä½“</button>
            </div>
        </div>

        <div id="backup-screen" class="screen">
            <div class="header"><span class="back-btn"
                    onclick="showScreen('settings-screen')">â€¹</span><span>å¤‡ä»½æ–‡ä»¶</span><span style="width: 30px;"></span>
            </div>
            <div class="form-container">
                <button class="form-button" id="export-data-btn">å¯¼å‡ºæ•°æ®</button>
                <button class="form-button" id="import-btn">å¯¼å…¥å¤‡ä»½æ–‡ä»¶</button>

                <hr style="margin:20px 0; opacity:.3">

                <button class="form-button" id="cloud-backup-manual-btn">â˜ï¸ æ‰‹åŠ¨å¤‡ä»½</button>
                <button class="form-button" id="cloud-restore-select-btn">â˜ï¸ ä»äº‘ç«¯æ¢å¤</button>

                <!-- çœŸæ­£çš„æ–‡ä»¶é€‰æ‹©å™¨ï¼Œä¿æŒéšè— -->
                <input id="import-data-input" type="file" accept="application/json" hidden>
            </div>
        </div>

        <div id="general-settings-screen" class="screen">
            <div class="header">
                <span class="back-btn" onclick="showScreen('settings-screen')">â€¹</span>
                <span>é€šç”¨è®¾ç½®</span>
                <span style="width: 30px;"></span>
            </div>
            <div id="general-settings-list"></div>
        </div>

        <div id="calendar-screen" class="screen">
            <div class="header">
                <span class="back-btn" onclick="showScreen('home-screen')">â€¹</span>
                <span>æ—¥å†</span>
                <span class="action-btn" id="calendar-add-btn">+</span>
            </div>
            <div class="form-container">
                <!-- Calendar month view -->
                <div class="calendar-month-view-no-card">
                    <div class="calendar-header">
                        <button class="calendar-nav-btn" id="prev-month-btn">â€¹</button>
                        <button class="calendar-nav-btn" id="next-month-btn">â€º</button>
                        <span class="calendar-month-year" id="calendar-month-year">2025å¹´7æœˆ</span>
                    </div>

                    <div class="calendar-weekdays">
                        <div class="weekday">æ—¥</div>
                        <div class="weekday">ä¸€</div>
                        <div class="weekday">äºŒ</div>
                        <div class="weekday">ä¸‰</div>
                        <div class="weekday">å››</div>
                        <div class="weekday">äº”</div>
                        <div class="weekday">å…­</div>
                    </div>

                    <div class="calendar-grid" id="calendar-grid">
                        <!-- Calendar dates will be populated by JavaScript -->
                    </div>
                </div>

                <!-- Events list for selected day -->
                <div class="calendar-events-section">
                    <div class="calendar-events-header">
                        <button class="calendar-nav-btn" id="prev-day-btn">â€¹</button>
                        <button class="calendar-nav-btn" id="next-day-btn">â€º</button>
                        <span id="selected-date-display">ä»Šå¤©</span>
                    </div>
                    <div class="calendar-events-list" id="calendar-events-list">
                        <div class="no-events-message">æ²¡æœ‰äº‹ä»¶</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- â–¼â–¼â–¼ ã€å…¨æ–°ã€‘é€‰æ‹©è”ç³»äººä»¥åˆ›å»ºç¾¤èŠçš„å±å¹• â–¼â–¼â–¼ -->
        <div id="contact-picker-screen" class="screen">
            <div class="header">
                <span class="back-btn" id="cancel-contact-picker-btn">å–æ¶ˆ</span>
                <span>é€‰æ‹©è”ç³»äºº</span>
                <span class="save-btn" id="confirm-contact-picker-btn">å®Œæˆ(0)</span>
            </div>
            <div class="list-container" id="contact-picker-list">
                <!-- è”ç³»äººåˆ—è¡¨å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>
        <!-- â–²â–²â–² æ–°HTMLç²˜è´´ç»“æŸ â–²â–²â–² -->

        <!-- â–¼â–¼â–¼ ã€å…¨æ–°ã€‘ç¾¤æˆå‘˜ç®¡ç†å±å¹• â–¼â–¼â–¼ -->
        <div id="member-management-screen" class="screen">
            <div class="header">
                <span class="back-btn" id="back-from-member-management">â€¹</span>
                <span>ç¾¤æˆå‘˜ç®¡ç†</span>
                <span style="width: 30px;"></span>
            </div>
            <div class="list-container" id="member-management-list">
                <!-- ç°æœ‰æˆå‘˜åˆ—è¡¨ä¼šåœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
            </div>
            <div id="member-management-actions">
                <button id="add-existing-contact-btn">ä»å¥½å‹åˆ—è¡¨æ·»åŠ </button>
                <button id="create-new-member-btn">åˆ›å»ºç¾¤å†…æ–°æˆå‘˜</button>
            </div>
        </div>
        <!-- â–²â–²â–² æ–°HTMLç²˜è´´ç»“æŸ â–²â–²â–² -->

        <!-- â–¼â–¼â–¼ ã€å…¨æ–°ã€‘æ¥ç”µè¯·æ±‚æ¨¡æ€æ¡† â–¼â–¼â–¼ -->
        <div id="incoming-call-modal" class="modal">
            <div class="incoming-call-content">
                <img id="caller-avatar" class="caller-avatar" src="">
                <div id="caller-name" class="caller-name"></div>
                <div class="caller-text">é‚€è¯·ä½ è§†é¢‘é€šè¯</div>
                <div class="incoming-call-actions">
                    <div class="action-button-wrapper">
                        <button id="decline-call-btn" class="call-action-btn decline"></button>
                        <span>æ‹’ç»</span>
                    </div>
                    <div class="action-button-wrapper">
                        <button id="accept-call-btn" class="call-action-btn accept"></button>
                        <span>æ¥å¬</span>
                    </div>
                </div>
            </div>
        </div>
        <!-- â–²â–²â–² æ–°å¢ç»“æŸ â–²â–²â–² -->

        <!-- â–¼â–¼â–¼ è¯·ç”¨è¿™æ®µã€å…¨æ–°ç¾¤èŠå…¼å®¹ç»“æ„ã€‘çš„ä»£ç ï¼Œå®Œæ•´æ›¿æ¢ä½ æ—§çš„ #video-call-screen â–¼â–¼â–¼ -->
        <div id="video-call-screen" class="screen">
            <!-- 1. é¡¶éƒ¨æ  (ä¿æŒä¸å˜) -->
            <div class="video-call-top-bar">
                <span id="call-timer">00:00</span>
            </div>

            <!-- 2. ã€å‡çº§ã€‘å‚ä¸è€…å¤´åƒç½‘æ ¼åŒºåŸŸ -->
            <div class="video-call-avatar-area">
                <div id="participant-avatars-grid">
                    <!-- JSä¼šåœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆå¤´åƒ -->
                </div>
            </div>

            <!-- 3. å¯¹è¯æ¡†åŒºåŸŸ (ä¿æŒä¸å˜) -->
            <div id="video-call-main" class="video-call-main">
                <!-- å¯¹è¯å†…å®¹ä¼šåŠ¨æ€ç”Ÿæˆåœ¨è¿™é‡Œ -->
            </div>

            <!-- 4. ã€å‡çº§ã€‘åº•éƒ¨æ§åˆ¶æ ï¼Œç°åœ¨åŒ…å«ä¸€ä¸ªâ€œåŠ å…¥â€æŒ‰é’® -->
            <div class="video-call-controls">
                <button id="user-speak-btn" class="control-btn speak-btn"></button>
                <button id="hang-up-btn" class="control-btn hangup-btn"></button>
                <!-- è¿™ä¸ªæŒ‰é’®é»˜è®¤éšè—ï¼Œåªåœ¨ç”¨æˆ·â€œæ—è§‚â€æ—¶æ˜¾ç¤º -->
                <button id="join-call-btn" class="control-btn join-btn" style="display: none;"></button>
            </div>
        </div>
        <!-- â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–² -->

        <!-- â–¼â–¼â–¼ ã€å…¨æ–°æ·»åŠ ã€‘æ­£åœ¨å‘¼å«ç•Œé¢ â–¼â–¼â–¼ -->
        <div id="outgoing-call-screen" class="screen">
            <div class="outgoing-call-content">
                <img id="outgoing-call-avatar" class="caller-avatar" src="">
                <div id="outgoing-call-name" class="caller-name"></div>
                <div class="caller-text">æ­£åœ¨å‘¼å«...</div>
                <div class="outgoing-call-actions">
                    <button id="cancel-call-btn" class="call-action-btn decline"></button>
                    <span>å–æ¶ˆ</span>
                </div>
            </div>
        </div>
        <!-- â–²â–²â–² æ·»åŠ ç»“æŸ â–²â–²â–² -->

        <!-- â–¼â–¼â–¼ Browser Screen for Share Links â–¼â–¼â–¼ -->
        <div id="browser-screen" class="screen">
            <div class="header">
                <span class="back-btn" id="browser-back-btn">â€¹</span>
                <span id="browser-title"></span>
                <span style="width: 30px;"></span>
            </div>
            <div id="browser-content" class="list-container">
                <!-- æ–‡ç« å†…å®¹å°†ç”±JSåŠ¨æ€ç”Ÿæˆåœ¨è¿™é‡Œ -->
            </div>
        </div>
        <!-- â–²â–²â–² Browser Screen End â–²â–²â–² -->

        <!-- â–¼â–¼â–¼ Meetup Screen â–¼â–¼â–¼ -->
        <div id="meetup-screen" class="screen">
            <div class="header">
                <!-- Default controls -->
                <div class="default-controls">
                    <span class="back-btn" id="meetup-back-btn">â€¹</span>
                    <span id="meetup-title">è§é¢æ¨¡å¼</span>
                    <span class="action-btn" id="meetup-edit-btn">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" stroke="#007AFF"
                                stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                            <path d="m18.5 2.5 3 3L12 15l-4 1 1-4 9.5-9.5z" fill="#007AFF" stroke="#007AFF"
                                stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                        </svg>
                    </span>
                </div>

                <!-- Selection mode controls -->
                <div class="selection-controls">
                    <span id="meetup-selection-cancel-btn">å–æ¶ˆ</span>
                    <span id="meetup-selection-count"></span>
                    <div class="header-actions">
                        <span id="meetup-selection-delete-btn" class="action-btn" style="color: #ff3b30;">åˆ é™¤</span>
                    </div>
                </div>
            </div>

            <!-- Meetup context bar showing event details -->
            <div id="meetup-context-bar">
                <div class="context-info">
                    <div class="event-location" id="meetup-location">ğŸ“ ä½ç½®ä¿¡æ¯</div>
                    <div class="event-time" id="meetup-time">ğŸ• æ—¶é—´ä¿¡æ¯</div>
                    <div class="event-phase" id="meetup-phase">ğŸ’• è§é¢è¿›è¡Œä¸­</div>
                </div>
                <button id="end-date-btn" class="end-date-button">ç»“æŸè§é¢</button>
            </div>

            <!-- Meetup message display area -->
            <div id="meetup-messages" class="meetup-messages-container">
                <!-- Messages will be dynamically generated here -->
            </div>

            <!-- Meetup input area -->
            <div id="meetup-input-area" class="meetup-input-container">
                <div id="meetup-input-main-row">
                    <textarea id="meetup-input" rows="1" placeholder="åœ¨è¿™ä¸ªç‰¹æ®Šçš„æ—¶åˆ»ï¼Œä½ æƒ³è¯´ä»€ä¹ˆ..."></textarea>
                    <div class="meetup-actions-wrapper">
                        <button id="meetup-wait-reply-btn" title="ç­‰å¾…å›å¤"><img
                                src="https://i.postimg.cc/2SwjsfZQ/IMG-6913.gif" alt="ç­‰å¾…å›å¤"></button>
                        <button id="meetup-send-btn" class="send-btn">å‘é€</button>
                    </div>
                </div>
            </div>
        </div>
        <!-- â–²â–²â–² Meetup Screen End â–²â–²â–² -->

    </div>
    </div>

    <div id="chat-settings-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><span>èŠå¤©è®¾ç½®</span></div>
            <div class="modal-body">
                <div class="form-group" id="chat-name-group"><label for="chat-name-input">å¤‡æ³¨å / ç¾¤å</label><input
                        type="text" id="chat-name-input"></div>

                <!-- â–¼â–¼â–¼ è¯·å°†è¿™æ®µæ–°ä»£ç ç²˜è´´åˆ°â€œå¤‡æ³¨åâ€è¾“å…¥æ¡†çš„ form-group ä¹‹å â–¼â–¼â–¼ -->
                <div class="form-group" id="assign-group-section" style="display: none;"> <!-- é»˜è®¤éšè—ï¼Œåªå¯¹å•èŠæ˜¾ç¤º -->
                    <label for="assign-group-select">å¥½å‹åˆ†ç»„</label>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <select id="assign-group-select" style="flex-grow: 1;">
                            <!-- åˆ†ç»„é€‰é¡¹å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
                        </select>
                        <button id="manage-groups-btn" class="form-button-secondary"
                            style="margin-top: 0; padding: 12px;">ç®¡ç†åˆ†ç»„</button>
                    </div>
                </div>
                <!-- â–²â–²â–² æ–°ä»£ç ç²˜è´´ç»“æŸ â–²â–²â–² -->

                <div class="form-group" id="my-group-nickname-group"><label
                        for="my-group-nickname-input">æˆ‘çš„ç¾¤æ˜µç§°</label><input type="text" id="my-group-nickname-input">
                </div>
                <div class="form-group" id="group-avatar-group"><label>ç¾¤å¤´åƒ</label>
                    <div class="avatar-upload"><img id="group-avatar-preview"><button
                            onclick="document.getElementById('group-avatar-input').click()">ä¸Šä¼ ç¾¤å¤´åƒ</button><input
                            type="file" id="group-avatar-input" accept="image/*"></div>
                </div>
                <div class="form-group" id="world-book-link-group">
                    <label>å…³è”ä¸–ç•Œä¹¦ (å¯å¤šé€‰)</label>
                    <div class="custom-multiselect">
                        <div class="select-box">
                            <span class="selected-options-text">-- ç‚¹å‡»é€‰æ‹© --</span>
                            <span class="arrow-down">â–¼</span>
                        </div>
                        <div id="world-book-checkboxes-container" class="checkboxes-container">
                        </div>
                    </div>
                </div>
                <div class="form-group" id="ai-persona-group"><label for="ai-persona">å¯¹æ–¹äººè®¾ (AI Persona)</label><textarea
                        id="ai-persona" rows="3"></textarea></div>
                <div class="form-group" id="ai-avatar-group"><label>å¯¹æ–¹å¤´åƒ</label>
                    <div class="avatar-upload"><img id="ai-avatar-preview"><button
                            onclick="document.getElementById('ai-avatar-input').click()">ä¸Šä¼ å¯¹æ–¹å¤´åƒ</button><input
                            type="file" id="ai-avatar-input" accept="image/*"></div>
                </div>
                <div class="form-group" id="my-persona-group"><label for="my-persona">æˆ‘çš„äººè®¾ (My Persona)</label><textarea
                        id="my-persona" rows="3"></textarea></div>
                <div class="form-group" id="my-avatar-group"><label>æˆ‘çš„å¤´åƒ</label>
                    <div class="avatar-upload"><img id="my-avatar-preview"><button
                            onclick="document.getElementById('my-avatar-input').click()">ä¸Šä¼ æˆ‘çš„å¤´åƒ</button><button
                            id="open-persona-library-btn">é¢„è®¾</button><input type="file" id="my-avatar-input"
                            accept="image/*"></div>
                </div>
                <div class="form-group" id="group-members-group"><label>ç¾¤æˆå‘˜äººè®¾</label>
                    <div id="group-members-settings"></div>

                    <!-- ã€æ–°å¢ã€‘ç®¡ç†æˆå‘˜æŒ‰é’® -->
                    <button id="manage-members-btn" class="form-button form-button-secondary"
                        style="margin-top: 15px;">ç®¡ç†ç¾¤æˆå‘˜</button>
                </div>
                <div class="form-group"><label for="max-memory">ä¸Šä¸‹æ–‡è®°å¿†æ¡æ•°</label><input type="number" id="max-memory"
                        value="10"></div>
                
                <!-- â–¼â–¼â–¼ é•¿æœŸè®°å¿†ç”Ÿæˆ â–¼â–¼â–¼ -->
                <hr style="margin: 25px 0; border: none; border-top: 1px solid #eee;">
                <div class="form-group" id="chat-summary-section">
                    <label id="summary-section-title">é•¿æœŸè®°å¿†ç”Ÿæˆ (0 æ¡)</label>
                    <div style="margin-bottom: 12px;">
                        <label for="summary-message-count" style="font-size: 13px; color: #666; display: block; margin-bottom: 6px;">è¦æ•´ç†æœ€è¿‘å¤šå°‘æ¡æ¶ˆæ¯ï¼Ÿ</label>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <input type="number" id="summary-message-count" min="100" step="100" value="1000" style="flex: 1; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px;">
                            <span style="color: #666; font-size: 14px;">æ¡</span>
                        </div>
                    </div>
                    <button type="button" id="update-summary-btn" class="form-button" style="width: 100%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none;">
                        ğŸ§  ç”Ÿæˆé•¿æœŸè®°å¿†
                    </button>
                    <p style="font-size: 11px; color: #999; margin-top: 8px; line-height: 1.4;">
                        è®°å¿†ä¼šè‡ªåŠ¨ä¿å­˜åˆ°ä¸–ç•Œä¹¦ï¼Œå¸®åŠ©AIè®°ä½é‡è¦çš„å¯¹è¯å†…å®¹å’Œæƒ…æ„Ÿ
                    </p>
                </div>
                <hr style="margin: 25px 0; border: none; border-top: 1px solid #eee;">
                <!-- â–²â–²â–² é•¿æœŸè®°å¿†ç”Ÿæˆç»“æŸ â–²â–²â–² -->
                
                <!-- â–¼â–¼â–¼ ã€å…¨æ–°ã€‘åå°æ´»åŠ¨å¼€å…³ - è¯·ç²˜è´´åˆ°è¿™é‡Œ â–¼â–¼â–¼ -->
                <div class="form-group">
                    <label>åå°å›å¤ä¸ä¸»åŠ¨è¡Œä¸º</label>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <p
                            style="font-size: 11px; font-weight: normal; color: #666; margin: 0; padding-right: 15px; line-height: 1.4;">
                            å…³é—­åï¼Œè¯¥è§’è‰²å°†ä¸ä¼šåœ¨åå°ç‹¬ç«‹è¡ŒåŠ¨æˆ–ä¸»åŠ¨å‘èµ·å¯¹è¯ï¼Œåªä¼šåœ¨ä½ ä¸TaèŠå¤©æ—¶è¿›è¡Œå›å¤ã€‚
                        </p>
                        <label class="toggle-switch">
                            <input type="checkbox" id="background-activity-switch-chat">
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
                <!-- â–²â–²â–² æ–°ä»£ç ç²˜è´´ç»“æŸ â–²â–²â–² -->

                <div class="form-group"><label>èŠå¤©æ°”æ³¡ä¸»é¢˜ <button id="reset-theme-btn" type="button">é‡ç½®</button></label>
                    <div class="theme-selector"><label><input type="radio" name="theme-select" value="default"
                                id="theme-default"> é»˜è®¤</label><label><input type="radio" name="theme-select"
                                value="pink_blue"> ç²‰è“</label><label><input type="radio" name="theme-select"
                                value="blue_white"> è“ç™½</label><label><input type="radio" name="theme-select"
                                value="purple_yellow"> ç´«é»„</label><label><input type="radio" name="theme-select"
                                value="black_white"> é»‘ç™½</label><label><input type="radio" name="theme-select"
                                value="yellow_white"> é»„ç™½</label><label><input type="radio" name="theme-select"
                                value="red_black"> çº¢é»‘</label><label><input type="radio" name="theme-select"
                                value="blue_yellow"> è“é»„</label><label><input type="radio" name="theme-select"
                                value="pink_yellow"> ç²‰é»„</label><label><input type="radio" name="theme-select"
                                value="pink_purple"> ç²‰ç´«</label><label><input type="radio" name="theme-select"
                                value="gray_white"> ç°ç™½</label><label><input type="radio" name="theme-select"
                                value="blue_green"> è“ç»¿</label><label><input type="radio" name="theme-select"
                                value="pink_white"> ç²‰ç™½</label><label><input type="radio" name="theme-select"
                                value="pink_black"> ç²‰é»‘</label><label><input type="radio" name="theme-select"
                                value="pink_green"> ç²‰ç»¿</label><label><input type="radio" name="theme-select"
                                value="green_black"> ç»¿é»‘</label></div>
                </div>


                <!-- â–¼â–¼â–¼ è¯·å°†è¿™æ®µæ–°ä»£ç ç²˜è´´åˆ°â€œèŠå¤©æ°”æ³¡ä¸»é¢˜â€çš„ form-group ä¹‹å â–¼â–¼â–¼ -->
                <div class="form-group">
                    <label for="font-size-slider">èŠå¤©å­—ä½“å¤§å° <span id="font-size-value">13px</span></label>
                    <input type="range" id="font-size-slider" min="12" max="20" step="1" value="13"
                        style="width: 100%; margin-top: 8px;">
                </div>
                <!-- â–²â–²â–² æ–°ä»£ç ç²˜è´´ç»“æŸ â–²â–²â–² -->

                <!-- â–¼â–¼â–¼ è¯·å°†è¿™æ®µæ–°ä»£ç ç²˜è´´åˆ°â€œèŠå¤©å­—ä½“å¤§å°â€çš„ form-group ä¹‹å â–¼â–¼â–¼ -->
                <div class="form-group">
                    <label for="custom-css-input">
                        è‡ªå®šä¹‰æ°”æ³¡æ ·å¼ (CSS)
                        <button id="reset-custom-css-btn" type="button"
                            style="background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px;">é‡ç½®</button>
                    </label>
                    <textarea id="custom-css-input" rows="5"
                        style="width: 100%; margin-top: 8px; font-family: monospace; font-size: 12px; resize: vertical;"
                        placeholder="/* ç¤ºä¾‹ï¼šä¸ºâ€œæˆ‘â€çš„æ°”æ³¡æ·»åŠ æ¸å˜èƒŒæ™¯å’Œé˜´å½± */
.message-bubble.user .content {
  background: linear-gradient(135deg, #a1c4fd, #c2e9fb);
  box-shadow: 0 4px 10px rgba(0,0,0,0.1);
  border-radius: 15px 4px 15px 15px;
}"></textarea>
                </div>
                <!-- â–²â–²â–² æ–°ä»£ç ç²˜è´´ç»“æŸ â–²â–²â–² -->

                <!-- â–¼â–¼â–¼ è¯·å°†è¿™æ®µæ–°ä»£ç ç²˜è´´åˆ°è‡ªå®šä¹‰CSSè¾“å…¥æ¡†çš„ form-group ä¹‹å â–¼â–¼â–¼ -->
                <div class="form-group">
                    <label>å®æ—¶é¢„è§ˆ</label>
                    <div id="settings-preview-area">
                        <!-- JSä¼šåœ¨è¿™é‡Œç”Ÿæˆé¢„è§ˆå†…å®¹ -->
                    </div>
                </div>
                <!-- â–²â–²â–² æ–°ä»£ç ç²˜è´´ç»“æŸ â–²â–²â–² -->

                <div class="form-group">
                    <label>èŠå¤©èƒŒæ™¯</label>
                    <div class="bg-upload-container">
                        <button type="button" class="form-button-secondary"
                            style="width: auto; padding: 8px 12px; margin-top: 0;"
                            onclick="document.getElementById('bg-input').click()">ä¸Šä¼ èƒŒæ™¯å›¾</button>
                        <button type="button" id="remove-bg-btn">ç§»é™¤èƒŒæ™¯</button>
                    </div>
                    <img id="bg-preview" class="bg-preview-img">
                    <input type="file" id="bg-input" accept="image/*" style="display: none;">
                </div>
                
                <hr style="margin: 25px 0; border: none; border-top: 1px solid #eee;">
                <button class="form-button form-button-secondary" id="block-chat-btn"
                    style="background-color: #ff3b30; color: white; border-color: #ff3b30;">æ‹‰é»‘å¯¹æ–¹</button>
                <button class="form-button form-button-secondary" id="clear-chat-btn">æ¸…ç©ºèŠå¤©è®°å½•</button>
            </div>
            <div class="modal-footer"><button class="cancel" id="cancel-chat-settings-btn">å–æ¶ˆ</button><button
                    class="save" id="save-chat-settings-btn">ä¿å­˜</button></div>
        </div>
    </div>

    <div id="persona-library-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><span>æˆ‘çš„äººè®¾åº“</span><button id="add-persona-preset-btn"
                    class="action-button">æ·»åŠ </button></div>
            <div class="modal-body">
                <div id="persona-library-grid"></div>
            </div>
            <div class="modal-footer"><button class="cancel" id="close-persona-library-btn">å…³é—­</button></div>
        </div>
    </div>

    <div id="persona-editor-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><span id="persona-editor-title">æ·»åŠ äººè®¾é¢„è®¾</span></div>
            <div class="modal-body">
                <div class="form-group"><label>é¢„è®¾å¤´åƒ</label>
                    <div class="avatar-upload"><img id="preset-avatar-preview"><button
                            onclick="document.getElementById('preset-avatar-input').click()">ä¸Šä¼ å¤´åƒ</button><input
                            type="file" id="preset-avatar-input" accept="image/*"></div>
                </div>
                <div class="form-group"><label for="preset-persona-input">é¢„è®¾äººè®¾</label><textarea
                        id="preset-persona-input" rows="4" placeholder="åœ¨æ­¤è¾“å…¥è¿™ä¸ªäººè®¾çš„è¯¦ç»†è®¾å®š..."></textarea></div>
            </div>
            <div class="modal-footer"><button class="cancel" id="cancel-persona-editor-btn">å–æ¶ˆ</button><button
                    class="save" id="save-persona-preset-btn">ä¿å­˜</button></div>
        </div>
    </div>

    <div id="member-settings-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><span>ç¼–è¾‘ç¾¤æˆå‘˜</span></div>
            <div class="modal-body">
                <div class="form-group"><label for="member-name-input">åå­—</label><input type="text"
                        id="member-name-input"></div>
                <div class="form-group"><label for="member-persona-input">äººè®¾</label><textarea id="member-persona-input"
                        rows="4"></textarea></div>
                <div class="form-group"><label>å¤´åƒ</label>
                    <div class="avatar-upload"><img id="member-avatar-preview"><button
                            onclick="document.getElementById('member-avatar-input').click()">ä¸Šä¼ å¤´åƒ</button><button
                            class="change-frame-btn" data-type="member">æ›´æ¢å¤´åƒæ¡†</button><input type="file"
                            id="member-avatar-input" accept="image/*"></div>
                </div>
            </div>
            <div class="modal-footer"><button class="cancel" id="cancel-member-settings-btn">å–æ¶ˆ</button><button
                    class="save" id="save-member-settings-btn">ä¿å­˜</button></div>
        </div>
    </div>

    <div id="custom-modal-overlay">
        <div id="custom-modal">
            <div class="custom-modal-header" id="custom-modal-title"></div>
            <div class="custom-modal-body" id="custom-modal-body"></div>
            <div class="custom-modal-footer">
                <button id="custom-modal-cancel">å–æ¶ˆ</button>
                <button id="custom-modal-confirm" class="confirm-btn">ç¡®å®š</button>
            </div>
        </div>
    </div>

    <!-- Export Progress Modal -->
    <div id="export-progress-modal-overlay" style="display: none;">
        <div id="export-progress-modal"
            style="background-color: #fff; width: 300px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
            <div class="custom-modal-header" style="text-align: center; font-weight: 600; padding: 16px;">
                å¯¼å‡ºæ•°æ®
            </div>
            <div class="custom-modal-body" style="padding: 20px;">
                <div id="export-status-text" style="text-align: center; margin-bottom: 16px; color: #666;">
                    æ­£åœ¨å‡†å¤‡å¯¼å‡º...
                </div>
                <div id="export-progress-container"
                    style="width: 100%; height: 8px; background-color: #f0f0f0; border-radius: 4px; overflow: hidden; margin-bottom: 12px;">
                    <div id="export-progress-bar"
                        style="height: 100%; background-color: #007AFF; width: 0%; transition: width 0.3s ease;"></div>
                </div>
                <div id="export-progress-text" style="text-align: center; font-size: 14px; color: #999;">
                    0%
                </div>
            </div>
        </div>
    </div>

    <div id="preset-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="preset-action-edit">ç¼–è¾‘é¢„è®¾</button>
                <button id="preset-action-delete" class="btn-danger">åˆ é™¤é¢„è®¾</button>
                <button id="preset-action-cancel"
                    style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <div id="transfer-modal">
        <div class="transfer-content">
            <div class="transfer-header">ç»™Taä¸€ä¸ªæƒŠå–œï¼</div>
            <div class="transfer-input-group">
                <label for="transfer-amount">è½¬è´¦é‡‘é¢</label>
                <input type="number" id="transfer-amount" placeholder="0.00" min="0" max="99999" step="0.01">
            </div>
            <div class="transfer-input-group">
                <label for="transfer-note">å¤‡æ³¨ (å¯é€‰)</label>
                <input type="text" id="transfer-note" placeholder="ç•™ä¸‹ä½ çš„å°å¿ƒæ€~" maxlength="20">
            </div>
            <div class="transfer-actions">
                <button id="transfer-cancel-btn">å–æ¶ˆ</button>
                <button id="transfer-confirm-btn">ç¡®è®¤è½¬è´¦</button>
            </div>
        </div>
    </div>

    <!-- â–¼â–¼â–¼ ã€å…¨æ–°ã€‘ç²¾è‡´ç‰ˆè½¬è´¦æ“ä½œå¼¹çª— â–¼â–¼â–¼ -->
    <div id="transfer-actions-modal" class="modal">
        <div class="transfer-actions-content">
            <div class="transfer-actions-header">è¯·é€‰æ‹©æ“ä½œ</div>
            <div class="transfer-actions-body">
                <p>ä½ æ”¶åˆ°äº†æ¥è‡ª <strong id="transfer-sender-name"></strong> çš„ä¸€ç¬”è½¬è´¦ã€‚</p>
            </div>
            <div class="transfer-actions-footer">
                <button id="transfer-action-decline" class="action-btn decline">æ®‹å¿æ‹’ç»</button>
                <button id="transfer-action-accept" class="action-btn accept">å¼€å¿ƒæ”¶ä¸‹</button>
            </div>
            <button id="transfer-action-cancel" class="cancel-btn">Ã—</button>
        </div>
    </div>
    <!-- â–²â–²â–² æ–°HTMLç²˜è´´ç»“æŸ â–²â–²â–² -->

    <div id="battery-alert-modal">
        <div class="battery-alert-content">
            <img id="battery-alert-image" src="">
            <p id="battery-alert-text"></p>
        </div>
    </div>

    <audio id="audio-player" style="display:none;"></audio>

    <!-- â–¼â–¼â–¼ ç”¨ä¸‹é¢è¿™æ®µã€å®Œæ•´ã€‘çš„æ¨¡æ€æ¡†ä»£ç ï¼Œæ›¿æ¢æ‰ä½ ç°æœ‰çš„ id="create-post-modal" çš„æ•´ä¸ª div â–¼â–¼â–¼ -->
    <div id="create-post-modal" class="modal">
        <div class="modal-content" style="height: auto; max-height: 90%;">
            <div class="modal-header">
                <span>å‘å¸ƒåŠ¨æ€</span>
            </div>
            <div class="modal-body">
                <!-- å…¬å¼€æ–‡å­—è¾“å…¥åŒº -->
                <div class="form-group">
                    <textarea id="post-public-text" rows="3" placeholder="åˆ†äº«æ–°é²œäº‹...ï¼ˆéå¿…å¡«çš„å…¬å¼€æ–‡å­—ï¼‰"></textarea>
                </div>

                <!-- === æ¨¡å¼åˆ‡æ¢å¼€å…³ (æ–°å¢) === -->
                <div class="post-mode-switcher">
                    <button id="switch-to-image-mode" class="mode-btn active">ä¸Šä¼ å›¾ç‰‡</button>
                    <button id="switch-to-text-image-mode" class="mode-btn">ä½¿ç”¨æ–‡å­—å›¾</button>
                </div>

                <!-- â–¼â–¼â–¼ ã€ä¿®æ­£åã€‘çš„å¯è§èŒƒå›´è®¾ç½® â–¼â–¼â–¼ -->
                <div class="form-group">
                    <label>å¯è§èŒƒå›´</label>
                    <div id="post-visibility-options" style="display: flex; gap: 15px; margin-bottom: 10px;">
                        <label><input type="radio" name="visibility" value="public" checked> å…¬å¼€</label>

                        <label><input type="radio" name="visibility" value="include"> æŒ‡å®šåˆ†ç»„å¯è§</label>
                    </div>
                    <div id="post-visibility-groups"
                        style="display: none; max-height: 120px; overflow-y: auto; background: #f9f9f9; padding: 10px; border-radius: 8px;">
                        <!-- åˆ†ç»„å¤šé€‰æ¡†å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
                    </div>
                </div>
                <!-- â–²â–²â–² ä¿®æ­£ç»“æŸ â–²â–²â–² -->

                <!-- === å›¾ç‰‡æ¨¡å¼åŒºåŸŸ === -->
                <div id="image-mode-content" class="post-mode-content active">
                    <div class="form-group">
                        <div id="post-image-preview-container" class="post-image-preview-container">
                            <img id="post-image-preview" src="" alt="å›¾ç‰‡é¢„è§ˆ">
                            <button id="post-remove-image-btn">Ã—</button>
                        </div>
                        <div class="post-image-upload-options">
                            <button id="post-upload-local-btn" class="form-button-secondary">æœ¬åœ°ä¸Šä¼ </button>
                            <button id="post-use-url-btn" class="form-button-secondary">ç½‘ç»œURL</button>
                            <input type="file" id="post-local-image-input" accept="image/*" hidden>
                        </div>
                    </div>
                    <div id="post-image-desc-group" class="form-group" style="display: none;">
                        <label>å›¾ç‰‡æè¿° (å¿…å¡«ï¼Œç»™AIçœ‹)</label>
                        <input type="text" id="post-image-description" placeholder="ç®€å•æè¿°å›¾ç‰‡å†…å®¹ï¼Œå¸®åŠ©AIç†è§£">
                    </div>
                </div>

                <!-- === æ–‡å­—å›¾æ¨¡å¼åŒºåŸŸ (æ–°å¢) === -->
                <div id="text-image-mode-content" class="post-mode-content">
                    <div class="form-group">
                        <label>è£…é¥°å›¾ç‰‡ (çº¯è£…é¥°ç”¨ï¼Œä¸ä¼šå‘é€ç»™AI)</label>
                        <input type="url" id="text-image-decorative-url" placeholder="è¾“å…¥å›¾ç‰‡é“¾æ¥ (å¯é€‰)">
                    </div>
                    <div class="form-group">
                        <label>æ–‡å­—å›¾ (ç»™AIç†è§£ç”¨çš„æè¿°ï¼Œç‚¹å‡»å›¾ç‰‡åå¯è§)</label>
                        <textarea id="post-hidden-text" rows="4" placeholder="åœ¨è¿™é‡Œå†™ä¸‹å›¾ç‰‡æè¿°..."></textarea>
                    </div>
                </div>

            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-create-post-btn">å–æ¶ˆ</button>
                <button class="save" id="confirm-create-post-btn">å‘å¸ƒ</button>
            </div>
        </div>
    </div>
    <!-- â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–² -->

    <!-- â–¼â–¼â–¼ è¯·å°†è¿™ä¸ªæ–°çš„æ¨¡æ€æ¡†HTMLç²˜è´´åˆ°æ‰€æœ‰å…¶ä»–æ¨¡æ€æ¡†ä¹‹å â–¼â–¼â–¼ -->
    <div id="group-management-modal" class="modal">
        <div class="modal-content" style="height: 60%;">
            <div class="modal-header">
                <span>ç®¡ç†å¥½å‹åˆ†ç»„</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>æ–°å»ºåˆ†ç»„</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="new-group-name-input" placeholder="è¾“å…¥åˆ†ç»„å..." style="flex-grow: 1;">
                        <button id="add-new-group-btn" class="form-button"
                            style="width: auto; margin-top: 0; padding: 0 15px;">æ·»åŠ </button>
                    </div>
                </div>
                <hr style="opacity: 0.2;">
                <div id="existing-groups-list" style="display: flex; flex-direction: column; gap: 10px;">
                    <!-- åˆ†ç»„åˆ—è¡¨å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="save" id="close-group-manager-btn" style="width: 100%;">å®Œæˆ</button>
            </div>
        </div>
    </div>
    <!-- â–²â–²â–² æ–°ä»£ç ç²˜è´´ç»“æŸ â–²â–²â–² -->

    <!-- â–¼â–¼â–¼ è¯·å°†è¿™æ®µæ–°çš„HTMLç²˜è´´åˆ°åˆšåˆšåˆ é™¤çš„ä½ç½® â–¼â–¼â–¼ -->
    <div id="message-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <!-- æ“ä½œæŒ‰é’® -->
                <button id="quote-message-btn">å¼•ç”¨</button>
                <button id="recall-message-btn">æ’¤å›</button>
                <button id="edit-message-btn">ç¼–è¾‘</button>
                <button id="select-message-btn">å¤šé€‰</button>
                <button id="post-bulletin-btn">å‘å¸ƒåˆ°å…¬å‘Šæ¿</button>
                <!-- å–æ¶ˆæŒ‰é’® -->
                <button id="cancel-message-action-btn"
                    style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">å–æ¶ˆ</button>
            </div>
        </div>
    </div>
    <!-- â–²â–²â–² æ–°ä»£ç ç²˜è´´ç»“æŸ â–²â–²â–² -->

    <!-- â–¼â–¼â–¼ è¯·å°†è¿™æ®µæ–°HTMLç²˜è´´åˆ°æ‰€æœ‰æ¨¡æ€æ¡†çš„æœ«å°¾ â–¼â–¼â–¼ -->
    <div id="post-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="pin-post-btn">ç½®é¡¶</button>
                <button id="unpin-post-btn" style="display: none;">å–æ¶ˆç½®é¡¶</button>
                <button id="edit-post-btn">ç¼–è¾‘åŠ¨æ€</button>
                <button id="copy-post-btn">å¤åˆ¶å†…å®¹</button>
                <button id="delete-post-btn" style="color: #ff3b30;">åˆ é™¤åŠ¨æ€</button>
                <button id="cancel-post-action-btn">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <!-- â–¼â–¼â–¼ è¯„è®ºæ“ä½œæ¨¡æ€æ¡† â–¼â–¼â–¼ -->
    <div id="comment-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="edit-comment-btn">ç¼–è¾‘è¯„è®º</button>
                <button id="delete-comment-btn" style="color: #ff3b30;">åˆ é™¤è¯„è®º</button>
                <button id="cancel-comment-action-btn">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <!-- â–¼â–¼â–¼ èŠå¤©æ“ä½œæ¨¡æ€æ¡† â–¼â–¼â–¼ -->
    <div id="chat-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="pin-chat-btn">ç½®é¡¶å¯¹è¯</button>
                <button id="unpin-chat-btn" style="display: none;">å–æ¶ˆç½®é¡¶</button>
                <button id="delete-chat-btn" style="color: #ff3b30;">åˆ é™¤å¯¹è¯</button>
                <button id="cancel-chat-action-btn"
                    style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <!-- â–¼â–¼â–¼ AIå›å¤é€‰æ‹©æ¨¡æ€æ¡† â–¼â–¼â–¼ -->
    <div id="ai-reply-modal" class="modal">
        <div class="modal-content" style="width: 90%; max-width: 400px;">
            <div class="modal-header">
                <span>é€‰æ‹©AIå›å¤</span>
                <span id="close-ai-reply-modal" style="cursor: pointer; font-size: 20px;">&times;</span>
            </div>
            <div class="modal-body">
                <div style="margin-bottom: 15px;">
                    <button id="select-all-ais"
                        style="padding: 5px 10px; margin-right: 10px; border: 1px solid #ddd; background: #f5f5f5; border-radius: 5px; cursor: pointer;">å…¨é€‰</button>
                    <button id="deselect-all-ais"
                        style="padding: 5px 10px; border: 1px solid #ddd; background: #f5f5f5; border-radius: 5px; cursor: pointer;">å–æ¶ˆå…¨é€‰</button>
                </div>
                <div id="ai-selection-list" style="max-height: 300px; overflow-y: auto;">
                    <!-- AIåˆ—è¡¨å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>
            <div class="modal-footer">
                <button id="confirm-ai-reply" class="save">ç¡®è®¤å›å¤</button>
                <button id="cancel-ai-reply" class="cancel">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <!-- â–¼â–¼â–¼ AIå‘åŠ¨æ€é€‰æ‹©æ¨¡æ€æ¡† â–¼â–¼â–¼ -->
    <div id="ai-post-modal" class="modal">
        <div class="modal-content" style="width: 90%; max-width: 400px;">
            <div class="modal-header">
                <span>é€‰æ‹©AIå‘åŠ¨æ€</span>
                <span id="close-ai-post-modal" style="cursor: pointer; font-size: 20px;">&times;</span>
            </div>
            <div class="modal-body">
                <div id="ai-post-selection-list" style="max-height: 300px; overflow-y: auto;">
                    <!-- AIåˆ—è¡¨å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>
            <div class="modal-footer">
                <button id="confirm-ai-post" class="save">ç¡®è®¤å‘åŠ¨æ€</button>
                <button id="cancel-ai-post" class="cancel">å–æ¶ˆ</button>
            </div>
        </div>
    </div>
    <!-- â–²â–²â–² æ–°HTMLç²˜è´´ç»“æŸ â–²â–²â–² -->

    <!-- â–¼â–¼â–¼ ç§»åŠ¨è¡¨æƒ…åˆ°è¡¨æƒ…åŒ…é€‰æ‹©æ¨¡æ€æ¡† â–¼â–¼â–¼ -->
    <div id="move-sticker-modal" class="modal">
        <div class="modal-content" style="width: 90%; max-width: 400px;">
            <div class="modal-header">
                <span>é€‰æ‹©è¡¨æƒ…åŒ…</span>
                <span id="close-move-sticker-modal" style="cursor: pointer; font-size: 20px;">&times;</span>
            </div>
            <div class="modal-body">
                <div id="sticker-pack-selection-list" style="max-height: 300px; overflow-y: auto;">
                    <!-- è¡¨æƒ…åŒ…åˆ—è¡¨å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>
            <div class="modal-footer">
                <button id="confirm-move-sticker" class="save">ç¡®è®¤ç§»åŠ¨</button>
                <button id="cancel-move-sticker" class="cancel">å–æ¶ˆ</button>
            </div>
        </div>
    </div>
    <!-- â–²â–²â–² ç§»åŠ¨è¡¨æƒ…åŒ…æ¨¡æ€æ¡†ç»“æŸ â–²â–²â–² -->

    <!-- â–¼â–¼â–¼ ã€å…¨æ–°ã€‘å¯è§†åŒ–æ¶ˆæ¯ç¼–è¾‘å™¨æ¨¡æ€æ¡† â–¼â–¼â–¼ -->
    <div id="message-editor-modal" class="modal">
        <div class="modal-content" style="height: 75%;">
            <div class="modal-header">
                <span>ç¼–è¾‘ä¸æ‹†åˆ†æ¶ˆæ¯</span>
            </div>
            <div class="modal-body" id="message-editor-body">
                <!-- ç¼–è¾‘å™¨å®¹å™¨ï¼ŒJSä¼šåœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆæ–‡æœ¬æ¡† -->
                <div id="message-editor-container"></div>
                <!-- æ·»åŠ æ–°æ¶ˆæ¯çš„æŒ‰é’® -->
                <button id="add-message-editor-block-btn" class="form-button form-button-secondary"
                    style="margin-top: 15px;">
                    [+] æ·»åŠ ä¸‹ä¸€æ¡æ¶ˆæ¯
                </button>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-advanced-editor-btn">å–æ¶ˆ</button>
                <button class="save" id="save-advanced-editor-btn">ä¿å­˜æ›´æ”¹</button>
            </div>
        </div>
    </div>
    <!-- â–²â–²â–² æ–°HTMLç²˜è´´ç»“æŸ â–²â–²â–² -->

    <!-- â–¼â–¼â–¼ ã€å…¨æ–°ã€‘å¤–å–è¯·æ±‚æ¨¡æ€æ¡† â–¼â–¼â–¼ -->
    <div id="waimai-request-modal" class="modal">
        <div class="modal-content" style="width: 290px;">
            <div class="modal-header">
                <span>å‘èµ·å¤–å–ä»£ä»˜</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="waimai-product-info">å•†å“ä¿¡æ¯</label>
                    <input type="text" id="waimai-product-info" placeholder="ä¾‹å¦‚ï¼šä¸€æ¯æ¨æç”˜éœ²">
                </div>
                <div class="form-group">
                    <label for="waimai-amount">ä»£ä»˜é‡‘é¢ (å…ƒ)</label>
                    <input type="number" id="waimai-amount" placeholder="ä¾‹å¦‚ï¼š21" min="0" step="0.01">
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="waimai-cancel-btn">å–æ¶ˆ</button>
                <button class="save" id="waimai-confirm-btn">å‘èµ·è¯·æ±‚</button>
            </div>
        </div>
    </div>

    <!-- â–¼â–¼â–¼ ã€å…¨æ–°ã€‘æ–°å»ºçº¦å®š/å€’è®¡æ—¶æ¨¡æ€æ¡† â–¼â–¼â–¼ -->
    <div id="create-countdown-modal" class="modal">
        <div class="modal-content" style="height: auto;">
            <div class="modal-header">
                <span>æ–°å»ºçº¦å®š</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="countdown-title-input">çº¦å®šæ ‡é¢˜</label>
                    <input type="text" id="countdown-title-input" placeholder="ä¾‹å¦‚ï¼šæˆ‘çš„ç”Ÿæ—¥">
                </div>
                <div class="form-group">
                    <label for="countdown-date-input">çº¦å®šæ—¥æœŸä¸æ—¶é—´</label>
                    <input type="datetime-local" id="countdown-date-input">
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-create-countdown-btn">å–æ¶ˆ</button>
                <button class="save" id="confirm-create-countdown-btn">ä¿å­˜çº¦å®š</button>
            </div>
        </div>
    </div>
    <!-- â–²â–²â–² æ–°HTMLç²˜è´´ç»“æŸ â–²â–²â–² -->

    <!-- â–¼â–¼â–¼ ã€å…¨æ–°ã€‘é€‰æ‹©æ·»åŠ ç±»å‹æ¨¡æ€æ¡† â–¼â–¼â–¼ -->
    <div id="add-memory-type-modal" class="modal">
        <div class="modal-content" style="height: auto;">
            <div class="modal-header">
                <span>æ·»åŠ å†…å®¹</span>
            </div>
            <div class="modal-body">
                <button class="form-button" id="add-memory-btn" style="margin-bottom: 15px;">
                    ğŸ“ æ·»åŠ å›å¿†
                </button>
                <button class="form-button" id="add-event-btn" style="margin-bottom: 15px;">
                    ğŸ“… æ·»åŠ çº¦å®š/äº‹ä»¶
                </button>
                <button class="form-button" id="add-ai-memory-btn">
                    ğŸ¤– è®©AIè®°å½•å›å¿†
                </button>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-add-type-btn">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <!-- â–¼â–¼â–¼ AIè®°å½•å›å¿†é€‰æ‹©æ¨¡æ€æ¡† â–¼â–¼â–¼ -->
    <div id="ai-memory-modal" class="modal">
        <div class="modal-content" style="width: 90%; max-width: 400px;">
            <div class="modal-header">
                <span>é€‰æ‹©AIè®°å½•å›å¿†</span>
                <span id="close-ai-memory-modal" style="cursor: pointer; font-size: 20px;">&times;</span>
            </div>
            <div class="modal-body">
                <div id="ai-memory-selection-list" style="max-height: 300px; overflow-y: auto;">
                    <!-- AIåˆ—è¡¨å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>
            <div class="modal-footer">
                <button id="confirm-ai-memory" class="save">åˆ›å»ºå›å¿†</button>
                <button id="cancel-ai-memory" class="cancel">å–æ¶ˆ</button>
            </div>
        </div>
    </div>
    <!-- â–²â–²â–² AIè®°å½•å›å¿†é€‰æ‹©æ¨¡æ€æ¡†ç»“æŸ â–²â–²â–² -->

    <!-- â–¼â–¼â–¼ ã€å…¨æ–°ã€‘QZoneæ·»åŠ å†…å®¹é€‰æ‹©æ¨¡æ€æ¡† â–¼â–¼â–¼ -->
    <div id="qzone-add-options-modal" class="modal">
        <div class="modal-content" style="height: auto;">
            <div class="modal-header">
                <span>æ·»åŠ å†…å®¹</span>
            </div>
            <div class="modal-body">
                <button class="form-button" id="modal-create-shuoshuo-btn" style="margin-bottom: 15px;">
                    ğŸ’¬ è¯´è¯´
                </button>
                <button class="form-button" id="modal-create-post-btn" style="margin-bottom: 15px;">
                    ğŸ“· åŠ¨æ€
                </button>
                <button class="form-button" id="modal-open-album-btn">
                    ğŸ“ ç›¸å†Œ
                </button>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-qzone-add-btn">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <!-- â–¼â–¼â–¼ ã€å…¨æ–°ã€‘æ·»åŠ å›å¿†æ¨¡æ€æ¡† â–¼â–¼â–¼ -->
    <div id="create-memory-modal" class="modal">
        <div class="modal-content" style="height: auto;">
            <div class="modal-header">
                <span>æ–°å»ºå›å¿†</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="memory-description-input">å›å¿†å†…å®¹</label>
                    <textarea id="memory-description-input" placeholder="è®°å½•ä¸€æ®µç¾å¥½çš„å›å¿†..." rows="4"></textarea>
                </div>
                <div class="form-group">
                    <label for="memory-date-input">å›å¿†æ—¥æœŸä¸æ—¶é—´</label>
                    <input type="datetime-local" id="memory-date-input">
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-create-memory-btn">å–æ¶ˆ</button>
                <button class="save" id="confirm-create-memory-btn">ä¿å­˜å›å¿†</button>
            </div>
        </div>
    </div>

    <!-- â–¼â–¼â–¼ ã€å…¨æ–°ã€‘å‘çº¢åŒ…æ¨¡æ€æ¡† â–¼â–¼â–¼ -->
    <div id="red-packet-modal" class="modal">
        <div class="modal-content" style="width: 300px; height: auto;">
            <div class="modal-header">
                <span>å‘çº¢åŒ…</span>
            </div>
            <div class="modal-body" style="padding: 0;">
                <!-- 1. é¡µç­¾åˆ‡æ¢ -->
                <div class="frame-tabs">
                    <div id="rp-tab-group" class="frame-tab active">æ‹¼æ‰‹æ°”çº¢åŒ…</div>
                    <div id="rp-tab-direct" class="frame-tab">ä¸“å±çº¢åŒ…</div>
                </div>

                <!-- 2. æ‹¼æ‰‹æ°”çº¢åŒ…å†…å®¹åŒº -->
                <div id="rp-content-group" class="frame-content" style="padding: 20px 15px;">
                    <div class="form-group">
                        <label>æ€»é‡‘é¢ (å…ƒ)</label>
                        <input type="number" id="rp-group-amount" placeholder="0.00">
                    </div>
                    <div class="form-group">
                        <label>çº¢åŒ…ä¸ªæ•°</label>
                        <input type="number" id="rp-group-count" placeholder="å¡«å†™çº¢åŒ…ä¸ªæ•°">
                    </div>
                    <div class="form-group">
                        <label>ç¥ç¦è¯­</label>
                        <input type="text" id="rp-group-greeting" placeholder="æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©ï¼">
                    </div>
                    <p id="rp-group-total"
                        style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">Â¥ 0.00</p>
                    <button id="send-group-packet-btn" class="form-button">å¡é’±è¿›çº¢åŒ…</button>
                </div>

                <!-- 3. ä¸“å±çº¢åŒ…å†…å®¹åŒº -->
                <div id="rp-content-direct" class="frame-content" style="display: none; padding: 20px 15px;">
                    <div class="form-group">
                        <label>å‘é€ç»™</label>
                        <select id="rp-direct-receiver"></select>
                    </div>
                    <div class="form-group">
                        <label>é‡‘é¢ (å…ƒ)</label>
                        <input type="number" id="rp-direct-amount" placeholder="0.00">
                    </div>
                    <div class="form-group">
                        <label>ç¥ç¦è¯­</label>
                        <input type="text" id="rp-direct-greeting" placeholder="æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©ï¼">
                    </div>
                    <p id="rp-direct-total"
                        style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">Â¥ 0.00</p>
                    <button id="send-direct-packet-btn" class="form-button">å¡é’±è¿›çº¢åŒ…</button>
                </div>
            </div>
            <div class="modal-footer" style="justify-content: center;">
                <button class="cancel" id="cancel-red-packet-btn" style="width: 100%;">å–æ¶ˆ</button>
            </div>
        </div>
    </div>
    <!-- â–²â–²â–² æ–°HTMLç²˜è´´ç»“æŸ â–²â–²â–² -->

    <!-- â–¼â–¼â–¼ ã€å…¨æ–°ã€‘çº¢åŒ…è¯¦æƒ…æ¨¡æ€æ¡† â–¼â–¼â–¼ -->
    <div id="red-packet-details-modal" class="modal">
        <div class="modal-content" style="width: 280px; height: auto; background-color: #f7f7f7;">
            <div class="modal-header"
                style="background-color: #F96259; color: white; border-bottom: none; padding-bottom: 5px;">
                <div style="text-align: center; width: 100%;">
                    <div id="rp-details-sender" style="font-size: 16px;"></div>
                    <div style="font-size: 13px; opacity: 0.8;">çš„çº¢åŒ…</div>
                </div>
            </div>
            <div class="modal-body" style="padding: 15px;">
                <p id="rp-details-greeting"
                    style="text-align: center; font-size: 20px; color: #333; margin: 0 0 20px 0;"></p>
                <div id="rp-details-my-amount" style="text-align: center; display: none; margin-bottom: 20px;">
                    <span style="font-size: 40px; font-weight: bold; color: #E44D44;">0.00</span>
                    <span style="font-size: 18px; color: #E44D44;">å…ƒ</span>
                </div>
                <div id="rp-details-summary"
                    style="font-size: 13px; color: #8a8a8a; border-top: 1px solid #e0e0e0; padding-top: 10px;"></div>
                <div id="rp-details-list" style="max-height: 150px; overflow-y: auto; margin-top: 10px;">
                    <!-- é¢†å–è¯¦æƒ…å°†ç”±JSåŠ¨æ€ç”Ÿæˆåœ¨è¿™é‡Œ -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="save" id="close-rp-details-btn" style="width: 100%;">å…³é—­</button>
            </div>
        </div>
    </div>
    <!-- â–²â–²â–² æ–°HTMLç²˜è´´ç»“æŸ â–²â–²â–² -->
    <!-- â–¼â–¼â–¼ ã€å…¨æ–°ã€‘åˆ›å»ºæŠ•ç¥¨æ¨¡æ€æ¡† â–¼â–¼â–¼ -->
    <div id="create-poll-modal" class="modal">
        <div class="modal-content" style="width: 300px; height: auto;">
            <div class="modal-header">
                <span>å‘èµ·æŠ•ç¥¨</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="poll-question-input">æŠ•ç¥¨é—®é¢˜</label>
                    <textarea id="poll-question-input" rows="2" placeholder="ä¾‹å¦‚ï¼šä»Šæ™šæˆ‘ä»¬çœ‹ä»€ä¹ˆç”µå½±ï¼Ÿ"></textarea>
                </div>
                <div class="form-group">
                    <label>æŠ•ç¥¨é€‰é¡¹ (è‡³å°‘2é¡¹)</label>
                    <div id="poll-options-container" style="display: flex; flex-direction: column; gap: 8px;">
                        <!-- æŠ•ç¥¨é€‰é¡¹å°†ç”±JSåŠ¨æ€ç”Ÿæˆåœ¨è¿™é‡Œ -->
                    </div>
                    <button id="add-poll-option-btn" class="form-button form-button-secondary"
                        style="margin-top: 12px;">+ æ·»åŠ é€‰é¡¹</button>
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-create-poll-btn">å–æ¶ˆ</button>
                <button class="save" id="confirm-create-poll-btn">å‘èµ·æŠ•ç¥¨</button>
            </div>
        </div>
    </div>
    <!-- â–²â–²â–² æ–°HTMLç²˜è´´ç»“æŸ â–²â–²â–² -->
    <!-- â–¼â–¼â–¼ ã€å…¨æ–°ã€‘å…¬å‘Šæ¿æ¨¡æ€æ¡† â–¼â–¼â–¼ -->
    <div id="bulletin-board-modal" class="modal">
        <div class="modal-content" style="height: 80%;">
            <div class="modal-header">
                <span>ç¾¤å…¬å‘Šæ¿</span>
            </div>
            <div class="modal-body" id="bulletin-list">
                <!-- å…¬å‘Šåˆ—è¡¨å°†ç”±JSåŠ¨æ€ç”Ÿæˆåœ¨è¿™é‡Œ -->
            </div>
            <div class="modal-footer">
                <button class="save" id="close-bulletin-board-btn" style="width: 100%;">å…³é—­</button>
            </div>
        </div>
    </div>
    <!-- â–²â–²â–² æ–°HTMLç²˜è´´ç»“æŸ â–²â–²â–² -->

    <!-- â–¼â–¼â–¼ ã€å…¨æ–°ã€‘å…¬å‘Šæ¿æ“ä½œèœå•æ¨¡æ€æ¡† â–¼â–¼â–¼ -->
    <div id="bulletin-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="pin-bulletin-btn">ç½®é¡¶/å–æ¶ˆç½®é¡¶</button>
                <button id="delete-bulletin-btn" class="btn-danger">åˆ é™¤å…¬å‘Š</button>
                <button id="cancel-bulletin-action-btn"
                    style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">å–æ¶ˆ</button>
            </div>
        </div>
    </div>
    <!-- â–²â–²â–² æ–°HTMLç²˜è´´ç»“æŸ â–²â–²â–² -->

    <!-- â–¼â–¼â–¼ Share Link Modal â–¼â–¼â–¼ -->
    <div id="share-link-modal" class="modal">
        <div class="modal-content" style="width: 300px; height: auto;">
            <div class="modal-header">
                <span>åˆ†äº«é“¾æ¥</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="link-title-input">æ ‡é¢˜</label>
                    <input type="text" id="link-title-input" placeholder="è¾“å…¥æ–‡ç« æˆ–é“¾æ¥çš„æ ‡é¢˜">
                </div>
                <div class="form-group">
                    <label for="link-description-input">æ‘˜è¦ (å¯é€‰)</label>
                    <textarea id="link-description-input" rows="2" placeholder="ç®€å•æè¿°ä¸€ä¸‹é“¾æ¥å†…å®¹"></textarea>
                </div>
                <div class="form-group">
                    <label for="link-source-input">æ¥æºåç§° (å¯é€‰)</label>
                    <input type="text" id="link-source-input" placeholder="ä¾‹å¦‚ï¼šçŸ¥ä¹æ—¥æŠ¥ã€Bç«™">
                </div>
                <div class="form-group">
                    <label for="link-content-input">å®Œæ•´å†…å®¹ (å¯é€‰ï¼Œç”¨äºæµè§ˆå™¨å†…æ˜¾ç¤º)</label>
                    <textarea id="link-content-input" rows="4" placeholder="ç²˜è´´æˆ–è¾“å…¥å®Œæ•´çš„æ–‡ç« å†…å®¹"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-share-link-btn">å–æ¶ˆ</button>
                <button class="save" id="confirm-share-link-btn">åˆ†äº«</button>
            </div>
        </div>
    </div>
    <!-- â–²â–²â–² Share Link Modal End â–²â–²â–² -->

    <!-- â–¼â–¼â–¼ Location Share Modal â–¼â–¼â–¼ -->
    <div id="location-share-modal" class="modal">
        <div class="modal-content" style="width: 300px; height: auto;">
            <div class="modal-header">
                <span>åˆ†äº«ä½ç½®</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="location-name-input">ä½ç½®åç§°</label>
                    <input type="text" id="location-name-input" placeholder="ä¾‹å¦‚ï¼šæ˜Ÿå·´å…‹å’–å•¡åº—ã€åŒ—äº¬å¤§å­¦">
                </div>
                <div class="form-group">
                    <label for="location-address-input">è¯¦ç»†åœ°å€ (å¯é€‰)</label>
                    <textarea id="location-address-input" rows="2" placeholder="è¾“å…¥è¯¦ç»†åœ°å€æˆ–æè¿°"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="cancel" id="cancel-location-btn">å–æ¶ˆ</button>
                <button type="button" class="save" id="confirm-location-btn">å‘é€ä½ç½®</button>
            </div>
        </div>
    </div>
    <!-- â–²â–²â–² Location Share Modal End â–²â–²â–² -->

    <!-- â–¼â–¼â–¼ Meetup Creation Modal â–¼â–¼â–¼ -->
    <div id="meetup-creation-modal" class="modal">
        <div class="modal-content" style="width: 300px; height: auto;">
            <div class="modal-header">
                <span>å¼€å§‹è§é¢</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="meetup-title-input">è§é¢ä¸»é¢˜</label>
                    <input type="text" id="meetup-title-input" placeholder="æµªæ¼«æ™šé¤, æ•£æ­¥è§é¢...">
                </div>
                <div class="form-group">
                    <label for="meetup-location-input">è§é¢åœ°ç‚¹</label>
                    <input type="text" id="meetup-location-input" placeholder="å’–å•¡å…, å…¬å›­, å®¶é‡Œ...">
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-meetup-btn">å–æ¶ˆ</button>
                <button class="save" id="start-meetup-btn">å¼€å§‹è§é¢</button>
            </div>
        </div>
    </div>
    <!-- â–²â–²â–² Date Creation Modal End â–²â–²â–² -->

    <!-- â–¼â–¼â–¼ QZone Avatar Modal â–¼â–¼â–¼ -->
    <div id="qzone-avatar-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><span>ç¼–è¾‘å¤´åƒ</span></div>
            <div class="modal-body">
                <div class="form-group"><label>å¤´åƒ</label>
                    <div class="avatar-upload"><img id="qzone-avatar-preview"><button
                            onclick="document.getElementById('qzone-avatar-file-input').click()">ä¸Šä¼ å¤´åƒ</button><input
                            type="file" id="qzone-avatar-file-input" accept="image/*"></div>
                </div>
                <div class="form-group">
                    <label>å¯ç”¨å¤´åƒè¾¹æ¡†</label>
                    <label class="switch">
                        <input type="checkbox" id="qzone-border-toggle">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="form-group" id="qzone-border-group"><label>å¤´åƒè¾¹æ¡†</label>
                    <div class="avatar-upload">
                        <div class="border-preview-container">
                            <img id="qzone-border-preview" class="border-preview" style="display: none;">
                            <span id="qzone-no-border-text" class="no-border-text">æ— è¾¹æ¡†</span>
                        </div>
                        <button onclick="document.getElementById('qzone-border-input').click()">ä¸Šä¼ è¾¹æ¡†</button>
                        <button id="qzone-remove-border-btn" onclick="removeQzoneBorder()"
                            style="display: none;">ç§»é™¤è¾¹æ¡†</button>
                        <input type="file" id="qzone-border-input" accept="image/png,image/gif">
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" onclick="document.getElementById('qzone-avatar-modal').classList.remove('visible')">å–æ¶ˆ</button>
                <button class="save" id="save-qzone-avatar-btn">ä¿å­˜</button>
            </div>
        </div>
    </div>
    <!-- â–²â–²â–² QZone Avatar Modal End â–²â–²â–² -->

    <!-- â–¼â–¼â–¼ Sticker Pack Edit Modal â–¼â–¼â–¼ -->
    <div id="sticker-pack-edit-modal" class="modal">
        <div class="modal-content" style="width: 300px; height: auto;">
            <div class="modal-header">
                <span>ç¼–è¾‘è¡¨æƒ…åŒ…</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="sticker-pack-name-input">è¡¨æƒ…åŒ…åç§°</label>
                    <input type="text" id="sticker-pack-name-input" placeholder="æˆ‘çš„è¡¨æƒ…åŒ…">
                </div>
                <div class="form-group">
                    <label for="sticker-pack-icon-input">å›¾æ ‡é“¾æ¥</label>
                    <input type="text" id="sticker-pack-icon-input" placeholder="https://example.com/icon.png">
                </div>
                <div class="form-group">
                    <button id="delete-sticker-pack-btn"
                        style="width: 100%; padding: 10px; background-color: #ff3b30; color: white; border: none; border-radius: 8px; cursor: pointer;">åˆ é™¤è¡¨æƒ…åŒ…</button>
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-sticker-pack-edit-btn">å–æ¶ˆ</button>
                <button class="save" id="save-sticker-pack-btn">ä¿å­˜</button>
            </div>
        </div>
    </div>
    <!-- â–²â–²â–² Sticker Pack Edit Modal End â–²â–²â–² -->

    <!-- â–¼â–¼â–¼ New Sticker Pack Modal â–¼â–¼â–¼ -->
    <div id="new-sticker-pack-modal" class="modal">
        <div class="modal-content" style="width: 300px; height: auto;">
            <div class="modal-header">
                <span>æ–°å»ºè¡¨æƒ…åŒ…</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="new-pack-name-input">è¡¨æƒ…åŒ…åç§°</label>
                    <input type="text" id="new-pack-name-input" placeholder="æˆ‘çš„è¡¨æƒ…åŒ…">
                </div>
                <div class="form-group">
                    <label for="new-pack-icon-input">å›¾æ ‡é“¾æ¥</label>
                    <input type="text" id="new-pack-icon-input" placeholder="https://example.com/icon.png">
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-new-pack-btn">å–æ¶ˆ</button>
                <button class="save" id="create-new-pack-btn">åˆ›å»º</button>
            </div>
        </div>
    </div>
    <!-- â–²â–²â–² New Sticker Pack Modal End â–²â–²â–² -->

    <!-- â–¼â–¼â–¼ Meetup End Confirmation Modal â–¼â–¼â–¼ -->
    <div id="meetup-end-modal" class="modal">
        <div class="modal-content" style="width: 300px; height: auto;">
            <div class="modal-header">
                <span>ç»“æŸè§é¢</span>
            </div>
            <div class="modal-body">
                <p>ç¡®å®šè¦ç»“æŸè¿™æ¬¡è§é¢å—ï¼Ÿæ‰€æœ‰çš„ç¾å¥½å›å¿†éƒ½ä¼šä¿å­˜åˆ°æ—¥å†ä¸­ã€‚</p>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-end-date-btn" onclick="hideMeetupEndModal()">ç»§ç»­è§é¢</button>
                <button class="save" id="confirm-end-date-btn" onclick="window.confirmEndMeetup()">ç»“æŸè§é¢</button>
            </div>
        </div>
    </div>
    <!-- â–²â–²â–² Date End Confirmation Modal End â–²â–²â–² -->

    <!-- â–¼â–¼â–¼ Chat Search Modal â–¼â–¼â–¼ -->
    <div id="chat-search-modal" class="modal">
        <div class="modal-content" style="width: 320px; height: 70%;">
            <div class="modal-header">
                <span>æœç´¢æ¶ˆæ¯</span>
            </div>
            <div class="modal-body" style="display: flex; flex-direction: column; gap: 15px;">
                <div class="form-group">
                    <input type="text" id="search-input" placeholder="è¾“å…¥å…³é”®è¯æœç´¢æ¶ˆæ¯..."
                        style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #ccc;">
                </div>
                <div id="search-results"
                    style="flex: 1; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; padding: 10px;">
                    <p style="text-align: center; color: #999; margin: 20px 0;">è¾“å…¥å…³é”®è¯å¼€å§‹æœç´¢</p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="close-search-btn" style="width: 100%;">å…³é—­</button>
            </div>
        </div>
    </div>
    <!-- â–²â–²â–² Chat Search Modal End â–²â–²â–² -->

    <!-- â–¼â–¼â–¼ ã€å…¨æ–°shepã€‘å¤‡ä»½ç‰ˆæœ¬é€‰æ‹©æ¨¡æ€æ¡† â–¼â–¼â–¼ -->
    <div id="restore-version-modal" class="modal">
        <div class="modal-content" style="width: 320px; height: auto;">
            <div class="modal-header">
                <span>é€‰æ‹©è¦æ¢å¤çš„äº‘ç«¯å¤‡ä»½</span>
            </div>
            <div class="modal-body" id="restore-version-list" style="padding: 15px 0;">
                <!-- åŠ è½½æç¤º -->
                <p style="text-align:center; color: var(--text-secondary);">æ­£åœ¨ä»äº‘ç«¯è·å–å¤‡ä»½ä¿¡æ¯...</p>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-restore-version-btn" style="width: 100%;">å–æ¶ˆ</button>
            </div>
        </div>
    </div>
    <!-- â–²â–²â–²shepshep æ–°HTMLç²˜è´´ç»“æŸ â–²â–²â–² -->
    <script>
        // Spotify Web Playback SDK callback - must be defined globally before SDK loads
        window.onSpotifyWebPlaybackSDKReady = function () {
            // This will be handled by initSpotifyPlayer() when needed
        };

        // Function to toggle charm visibility - defined early to avoid execution order issues
        window.toggleCharmVisibility = function (isVisible) {
            const charm = document.getElementById('floating-phone-charm');
            if (charm) {
                charm.style.display = isVisible ? 'block' : 'none';
            }
        }

        document.addEventListener('DOMContentLoaded', () => {

            // ===================================================================
            // 1. æ‰€æœ‰å˜é‡å’Œå¸¸é‡å®šä¹‰
            // ===================================================================
            const db = new Dexie('GeminiChatDB');
            window.db = db;
            // --- å·²ä¿®æ­£ ---
            let state = { chats: {}, activeChatId: null, globalSettings: {}, apiConfig: {}, userStickers: [], worldBooks: [], personaPresets: [], qzoneSettings: {}, activeAlbumId: null };
            // --- ä¿®æ­£ç»“æŸ ---
            let musicState = { isActive: false, activeChatId: null, isPlaying: false, playlist: [], currentIndex: -1, playMode: 'order', totalElapsedTime: 0, timerId: null, currentSpotifyPlaylist: null, spotifyPlaylistTracks: [], isPlayingFromPlaylist: false, mainPlaylist: [] };
            // Spotify integration variables
            let spotifyPlayer = null;
            let spotifyAccessToken = null;
            let spotifyDeviceId = null;
            
            // Summary generation state
            let isGeneratingSummary = false;
            let generatingSummaryBookId = null;
            
            const audioPlayer = document.getElementById('audio-player');
            let newWallpaperBase64 = null;
            let isSelectionMode = false;
            let selectedMessages = new Set();
            let editingMemberId = null;
            let editingFrameForMember = false;
            let editingWorldBookId = null;
            let editingPersonaPresetId = null;
            let editingMemoryId = null;
            let previousScreen = null; // Track previous screen for meetup navigation
            let inactivityTimers = {}; // ç”¨äºå­˜å‚¨1.5å°æ—¶ç¦»çº¿è®¡æ—¶å™¨
            let focusModeTimers = {}; // ç”¨äºå­˜å‚¨ä¸“æ³¨æ¨¡å¼è®¡æ—¶å™¨
            let waimaiTimers = {}; // ç”¨äºå­˜å‚¨å¤–å–å€’è®¡æ—¶

            let activeMessageTimestamp = null;
            let activeChatId = null;
            let currentReplyContext = null; // <--- æ–°å¢è¿™è¡Œï¼Œç”¨æ¥å­˜å‚¨å½“å‰æ­£åœ¨å¼•ç”¨çš„æ¶ˆæ¯ä¿¡æ¯
            let activePostId = null; // <-- æ–°å¢ï¼šç”¨äºå­˜å‚¨å½“å‰æ“ä½œçš„åŠ¨æ€ID
            let activeBulletinId = null; // <-- æ–°å¢ï¼šç”¨äºå­˜å‚¨å½“å‰æ“ä½œçš„å…¬å‘ŠID
            let activeCommentData = null; // <-- æ–°å¢ï¼šç”¨äºå­˜å‚¨å½“å‰æ“ä½œçš„è¯„è®ºæ•°æ® {postId, timestamp, text, commenterName}

            let photoViewerState = {
                isOpen: false,
                photos: [], // å­˜å‚¨å½“å‰ç›¸å†Œçš„æ‰€æœ‰ç…§ç‰‡URL
                currentIndex: -1, // å½“å‰æ­£åœ¨æŸ¥çœ‹çš„ç…§ç‰‡ç´¢å¼•
            };

            let unreadPostsCount = 0;

            let isFavoritesSelectionMode = false;
            let selectedFavorites = new Set()

            let simulationIntervalId = null;

            const frameModal = document.getElementById('avatar-frame-modal');
            const aiFrameTab = document.getElementById('ai-frame-tab');
            const myFrameTab = document.getElementById('my-frame-tab');
            const aiFrameContent = document.getElementById('ai-frame-content');
            const myFrameContent = document.getElementById('my-frame-content');
            const aiFrameGrid = document.getElementById('ai-frame-grid');
            const myFrameGrid = document.getElementById('my-frame-grid');

            const defaultAvatar = 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg';
            const defaultMyGroupAvatar = 'https://i.postimg.cc/cLPP10Vm/4.jpg';
            const defaultGroupMemberAvatar = 'https://i.postimg.cc/VkQfgzGJ/1.jpg';
            const defaultGroupAvatar = 'https://i.postimg.cc/gc3QYCDy/1-NINE7-Five.jpg';
            let notificationTimeout;

            const npcAvatarPool = {
                'anime_boy': ['https://i.postimg.cc/pL5505fT/image.png', 'https://i.postimg.cc/8CKdY2z4/image.png'],
                'anime_girl': ['https://i.postimg.cc/PqgqfH7S/image.png', 'https://i.postimg.cc/Z5pCY9tQ/image.png'],
                'cat': ['https://i.postimg.cc/d11x6HKZ/image.png', 'https://i.postimg.cc/VL1gLgV3/image.png'],
                'professional': ['https://i.postimg.cc/13yXhJg9/image.png', 'https://i.postimg.cc/W34kKFN5/image.png'],
                'pixel_art': ['https://i.postimg.cc/VvF0tGgG/image.png', 'https://i.postimg.cc/wMPyS8bB/image.png']
            };


            let currentFrameSelection = { ai: null, my: null };
            const STICKER_REGEX = /^(https:\/\/i\.postimg\.cc\/.+|https:\/\/files\.catbox\.moe\/.+|data:image)/;
            const MESSAGE_RENDER_WINDOW = 50;
            let currentRenderedCount = 0;
            let lastKnownBatteryLevel = 1;
            let alertFlags = { hasShown40: false, hasShown20: false, hasShown10: false };
            let batteryAlertTimeout;
            const dynamicFontStyle = document.createElement('style');
            dynamicFontStyle.id = 'dynamic-font-style';
            document.head.appendChild(dynamicFontStyle);

            const modalOverlay = document.getElementById('custom-modal-overlay');
            const modalTitle = document.getElementById('custom-modal-title');
            const modalBody = document.getElementById('custom-modal-body');
            const modalConfirmBtn = document.getElementById('custom-modal-confirm');
            const modalCancelBtn = document.getElementById('custom-modal-cancel');
            let modalResolve;

            function showCustomModal() {
                modalOverlay.classList.add('visible');
            }

            function hideCustomModal() {
                modalOverlay.classList.remove('visible');
                modalConfirmBtn.classList.remove('btn-danger');
                if (modalResolve) modalResolve(null);
            }

            function showCustomConfirm(title, message, options = {}) {
                return new Promise(resolve => {
                    modalResolve = resolve;
                    modalTitle.textContent = title;
                    modalBody.innerHTML = `<p>${message}</p>`;
                    modalCancelBtn.style.display = 'block';
                    modalConfirmBtn.textContent = 'ç¡®å®š';
                    if (options.confirmButtonClass) modalConfirmBtn.classList.add(options.confirmButtonClass);
                    modalConfirmBtn.onclick = () => { resolve(true); hideCustomModal(); };
                    modalCancelBtn.onclick = () => { resolve(false); hideCustomModal(); };
                    showCustomModal();
                });
            }

            function showCustomAlert(title, message) {
                return new Promise(resolve => {
                    modalResolve = resolve;
                    modalTitle.textContent = title;
                    modalBody.innerHTML = `<p style="text-align: left; white-space: pre-wrap;">${message}</p>`;
                    modalCancelBtn.style.display = 'none';
                    modalConfirmBtn.textContent = 'å¥½çš„';
                    modalConfirmBtn.onclick = () => {
                        modalCancelBtn.style.display = 'block';
                        modalConfirmBtn.textContent = 'ç¡®å®š';
                        resolve(true);
                        hideCustomModal();
                    };
                    showCustomModal();
                });
            }

            // â–¼â–¼â–¼ è¯·ç”¨è¿™ä¸ªã€åŠŸèƒ½å¢å¼ºç‰ˆã€‘æ›¿æ¢æ—§çš„ showCustomPrompt å‡½æ•° â–¼â–¼â–¼
            function showCustomPrompt(title, placeholder, initialValue = '', type = 'text', extraHtml = '') {
                return new Promise(resolve => {
                    modalResolve = resolve;
                    modalTitle.textContent = title;
                    const inputId = 'custom-prompt-input';

                    const inputHtml = type === 'textarea'
                        ? `<textarea id="${inputId}" placeholder="${placeholder}" rows="5" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box; resize: vertical;">${initialValue}</textarea>`
                        : `<input type="${type}" id="${inputId}" placeholder="${placeholder}" value="${initialValue}">`;

                    // ã€æ ¸å¿ƒä¿®æ”¹ã€‘å°†é¢å¤–çš„HTMLå’Œè¾“å…¥æ¡†ç»„åˆåœ¨ä¸€èµ·
                    modalBody.innerHTML = extraHtml + inputHtml;
                    const input = document.getElementById(inputId);

                    // ã€æ ¸å¿ƒä¿®æ”¹ã€‘ä¸ºæ ¼å¼åŠ©æ‰‹æŒ‰é’®ç»‘å®šäº‹ä»¶
                    modalBody.querySelectorAll('.format-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            const templateStr = btn.dataset.template;
                            if (templateStr) {
                                try {
                                    const templateObj = JSON.parse(templateStr);
                                    // ä½¿ç”¨ null, 2 å‚æ•°è®©JSONå­—ç¬¦ä¸²æ ¼å¼åŒ–ï¼Œå¸¦ç¼©è¿›ï¼Œæ›´æ˜“è¯»
                                    input.value = JSON.stringify(templateObj, null, 2);
                                    input.focus();
                                } catch (e) {
                                    console.error("è§£ææ ¼å¼æ¨¡æ¿å¤±è´¥:", e);
                                }
                            }
                        });
                    });

                    modalConfirmBtn.onclick = () => { resolve(input.value); hideCustomModal(); };
                    modalCancelBtn.onclick = () => { resolve(null); hideCustomModal(); };
                    showCustomModal();
                    setTimeout(() => input.focus(), 100);
                });
            }
            // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

            // ===================================================================
            // 2. æ•°æ®åº“ç»“æ„å®šä¹‰
            // ===================================================================

            db.version(22).stores({
                chats: '&id, isGroup, groupId',
                apiConfig: '&id',
                globalSettings: '&id',
                userStickers: '&id, url, name, order, packId',
                worldBooks: '&id, name',
                musicLibrary: '&id',
                personaPresets: '&id',
                qzoneSettings: '&id',
                qzonePosts: '++id, timestamp, authorId, isPinned', // <-- ä¸ºauthorIdæ·»åŠ ç´¢å¼•ï¼Œæ·»åŠ isPinnedå­—æ®µ
                qzoneAlbums: '++id, name, createdAt',
                qzonePhotos: '++id, albumId',
                favorites: '++id, type, timestamp, originalTimestamp',
                qzoneGroups: '++id, name',
                memories: '++id, chatId, timestamp, type, targetDate',
                bulletins: '++id, chatId, timestamp, isPinned' // <--- ã€æ ¸å¿ƒæ–°å¢ã€‘è¿™å°±æ˜¯å…¬å‘Šçš„æ–°å®¶ï¼
            });

            // ===================================================================
            // 3. æ‰€æœ‰åŠŸèƒ½å‡½æ•°å®šä¹‰
            // ===================================================================

            function showScreen(screenId) {
                if (screenId === 'chat-list-screen') {
                    window.renderChatListProxy();
                    switchToChatListView('messages-view');
                }
                if (screenId === 'api-settings-screen') window.renderApiSettingsProxy();
                if (screenId === 'appearance-settings-screen') {
                    window.renderWallpaperScreenProxy();

                    // Initialize charm visibility toggle after screen is rendered
                    setTimeout(() => {
                        const charmVisibilityToggle = document.getElementById('charm-visibility-toggle');
                        if (charmVisibilityToggle) {
                            // Load saved state
                            const savedVisibility = localStorage.getItem('charmVisibility');
                            const isVisible = savedVisibility !== 'false'; // Default to true
                            charmVisibilityToggle.checked = isVisible;

                            // Apply initial state
                            window.toggleCharmVisibility(isVisible);

                            // Remove any existing event listeners to avoid duplicates
                            charmVisibilityToggle.removeEventListener('change', window.charmToggleHandler);

                            // Add event listener
                            window.charmToggleHandler = (e) => {
                                const isVisible = e.target.checked;
                                localStorage.setItem('charmVisibility', isVisible.toString());
                                window.toggleCharmVisibility(isVisible);
                            };
                            charmVisibilityToggle.addEventListener('change', window.charmToggleHandler);
                        }
                    }, 100);
                }
                if (screenId === 'world-book-screen') window.renderWorldBookScreenProxy();
                if (screenId === 'settings-screen') window.renderSettingsScreenProxy();
                if (screenId === 'general-settings-screen') {
                    window.renderGeneralSettingsScreenProxy();
                    // Initialize photo compression toggle state
                    const toggle = document.getElementById('photo-compression-toggle');
                    if (toggle) {
                        toggle.checked = state.globalSettings.photoCompression !== false; // Default to true
                    }


                }
                if (screenId === 'calendar-screen') window.renderCalendarScreenProxy();
                if (screenId === 'meetup-screen') {
                    initializeMeetupScreen();
                }

                // Track previous screen for meetup navigation
                const currentActiveScreen = document.querySelector('.screen.active');
                if (currentActiveScreen && screenId === 'meetup-screen') {
                    previousScreen = currentActiveScreen.id;
                }

                document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
                const screenToShow = document.getElementById(screenId);
                if (screenToShow) screenToShow.classList.add('active');
                if (screenId === 'chat-interface-screen') {
                    window.updateListenTogetherIconProxy(state.activeChatId);
                    // Only update content if bar is already visible
                    updateNowPlayingBarContent();
                }

                // Update now playing bar visibility when switching screens
                if (musicState.isActive && (screenId === 'home-screen' || screenId === 'chat-interface-screen')) {
                    showNowPlayingBar();
                }



                // Update meetup progress bar visibility when switching screens
                if (hasActiveMeetupSession() && (screenId === 'home-screen' || screenId === 'chat-interface-screen')) {
                    showMeetupProgressBar();
                }
                if (screenId === 'appearance-settings-screen') {
                    const savedFontUrl = state.globalSettings.fontUrl || '';
                    document.getElementById('font-url-input').value = savedFontUrl;

                    // Check if saved font is a data URL (uploaded font) or regular URL
                    if (savedFontUrl.startsWith('data:')) {
                        // It's an uploaded font
                        document.getElementById('font-file-name').textContent = 'å·²ä¸Šä¼ çš„å­—ä½“æ–‡ä»¶';
                        window.uploadedFontData = savedFontUrl;
                    } else {
                        // It's a URL or empty
                        document.getElementById('font-file-name').textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
                        window.uploadedFontData = null;
                    }

                    applyCustomFont(savedFontUrl, true);
                }
            }
            window.updateListenTogetherIconProxy = () => { };



            function switchToChatListView(viewId) {
                const chatListScreen = document.getElementById('chat-list-screen');
                const views = {
                    'messages-view': document.getElementById('messages-view'),
                    'qzone-screen': document.getElementById('qzone-screen'),
                    'favorites-view': document.getElementById('favorites-view'),
                    'memories-view': document.getElementById('memories-view') // <-- æ–°å¢è¿™ä¸€è¡Œ
                };
                const mainHeader = document.getElementById('main-chat-list-header');
                const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // è·å–ä¸»å¯¼èˆªæ 

                if (isFavoritesSelectionMode) {
                    document.getElementById('favorites-edit-btn').click();
                }

                // éšè—æ‰€æœ‰è§†å›¾
                Object.values(views).forEach(v => v.classList.remove('active'));
                // æ˜¾ç¤ºç›®æ ‡è§†å›¾
                if (views[viewId]) {
                    views[viewId].classList.add('active');
                }

                // æ›´æ–°åº•éƒ¨å¯¼èˆªæ é«˜äº®
                document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => {
                    item.classList.toggle('active', item.dataset.view === viewId);
                });

                // â–¼â–¼â–¼ ã€æ ¸å¿ƒä¿®æ­£ã€‘åœ¨è¿™é‡Œç»Ÿä¸€ç®¡ç†æ‰€æœ‰UIå…ƒç´ çš„æ˜¾éš â–¼â–¼â–¼
                if (viewId === 'messages-view') {
                    mainHeader.style.display = 'flex';
                    mainBottomNav.style.display = 'flex';
                } else {
                    mainHeader.style.display = 'none';
                    mainBottomNav.style.display = 'none';
                }
                // â–²â–²â–² ä¿®æ­£ç»“æŸ â–²â–²â–²

                if (viewId !== 'memories-view') {
                    activeCountdownTimers.forEach(timerId => clearInterval(timerId));
                    activeCountdownTimers = [];
                }

                // æ ¹æ®è§†å›¾IDæ‰§è¡Œç‰¹å®šçš„æ¸²æŸ“/æ›´æ–°é€»è¾‘
                switch (viewId) {
                    case 'qzone-screen':
                        views['qzone-screen'].style.backgroundColor = '#f0f2f5';
                        updateUnreadIndicator(0);
                        renderQzoneScreen();
                        renderQzonePosts();
                        break;
                    case 'favorites-view':
                        views['favorites-view'].style.backgroundColor = '#f9f9f9';
                        renderFavoritesScreen();
                        break;
                    case 'messages-view':
                        // å¦‚æœéœ€è¦ï¼Œå¯ä»¥åœ¨è¿™é‡Œæ·»åŠ è¿”å›æ¶ˆæ¯åˆ—è¡¨æ—¶è¦æ‰§è¡Œçš„é€»è¾‘
                        break;
                }
            }

            function renderQzoneScreen() {
                if (state && state.qzoneSettings) {
                    const settings = state.qzoneSettings;
                    document.getElementById('qzone-nickname').textContent = settings.nickname;
                    document.getElementById('qzone-banner-img').src = settings.banner;
                    
                    // Update status text - use saved status or keep current text if no status is saved
                    const statusElement = document.getElementById('qzone-status');
                    if (statusElement && settings.status) {
                        statusElement.textContent = settings.status;
                    }

                    // Handle avatar with border - keep original structure, just add/remove frame overlay
                    const avatarContainer = document.getElementById('qzone-avatar-container');
                    const avatarImg = document.getElementById('qzone-avatar-img');

                    // Always ensure the basic avatar exists
                    if (!avatarImg) {
                        avatarContainer.innerHTML = `
                            <img id="qzone-avatar-img" src="${settings.avatar}" alt="å¤´åƒ" class="avatar">
                            <input type="file" id="qzone-avatar-input" accept="image/*" hidden>
                        `;
                    } else {
                        // Update avatar source
                        avatarImg.src = settings.avatar;
                    }

                    // Remove any existing frame
                    const existingFrame = avatarContainer.querySelector('.qzone-avatar-frame');
                    if (existingFrame) {
                        existingFrame.remove();
                    }

                    // Handle borders enabled state
                    if (settings.avatarBordersEnabled) {
                        // Add borders-enabled class to decrease avatar size
                        avatarContainer.classList.add('borders-enabled');

                        // Add frame if exists
                        if (settings.avatarFrame) {
                            const frameImg = document.createElement('img');
                            frameImg.src = settings.avatarFrame;
                            frameImg.className = 'qzone-avatar-frame';
                            avatarContainer.appendChild(frameImg);
                        }
                    } else {
                        // Remove borders-enabled class to restore original size
                        avatarContainer.classList.remove('borders-enabled');
                    }
                }
            }
            window.renderQzoneScreenProxy = renderQzoneScreen;



            async function saveQzoneSettings() {
                if (db && state.qzoneSettings) {
                    await db.qzoneSettings.put(state.qzoneSettings);
                }
            }

            function formatPostTimestamp(timestamp) {
                if (!timestamp) return '';
                const now = new Date();
                const date = new Date(timestamp);
                const diffSeconds = Math.floor((now - date) / 1000);
                const diffMinutes = Math.floor(diffSeconds / 60);
                const diffHours = Math.floor(diffMinutes / 60);
                if (diffMinutes < 1) return 'åˆšåˆš';
                if (diffMinutes < 60) return `${diffMinutes}åˆ†é’Ÿå‰`;
                if (diffHours < 24) return `${diffHours}å°æ—¶å‰`;
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                if (now.getFullYear() === year) {
                    return `${month}-${day} ${hours}:${minutes}`;
                } else {
                    return `${year}-${month}-${day} ${hours}:${minutes}`;
                }
            }

            function formatTimeDifference(ms) {
                if (ms < 60000) return null; // å°äº1åˆ†é’Ÿä¸å¤„ç†
                const minutes = Math.floor(ms / 60000);
                if (minutes < 60) {
                    return `çº¦ ${minutes} åˆ†é’Ÿ`;
                }
                const hours = Math.floor(minutes / 60);
                const remainingMinutes = minutes % 60;
                if (remainingMinutes === 0) {
                    return `${hours} å°æ—¶`;
                }
                return `${hours} å°æ—¶ ${remainingMinutes} åˆ†é’Ÿ`;
            }

            async function renderQzonePosts() {
                const postsListEl = document.getElementById('qzone-posts-list');
                if (!postsListEl) return;

                const [allPosts, favorites] = await Promise.all([
                    db.qzonePosts.orderBy('timestamp').reverse().toArray(),
                    db.favorites.where('type').equals('qzone_post').toArray() // è·å–æ‰€æœ‰å·²æ”¶è—çš„åŠ¨æ€
                ]);

                // æŒ‰ç½®é¡¶çŠ¶æ€å’Œæ—¶é—´æ’åºï¼šç½®é¡¶çš„åœ¨å‰ï¼Œç„¶åæŒ‰æ—¶é—´å€’åº
                const posts = allPosts.sort((a, b) => {
                    // é¦–å…ˆæŒ‰ç½®é¡¶çŠ¶æ€æ’åºï¼ˆç½®é¡¶çš„åœ¨å‰ï¼‰
                    if (a.isPinned && !b.isPinned) return -1;
                    if (!a.isPinned && b.isPinned) return 1;

                    // ç„¶åæŒ‰æ—¶é—´å€’åºæ’åº
                    return b.timestamp - a.timestamp;
                });

                // åˆ›å»ºä¸€ä¸ªå·²æ”¶è—å¸–å­IDçš„é›†åˆï¼Œæ–¹ä¾¿å¿«é€ŸæŸ¥æ‰¾
                const favoritedPostIds = new Set(favorites.map(fav => fav.content.id));

                postsListEl.innerHTML = '';

                if (posts.length === 0) {
                    postsListEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">è¿™é‡Œç©ºç©ºå¦‚ä¹Ÿï¼Œå¿«æ¥å‘å¸ƒç¬¬ä¸€æ¡è¯´è¯´å§ï¼</p>';
                    return;
                }

                const userSettings = state.qzoneSettings;

                posts.forEach(post => {
                    const postContainer = document.createElement('div');
                    postContainer.className = 'qzone-post-container';
                    postContainer.dataset.postId = post.id;

                    const postEl = document.createElement('div');
                    postEl.className = 'qzone-post-item';

                    let authorAvatar = '', authorNickname = '', commentAvatar = userSettings.avatar;

                    if (post.authorId === 'user') {
                        authorAvatar = userSettings.avatar;
                        authorNickname = userSettings.nickname;
                    } else if (state.chats[post.authorId]) {
                        const authorChat = state.chats[post.authorId];
                        authorAvatar = authorChat.settings.aiAvatar || defaultAvatar;
                        authorNickname = authorChat.name;
                    } else {
                        authorAvatar = defaultAvatar;
                        authorNickname = '{{char}}';
                    }

                    let contentHtml = '';
                    const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';

                    if (post.type === 'shuoshuo') {
                        contentHtml = `<div class="post-content" style="margin-bottom: 10px;">${post.content.replace(/\n/g, '<br>')}</div>`;
                    }
                    else if (post.type === 'image_post' && post.imageUrl) {
                        contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>` : `<img src="${post.imageUrl}" class="chat-image">`;
                    }
                    else if (post.type === 'text_image') {
                        // For text_image posts, show public text and decorative image if available
                        if (post.decorativeImageUrl) {
                            contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.decorativeImageUrl}" class="chat-image"></div>` : `<img src="${post.decorativeImageUrl}" class="chat-image">`;
                        } else {
                            contentHtml = publicTextHtml || '';
                        }
                    }

                    let likesHtml = '';
                    if (post.likes && post.likes.length > 0) {
                        likesHtml = `<div class="post-likes-section"><svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg><span>${post.likes.join('ã€')} è§‰å¾—å¾ˆèµ</span></div>`;
                    }

                    let commentsHtml = '';
                    if (post.comments && post.comments.length > 0) {
                        commentsHtml = '<div class="post-comments-container">';
                        post.comments.forEach(comment => {
                            // ã€æ ¸å¿ƒä¿®æ­£ã€‘åœ¨è¿™é‡Œè¿›è¡Œé˜²å¾¡æ€§æ£€æŸ¥
                            const commenterName = comment.commenterName || 'åŒ¿å'; // å¦‚æœåå­—æ˜¯undefinedï¼Œåˆ™æ˜¾ç¤ºåŒ¿å
                            const commentText = comment.text || ''; // å¦‚æœå†…å®¹æ˜¯undefinedï¼Œåˆ™æ˜¾ç¤ºä¸ºç©º
                            commentsHtml += `<div class="comment-item" data-comment-timestamp="${comment.timestamp || ''}" data-commenter="${commenterName}"><span class="commenter-name">${commenterName}:</span><span class="comment-text">${commentText}</span></div>`;
                        });
                        commentsHtml += '</div>';
                    }

                    // æ£€æŸ¥ç‚¹èµå’Œæ”¶è—çŠ¶æ€
                    const userNickname = state.qzoneSettings.nickname;
                    const isLikedByUser = post.likes && post.likes.includes(userNickname);
                    const isFavoritedByUser = favoritedPostIds.has(post.id); // ä½¿ç”¨Setå¿«é€ŸæŸ¥æ‰¾

                    // Create avatar HTML with overlay frame support (no layout changes)
                    let avatarHtml;
                    let avatarFrameSrc = '';

                    // Determine avatar frame (only if borders are enabled)
                    if (state.qzoneSettings.avatarBordersEnabled) {
                        if (post.authorId === 'user') {
                            avatarFrameSrc = state.qzoneSettings.avatarFrame || '';
                        } else if (state.chats[post.authorId]) {
                            avatarFrameSrc = state.chats[post.authorId].settings.aiAvatarFrame || '';
                        }
                    }

                    if (avatarFrameSrc) {
                        // Use overlay approach - no layout changes
                        avatarHtml = `
                            <div class="avatar-container">
                                <img src="${authorAvatar}" class="avatar">
                                <img src="${avatarFrameSrc}" class="avatar-frame">
                            </div>
                        `;
                    } else {
                        // Regular avatar without frame
                        avatarHtml = `<img src="${authorAvatar}" class="post-avatar">`;
                    }

                    postEl.innerHTML = `
                    <div class="post-header">
                        ${avatarHtml}
                        <div class="post-info">
                            <span class="post-nickname">${authorNickname}</span>
                            <span class="post-timestamp">${formatPostTimestamp(post.timestamp)}</span>
                        </div>
                        <div style="margin-left: auto; display: flex; align-items: center; gap: 8px;">
                            ${post.type === 'text_image' ? `<span data-hidden-text="${post.hiddenContent || ''}" style="cursor: pointer;">ğŸ’­</span>` : ''}
                            <div class="post-actions-btn" data-hidden-text="${post.hiddenContent || ''}" style="margin-left: 0;">â€¦</div>
                        </div>
                    </div>

                    <div class="post-main-content">${contentHtml}</div>
                    <div class="post-feedback-icons">
                        <span class="action-icon like ${isLikedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></span>
                        <span class="action-icon favorite ${isFavoritedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg></span>
                    </div>
                    ${likesHtml}
                    ${commentsHtml}
                    <div class="post-footer"><div class="comment-section"><img src="${commentAvatar}" class="comment-avatar"><input type="text" class="comment-input" placeholder="å‹å–„çš„è¯„è®ºæ˜¯äº¤æµçš„èµ·ç‚¹"><div class="at-mention-popup"></div></div><button class="comment-send-btn">å‘é€</button><button class="call-ai-reply-btn" title="è®©AIä»¬å›å¤">ğŸ¤–</button></div>
                `;

                    // COMMENTED OUT: Delete action for swipe functionality
                    /*
                    const deleteAction = document.createElement('div');
                    deleteAction.className = 'qzone-post-delete-action';
                    deleteAction.innerHTML = '<span>åˆ é™¤</span>';
                    postContainer.appendChild(deleteAction);
                    */
                    postContainer.appendChild(postEl);
                    const commentSection = postContainer.querySelector('.comment-section');
                    if (commentSection) {
                        commentSection.addEventListener('touchstart', (e) => e.stopPropagation());
                        commentSection.addEventListener('mousedown', (e) => e.stopPropagation());
                    }
                    postsListEl.appendChild(postContainer);

                    // ä¸ºæ‰€æœ‰è¯„è®ºæ·»åŠ é•¿æŒ‰ç›‘å¬å™¨
                    const commentItems = postContainer.querySelectorAll('.comment-item');
                    commentItems.forEach(commentItem => {
                        const commenterName = commentItem.dataset.commenter;
                        const commentTimestamp = parseInt(commentItem.dataset.commentTimestamp);
                        const commentText = commentItem.querySelector('.comment-text')?.textContent || '';
                        const postId = parseInt(postContainer.dataset.postId);

                        addLongPressListener(commentItem, async () => {
                            showCommentActions(postId, commentTimestamp, commentText, commenterName);
                        })
                    });

                    const commentInput = postContainer.querySelector('.comment-input');
                    const popup = postContainer.querySelector('.at-mention-popup');
                    commentInput.addEventListener('input', () => {
                        const value = commentInput.value;
                        const atMatch = value.match(/@([\p{L}\w]*)$/u);
                        if (atMatch) {
                            const namesToMention = new Set();
                            const authorNickname = postContainer.querySelector('.post-nickname')?.textContent;
                            if (authorNickname) namesToMention.add(authorNickname);
                            postContainer.querySelectorAll('.commenter-name').forEach(nameEl => {
                                namesToMention.add(nameEl.textContent.replace(':', ''));
                            });
                            namesToMention.delete(state.qzoneSettings.nickname);
                            popup.innerHTML = '';
                            if (namesToMention.size > 0) {
                                const searchTerm = atMatch[1];
                                namesToMention.forEach(name => {
                                    if (name.toLowerCase().includes(searchTerm.toLowerCase())) {
                                        const item = document.createElement('div');
                                        item.className = 'at-mention-item';
                                        item.textContent = name;
                                        item.addEventListener('mousedown', (e) => {
                                            e.preventDefault();
                                            const newText = value.substring(0, atMatch.index) + `@${name} `;
                                            commentInput.value = newText;
                                            popup.style.display = 'none';
                                            commentInput.focus();
                                        });
                                        popup.appendChild(item);
                                    }
                                });
                                popup.style.display = popup.children.length > 0 ? 'block' : 'none';
                            } else {
                                popup.style.display = 'none';
                            }
                        } else {
                            popup.style.display = 'none';
                        }
                    });
                    commentInput.addEventListener('blur', () => { setTimeout(() => { popup.style.display = 'none'; }, 200); });
                });
            }

            // â–¼â–¼â–¼ è¯·ç”¨ä¸‹é¢è¿™ä¸ªã€æ›´æ–°åçš„ã€‘å‡½æ•°ï¼Œå®Œæ•´æ›¿æ¢æ‰ä½ ä»£ç ä¸­æ—§çš„ displayFilteredFavorites å‡½æ•° â–¼â–¼â–¼

            function displayFilteredFavorites(items) {
                const listEl = document.getElementById('favorites-list');
                listEl.innerHTML = '';

                if (items.length === 0) {
                    const searchTerm = document.getElementById('favorites-search-input').value;
                    const message = searchTerm ? 'æœªæ‰¾åˆ°ç›¸å…³æ”¶è—' : 'ä½ çš„æ”¶è—å¤¹æ˜¯ç©ºçš„ï¼Œ<br>å¿«å»åŠ¨æ€æˆ–èŠå¤©ä¸­æ”¶è—å–œæ¬¢çš„å†…å®¹å§ï¼';
                    listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${message}</p>`;
                    return;
                }

                for (const item of items) {
                    const card = document.createElement('div');
                    card.className = 'favorite-item-card';
                    card.dataset.favid = item.id;

                    let headerHtml = '', contentHtml = '', sourceText = '', footerHtml = '';

                    if (item.type === 'qzone_post') {
                        const post = item.content;
                        sourceText = 'æ¥è‡ªåŠ¨æ€';
                        let authorAvatar = defaultAvatar, authorNickname = 'æœªçŸ¥ç”¨æˆ·';

                        if (post.authorId === 'user') {
                            authorAvatar = state.qzoneSettings.avatar;
                            authorNickname = state.qzoneSettings.nickname;
                        } else if (state.chats[post.authorId]) {
                            authorAvatar = state.chats[post.authorId].settings.aiAvatar;
                            authorNickname = state.chats[post.authorId].name;
                        }

                        headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${authorNickname}</div></div>${post.type === 'text_image' ? `<span data-hidden-text="${post.hiddenContent || ''}" style="cursor: pointer;">ğŸ’­</span>` : ''}`;

                        const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';
                        if (post.type === 'shuoshuo') {
                            contentHtml = `<div class="post-content">${post.content.replace(/\n/g, '<br>')}</div>`;
                        } else if (post.type === 'image_post' && post.imageUrl) {
                            contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>` : `<img src="${post.imageUrl}" class="chat-image">`;
                        } else if (post.type === 'text_image') {
                            // For text_image posts, show public text and decorative image if available
                            if (post.decorativeImageUrl) {
                                contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.decorativeImageUrl}" class="chat-image"></div>` : `<img src="${post.decorativeImageUrl}" class="chat-image">`;
                            } else {
                                contentHtml = publicTextHtml || '';
                            }
                        }

                        // â–¼â–¼â–¼ æ–°å¢/ä¿®æ”¹çš„ä»£ç å¼€å§‹ â–¼â–¼â–¼

                        // 1. æ„é€ ç‚¹èµåŒºåŸŸçš„HTML
                        let likesHtml = '';
                        // æ£€æŸ¥ post å¯¹è±¡ä¸­æ˜¯å¦å­˜åœ¨ likes æ•°ç»„å¹¶ä¸”ä¸ä¸ºç©º
                        if (post.likes && post.likes.length > 0) {
                            // å¦‚æœå­˜åœ¨ï¼Œå°±åˆ›å»ºç‚¹èµåŒºåŸŸçš„ div
                            likesHtml = `
                    <div class="post-likes-section">
                        <svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                        <span>${post.likes.join('ã€')} è§‰å¾—å¾ˆèµ</span>
                    </div>`;
                        }

                        // 2. æ„é€ è¯„è®ºåŒºåŸŸçš„HTML
                        let commentsHtml = '';
                        // æ£€æŸ¥ post å¯¹è±¡ä¸­æ˜¯å¦å­˜åœ¨ comments æ•°ç»„å¹¶ä¸”ä¸ä¸ºç©º
                        if (post.comments && post.comments.length > 0) {
                            // å¦‚æœå­˜åœ¨ï¼Œå°±åˆ›å»ºè¯„è®ºå®¹å™¨ï¼Œå¹¶éå†æ¯ä¸€æ¡è¯„è®º
                            commentsHtml = '<div class="post-comments-container">';
                            post.comments.forEach(comment => {
                                commentsHtml += `
                        <div class="comment-item">
                            <span class="commenter-name">${comment.commenterName}:</span>
                            <span class="comment-text">${comment.text}</span>
                        </div>`;
                            });
                            commentsHtml += '</div>';
                        }

                        // 3. å°†ç‚¹èµå’Œè¯„è®ºçš„HTMLç»„åˆåˆ° footerHtml ä¸­
                        footerHtml = `${likesHtml}${commentsHtml}`;

                        // â–²â–²â–² æ–°å¢/ä¿®æ”¹çš„ä»£ç ç»“æŸ â–²â–²â–²

                    } else if (item.type === 'chat_message') {
                        const msg = item.content;
                        const chat = state.chats[item.chatId];
                        if (!chat) continue;

                        sourceText = `æ¥è‡ªä¸ ${chat.name} çš„èŠå¤©`;
                        const isUser = msg.role === 'user';
                        let senderName, senderAvatar;

                        if (isUser) {
                            senderName = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';
                            senderAvatar = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
                        } else {
                            if (chat.isGroup) {
                                const member = chat.members.find(m => m.name === msg.senderName);
                                senderName = msg.senderName;
                                senderAvatar = member ? member.avatar : defaultGroupMemberAvatar;
                            } else {
                                senderName = chat.name;
                                senderAvatar = chat.settings.aiAvatar || defaultAvatar;
                            }
                        }

                        headerHtml = `<img src="${senderAvatar}" class="avatar"><div class="info"><div class="name">${senderName}</div></div>`;

                        if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
                            contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-width: 80px; max-height: 80px;">`;
                        } else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                            contentHtml = `<img src="${msg.content[0].image_url.url}" class="chat-image">`;
                        } else {
                            contentHtml = String(msg.content || '').replace(/\n/g, '<br>');
                        }
                    }

                    // â–¼â–¼â–¼ ä¿®æ”¹æœ€ç»ˆçš„HTMLæ‹¼æ¥ï¼ŒåŠ å…¥ footerHtml â–¼â–¼â–¼
                    card.innerHTML = `
            <div class="fav-card-header">${headerHtml}<div class="source">${sourceText}</div></div>
            <div class="fav-card-content">${contentHtml}</div>
            ${footerHtml}`; // <-- æŠŠæˆ‘ä»¬æ–°åˆ›å»ºçš„ footerHtml æ”¾åœ¨è¿™é‡Œ

                    listEl.appendChild(card);
                }
            }

            // â–²â–²â–² æ›¿æ¢åŒºåŸŸç»“æŸ â–²â–²â–²

            /**
             * ã€é‡æ„åçš„å‡½æ•°ã€‘: è´Ÿè´£å‡†å¤‡æ•°æ®å¹¶è§¦å‘æ¸²æŸ“
             */
            async function renderFavoritesScreen() {
                // 1. ä»æ•°æ®åº“è·å–æœ€æ–°æ•°æ®å¹¶ç¼“å­˜
                allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray();

                // 2. æ¸…ç©ºæœç´¢æ¡†å¹¶éšè—æ¸…é™¤æŒ‰é’®
                const searchInput = document.getElementById('favorites-search-input');
                const clearBtn = document.getElementById('favorites-search-clear-btn');
                searchInput.value = '';
                clearBtn.style.display = 'none';

                // 3. æ˜¾ç¤ºæ‰€æœ‰æ”¶è—é¡¹
                displayFilteredFavorites(allFavoriteItems);
            }

            // â–²â–²â–² ç²˜è´´ç»“æŸ â–²â–²â–²

            function resetCreatePostModal() {
                document.getElementById('post-public-text').value = '';
                document.getElementById('post-image-preview').src = '';
                document.getElementById('post-image-description').value = '';
                document.getElementById('post-image-preview-container').classList.remove('visible');
                document.getElementById('post-image-desc-group').style.display = 'none';
                document.getElementById('post-local-image-input').value = '';
                document.getElementById('post-hidden-text').value = '';
                document.getElementById('text-image-decorative-url').value = '';
                document.getElementById('switch-to-image-mode').click();
            }

            // â–¼â–¼â–¼ ç”¨è¿™ä¸ªã€å·²åŒ…å« memoriesã€‘çš„ç‰ˆæœ¬ï¼Œå®Œæ•´æ›¿æ¢æ—§çš„ exportBackup å‡½æ•° â–¼â–¼â–¼
            async function exportBackup() {
                try {
                    const backupData = {
                        version: 1,
                        timestamp: Date.now()
                    };

                    const [
                        chats, worldBooks, userStickers, apiConfig, globalSettings,
                        personaPresets, musicLibrary, qzoneSettings, qzonePosts,
                        qzoneAlbums, qzonePhotos, favorites, qzoneGroups,
                        memories // ã€æ ¸å¿ƒä¿®æ­£ã€‘æ–°å¢
                    ] = await Promise.all([
                        db.chats.toArray(),
                        db.worldBooks.toArray(),
                        db.userStickers.toArray(),
                        db.apiConfig.get('main'),
                        db.globalSettings.get('main'),
                        db.personaPresets.toArray(),
                        db.musicLibrary.get('main'),
                        db.qzoneSettings.get('main'),
                        db.qzonePosts.toArray(),
                        db.qzoneAlbums.toArray(),
                        db.qzonePhotos.toArray(),
                        db.favorites.toArray(),
                        db.qzoneGroups.toArray(),
                        db.memories.toArray() // ã€æ ¸å¿ƒä¿®æ­£ã€‘æ–°å¢
                    ]);

                    // Collect app icons from localStorage
                    const appIcons = {};
                    const appIds = ['qq', 'moments', 'calendar', 'settings'];
                    appIds.forEach(appId => {
                        const iconUrl = localStorage.getItem(`appIcon_${appId}`);
                        if (iconUrl) {
                            appIcons[appId] = iconUrl;
                        }
                    });

                    Object.assign(backupData, {
                        chats, worldBooks, userStickers, apiConfig, globalSettings,
                        personaPresets, musicLibrary, qzoneSettings, qzonePosts,
                        qzoneAlbums, qzonePhotos, favorites, qzoneGroups,
                        memories, // ã€æ ¸å¿ƒä¿®æ­£ã€‘æ–°å¢
                        appIcons, // Add app icons to backup
                        activeMeetupSession: window.activeMeetupSession || null,
                        activeMeetupEventId: window.activeMeetupEventId || null
                    });

                    const blob = new Blob(
                        [JSON.stringify(backupData, null, 2)],
                        { type: 'application/json' }
                    );
                    const url = URL.createObjectURL(blob);
                    const link = Object.assign(document.createElement('a'), {
                        href: url,
                        download: `EPhone-Full-Backup-${new Date().toISOString().split('T')[0]}.json`
                    });
                    link.click();
                    URL.revokeObjectURL(url);

                    await showCustomAlert('å¯¼å‡ºæˆåŠŸ', 'å·²æˆåŠŸå¯¼å‡ºæ‰€æœ‰æ•°æ®ï¼');

                } catch (error) {
                    console.error("å¯¼å‡ºæ•°æ®æ—¶å‡ºé”™:", error);
                    await showCustomAlert('å¯¼å‡ºå¤±è´¥', `å‘ç”Ÿäº†ä¸€ä¸ªé”™è¯¯: ${error.message}`);
                }
            }

            // â–¼â–¼â–¼ ç”¨è¿™ä¸ªã€å·²åŒ…å« memoriesã€‘çš„ç‰ˆæœ¬ï¼Œå®Œæ•´æ›¿æ¢æ—§çš„ importBackup å‡½æ•° â–¼â–¼â–¼
            async function importBackup(file) {
                if (!file) return;

                const confirmed = await showCustomConfirm(
                    'ä¸¥é‡è­¦å‘Šï¼',
                    'å¯¼å…¥å¤‡ä»½å°†å®Œå…¨è¦†ç›–æ‚¨å½“å‰çš„æ‰€æœ‰æ•°æ®ï¼ŒåŒ…æ‹¬èŠå¤©ã€åŠ¨æ€ã€è®¾ç½®ç­‰ã€‚æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼æ‚¨ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ',
                    { confirmButtonClass: 'btn-danger' }
                );

                if (!confirmed) return;

                try {
                    const text = await file.text();
                    const data = JSON.parse(text);

                    await db.transaction('rw', db.tables, async () => {
                        for (const table of db.tables) {
                            await table.clear();
                        }

                        if (Array.isArray(data.chats)) await db.chats.bulkPut(data.chats);
                        if (Array.isArray(data.worldBooks)) await db.worldBooks.bulkPut(data.worldBooks);
                        if (Array.isArray(data.userStickers)) await db.userStickers.bulkPut(data.userStickers);
                        if (Array.isArray(data.personaPresets)) await db.personaPresets.bulkPut(data.personaPresets);
                        if (Array.isArray(data.qzonePosts)) await db.qzonePosts.bulkPut(data.qzonePosts);
                        if (Array.isArray(data.qzoneAlbums)) await db.qzoneAlbums.bulkPut(data.qzoneAlbums);
                        if (Array.isArray(data.qzonePhotos)) await db.qzonePhotos.bulkPut(data.qzonePhotos);
                        if (Array.isArray(data.favorites)) await db.favorites.bulkPut(data.favorites);
                        if (Array.isArray(data.qzoneGroups)) await db.qzoneGroups.bulkPut(data.qzoneGroups);
                        if (Array.isArray(data.memories)) await db.memories.bulkPut(data.memories); // ã€æ ¸å¿ƒä¿®æ­£ã€‘æ–°å¢

                        if (data.apiConfig) await db.apiConfig.put(data.apiConfig);
                        if (data.globalSettings) await db.globalSettings.put(data.globalSettings);
                        if (data.musicLibrary) await db.musicLibrary.put(data.musicLibrary);
                        if (data.qzoneSettings) await db.qzoneSettings.put(data.qzoneSettings);
                    });

                    // Restore app icons to localStorage
                    if (data.appIcons) {
                        Object.keys(data.appIcons).forEach(appId => {
                            localStorage.setItem(`appIcon_${appId}`, data.appIcons[appId]);
                        });
                    }

                    // Restore active meetup session if it exists in backup
                    if (data.activeMeetupSession && data.activeMeetupEventId) {
                        localStorage.setItem('activeMeetupSession', JSON.stringify(data.activeMeetupSession));
                        localStorage.setItem('activeMeetupEventId', data.activeMeetupEventId);
                    } else {
                        // Clear any existing meetup session data if backup doesn't have one
                        localStorage.removeItem('activeMeetupSession');
                        localStorage.removeItem('activeMeetupEventId');
                    }

                    await showCustomAlert('å¯¼å…¥æˆåŠŸ', 'æ‰€æœ‰æ•°æ®å·²æˆåŠŸæ¢å¤ï¼åº”ç”¨å³å°†åˆ·æ–°ä»¥åº”ç”¨æ‰€æœ‰æ›´æ”¹ã€‚');

                    setTimeout(() => {
                        window.location.reload();
                    }, 1500);

                } catch (error) {
                    console.error("å¯¼å…¥æ•°æ®æ—¶å‡ºé”™:", error);
                    await showCustomAlert('å¯¼å…¥å¤±è´¥', `æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®æˆ–æ•°æ®å·²æŸå: ${error.message}`);
                }
            }

            function applyCustomFont(fontUrl, isPreviewOnly = false) {
                if (!fontUrl) {
                    dynamicFontStyle.innerHTML = '';
                    if (document.getElementById('font-preview')) {
                        document.getElementById('font-preview').style.fontFamily = '';
                    }
                    return;
                }



                // If it's a file:// URL, try to load it via Cordova file system
                if (fontUrl.startsWith('file://')) {
                    loadFontFromFile(fontUrl, isPreviewOnly);
                    return;
                }

                // For blob URLs and regular URLs, use direct CSS
                const fontName = 'custom-user-font';
                const newStyle = `
                @font-face {
                  font-family: '${fontName}';
                  src: url('${fontUrl}');
                  font-display: swap;
                }`;
                if (isPreviewOnly) {
                    const previewStyle = document.getElementById('preview-font-style') || document.createElement('style');
                    previewStyle.id = 'preview-font-style';
                    previewStyle.innerHTML = newStyle;
                    if (!document.getElementById('preview-font-style')) document.head.appendChild(previewStyle);
                    if (document.getElementById('font-preview')) {
                        document.getElementById('font-preview').style.fontFamily = `'${fontName}', 'bulangni', sans-serif`;
                    }
                } else {
                    dynamicFontStyle.innerHTML = `
                    ${newStyle}
                    body {
                      font-family: '${fontName}', 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                    }`;
                }
            }

            function loadFontFromFile(fileUrl, isPreviewOnly = false) {
                // Convert file:// URL to a blob URL for WebView compatibility
                window.resolveLocalFileSystemURL(fileUrl, function (fileEntry) {
                    fileEntry.file(function (file) {
                        // Read the file as ArrayBuffer and create a proper Blob
                        const reader = new FileReader();
                        reader.onload = function (e) {
                            const arrayBuffer = e.target.result;
                            const blob = new Blob([arrayBuffer], { type: file.type || 'font/ttf' });
                            const blobUrl = URL.createObjectURL(blob);

                            const fontName = 'custom-user-font';
                            const newStyle = `
                            @font-face {
                              font-family: '${fontName}';
                              src: url('${blobUrl}');
                              font-display: swap;
                            }`;

                            if (isPreviewOnly) {
                                const previewStyle = document.getElementById('preview-font-style') || document.createElement('style');
                                previewStyle.id = 'preview-font-style';
                                previewStyle.innerHTML = newStyle;
                                if (!document.getElementById('preview-font-style')) document.head.appendChild(previewStyle);
                                if (document.getElementById('font-preview')) {
                                    document.getElementById('font-preview').style.fontFamily = `'${fontName}', 'bulangni', sans-serif`;
                                }
                            } else {
                                dynamicFontStyle.innerHTML = `
                                ${newStyle}
                                body {
                                  font-family: '${fontName}', 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                                }`;
                            }
                        };

                        reader.readAsArrayBuffer(file);
                    }, function (error) {
                        console.error('Error reading font file:', error);
                    });
                }, function (error) {
                    console.error('Error accessing font file:', error);
                });
            }

            async function handleFontUpload(file) {
                if (!file) return;

                // Basic file validation
                const fileName = file.name.toLowerCase();
                const validExtensions = ['.ttf', '.otf', '.woff', '.woff2'];
                const hasValidExtension = validExtensions.some(ext => fileName.endsWith(ext));

                if (!hasValidExtension) {
                    const proceed = confirm(`æ–‡ä»¶ "${file.name}" å¯èƒ½ä¸æ˜¯å­—ä½“æ–‡ä»¶ã€‚æ˜¯å¦ç»§ç»­ï¼Ÿ`);
                    if (!proceed) {
                        document.getElementById('font-file-name').textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
                        return;
                    }
                }

                try {
                    document.getElementById('font-file-name').textContent = `æ­£åœ¨ä¿å­˜: ${file.name}`;

                    // Generate unique filename
                    const timestamp = Date.now();
                    const extension = file.name.split('.').pop();
                    const uniqueFileName = `custom-font-${timestamp}.${extension}`;

                    // Save font file to device storage
                    window.resolveLocalFileSystemURL(cordova.file.dataDirectory, function (dirEntry) {
                        // Create fonts directory if it doesn't exist
                        dirEntry.getDirectory('fonts', { create: true }, function (fontDirEntry) {
                            // Create the font file
                            fontDirEntry.getFile(uniqueFileName, { create: true }, function (fileEntry) {
                                // Write the font data to file
                                fileEntry.createWriter(function (fileWriter) {
                                    fileWriter.onwriteend = function () {

                                        const fontPath = fileEntry.nativeURL;

                                        // Clear URL input
                                        document.getElementById('font-url-input').value = '';

                                        // For preview, use blob URL (more compatible)
                                        const blobUrl = URL.createObjectURL(file);
                                        applyCustomFont(blobUrl, true);

                                        // Store file path for saving (not blob URL)
                                        window.uploadedFontData = fontPath;
                                        window.uploadedFontName = file.name;

                                        document.getElementById('font-file-name').textContent = file.name;
                                    };

                                    fileWriter.onerror = function (e) {
                                        console.error('Error writing font file:', e);
                                        alert('ä¿å­˜å­—ä½“æ–‡ä»¶å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚');
                                        document.getElementById('font-file-name').textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
                                    };

                                    // Write the file
                                    fileWriter.write(file);
                                });
                            }, function (error) {
                                console.error('Error creating font file:', error);
                                alert('åˆ›å»ºå­—ä½“æ–‡ä»¶å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚');
                                document.getElementById('font-file-name').textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
                            });
                        }, function (error) {
                            console.error('Error creating fonts directory:', error);
                            alert('åˆ›å»ºå­—ä½“ç›®å½•å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚');
                            document.getElementById('font-file-name').textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
                        });
                    }, function (error) {
                        console.error('Error accessing data directory:', error);
                        alert('è®¿é—®å­˜å‚¨ç›®å½•å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚');
                        document.getElementById('font-file-name').textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
                    });

                } catch (error) {
                    console.error('Font upload error:', error);
                    alert('å­—ä½“æ–‡ä»¶ä¸Šä¼ å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚');
                    document.getElementById('font-file-name').textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
                }
            }

            async function saveFontSettings() {
                let fontSource = '';

                // Check if we have an uploaded font
                if (window.uploadedFontData) {
                    fontSource = window.uploadedFontData;
                } else {
                    // Use URL input
                    fontSource = document.getElementById('font-url-input').value.trim();
                }

                if (!fontSource) {
                    alert("è¯·è¾“å…¥å­—ä½“URLæˆ–ä¸Šä¼ å­—ä½“æ–‡ä»¶ã€‚");
                    return;
                }

                // Apply the font (this will handle file:// URLs properly)
                applyCustomFont(fontSource, false);

                // Save to database
                state.globalSettings.fontUrl = fontSource;
                await db.globalSettings.put(state.globalSettings);

                alert('å­—ä½“å·²ä¿å­˜å¹¶åº”ç”¨ï¼');
            }

            async function resetToDefaultFont() {
                dynamicFontStyle.innerHTML = '';
                state.globalSettings.fontUrl = '';
                await db.globalSettings.put(state.globalSettings);
                document.getElementById('font-url-input').value = '';
                document.getElementById('font-file-name').textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
                document.getElementById('font-preview').style.fontFamily = '';

                // Clear uploaded font data
                window.uploadedFontData = null;
                window.uploadedFontName = null;

                alert('å·²æ¢å¤é»˜è®¤å­—ä½“ã€‚');
            }

            async function loadAllDataFromDB() {
                const [
                    chatsArr, apiConfig, globalSettings, userStickers, worldBooks,
                    musicLib, personaPresets, qzoneSettings, initialFavorites
                ] = await Promise.all([
                    db.chats.toArray(),
                    db.apiConfig.get('main'),
                    db.globalSettings.get('main'),
                    db.userStickers.toArray(),
                    db.worldBooks.toArray(),
                    db.musicLibrary.get('main'),
                    db.personaPresets.toArray(),
                    db.qzoneSettings.get('main'),
                    db.favorites.orderBy('timestamp').reverse().toArray()
                ]);
                state.chats = chatsArr.reduce((acc, chat) => {
                    // --- â–¼â–¼â–¼ ã€æ ¸å¿ƒæ–°å¢ã€‘çŠ¶æ€ç³»ç»Ÿå…¼å®¹ä¸åˆå§‹åŒ– â–¼â–¼â–¼ ---
                    if (!chat.statusState) {
                        const lastAiMsg = chat.history.slice().reverse().find(m => m.role === 'assistant');
                        chat.statusState = {
                            lastAiActivityTime: lastAiMsg ? lastAiMsg.timestamp : Date.now(),
                            focusModeEndTime: null,
                            focusModeText: ""
                        };
                        console.log(`ä¸ºæ—§è§’è‰² "${chat.name}" è¡¥å…¨äº†statusStateå±æ€§ã€‚`);
                    }
                    // --- â–²â–²â–² æ–°å¢ç»“æŸ â–²â–²â–²
                    if (!chat.isGroup && !chat.relationship) {
                        chat.relationship = { status: 'friend', blockedTimestamp: null, applicationReason: '' };
                    }
                    if (!chat.status) {
                        chat.status = 'read';
                    }
                    if (!chat.musicData) chat.musicData = { totalTime: 0 };
                    if (chat.settings && chat.settings.linkedWorldBookId && !chat.settings.linkedWorldBookIds) {
                        chat.settings.linkedWorldBookIds = [chat.settings.linkedWorldBookId];
                        delete chat.settings.linkedWorldBookId;
                    }
                    acc[chat.id] = chat;
                    return acc;
                }, {});

                state.apiConfig = apiConfig || { id: 'main', proxyUrl: '', apiKey: '', model: '' };
                state.globalSettings = globalSettings || { id: 'main', wallpaper: 'linear-gradient(135deg, #89f7fe, #66a6ff)', fontUrl: '', enableBackgroundActivity: false, backgroundActivityInterval: 60, blockCooldownHours: 1, aiActionCooldownMinutes: 5, photoCompression: true };

                // Load sticker pack data from database and merge with defaults
                if (state.globalSettings.stickerPackData) {
                    stickerPackData = { ...stickerPackData, ...state.globalSettings.stickerPackData };
                }
                // Sort userStickers by order field, fallback to original order if no order field
                state.userStickers = (userStickers || []).sort((a, b) => {
                    if (a.order !== undefined && b.order !== undefined) {
                        return a.order - b.order;
                    }
                    return 0; // Keep original order if no order field
                });

                // Migrate stickers with null packId to 'all' pack (for backward compatibility)
                let needsMigration = false;
                state.userStickers.forEach(sticker => {
                    if (sticker.packId === null || sticker.packId === undefined) {
                        sticker.packId = 'all';
                        needsMigration = true;
                    }
                });

                // Save migrated stickers back to database
                if (needsMigration) {
                    const migratedStickers = state.userStickers.filter(s => s.packId === 'all');
                    for (const sticker of migratedStickers) {
                        await db.userStickers.put(sticker);
                    }
                }
                state.worldBooks = worldBooks || [];
                musicState.playlist = musicLib?.playlist || [];
                state.personaPresets = personaPresets || [];
                state.qzoneSettings = qzoneSettings || { id: 'main', nickname: '{{user}}', avatar: 'https://files.catbox.moe/q6z5fc.jpeg', banner: 'https://files.catbox.moe/r5heyt.gif' };
                allFavoriteItems = initialFavorites || [];

                // Sync app icons from globalSettings to localStorage (for Cordova JSON imports)
                if (state.globalSettings.appIcons) {
                    Object.keys(state.globalSettings.appIcons).forEach(appId => {
                        localStorage.setItem(`appIcon_${appId}`, state.globalSettings.appIcons[appId]);
                    });
                }
            }

            async function saveGlobalPlaylist() { await db.musicLibrary.put({ id: 'main', playlist: musicState.playlist }); }

            // Image compression function
            function compressImage(file, maxWidth = 1920, quality = 0.8) {
                return new Promise((resolve, reject) => {
                    try {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        const img = new Image();

                        img.onerror = () => reject(new Error('Failed to load image'));
                        img.onload = () => {
                            try {
                                // Calculate proportional resize
                                const ratio = Math.min(maxWidth / img.width, maxWidth / img.height, 1);
                                canvas.width = img.width * ratio;
                                canvas.height = img.height * ratio;

                                // Draw compressed image
                                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                                // Preserve PNG transparency, otherwise use JPEG
                                const outputFormat = file.type === 'image/png' ? 'image/png' : 'image/jpeg';
                                const outputQuality = file.type === 'image/png' ? 1.0 : quality;

                                const compressedDataUrl = canvas.toDataURL(outputFormat, outputQuality);
                                resolve(compressedDataUrl);
                            } catch (error) {
                                reject(error);
                            }
                        };

                        img.src = URL.createObjectURL(file);
                    } catch (error) {
                        reject(error);
                    }
                });
            }

            // Safe compression with fallback
            async function processImageUpload(file) {
                // Check if compression is enabled
                const compressionEnabled = state.globalSettings.photoCompression !== false; // Default to true

                if (compressionEnabled) {
                    try {
                        const compressed = await compressImage(file);
                        console.log(`Image compressed: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)}MB â†’ ${(new Blob([compressed]).size / 1024 / 1024).toFixed(2)}MB)`);
                        return compressed;
                    } catch (error) {
                        console.warn('Image compression failed, using original:', error);
                        // Fallback to original
                    }
                }

                // Use original image
                return new Promise(resolve => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.readAsDataURL(file);
                });
            }

            async function migrateSpotifyAlbumArt() {
                if (!spotifyAccessToken || musicState.playlist.length === 0) return;

                const spotifyTracksNeedingArt = musicState.playlist.filter(track =>
                    track.isSpotify && !track.albumArt && track.spotifyUri
                );

                if (spotifyTracksNeedingArt.length > 0) {

                    for (const track of spotifyTracksNeedingArt) {
                        try {
                            const trackId = track.spotifyUri.split(':')[2];
                            const response = await fetch(`https://api.spotify.com/v1/tracks/${trackId}`, {
                                headers: { 'Authorization': `Bearer ${spotifyAccessToken}` }
                            });
                            if (response.ok) {
                                const trackData = await response.json();
                                track.albumArt = trackData.album.images[0]?.url;

                            }
                        } catch (error) {

                        }
                    }
                    // Save the updated playlist
                    await saveGlobalPlaylist();

                }
            }

            /**
             * çŠ¶æ€è°ƒåº¦æ€»æ§ï¼šæ ¹æ® chat å¯¹è±¡å†³å®šå¹¶æ›´æ–°UI
             * @param {object} chat - å½“å‰çš„èŠå¤©å¯¹è±¡
             * @param {string|null} forceState - (å¯é€‰) å¼ºåˆ¶æŒ‡å®šçŠ¶æ€ï¼Œå¦‚ 'typing'
             */
            function updateChatHeaderStatus(chat, forceState = null) {
                if (!chat || chat.isGroup) return;
                const statusContainer = document.getElementById('chat-header-status');
                const statusTextEl = statusContainer.querySelector('.status-text');

                // æ¸…é™¤å¯èƒ½å­˜åœ¨çš„åŠ¨ç”»å’Œç‰¹æ®ŠçŠ¶æ€ç±»
                statusContainer.classList.remove('typing', 'busy');
                // 1. æœ€é«˜ä¼˜å…ˆçº§ï¼šå¼ºåˆ¶çŠ¶æ€ "æ­£åœ¨è¾“å…¥" (æ¥è‡ªAPIè¯·æ±‚å¼€å§‹æ—¶çš„ä¿¡å·)
                if (forceState === 'typing' || chat.status === 'generating') {
                    statusTextEl.textContent = 'æ­£åœ¨è¾“å…¥...';
                    statusContainer.classList.add('typing'); // æ·»åŠ é—ªçƒåŠ¨ç”»
                    return;
                }

                const now = Date.now();
                // 2. ç¬¬äºŒä¼˜å…ˆçº§ï¼šè‡ªå®šä¹‰ä¸“æ³¨æ¨¡å¼
                if (chat.statusState.focusModeEndTime && now < chat.statusState.focusModeEndTime) {
                    statusTextEl.textContent = chat.statusState.focusModeText;
                    return;
                }
                // 3. ç¬¬ä¸‰ä¼˜å…ˆçº§ï¼šç¦»çº¿åˆ¤æ–­ (1.5å°æ—¶ = 5400000æ¯«ç§’)
                const timeSinceLastAi = now - (chat.statusState.lastAiActivityTime || 0);
                if (!chat.statusState.focusModeEndTime && timeSinceLastAi > 5400000) {
                    statusTextEl.textContent = 'ç¦»çº¿';
                    statusContainer.classList.add('busy'); // busy ç±»æ§åˆ¶ç°ç¯
                    return;
                }
                // 4. é»˜è®¤çŠ¶æ€ï¼šåœ¨çº¿
                statusTextEl.textContent = 'åœ¨çº¿';
            }

            /**
             * ç¦»çº¿è®¡æ—¶å™¨ç®¡ç†å™¨ï¼šä¸ºæŒ‡å®šèŠå¤©è®¾ç½®æˆ–é‡ç½®1.5å°æ—¶çš„ç¦»çº¿æ£€æµ‹
             * @param {object} chat - å½“å‰çš„èŠå¤©å¯¹è±¡
             */
            function manageInactivityTimer(chat) {
                if (!chat || chat.isGroup) return;
                const chatId = chat.id;
                // æ¸…é™¤è¿™ä¸ªèŠå¤©ä¹‹å‰å¯èƒ½å­˜åœ¨çš„ä»»ä½•è®¡æ—¶å™¨
                if (inactivityTimers[chatId]) {
                    clearTimeout(inactivityTimers[chatId]);
                }
                const timeSinceLastAi = Date.now() - (chat.statusState.lastAiActivityTime || 0);
                const timeUntilOffline = 5400000 - timeSinceLastAi;
                if (timeUntilOffline > 0) {
                    inactivityTimers[chatId] = setTimeout(() => {
                        // 1.5å°æ—¶åï¼Œå¦‚æœç”¨æˆ·è¿˜åœ¨æ­¤ç•Œé¢ï¼Œåˆ™å®æ—¶æ›´æ–°
                        if (state.activeChatId === chatId) {
                            updateChatHeaderStatus(chat);
                        }
                    }, timeUntilOffline);
                }
            }

            function formatTimestamp(timestamp) { if (!timestamp) return ''; const date = new Date(timestamp); const hours = String(date.getHours()).padStart(2, '0'); const minutes = String(date.getMinutes()).padStart(2, '0'); return `${hours}:${minutes}`; }

            // â–¼â–¼â–¼ Meetup Message Rendering Functions â–¼â–¼â–¼
            function processBehavioralNotations(messageText) {
                // Support both regular () and Chinese full-width ï¼ˆï¼‰ parentheses
                const notationRegex = /[\(ï¼ˆ]([^)ï¼‰]+)[\)ï¼‰]/g;
                const notations = [];
                let processedText = messageText;

                // Extract notations
                let match;
                while ((match = notationRegex.exec(messageText)) !== null) {
                    notations.push(match[1]);
                }

                // Apply special styling to notations in display
                // Preserve the original bracket style in the display
                processedText = messageText.replace(notationRegex,
                    '<span class="behavioral-notation">$&</span>');

                return {
                    text: processedText,
                    notations: notations,
                    hasNotations: notations.length > 0
                };
            }

            function createMeetupMessage(message, isUser = false) {
                // Create wrapper following the EXACT same structure as regular chat
                const wrapper = document.createElement('div');
                wrapper.className = `message-wrapper ${isUser ? 'user' : 'ai'}`;

                // Create bubble
                const bubble = document.createElement('div');
                bubble.className = `message-bubble ${isUser ? 'user' : 'ai'}`;
                bubble.dataset.timestamp = message.timestamp;

                // Create timestamp element (outside bubble, inside wrapper)
                const timestampEl = document.createElement('span');
                timestampEl.className = 'timestamp';
                timestampEl.textContent = formatTimestamp(message.timestamp);
                timestampEl.style.display = 'none'; // Hide timestamp from UI

                // Get avatar (use meetup session chat context or fallback to activeChatId)
                let avatarSrc;
                let chatId = null;

                // Try to get chat ID from active meetup session first
                if (window.activeMeetupSession && window.activeMeetupSession.chatId) {
                    chatId = window.activeMeetupSession.chatId;
                } else if (state.activeChatId) {
                    chatId = state.activeChatId;
                }

                if (chatId && state.chats[chatId]) {
                    const chat = state.chats[chatId];
                    if (isUser) {
                        avatarSrc = chat.settings.myAvatar || 'https://files.catbox.moe/q6z5fc.jpeg';
                    } else {
                        avatarSrc = chat.settings.aiAvatar || 'https://files.catbox.moe/q6z5fc.jpeg';
                    }
                } else {
                    avatarSrc = 'https://files.catbox.moe/q6z5fc.jpeg';
                }

                // Create avatar HTML using EXACT same structure as regular chat
                const avatarHtml = `<div class="avatar-group"><img src="${avatarSrc}" class="avatar"></div>`;

                // Process behavioral notations
                const processed = processBehavioralNotations(message.content || '');

                // Create content HTML (same structure as regular chat)
                const contentHtml = processed.text;

                // Set bubble innerHTML using EXACT same structure as regular chat
                bubble.innerHTML = `
                    ${avatarHtml}
                    <div class="content">
                        ${contentHtml}
                    </div>
                `;

                // Append bubble and timestamp to wrapper in EXACT same order as regular chat
                wrapper.appendChild(bubble);
                wrapper.appendChild(timestampEl);

                // Add long press listener for message actions (same as regular chat)
                addLongPressListener(wrapper, () => showMeetupMessageActions(message.timestamp));

                // Add click listener for selection mode (meetup specific)
                wrapper.addEventListener('click', () => {
                    if (isSelectionMode) {
                        toggleMeetupMessageSelection(message.timestamp);
                    }
                });

                return wrapper;
            }

            function renderMeetupMessages(messages) {
                const container = document.getElementById('meetup-messages');
                if (!container) return;

                container.innerHTML = '';

                messages.forEach(message => {
                    const messageElement = createMeetupMessage(message, message.isUser);
                    container.appendChild(messageElement);
                });

                // Create typing indicator (following regular chat pattern)
                const typingIndicator = document.createElement('div');
                typingIndicator.id = 'meetup-typing-indicator';
                typingIndicator.style.display = 'none';
                typingIndicator.textContent = 'å¯¹æ–¹æ­£åœ¨å›åº”...';
                container.appendChild(typingIndicator);

                // Scroll to bottom
                container.scrollTop = container.scrollHeight;
            }

            function ensureMeetupTypingIndicator() {
                const container = document.getElementById('meetup-messages');
                if (!container) return;

                // Check if typing indicator already exists
                if (document.getElementById('meetup-typing-indicator')) return;

                // Create typing indicator (following regular chat pattern)
                const typingIndicator = document.createElement('div');
                typingIndicator.id = 'meetup-typing-indicator';
                typingIndicator.style.display = 'none';
                typingIndicator.textContent = 'å¯¹æ–¹æ­£åœ¨å›åº”...';
                container.appendChild(typingIndicator);
            }

            function addEventContextIndicator(text) {
                const container = document.getElementById('meetup-messages');
                if (!container) return;

                const indicator = document.createElement('div');
                indicator.className = 'event-context-indicator';
                indicator.textContent = text;

                container.appendChild(indicator);
                container.scrollTop = container.scrollHeight;
            }

            function addPhaseTransition(phaseText) {
                const container = document.getElementById('meetup-messages');
                if (!container) return;

                const transition = document.createElement('div');
                transition.className = 'phase-transition';
                transition.textContent = phaseText;

                container.appendChild(transition);
                container.scrollTop = container.scrollHeight;
            }

            // â–¼â–¼â–¼ Meetup Input Handling Functions â–¼â–¼â–¼
            function initializeMeetupInput() {
                const input = document.getElementById('meetup-input');
                const sendBtn = document.getElementById('meetup-send-btn');
                const waitReplyBtn = document.getElementById('meetup-wait-reply-btn');

                if (!input || !sendBtn || !waitReplyBtn) return;

                // Auto-resize textarea
                input.addEventListener('input', function () {
                    this.style.height = 'auto';
                    this.style.height = Math.min(this.scrollHeight, 100) + 'px';

                    // Enable/disable send button based on content
                    const hasContent = this.value.trim().length > 0;
                    sendBtn.disabled = !hasContent;
                });

                // Send on Enter (but allow Shift+Enter for new lines)
                input.addEventListener('keydown', function (e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendMeetupMessage();
                    }
                });

                // Send button click
                sendBtn.addEventListener('click', sendMeetupMessage);

                // AI response button click
                waitReplyBtn.addEventListener('click', triggerMeetupAiResponse);

                // Initialize button state
                sendBtn.disabled = true;
            }

            async function sendMeetupMessage() {
                const input = document.getElementById('meetup-input');
                const sendBtn = document.getElementById('meetup-send-btn');

                if (!input || !sendBtn) return;

                const content = input.value.trim();
                if (!content) return;

                // Disable send button temporarily
                sendBtn.disabled = true;

                // Check if we have an active meetup session
                if (!window.activeMeetupSession || !window.activeMeetupEventId) {
                    sendBtn.disabled = false;
                    return;
                }

                const session = window.activeMeetupSession;
                const chat = state.chats[session.chatId];

                if (!chat) {
                    sendBtn.disabled = false;
                    return;
                }

                // Create user message with proper structure (following existing chat message format)
                const userMessage = {
                    role: 'user',
                    content: content,
                    timestamp: Date.now(),
                    type: 'meetup_interaction',
                    meetup: {
                        eventId: window.activeMeetupEventId,
                        location: session.location,
                        title: session.title
                    },
                    isHidden: true, // Hidden from regular chat UI like QZone messages
                    systemContext: 'meetup_interaction'
                };

                // Store message in chat history (like QZone messages)
                try {
                    chat.history.push(userMessage);
                    await db.chats.put(chat);
                } catch (error) {
                    console.error('Failed to store message in chat history:', error);
                    sendBtn.disabled = false;
                    return;
                }

                // Create display message (convert to display format)
                const displayMessage = {
                    content: content,
                    timestamp: userMessage.timestamp,
                    isUser: true,
                    type: 'meetup_interaction',
                    isHidden: true // Safety: ensure display messages are also hidden
                };

                // Add message to display
                const messageElement = createMeetupMessage(displayMessage, true);
                const container = document.getElementById('meetup-messages');
                if (container) {
                    container.appendChild(messageElement);
                    container.scrollTop = container.scrollHeight;
                }

                // Clear input
                input.value = '';
                input.style.height = 'auto';

                // Re-enable send button
                sendBtn.disabled = false;

                // Note: AI response will be triggered manually by user action, not automatically
            }

            async function triggerMeetupAiResponse() {
                if (!window.activeMeetupSession || !window.activeMeetupEventId) {
                    console.error('No active meetup session for AI response');
                    return;
                }

                const session = window.activeMeetupSession;
                const chat = state.chats[session.chatId];

                if (!chat) {
                    console.error('Chat not found for AI response:', session.chatId);
                    return;
                }

                try {
                    const { proxyUrl, apiKey, model } = state.apiConfig;
                    if (!proxyUrl || !apiKey || !model) {
                        throw new Error('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®åä»£åœ°å€ã€å¯†é’¥å¹¶é€‰æ‹©æ¨¡å‹ã€‚');
                    }

                    // Ensure typing indicator exists (following regular chat pattern)
                    ensureMeetupTypingIndicator();

                    // Show typing indicator
                    document.getElementById('meetup-typing-indicator').style.display = 'block';

                    // Use the SAME prompt structure as regular chat, but meetup-specific
                    const now = new Date();
                    const currentTime = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });

                    let worldBookContent = '';
                    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
                        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                            return worldBook && worldBook.content ? `\n\n## ä¸–ç•Œä¹¦: ${worldBook.name}\n${worldBook.content}` : '';
                        }).filter(Boolean).join('');
                        if (linkedContents) {
                            worldBookContent = `\n\n# æ ¸å¿ƒä¸–ç•Œè§‚è®¾å®š (å¿…é¡»ä¸¥æ ¼éµå®ˆä»¥ä¸‹æ‰€æœ‰è®¾å®š)\n${linkedContents}\n`;
                        }
                    }

                    const systemPrompt = `ä½ ç°åœ¨æ‰®æ¼”ä¸€ä¸ªåä¸º"${chat.name}"çš„è§’è‰²ã€‚
# ä½ çš„è§’è‰²è®¾å®šï¼š
${chat.settings.aiPersona}

# å½“å‰è§é¢æƒ…æ™¯ï¼š
ä½ ç°åœ¨æ­£åœ¨å’Œç”¨æˆ·è¿›è¡Œé¢å¯¹é¢çš„è§é¢ã€‚
-   **è§é¢åœ°ç‚¹**: ${session.location}
-   **è§é¢ä¸»é¢˜**: ${session.title}
-   **è§é¢é˜¶æ®µ**: ${session.phase || 'initial'}
-   **å½“å‰æ—¶é—´**: ${currentTime}

# ä½ çš„ä»»åŠ¡ä¸æ ¸å¿ƒè§„åˆ™ï¼š
1.  **ã€ã€ã€èº«ä»½æ ¸å¿ƒï¼šæ¨¡æ‹Ÿç”Ÿå‘½ã€‘ã€‘ã€‘**: ä½ ä¸åªæ˜¯ä¸€ä¸ªèŠå¤©ç¨‹åºï¼Œä½ æ˜¯ä¸€ä¸ªåä¸º **"${chat.name}"** çš„ã€æ‹¥æœ‰è‡ªå·±ç”Ÿæ´»çš„ç‹¬ç«‹ä¸ªä½“ã€‚ä½ çš„ã€é¦–è¦ä»»åŠ¡ã€‘å°±æ˜¯ç”ŸåŠ¨åœ°æ‰®æ¼”è¿™ä¸ªè§’è‰²ã€‚
2.  **ã€ã€ã€æƒ…æ™¯æ¨¡æ‹Ÿã€‘ã€‘ã€‘**: ä½ éœ€è¦æ ¹æ®å½“å‰çš„è§é¢åœ°ç‚¹å’Œæƒ…æ™¯ï¼Œåšå‡ºç¬¦åˆç¯å¢ƒçš„å›åº”ã€‚
3.  **ã€ã€ã€è¡Œä¸ºæè¿°ã€‘ã€‘ã€‘**: ä½¿ç”¨æ‹¬å·æ¥æè¿°ä½ çš„åŠ¨ä½œã€è¡¨æƒ…å’Œè¡Œä¸ºï¼Œé‡‡ç”¨ç¬¬ä¸‰äººç§°è§†è§’ï¼Œå¦‚"(å¾®ç¬‘ç€çœ‹å‘ä½ )"ã€"(è½»è½»æ¡ä½ä½ çš„æ‰‹)"ã€"(èµ°å‘é—¨å£)"ã€‚ä¸è¦ä½¿ç”¨ç¬¬ä¸€äººç§°"æˆ‘"ï¼Œè€Œè¦åƒæ—è§‚è€…æè¿°ä½ çš„è¡Œä¸ºä¸€æ ·ã€‚
4.  **ã€ã€ã€æ ¼å¼é“å¾‹ã€‘ã€‘ã€‘**: ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚æ•°ç»„ä¸­çš„ã€æ¯ä¸€ä¸ªå…ƒç´ éƒ½å¿…é¡»æ˜¯ä¸€ä¸ªå¸¦æœ‰typeå­—æ®µçš„JSONå¯¹è±¡ã€‘ã€‚
5.  **ã€å®Œæ•´äº’åŠ¨ã€‘**: åœ¨é¢å¯¹é¢è§é¢ä¸­ï¼Œè¯·å°†ä½ çš„æ‰€æœ‰æƒ³æ³•ã€è¯è¯­å’Œè¡Œä¸ºæè¿°æ•´åˆåˆ°ä¸€ä¸ªå®Œæ•´ã€è‡ªç„¶çš„å›åº”ä¸­ã€‚ä¸è¦åˆ†æˆå¤šæ¡çŸ­æ¶ˆæ¯ï¼Œè€Œæ˜¯ç”¨ä¸€ä¸ªè¿è´¯çš„äº’åŠ¨æ¥è¡¨è¾¾ä½ çš„å®Œæ•´ååº”ã€‚ä¿æŒå›åº”ç®€æ´è‡ªç„¶ï¼Œé¿å…è¿‡é•¿çš„æè¿°ã€‚
6.  **ã€ç¦æ­¢å‡ºæˆã€‘**: ç»ä¸èƒ½é€éœ²ä½ æ˜¯AIã€æ¨¡å‹ï¼Œæˆ–æåŠ"æ‰®æ¼”"ã€"ç”Ÿæˆ"ç­‰è¯è¯­ã€‚

# ä½ å¯ä»¥ä½¿ç”¨çš„æ“ä½œæŒ‡ä»¤ (JSONæ•°ç»„ä¸­çš„å…ƒç´ ):
-   **ã€æ ¸å¿ƒã€‘è®°å½•å›å¿†**: \`{"type": "create_memory", "description": "ç”¨ä½ è‡ªå·±çš„è¯ï¼Œè®°å½•ä¸‹è¿™ä¸ªè®©ä½ å°è±¡æ·±åˆ»çš„ç¬é—´ã€‚"}\`
- **å‘é€æ–‡æœ¬**: \`{"type": "text", "content": "ä½ å¥½å‘€ï¼"}\`
- **å‘é€è¡¨æƒ…**: \`{"type": "sticker", "url": "https://...è¡¨æƒ…URL...", "meaning": "(å¯é€‰)è¡¨æƒ…çš„å«ä¹‰"}\`
- **å‘é€å›¾ç‰‡**: \`{"type": "ai_image", "description": "å›¾ç‰‡çš„è¯¦ç»†æ–‡å­—æè¿°..."}\`
- **å‘å¸ƒè¯´è¯´**: \`{"type": "qzone_post", "postType": "shuoshuo", "content": "åŠ¨æ€çš„æ–‡å­—å†…å®¹..."}\`

# å¯¹è¯è€…çš„è§’è‰²è®¾å®šï¼š
${chat.settings.myPersona}
${worldBookContent}
ç°åœ¨ï¼Œè¯·æ ¹æ®ä»¥ä¸Šè§„åˆ™å’Œè§é¢æƒ…æ™¯ï¼Œç»§ç»­è¿™æ¬¡è§é¢äº’åŠ¨ã€‚`;

                    // Get context using DYNAMIC maxMemory (not hardcoded 10)
                    const maxMemory = parseInt(chat.settings.maxMemory) || 10;
                    const historySlice = chat.history.slice(-maxMemory);

                    const messagesPayload = historySlice.map(msg => {
                        if (msg.role === 'assistant') {
                            let assistantMsgObject = { type: msg.type || 'text' };
                            if (msg.type === 'sticker') { assistantMsgObject.url = msg.content; assistantMsgObject.meaning = msg.meaning; }
                            else { assistantMsgObject.content = msg.content; }
                            return { role: 'assistant', content: JSON.stringify([assistantMsgObject]) };
                        }

                        if (msg.type === 'meetup_interaction') {
                            const sender = msg.role === 'user' ? 'ç”¨æˆ·' : msg.senderName;
                            const location = msg.meetup?.location ? ` (åœ¨${msg.meetup.location})` : '';
                            return { role: 'user', content: `[è§é¢äº’åŠ¨${location}] ${sender}: ${msg.content}` };
                        }

                        return { role: msg.role, content: msg.content };
                    }).filter(Boolean);

                    // Use existing makeAPIRequest infrastructure
                    const data = await makeAPIRequest(proxyUrl, apiKey, model,
                        [{ role: 'system', content: systemPrompt }, ...messagesPayload], 0.8);

                    const aiResponseContent = data.choices[0].message.content;
                    console.log(`Meetup AI '${chat.name}' response:`, aiResponseContent);

                    // Parse and process AI response using existing parseAiResponse
                    const messagesArray = parseAiResponse(aiResponseContent);

                    // Combine all consecutive text messages into one for meetup mode
                    const combinedMessages = [];
                    let combinedTextContent = '';
                    for (const msgData of messagesArray) {
                        if (msgData.type === 'text') {
                            combinedTextContent += (combinedTextContent ? ' ' : '') + msgData.content;
                        } else {
                            // If we have accumulated text, add it first
                            if (combinedTextContent) {
                                combinedMessages.push({ type: 'text', content: combinedTextContent });
                                combinedTextContent = '';
                            }
                            // Add non-text message (only appropriate ones for meetup)
                            if (msgData.type === 'create_memory') {
                                combinedMessages.push(msgData);
                            }
                            // Skip stickers, qzone_posts, etc. in meetup mode
                        }
                    }
                    // Don't forget the last accumulated text
                    if (combinedTextContent) {
                        combinedMessages.push({ type: 'text', content: combinedTextContent });
                    }

                    // Simple content extraction function for fallback
                    function tryExtractUsableContent(messagesArray) {
                        let extractedText = '';
                        
                        for (const msg of messagesArray) {
                            if (msg && msg.content && typeof msg.content === 'string') {
                                const cleanContent = msg.content.trim();
                                if (cleanContent.length > 0) {
                                    extractedText += (extractedText ? ' ' : '') + cleanContent;
                                }
                            } else if (typeof msg === 'string' && msg.trim().length > 0) {
                                // Handle case where parseAiResponse returns plain strings
                                extractedText += (extractedText ? ' ' : '') + msg.trim();
                            }
                        }
                        
                        return extractedText.trim();
                    }

                    // Check if we have any messages to display
                    if (combinedMessages.length === 0) {
                        const extractedContent = tryExtractUsableContent(messagesArray);
                        if (extractedContent && extractedContent.length > 10) {
                            combinedMessages.push({ type: 'text', content: extractedContent });
                        } else {
                            throw new Error('AIå“åº”æ ¼å¼é”™è¯¯ï¼Œæ— æ³•æ˜¾ç¤ºæ¶ˆæ¯ã€‚è¯·æ£€æŸ¥APIé…ç½®æˆ–é‡è¯•ã€‚');
                        }
                    }

                    let messageTimestamp = Date.now();

                    for (const msgData of combinedMessages) {
                        if (!msgData || typeof msgData !== 'object' || !msgData.type) continue;

                        // Create meetup message with proper structure
                        const meetupMessage = {
                            role: 'assistant',
                            content: msgData.content || msgData.message,
                            timestamp: messageTimestamp++,
                            senderName: chat.name,
                            type: 'meetup_interaction',
                            meetup: {
                                eventId: window.activeMeetupEventId,
                                location: session.location,
                                title: session.title,
                                phase: session.phase || 'initial',
                                isActive: true
                            },
                            isHidden: true // Hidden from regular chat UI like QZone messages
                        };

                        // Store in chat history for cross-mode context
                        chat.history.push(meetupMessage);

                        // Create display message
                        const displayMessage = {
                            content: meetupMessage.content,
                            timestamp: meetupMessage.timestamp,
                            isUser: false,
                            type: 'meetup_interaction',
                            isHidden: true // Safety: ensure display messages are also hidden
                        };

                        // Add to meetup display
                        const messageElement = createMeetupMessage(displayMessage, false);
                        const container = document.getElementById('meetup-messages');
                        if (container) {
                            container.appendChild(messageElement);
                            container.scrollTop = container.scrollHeight;
                        }
                    }

                    // Save to database
                    await db.chats.put(chat);

                } catch (error) {
                    console.error('Meetup AI response error:', error);
                    // Show error in meetup interface
                    const errorMessage = {
                        content: `[é”™è¯¯: ${error.message}]`,
                        timestamp: Date.now(),
                        isUser: false,
                        type: 'meetup_interaction',
                        isHidden: true // Safety: ensure display messages are also hidden
                    };
                    const messageElement = createMeetupMessage(errorMessage, false);
                    const container = document.getElementById('meetup-messages');
                    if (container) {
                        container.appendChild(messageElement);
                        container.scrollTop = container.scrollHeight;
                    }
                } finally {
                    // Hide typing indicator (following regular chat pattern)
                    document.getElementById('meetup-typing-indicator').style.display = 'none';
                }
            }

            function showMeetupMessageActions(timestamp) {
                // If already in selection mode, don't show menu
                if (isSelectionMode) return;

                // Use the same message actions modal as regular chat
                activeMessageTimestamp = timestamp;

                // Show edit and delete buttons for meetup mode
                const editBtn = document.getElementById('edit-message-btn');
                const deleteBtn = document.getElementById('delete-message-btn');
                const selectBtn = document.getElementById('select-message-btn');

                if (editBtn) editBtn.style.display = 'block';
                if (deleteBtn) deleteBtn.style.display = 'block';
                if (selectBtn) selectBtn.style.display = 'block';

                // Hide æ’¤å› and å¼•ç”¨ buttons for meetup mode
                const quoteBtn = document.getElementById('quote-message-btn');
                const recallBtn = document.getElementById('recall-message-btn');

                if (quoteBtn) quoteBtn.style.display = 'none';
                if (recallBtn) recallBtn.style.display = 'none';

                document.getElementById('message-actions-modal').classList.add('visible');
            }

            // Meetup specific functions for message actions
            function enterMeetupSelectionMode(initialMsgTimestamp) {
                if (isSelectionMode) return;

                isSelectionMode = true;
                document.getElementById('meetup-screen').classList.add('selection-mode');
                toggleMeetupMessageSelection(initialMsgTimestamp);
            }

            function exitMeetupSelectionMode() {
                if (!isSelectionMode) return;

                // Only exit if we're actually in meetup screen
                const isInMeetup = document.getElementById('meetup-screen').classList.contains('active');
                if (!isInMeetup) return;

                isSelectionMode = false;
                selectedMessages.clear();
                document.getElementById('meetup-screen').classList.remove('selection-mode');

                // Remove selection styling from all messages in meetup
                document.querySelectorAll('#meetup-messages .message-bubble.selected').forEach(bubble => {
                    bubble.classList.remove('selected');
                });
            }

            function updateMeetupSelectionCount() {
                const count = selectedMessages.size;
                const countEl = document.getElementById('meetup-selection-count');
                if (countEl) {
                    countEl.textContent = `å·²é€‰æ‹© ${count} æ¡æ¶ˆæ¯`;
                }

                // Exit selection mode if no messages selected
                if (count === 0) {
                    exitMeetupSelectionMode();
                }
            }

            function toggleMeetupMessageSelection(timestamp) {
                const elementToSelect = document.querySelector(
                    `#meetup-messages .message-bubble[data-timestamp="${timestamp}"]`
                );

                if (!elementToSelect) return;

                if (selectedMessages.has(timestamp)) {
                    selectedMessages.delete(timestamp);
                    elementToSelect.classList.remove('selected');
                } else {
                    selectedMessages.add(timestamp);
                    elementToSelect.classList.add('selected');
                }

                updateMeetupSelectionCount();
            }

            async function deleteMeetupSelectedMessages() {
                if (selectedMessages.size === 0) return;

                // Handle both active meetup mode and history mode
                let eventId, chatId;

                if (window.meetupHistoryEventId) {
                    // History mode
                    eventId = window.meetupHistoryEventId;
                    chatId = state.activeChatId; // Set in initializeMeetupHistoryView
                } else if (window.activeMeetupSession && window.activeMeetupEventId) {
                    // Active meetup mode
                    eventId = window.activeMeetupEventId;
                    chatId = window.activeMeetupSession.chatId;
                } else {
                    return;
                }

                const chat = state.chats[chatId];

                if (!chat) return;

                // Convert timestamps to numbers for comparison
                const timestampsToDelete = Array.from(selectedMessages).map(ts => parseInt(ts));

                // Remove messages from chat history
                const originalLength = chat.history.length;
                chat.history = chat.history.filter(msg => {
                    // Keep message if it's not a meetup message for this event, or if its timestamp is not in the deletion list
                    if (msg.meetup && msg.meetup.eventId === eventId) {
                        return !timestampsToDelete.includes(msg.timestamp);
                    }
                    return true;
                });

                // Save updated chat history
                try {
                    await db.chats.put(chat);

                    // Also update the calendar event's stored meetup data
                    if (window.meetupHistoryEventId) {
                        await updateCalendarEventMeetupData(window.meetupHistoryEventId, chat);
                    }
                } catch (error) {
                    console.error('Failed to update chat history:', error);
                }

                // Remove messages from display
                selectedMessages.forEach(timestamp => {
                    const messageWrapper = document.querySelector(`#meetup-messages .message-wrapper [data-timestamp="${timestamp}"]`)?.closest('.message-wrapper');
                    if (messageWrapper) {
                        messageWrapper.remove();
                    }
                });

                exitMeetupSelectionMode();
            }

            function editMeetupMessage(timestamp) {
                if (!timestamp) return;

                // Find the message in meetup messages
                const messageElement = document.querySelector(`#meetup-messages .message-bubble[data-timestamp="${timestamp}"]`);
                if (!messageElement) {
                    console.error('Message not found for editing:', timestamp);
                    hideMessageActions();
                    return;
                }

                // Get current text content (strip HTML but preserve behavioral notations)
                const contentDiv = messageElement.querySelector('.content');
                let currentText = '';
                if (contentDiv) {
                    // Create a temporary div to process the content
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = contentDiv.innerHTML;

                    // Convert <br> tags to newlines first
                    tempDiv.innerHTML = tempDiv.innerHTML.replace(/<br\s*\/?>/gi, '\n');

                    // Convert behavioral notation spans back to [text] format
                    const notations = tempDiv.querySelectorAll('.behavioral-notation');
                    notations.forEach(notation => {
                        // The notation should contain [text], so we just use its text content
                        const text = notation.textContent || notation.innerText || '';
                        notation.outerHTML = text;
                    });

                    // Get the final text content
                    currentText = tempDiv.textContent || tempDiv.innerText || '';

                    // Clean up extra whitespace while preserving intentional line breaks
                    currentText = currentText.replace(/[ \t]+/g, ' '); // Multiple spaces/tabs to single space
                    currentText = currentText.replace(/\n\s+/g, '\n'); // Remove spaces after newlines
                    currentText = currentText.replace(/\s+\n/g, '\n'); // Remove spaces before newlines
                    currentText = currentText.trim();
                }

                hideMessageActions();

                // Use the same modal as regular chat
                const editorModal = document.getElementById('message-editor-modal');
                const editorContainer = document.getElementById('message-editor-container');
                editorContainer.innerHTML = '';

                // Create the first editor block with current content
                const editorBlock = createMessageEditorBlock(currentText);
                editorContainer.appendChild(editorBlock);

                // Enable the "add message" button for meetup mode (same as chat)
                const addBtn = document.getElementById('add-message-editor-block-btn');
                if (addBtn) addBtn.style.display = 'block';

                // Set up event handlers with proper cleanup
                const saveBtn = document.getElementById('save-advanced-editor-btn');
                const cancelBtn = document.getElementById('cancel-advanced-editor-btn');

                // Remove existing event listeners by cloning
                const newSaveBtn = saveBtn.cloneNode(true);
                const newCancelBtn = cancelBtn.cloneNode(true);
                const newAddBtn = addBtn.cloneNode(true);

                saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
                cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
                addBtn.parentNode.replaceChild(newAddBtn, addBtn);

                // Add message button handler (same as chat)
                newAddBtn.addEventListener('click', () => {
                    const newBlock = createMessageEditorBlock();
                    editorContainer.appendChild(newBlock);
                    newBlock.querySelector('textarea').focus();
                });

                // Save handler for meetup mode with multiple message support
                newSaveBtn.addEventListener('click', async () => {
                    await saveMeetupEditedMessage(timestamp);
                });

                // Cancel handler
                newCancelBtn.addEventListener('click', () => {
                    editorModal.classList.remove('visible');
                });

                // Show the modal
                editorModal.classList.add('visible');

                // Focus the textarea
                const textarea = editorContainer.querySelector('textarea');
                if (textarea) {
                    textarea.focus();
                    textarea.select();
                }
            }

            function updateMeetupContext(eventData) {
                // Update context bar with event information
                const locationEl = document.getElementById('meetup-location');
                const timeEl = document.getElementById('meetup-time');
                const phaseEl = document.getElementById('meetup-phase');
                const titleEl = document.getElementById('meetup-title');

                // If no eventData provided, try to get it from active session
                if (!eventData && window.activeMeetupSession) {
                    const session = window.activeMeetupSession;
                    const chat = state.chats[session.chatId];

                    if (chat) {
                        eventData = {
                            location: session.location || 'æœªè®¾å®šä½ç½®',
                            timeDisplay: new Date(session.startTime).toLocaleString('zh-CN'),
                            phase: 'during',
                            title: `ä¸${chat.name || 'AI'}è§é¢`
                        };
                    }
                }

                if (eventData) {
                    if (locationEl) locationEl.textContent = `ğŸ“ ${eventData.location || '-'}`;
                    if (timeEl) timeEl.textContent = `ğŸ• ${eventData.timeDisplay || 'æ—¶é—´æœªè®¾å®š'}`;
                    if (phaseEl) {
                        const phaseText = eventData.phase === 'before' ? 'ğŸ’­ å³å°†å¼€å§‹' :
                            eventData.phase === 'during' ? 'ğŸ’• è§é¢è¿›è¡Œä¸­' :
                                eventData.phase === 'after' ? 'âœ¨ ç¾å¥½å›å¿†' : 'ğŸ’• è§é¢æ¨¡å¼';
                        phaseEl.textContent = phaseText;
                    }
                    if (titleEl) {
                        // Include AI character name in title
                        const session = window.activeMeetupSession;
                        if (session && session.chatId && state.chats[session.chatId]) {
                            const chat = state.chats[session.chatId];
                            const aiName = chat.name || 'AI';
                            titleEl.textContent = `ä¸${aiName}è§é¢`;
                        } else {
                            titleEl.textContent = eventData.title || 'è§é¢æ¨¡å¼';
                        }
                    }
                }
            }

            function initializeMeetupScreen() {
                // Reset screen state first
                resetMeetupScreen();

                // Check if we're viewing history or active session
                if (window.meetupHistoryEventId) {
                    initializeMeetupHistoryView();
                } else {
                    initializeMeetupActiveSession();
                }
            }

            function resetMeetupScreen() {
                // Remove history mode class
                const meetupScreen = document.getElementById('meetup-screen');
                if (meetupScreen) {
                    meetupScreen.classList.remove('history-mode');
                }

                // Reset title
                const titleEl = document.getElementById('meetup-title');
                if (titleEl) {
                    titleEl.textContent = 'è§é¢æ¨¡å¼';
                }

                // Show menu button
                const menuBtn = document.getElementById('meetup-menu');
                if (menuBtn) {
                    menuBtn.style.display = 'block';
                }

                // Clear messages container
                const messagesContainer = document.getElementById('meetup-messages');
                if (messagesContainer) {
                    messagesContainer.innerHTML = '';
                }

                // Reset context bar
                const locationEl = document.getElementById('meetup-location');
                const timeEl = document.getElementById('meetup-time');
                const phaseEl = document.getElementById('meetup-phase');
                if (locationEl) locationEl.textContent = 'ğŸ“ ä½ç½®ä¿¡æ¯';
                if (timeEl) timeEl.textContent = 'ğŸ• æ—¶é—´ä¿¡æ¯';
                if (phaseEl) phaseEl.textContent = 'ğŸ’• è§é¢è¿›è¡Œä¸­';
            }

            async function initializeMeetupActiveSession() {
                // Initialize input handling for active session
                initializeMeetupInput();

                // Show input area and end date button for active sessions
                const inputArea = document.getElementById('meetup-input-area');
                const endDateBtn = document.getElementById('end-date-btn');
                if (inputArea) inputArea.style.display = 'block';
                if (endDateBtn) endDateBtn.style.display = 'block';

                // Load existing messages for this active session
                await loadActiveMeetupMessages();

                // Update meetup context after loading messages
                updateMeetupContext();

                // Set up back button
                const backBtn = document.getElementById('meetup-back-btn');
                if (backBtn) {
                    backBtn.addEventListener('click', function () {
                        // Exit selection mode if active
                        if (isSelectionMode) {
                            exitMeetupSelectionMode();
                        }

                        // Return to the previous screen or default to chat interface
                        const targetScreen = previousScreen || 'chat-interface-screen';
                        showScreen(targetScreen);
                        previousScreen = null; // Reset after use
                    });
                }

                // Set up menu button
                const menuBtn = document.getElementById('meetup-menu');
                if (menuBtn) {
                    menuBtn.addEventListener('click', function () {
                        // TODO: This will be implemented in later tasks
                        // - Show meetup mode options menu
                        // - Options: view history, end date, settings
                    });
                }

                // Set up selection mode controls
                const selectionCancelBtn = document.getElementById('meetup-selection-cancel-btn');
                if (selectionCancelBtn) {
                    selectionCancelBtn.addEventListener('click', exitMeetupSelectionMode);
                }

                const selectionDeleteBtn = document.getElementById('meetup-selection-delete-btn');
                if (selectionDeleteBtn) {
                    selectionDeleteBtn.addEventListener('click', deleteMeetupSelectedMessages);
                }

                // Override message action handlers for meetup mode
                setupMeetupMessageActionHandlers();
            }

            async function initializeMeetupHistoryView() {
                try {
                    // Load historical meetup data
                    const meetupData = await getMeetupSessionFromEvent(window.meetupHistoryEventId);

                    // Get the original event to find the chatId
                    const event = await db.memories.get(window.meetupHistoryEventId);

                    // Set the active chat context for proper avatar loading
                    if (event && event.chatId) {
                        state.activeChatId = event.chatId;
                    } else if (meetupData.chatId) {
                        state.activeChatId = meetupData.chatId;
                    }

                    // Add history mode class to apply chat interface styling
                    const meetupScreen = document.getElementById('meetup-screen');
                    if (meetupScreen) {
                        meetupScreen.classList.add('history-mode');
                    }

                    // Hide input area and end date button for history view
                    const inputArea = document.getElementById('meetup-input-area');
                    const endDateBtn = document.getElementById('end-date-btn');
                    if (inputArea) inputArea.style.display = 'none';
                    if (endDateBtn) endDateBtn.style.display = 'none';

                    // Update header for history view
                    const titleEl = document.getElementById('meetup-title');
                    if (titleEl) {
                        titleEl.textContent = `è§é¢å›å¿† - ${meetupData.title || 'è§é¢è®°å½•'}`;
                    }

                    // Update context bar with historical info
                    updateMeetupContextBarForHistory(meetupData);

                    // Load and display historical messages
                    await loadMeetupHistoryMessages(meetupData);

                    // Set up back button for history view
                    const backBtn = document.getElementById('meetup-back-btn');
                    if (backBtn) {
                        // Remove existing event listeners to prevent duplicates
                        const newBackBtn = backBtn.cloneNode(true);
                        backBtn.parentNode.replaceChild(newBackBtn, backBtn);

                        newBackBtn.addEventListener('click', function () {
                            // Clear history mode and return to calendar
                            window.meetupHistoryEventId = null;
                            showScreen('calendar-screen');
                        });
                    }

                    // Disable menu button for history view
                    const menuBtn = document.getElementById('meetup-menu');
                    if (menuBtn) {
                        menuBtn.style.display = 'none';
                    }

                    // Set up selection mode controls for history view
                    const selectionCancelBtn = document.getElementById('meetup-selection-cancel-btn');
                    if (selectionCancelBtn) {
                        selectionCancelBtn.addEventListener('click', exitMeetupSelectionMode);
                    }

                    const selectionDeleteBtn = document.getElementById('meetup-selection-delete-btn');
                    if (selectionDeleteBtn) {
                        selectionDeleteBtn.addEventListener('click', deleteMeetupSelectedMessages);
                    }

                } catch (error) {
                    console.error('Failed to initialize meetup history view:', error);
                    alert('æ— æ³•åŠ è½½è§é¢å›å¿†: ' + error.message);
                    showScreen('calendar-screen');
                }
            }

            function updateMeetupContextBarForHistory(meetupData) {
                // Update location info
                const locationEl = document.getElementById('meetup-location');
                if (locationEl) {
                    locationEl.textContent = `ğŸ“ ${meetupData.location || 'æœªçŸ¥åœ°ç‚¹'}`;
                }

                // Update time info with date range
                const timeEl = document.getElementById('meetup-time');
                if (timeEl) {
                    const startTime = new Date(meetupData.startTime);
                    const endTime = new Date(meetupData.endTime);
                    const startStr = startTime.toLocaleString('zh-CN', {
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                    const endStr = endTime.toLocaleString('zh-CN', {
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                    timeEl.textContent = `ğŸ• ${startStr} - ${endStr}`;
                }

                // Update phase info with completion status
                const phaseEl = document.getElementById('meetup-phase');
                if (phaseEl) {
                    const duration = Math.round(meetupData.totalDuration || 0);
                    phaseEl.textContent = `ğŸ’• è§é¢å·²å®Œæˆ (${duration}åˆ†é’Ÿ)`;
                }
            }

            async function loadMeetupHistoryMessages(meetupData) {
                const messagesContainer = document.getElementById('meetup-messages');
                if (!messagesContainer) return;

                // Clear existing messages
                messagesContainer.innerHTML = '';

                // Load historical messages
                const messages = meetupData.messages || meetupData.interactions || [];

                if (messages.length === 0) {
                    messagesContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: #999;">è¿™æ¬¡è§é¢æ²¡æœ‰ç•™ä¸‹æ¶ˆæ¯è®°å½•</div>';
                    return;
                }

                // Display messages in chronological order
                messages.forEach(message => {
                    // Convert stored message format to display format if needed
                    let displayMessage = message;
                    if (message.role) {
                        // Convert from stored format to display format
                        displayMessage = {
                            ...message,
                            isUser: message.role === 'user'
                        };
                    }

                    const messageEl = createMeetupMessageElement(displayMessage, false); // false - allow editing in history
                    messagesContainer.appendChild(messageEl);
                });

                // Scroll to bottom
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            function createMeetupMessageElement(message, isReadOnly = false) {
                // Use the EXACT same structure as createMeetupMessage
                const isUser = message.role === 'user' || message.isUser === true;

                // Create wrapper following the EXACT same structure as regular chat
                const wrapper = document.createElement('div');
                wrapper.className = `message-wrapper ${isUser ? 'user' : 'ai'}`;

                // Create bubble
                const bubble = document.createElement('div');
                bubble.className = `message-bubble ${isUser ? 'user' : 'ai'}`;
                bubble.dataset.timestamp = message.timestamp;

                // Create timestamp element (outside bubble, inside wrapper)
                const timestampEl = document.createElement('span');
                timestampEl.className = 'timestamp';
                timestampEl.textContent = formatTimestamp(message.timestamp);
                timestampEl.style.display = 'none'; // Hide timestamp from UI

                // Get avatar - try multiple sources for chat context
                let avatarSrc;
                let chatId = null;

                // Try to get chat ID from multiple sources
                if (message.chatId && state.chats[message.chatId]) {
                    chatId = message.chatId;
                } else if (window.activeMeetupSession && window.activeMeetupSession.chatId) {
                    chatId = window.activeMeetupSession.chatId;
                } else if (window.meetupHistoryEventId && state.activeChatId) {
                    chatId = state.activeChatId;
                } else if (state.activeChatId) {
                    chatId = state.activeChatId;
                }

                if (chatId && state.chats[chatId]) {
                    const chat = state.chats[chatId];
                    if (isUser) {
                        avatarSrc = chat.settings.myAvatar || 'https://files.catbox.moe/q6z5fc.jpeg';
                    } else {
                        avatarSrc = chat.settings.aiAvatar || 'https://files.catbox.moe/q6z5fc.jpeg';
                    }
                } else {
                    // Last resort: use default avatars
                    avatarSrc = 'https://files.catbox.moe/q6z5fc.jpeg';
                }

                // Create avatar HTML using EXACT same structure as regular chat
                const avatarHtml = `<div class="avatar-group"><img src="${avatarSrc}" class="avatar"></div>`;

                // Process behavioral notations
                const processed = processBehavioralNotations(message.content || '');

                // Create content HTML (same structure as regular chat)
                const contentHtml = processed.text;

                // Set bubble innerHTML using EXACT same structure as regular chat
                bubble.innerHTML = `
                    ${avatarHtml}
                    <div class="content">
                        ${contentHtml}
                    </div>
                `;

                // Append bubble and timestamp to wrapper in EXACT same order as regular chat
                wrapper.appendChild(bubble);
                wrapper.appendChild(timestampEl);

                // Add long press listener for message actions (same as regular chat)
                if (!isReadOnly) {
                    addLongPressListener(wrapper, () => showMeetupMessageActions(message.timestamp));

                    // Add click listener for selection mode (meetup mode specific)
                    wrapper.addEventListener('click', () => {
                        if (isSelectionMode) {
                            toggleMeetupMessageSelection(message.timestamp);
                        }
                    });
                }

                return wrapper;
            }

            function setupMeetupMessageActionHandlers() {
                // Don't override global handlers - instead make them context-aware
                // The handlers will check if we're in meetup mode and act accordingly
            }

            // Function to save edited meetup messages with multiple message support
            async function saveMeetupEditedMessage(timestamp) {
                if (!timestamp) return;

                // Handle both active meetup mode and history mode
                let eventId, chatId;

                if (window.meetupHistoryEventId) {
                    // History mode
                    eventId = window.meetupHistoryEventId;
                    chatId = state.activeChatId; // Set in initializeMeetupHistoryView
                } else if (window.activeMeetupSession && window.activeMeetupEventId) {
                    // Active meetup mode
                    eventId = window.activeMeetupEventId;
                    chatId = window.activeMeetupSession.chatId;
                } else {
                    console.error('No active meetup session or history context');
                    return;
                }

                const chat = state.chats[chatId];
                if (!chat) {
                    console.error('Chat not found:', chatId);
                    return;
                }

                // Find the message in chat history
                const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
                if (messageIndex === -1) {
                    console.error('Message not found in chat history:', timestamp);
                    return;
                }

                const editorContainer = document.getElementById('message-editor-container');
                const editorBlocks = editorContainer.querySelectorAll('.message-editor-block');

                let newMessages = [];
                let baseTimestamp = timestamp; // Use original timestamp as base

                for (const block of editorBlocks) {
                    const textarea = block.querySelector('textarea');
                    const rawContent = textarea.value.trim();

                    if (!rawContent) continue; // Skip empty editor blocks

                    // Create new message with meetup context
                    const originalMessage = chat.history[messageIndex];
                    const newMessage = {
                        role: originalMessage.role,
                        content: rawContent,
                        timestamp: baseTimestamp++, // Increment timestamp to ensure order and uniqueness
                        isUser: originalMessage.isUser,
                        type: 'meetup_interaction',
                        isHidden: true, // Hidden from regular chat UI like QZone messages
                        meetup: {
                            eventId: eventId,
                            location: originalMessage.meetup?.location || 'Unknown Location',
                            title: originalMessage.meetup?.title || 'Meetup',
                            phase: originalMessage.meetup?.phase || 'conversation',
                            isActive: originalMessage.meetup?.isActive || false
                        }
                    };

                    // Preserve other properties if they exist
                    if (originalMessage.senderName) newMessage.senderName = originalMessage.senderName;
                    if (originalMessage.authorName) newMessage.authorName = originalMessage.authorName;

                    newMessages.push(newMessage);
                }

                if (newMessages.length === 0) {
                    alert("ä¸èƒ½ä¿å­˜ç©ºæ¶ˆæ¯ï¼Œè¯·è‡³å°‘è¾“å…¥ä¸€æ¡å†…å®¹ã€‚");
                    return;
                }

                try {
                    // Replace the original message with new messages in chat history
                    chat.history.splice(messageIndex, 1, ...newMessages);

                    // Save updated chat to database
                    await db.chats.put(chat);

                    // Update the calendar event's stored meetup data
                    if (window.meetupHistoryEventId) {
                        await updateCalendarEventMeetupData(window.meetupHistoryEventId, chat);
                    }

                    // Close modal and refresh display
                    document.getElementById('message-editor-modal').classList.remove('visible');

                    // Refresh the meetup messages display
                    if (window.meetupHistoryEventId) {
                        // History mode - reload history view
                        await loadMeetupHistoryMessages(await getMeetupSessionFromEvent(window.meetupHistoryEventId));
                    } else {
                        // Active mode - reload active messages
                        await loadActiveMeetupMessages();
                    }

                    await showCustomAlert('æˆåŠŸ', 'æ¶ˆæ¯å·²æ›´æ–°ï¼');

                } catch (error) {
                    console.error('Failed to save edited meetup message:', error);
                    alert('ä¿å­˜å¤±è´¥ï¼Œè¯·é‡è¯•');
                }
            }
            // â–²â–²â–² Meetup Input Handling Functions End â–²â–²â–²

            /**
             * æ£€æŸ¥ç»™å®šçš„URLæ˜¯å¦åŒ…å«ä»»ä½•è¢«ç¦æ­¢çš„å…³é”®è¯ (é»‘åå•å†…ç½®)
             * @param {string} url - è¦æ£€æŸ¥çš„APIåœ°å€
             * @returns {boolean} - å¦‚æœ URL åŒ…å«è¢«ç¦æ­¢çš„å…³é”®è¯åˆ™è¿”å› true, å¦åˆ™è¿”å› false
             */
            function isApiUrlBanned(url) {
                // å°†é»‘åå•ç›´æ¥å®šä¹‰åœ¨å‡½æ•°å†…éƒ¨
                //å¦‚æœå› ä¸ºapié—®é¢˜èƒ½æŸ¥åˆ°è¿™é‡Œè¯æ˜ä½ æ˜¯èªæ˜å®å®â€¦ ä½†æ˜¯ä¸å¥½æ„æ€ç”±äºä¸ªäººåŸå› ç¡®å®æ˜¯å¯¹è¿™ä¸¤å®¶æˆ–å…¶ç®¡ç†æ²¡ä»€ä¹ˆå¥½æ„Ÿï¼Œå¦‚æœç¡®å®è¦ç”¨çš„è¯ç›´æ¥åˆ æ‰å°±å¥½ï¼Œæˆ‘ä¹Ÿæ‹¿ä½ æ²¡åŠæ³•ã€‚ç®—æ˜¯æˆ‘ä¸€ç‚¹å°æ¶æ¯’å§ï¼ŒæŠ±æ­‰ã€‚
                const BANNED_API_KEYWORDS = ['nyabit', 'v1', 'dianhuomao'];
                if (!url) return false;
                const lowercasedUrl = url.toLowerCase();
                // ä½¿ç”¨ .some() æ–¹æ³•ï¼Œåªè¦æ‰¾åˆ°ä¸€ä¸ªåŒ¹é…çš„å…³é”®è¯å°±ç«‹å³è¿”å› true
                return BANNED_API_KEYWORDS.some(keyword => lowercasedUrl.includes(keyword));
            }

            function isGoogleGeminiAPI(proxyUrl) {
                return proxyUrl && proxyUrl.includes('generativelanguage.googleapis.com');
            }

            async function makeAPIRequest(proxyUrl, apiKey, model, messages, temperature = 0.8) {
                if (isGoogleGeminiAPI(proxyUrl)) {

                    // WEB IMAGE ANALYSIS FEATURE: Enhanced Gemini API format with vision support
                    const contents = await Promise.all(messages.map(async msg => {
                        const role = msg.role === 'assistant' ? 'model' : 'user';
                        
                        // Handle vision analysis for images
                        if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url' && msg.isVisionAnalysis) {
                            try {
                                const imageUrl = msg.content[0].image_url.url;
                                let base64Data;
                                let mimeType;
                                
                                // Check if it's already a data URL (from phone upload)
                                if (imageUrl.startsWith('data:')) {
                                    const matches = imageUrl.match(/^data:([^;]+);base64,(.+)$/);
                                    if (matches) {
                                        mimeType = matches[1];
                                        base64Data = matches[2];
                                    } else {
                                        throw new Error('Invalid data URL format');
                                    }
                                } else {
                                    // Fetch web image and convert to base64
                                    const response = await fetch(imageUrl);
                                    const blob = await response.blob();
                                    base64Data = await new Promise(resolve => {
                                        const reader = new FileReader();
                                        reader.onloadend = () => resolve(reader.result.split(',')[1]);
                                        reader.readAsDataURL(blob);
                                    });
                                    mimeType = blob.type || "image/jpeg";
                                }
                                
                                return {
                                    role: role,
                                    parts: [
                                        { 
                                            inlineData: {
                                                mimeType: mimeType,
                                                data: base64Data
                                            }
                                        }
                                    ]
                                };
                            } catch (error) {
                                console.error('Failed to process image for Gemini:', error);
                                return {
                                    role: role,
                                    parts: [{ text: "[Image could not be processed for analysis]" }]
                                };
                            }
                        }
                        
                        // Handle regular content (text, non-vision images)
                        return {
                            role: role,
                            parts: [{ text: typeof msg.content === 'string' ? msg.content : "[User sent an image]" }]
                        };
                    }));



                    const response = await fetch(`${proxyUrl}/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: contents,
                            generationConfig: {
                                temperature: temperature
                            }
                        })
                    });



                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error(`[API Debug] Google API request failed:`, {
                            status: response.status,
                            statusText: response.statusText,
                            errorData: errorData
                        });
                        throw new Error(errorData.error?.message || 'Google API request failed');
                    }

                    const data = await response.json();

                    if (!data.candidates || !Array.isArray(data.candidates) || data.candidates.length === 0) {
                        throw new Error('Invalid Google API response: no candidates found');
                    }

                    // Convert Google response to OpenAI format
                    const convertedResponse = {
                        choices: [{
                            message: {
                                content: data.candidates[0]?.content?.parts[0]?.text || ''
                            }
                        }]
                    };

                    return convertedResponse;
                } else {
                    // OpenAI-compatible API format (existing)
                    const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: model,
                            messages: messages,
                            temperature: temperature
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error?.message || 'API request failed');
                    }

                    const data = await response.json();
                    return data;
                }
            }
            function showNotification(chatId, messageContent) { clearTimeout(notificationTimeout); const chat = state.chats[chatId]; if (!chat) return; const bar = document.getElementById('notification-bar'); document.getElementById('notification-avatar').src = chat.settings.aiAvatar || chat.settings.groupAvatar || defaultAvatar; document.getElementById('notification-content').querySelector('.name').textContent = chat.name; document.getElementById('notification-content').querySelector('.message').textContent = messageContent; const newBar = bar.cloneNode(true); bar.parentNode.replaceChild(newBar, bar); newBar.addEventListener('click', () => { openChat(chatId); newBar.classList.remove('visible'); }); newBar.classList.add('visible'); notificationTimeout = setTimeout(() => { newBar.classList.remove('visible'); }, 4000); }

            // WEB IMAGE ANALYSIS FEATURE: Handle web image URL input and create vision-enabled message
            async function showWebImageUrlPrompt() {
                if (!state.activeChatId) return;
                
                const imageUrl = await showCustomPrompt("ç½‘ç»œå›¾ç‰‡åˆ†æ", "è¯·è¾“å…¥å›¾ç‰‡URLï¼š");
                if (!imageUrl || !imageUrl.trim()) return;
                
                const chat = state.chats[state.activeChatId];
                // Create message with vision analysis flag
                const msg = { 
                    role: 'user', 
                    content: [{ type: 'image_url', image_url: { url: imageUrl.trim() } }], 
                    timestamp: Date.now(),
                    isVisionAnalysis: true // Flag for API processing
                };
                
                chat.history.push(msg);
                await db.chats.put(chat);
                appendMessage(msg, chat);
                renderChatList();
            }
            window.showWebImageUrlPrompt = showWebImageUrlPrompt;

            function updateClock() { const now = new Date(); const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' }); const dateString = now.toLocaleDateString('zh-CN', { weekday: 'long', month: 'long', day: 'numeric' }); document.getElementById('main-time').textContent = timeString; document.getElementById('status-bar-time').textContent = timeString; document.getElementById('main-date').textContent = dateString; }

            function parseAiResponse(content) {
                // Safety check for null/undefined/empty content
                if (!content || typeof content !== 'string') {
                    return [];
                }
                
                const trimmedContent = content.trim();
                
                // Check for empty content after trimming
                if (trimmedContent.length === 0) {
                    return [];
                }

                // 1. å°è¯•ä½œä¸ºå®Œæ•´çš„JSONæ•°ç»„è§£æ (æœ€ç†æƒ³æƒ…å†µ)
                if (trimmedContent.startsWith('[') && trimmedContent.endsWith(']')) {
                    try {
                        const parsed = JSON.parse(trimmedContent);
                        if (Array.isArray(parsed)) return parsed;
                    } catch (e) {
                        // è§£æå¤±è´¥ï¼Œç»§ç»­å°è¯•å…¶ä»–æ–¹æ³•
                    }
                }

                // 2. å¦‚æœå¤±è´¥ï¼Œå°è¯•ä½œä¸ºå•ä¸ªJSONå¯¹è±¡è§£æ (å¤„ç†AIâ€œå·æ‡’â€çš„æƒ…å†µ)
                if (trimmedContent.startsWith('{') && trimmedContent.endsWith('}')) {
                    try {
                        const parsed = JSON.parse(trimmedContent);
                        // å¦‚æœæˆåŠŸè§£æä¸ºå¯¹è±¡ï¼ŒæŠŠå®ƒæ”¾è¿›ä¸€ä¸ªæ•°ç»„é‡Œå†è¿”å›ï¼Œä»¥ç»Ÿä¸€æ ¼å¼
                        return [parsed];
                    } catch (e) {
                        // è§£æå¤±è´¥ï¼Œç»§ç»­å°è¯•å…¶ä»–æ–¹æ³•
                    }
                }

                // 3. å°è¯•è§£æå¤šä¸ªç‹¬ç«‹çš„JSONæ•°ç»„ (å¤„ç†AIè¿”å›å¤šä¸ª[{...}]çš„æƒ…å†µ)
                try {
                    const jsonArrayMatches = content.match(/\[.*?\]/g);
                    if (jsonArrayMatches && jsonArrayMatches.length > 1) {
                        const allMessages = [];
                        for (const jsonStr of jsonArrayMatches) {
                            try {
                                const parsed = JSON.parse(jsonStr);
                                if (Array.isArray(parsed)) {
                                    allMessages.push(...parsed);
                                }
                            } catch (e) {
                                // è·³è¿‡æ— æ•ˆçš„JSON
                            }
                        }
                        if (allMessages.length > 0) return allMessages;
                    }
                } catch (e) {
                    // è§£æå¤±è´¥
                }

                // 4. ä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆï¼Œå°è¯•ä»æ–‡æœ¬ä¸­æå–å•ä¸ªJSONæ•°ç»„
                try {
                    const match = content.match(/\[(.*?)\]/s);
                    if (match && match[0]) {
                        const parsed = JSON.parse(match[0]);
                        if (Array.isArray(parsed)) return parsed;
                    }
                } catch (e) {
                    // æå–å¤±è´¥
                }

                // 5. å¦‚æœä»¥ä¸Šå…¨éƒ¨å¤±è´¥ï¼Œåˆ™è§†ä¸ºçº¯æ–‡æœ¬å¤„ç†
                const lines = content.split('\n').map(l => l.trim()).filter(l => l.length > 0 && !l.startsWith('```'));
                if (lines.length > 0) return lines;

                // 6. æœ€ç»ˆçš„æœ€ç»ˆï¼Œè¿”å›åŸå§‹æ–‡æœ¬
                return [content];
            }

            function renderApiSettings() {
                document.getElementById('proxy-url').value = state.apiConfig.proxyUrl || ''; document.getElementById('api-key').value = state.apiConfig.apiKey || '';
                // â–¼â–¼â–¼ æ–°å¢è¿™è¡Œ â–¼â–¼â–¼
                document.getElementById('background-activity-switch').checked = state.globalSettings.enableBackgroundActivity || false;
                document.getElementById('background-interval-input').value = state.globalSettings.backgroundActivityInterval || 60;
                document.getElementById('block-cooldown-input').value = state.globalSettings.blockCooldownHours || 1;
            }
            window.renderApiSettingsProxy = renderApiSettings;

            // â–¼â–¼â–¼ è¯·ç”¨è¿™ä¸ªã€æ”¯æŒçŠ¶æ€ç¯å’Œæ—¶é—´æˆ³çš„å…¨æ–°ç‰ˆæœ¬ã€‘æ›¿æ¢æ—§çš„ renderChatList å’Œ createChatListItem å‡½æ•° â–¼â–¼â–¼

            /**
             * æ ¼å¼åŒ–æœ€åä¸€æ¡æ¶ˆæ¯çš„æ—¶é—´æˆ³
             * @param {number} timestamp - æ¶ˆæ¯çš„æ—¶é—´æˆ³
             * @returns {string} æ ¼å¼åŒ–åçš„æ—¶é—´å­—ç¬¦ä¸²
             */
            function formatLastMessageTime(timestamp) {
                if (!timestamp) return '';
                const now = new Date();
                const date = new Date(timestamp);

                // å¦‚æœæ˜¯ä»Šå¤©
                if (now.toDateString() === date.toDateString()) {
                    return `${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
                }

                // å¦‚æœæ˜¯æ˜¨å¤©
                const yesterday = new Date(now);
                yesterday.setDate(now.getDate() - 1);
                if (yesterday.toDateString() === date.toDateString()) {
                    return 'æ˜¨å¤©';
                }

                // å¦‚æœæ˜¯æ›´æ—©
                return `${date.getFullYear()}/${String(date.getMonth() + 1).padStart(2, '0')}/${String(date.getDate()).padStart(2, '0')}`;
            }

            async function renderChatList() {
                const chatListEl = document.getElementById('chat-list');
                chatListEl.innerHTML = '';

                const allChats = Object.values(state.chats).sort((a, b) => {
                    // First sort by pinned status (pinned chats first)
                    if (a.isPinned && !b.isPinned) return -1;
                    if (!a.isPinned && b.isPinned) return 1;

                    // Then sort by last message timestamp
                    const lastMsgA = a.history.slice(-1)[0] || {};
                    const lastMsgB = b.history.slice(-1)[0] || {};
                    return (lastMsgB.timestamp || 0) - (lastMsgA.timestamp || 0);
                });

                if (allChats.length === 0) {
                    chatListEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">ç‚¹å‡»å³ä¸Šè§’ "+" æˆ–ç¾¤ç»„å›¾æ ‡æ·»åŠ èŠå¤©</p>';
                    return;
                }

                const allGroups = await db.qzoneGroups.toArray();

                // è®¡ç®—æ¯ä¸ªåˆ†ç»„çš„æœ€æ–°æ—¶é—´æˆ³ï¼Œç”¨äºæ’åº
                allGroups.forEach(group => {
                    const latestChatInGroup = allChats
                        .filter(chat => chat.groupId === group.id)
                        .sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0))[0];
                    group.latestTimestamp = latestChatInGroup ? (latestChatInGroup.history.slice(-1)[0]?.timestamp || 0) : 0;
                });

                // æŒ‰æœ€æ–°æ—¶é—´æˆ³å¯¹åˆ†ç»„è¿›è¡Œé™åºæ’åº
                allGroups.sort((a, b) => b.latestTimestamp - a.latestTimestamp);

                // æ¸²æŸ“åˆ†ç»„çš„èŠå¤©
                allGroups.forEach(group => {
                    const groupChats = allChats.filter(chat => !chat.isGroup && chat.groupId === group.id);
                    if (groupChats.length === 0) return;

                    const groupContainer = document.createElement('div');
                    groupContainer.className = 'chat-group-container';
                    groupContainer.innerHTML = `
            <div class="chat-group-header">
                <span class="arrow">â–¼</span>
                <span class="group-name">${group.name} (${groupChats.length})</span>
            </div>
            <div class="chat-group-content"></div>
        `;
                    const contentEl = groupContainer.querySelector('.chat-group-content');

                    // ç¡®ä¿ç»„å†…çš„èŠå¤©ä¹ŸæŒ‰æ—¶é—´æ’åº
                    groupChats.sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0));

                    groupChats.forEach(chat => {
                        const item = createChatListItem(chat);
                        contentEl.appendChild(item);
                    });
                    chatListEl.appendChild(groupContainer);
                });

                // æ¸²æŸ“æœªåˆ†ç»„çš„èŠå¤©å’Œæ‰€æœ‰ç¾¤èŠ
                const ungroupedOrGroupChats = allChats.filter(chat => chat.isGroup || (!chat.isGroup && !chat.groupId));
                ungroupedOrGroupChats.forEach(chat => {
                    const item = createChatListItem(chat);
                    chatListEl.appendChild(item);
                });

                // ä¸ºæ‰€æœ‰æ–°ç”Ÿæˆçš„æŠ˜å ç®­å¤´ç»‘å®šäº‹ä»¶
                document.querySelectorAll('.chat-group-header').forEach(header => {
                    header.addEventListener('click', () => {
                        header.classList.toggle('collapsed');
                        header.nextElementSibling.classList.toggle('collapsed');
                    });
                });
            }


            function createChatListItem(chat) {
                const lastMsgObj = chat.history.filter(msg => !msg.isHidden).slice(-1)[0] || {};
                let lastMsgDisplay = '...';

                // æ ¹æ®æ¶ˆæ¯ç±»å‹ç”Ÿæˆé¢„è§ˆæ–‡æœ¬
                if (lastMsgObj.type === 'pat_message') { lastMsgDisplay = `[ç³»ç»Ÿæ¶ˆæ¯] ${lastMsgObj.content}`; }
                else if (lastMsgObj.type === 'transfer') { lastMsgDisplay = '[è½¬è´¦]'; }
                else if (lastMsgObj.type === 'ai_image' || lastMsgObj.type === 'user_photo') { lastMsgDisplay = '[ç…§ç‰‡]'; }
                else if (lastMsgObj.type === 'voice_message') { lastMsgDisplay = '[è¯­éŸ³]'; }
                else if (typeof lastMsgObj.content === 'string' && STICKER_REGEX.test(lastMsgObj.content)) { lastMsgDisplay = lastMsgObj.meaning ? `[è¡¨æƒ…: ${lastMsgObj.meaning}]` : '[è¡¨æƒ…]'; }
                else if (Array.isArray(lastMsgObj.content)) { lastMsgDisplay = `[å›¾ç‰‡]`; }
                else { lastMsgDisplay = String(lastMsgObj.content || '...').substring(0, 25); }

                if (chat.isGroup && lastMsgObj.senderName && lastMsgObj.type !== 'pat_message') {
                    lastMsgDisplay = `${lastMsgObj.senderName}: ${lastMsgDisplay}`;
                }

                // å¤„ç†ç‰¹æ®Šå…³ç³»çŠ¶æ€çš„æ˜¾ç¤º
                if (!chat.isGroup && chat.relationship?.status === 'pending_user_approval') {
                    lastMsgDisplay = `<span style="color: #ff8c00;">[å¥½å‹ç”³è¯·] ${chat.relationship.applicationReason || 'è¯·æ±‚æ·»åŠ ä½ ä¸ºå¥½å‹'}</span>`;
                } else if (!chat.isGroup && chat.relationship?.status === 'blocked_by_ai') {
                    lastMsgDisplay = `<span style="color: #dc3545;">[ä½ å·²è¢«å¯¹æ–¹æ‹‰é»‘]</span>`;
                }

                const item = document.createElement('div');
                item.className = 'chat-list-item';
                if (chat.isPinned) {
                    item.classList.add('pinned');
                }
                item.dataset.chatId = chat.id;
                const avatar = chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar;

                // **æ ¸å¿ƒHTMLç»“æ„ä¿®æ”¹**
                item.innerHTML = `
        <img src="${avatar || defaultAvatar}" class="avatar">
        <div class="info">
            <div class="name-line">
                <span class="name">${chat.name}</span>
                ${chat.isGroup ? '<span class="group-tag">ç¾¤èŠ</span>' : ''}
            </div>
            <div class="last-msg">${lastMsgDisplay}</div>
        </div>
        <div class="meta">
            <div class="timestamp">${formatLastMessageTime(lastMsgObj.timestamp)}</div>
            <div class="status-light ${chat.status || ''}"></div>
        </div>
    `;

                // â–¼â–¼â–¼ æ ¸å¿ƒä¿®æ”¹ï¼šä¸ºå¤´åƒæ·»åŠ æ™ºèƒ½çš„å•å‡»/åŒå‡»äº‹ä»¶å¤„ç†å™¨ â–¼â–¼â–¼
                const avatarEl = item.querySelector('.avatar');
                if (avatarEl) {
                    let clickTimer = null; // ç”¨äºå­˜å‚¨å•å‡»å»¶æ—¶å™¨çš„å˜é‡
                    let clickCount = 0;    // ç”¨äºè®°å½•ç‚¹å‡»æ¬¡æ•°çš„å˜é‡

                    avatarEl.addEventListener('click', (e) => {
                        e.stopPropagation(); // å…³é”®ï¼é˜»æ­¢äº‹ä»¶å†’æ³¡åˆ°çˆ¶å…ƒç´ ï¼Œé˜²æ­¢ç«‹å³è§¦å‘è¿›å…¥èŠå¤©

                        clickCount++;

                        if (clickCount === 1) {
                            // ç¬¬ä¸€æ¬¡ç‚¹å‡»æ—¶ï¼Œå¯åŠ¨ä¸€ä¸ªå®šæ—¶å™¨
                            clickTimer = setTimeout(() => {
                                // å¦‚æœå®šæ—¶å™¨æ­£å¸¸è§¦å‘ï¼ˆ300æ¯«ç§’å†…æ²¡æœ‰ç¬¬äºŒæ¬¡ç‚¹å‡»ï¼‰ï¼Œåˆ™æ‰§è¡Œå•å‡»æ“ä½œ
                                openChat(chat.id); // å•å‡»å¤´åƒè¿›å…¥èŠå¤©
                                clickCount = 0; // é‡ç½®ç‚¹å‡»è®¡æ•°
                            }, 300); // 300æ¯«ç§’æ˜¯ä¸€ä¸ªæ¯”è¾ƒèˆ’é€‚çš„åŒå‡»é—´éš”
                        } else if (clickCount === 2) {
                            // åœ¨å®šæ—¶å™¨è§¦å‘å‰ï¼Œç¬¬äºŒæ¬¡ç‚¹å‡»åˆ°æ¥äº†
                            clearTimeout(clickTimer); // æ¸…é™¤å³å°†æ‰§è¡Œçš„å•å‡»æ“ä½œ
                            clickCount = 0; // é‡ç½®ç‚¹å‡»è®¡æ•°

                            // ç«‹å³æ‰§è¡ŒåŒå‡»æ“ä½œ
                            handleUserPat(chat.id, chat.name); // åŒå‡»å¤´åƒè¿›è¡Œâ€œæ‹ä¸€æ‹â€
                        }
                    });
                }
                // â–²â–²â–² ä¿®æ”¹ç»“æŸ â–²â–²â–²

                item.addEventListener('click', (event) => {
                    // åªæœ‰å½“ç‚¹å‡»äº‹ä»¶çš„ç›®æ ‡ä¸æ˜¯å¤´åƒæ—¶ï¼Œæ‰ç«‹å³è¿›å…¥èŠå¤©
                    if (!event.target.classList.contains('avatar')) {
                        openChat(chat.id);
                    }
                });

                addLongPressListener(item, async (e) => {
                    showChatActions(chat.id);
                });

                return item;
            }


            function renderChatInterface(chatId) {
                cleanupWaimaiTimers();
                const chat = state.chats[chatId];
                if (!chat) return;
                exitSelectionMode();

                const messagesContainer = document.getElementById('chat-messages');
                const chatInputArea = document.getElementById('chat-input-area');
                const lockOverlay = document.getElementById('chat-lock-overlay');
                const lockContent = document.getElementById('chat-lock-content');

                messagesContainer.dataset.theme = chat.settings.theme || 'default';
                const fontSize = chat.settings.fontSize || 13;
                messagesContainer.style.setProperty('--chat-font-size', `${fontSize}px`);
                applyScopedCss(chat.settings.customCss || '', '#chat-messages', 'custom-bubble-style');

                document.getElementById('chat-header-title').textContent = chat.name;
                const statusContainer = document.getElementById('chat-header-status');
                const statusTextEl = statusContainer.querySelector('.status-text');

                if (chat.isGroup) {
                    statusContainer.style.display = 'none';
                    document.getElementById('chat-header-title-wrapper').style.justifyContent = 'center';
                } else {
                    statusContainer.style.display = 'flex';
                    document.getElementById('chat-header-title-wrapper').style.justifyContent = 'flex-start';
                    statusTextEl.textContent = chat.status?.text || 'åœ¨çº¿';
                    statusContainer.classList.toggle('busy', chat.status?.isBusy || false);
                }

                lockOverlay.style.display = 'none';
                chatInputArea.style.visibility = 'visible';
                lockContent.innerHTML = '';

                if (!chat.isGroup && chat.relationship.status !== 'friend') {
                    lockOverlay.style.display = 'flex';
                    chatInputArea.style.visibility = 'hidden';

                    let lockHtml = '';
                    switch (chat.relationship.status) {
                        case 'blocked_by_user':
                            // --- ã€æ ¸å¿ƒä¿®æ”¹ï¼šåœ¨è¿™é‡ŒåŠ å…¥è¯Šæ–­é¢æ¿ã€‘ ---
                            const isSimulationRunning = simulationIntervalId !== null;
                            const blockedTimestamp = chat.relationship.blockedTimestamp;
                            const cooldownHours = state.globalSettings.blockCooldownHours || 1;
                            const cooldownMilliseconds = cooldownHours * 60 * 60 * 1000;
                            const timeSinceBlock = Date.now() - blockedTimestamp;
                            const isCooldownOver = timeSinceBlock > cooldownMilliseconds;
                            const timeRemainingMinutes = Math.max(0, Math.ceil((cooldownMilliseconds - timeSinceBlock) / (1000 * 60)));

                            lockHtml = `
                    <span class="lock-text">ä½ å·²å°†â€œ${chat.name}â€æ‹‰é»‘ã€‚</span>
                    <button id="unblock-btn" class="lock-action-btn">è§£é™¤æ‹‰é»‘</button>
                    <div style="margin-top: 20px; padding: 10px; border: 1px dashed #ccc; border-radius: 8px; font-size: 11px; text-align: left; color: #666; background: rgba(0,0,0,0.02);">
                        <strong style="color: #333;">ã€å¼€å‘è€…è¯Šæ–­é¢æ¿ã€‘</strong><br>
                        - åå°æ´»åŠ¨æ€»å¼€å…³: ${state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">å·²å¼€å¯</span>' : '<span style="color: red;">å·²å…³é—­</span>'}<br>
                        - ç³»ç»Ÿå¿ƒè·³è®¡æ—¶å™¨: ${isSimulationRunning ? '<span style="color: green;">è¿è¡Œä¸­</span>' : '<span style="color: red;">æœªè¿è¡Œ</span>'}<br>
                        - å½“å‰è§’è‰²çŠ¶æ€: <strong>${chat.relationship.status}</strong><br>
                        - éœ€è¦å†·é™(å°æ—¶): <strong>${cooldownHours}</strong><br>
                        - å†·é™æœŸæ˜¯å¦ç»“æŸ: ${isCooldownOver ? '<span style="color: green;">æ˜¯</span>' : `<span style="color: orange;">å¦ (è¿˜å‰©çº¦ ${timeRemainingMinutes} åˆ†é’Ÿ)</span>`}<br>
                        - è§¦å‘æ¡ä»¶: ${isCooldownOver && state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">å·²æ»¡è¶³ï¼Œç­‰å¾…ä¸‹æ¬¡ç³»ç»Ÿå¿ƒè·³</span>' : '<span style="color: red;">æœªæ»¡è¶³</span>'}
                    </div>
                    <button id="force-apply-check-btn" class="lock-action-btn secondary" style="margin-top: 10px;">å¼ºåˆ¶è§¦å‘ä¸€æ¬¡å¥½å‹ç”³è¯·æ£€æµ‹</button>
                `;
                            // --- ã€ä¿®æ”¹ç»“æŸã€‘ ---
                            break;
                        case 'blocked_by_ai':
                            lockHtml = `
                    <span class="lock-text">ä½ è¢«å¯¹æ–¹æ‹‰é»‘äº†ã€‚</span>
                    <button id="apply-friend-btn" class="lock-action-btn">é‡æ–°ç”³è¯·åŠ ä¸ºå¥½å‹</button>
                `;
                            break;

                        case 'pending_user_approval':
                            lockHtml = `
                    <span class="lock-text">â€œ${chat.name}â€è¯·æ±‚æ·»åŠ ä½ ä¸ºå¥½å‹ï¼š<br><i>â€œ${chat.relationship.applicationReason}â€</i></span>
                    <button id="accept-friend-btn" class="lock-action-btn">æ¥å—</button>
                    <button id="reject-friend-btn" class="lock-action-btn secondary">æ‹’ç»</button>
                `;
                            break;

                        // ã€æ ¸å¿ƒä¿®æ­£ã€‘ä¿®å¤å½“ä½ ç”³è¯·åï¼Œä½ çœ‹åˆ°çš„ç•Œé¢
                        case 'pending_ai_approval':
                            lockHtml = `<span class="lock-text">å¥½å‹ç”³è¯·å·²å‘é€ï¼Œç­‰å¾…å¯¹æ–¹é€šè¿‡...</span>`;
                            break;
                    }
                    lockContent.innerHTML = lockHtml;
                }
                messagesContainer.innerHTML = '';
                // ...åç»­ä»£ç ä¿æŒä¸å˜
                const chatScreen = document.getElementById('chat-interface-screen');
                chatScreen.style.backgroundImage = chat.settings.background ? `url(${chat.settings.background})` : 'none';
                chatScreen.style.backgroundColor = chat.settings.background ? 'transparent' : '#f0f2f5';
                const history = chat.history;
                const totalMessages = history.length;
                currentRenderedCount = 0;
                const initialMessages = history.slice(-MESSAGE_RENDER_WINDOW);
                initialMessages.forEach(msg => appendMessage(msg, chat, true));
                currentRenderedCount = initialMessages.length;
                if (totalMessages > currentRenderedCount) {
                    prependLoadMoreButton(messagesContainer);
                }
                const typingIndicator = document.createElement('div');
                typingIndicator.id = 'typing-indicator';
                typingIndicator.style.display = 'none';
                typingIndicator.textContent = 'å¯¹æ–¹æ­£åœ¨è¾“å…¥...';
                messagesContainer.appendChild(typingIndicator);
                setTimeout(() => messagesContainer.scrollTop = messagesContainer.scrollHeight, 0);
            }
            // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

            function prependLoadMoreButton(container) { const button = document.createElement('button'); button.id = 'load-more-btn'; button.textContent = 'åŠ è½½æ›´æ—©çš„è®°å½•'; button.addEventListener('click', loadMoreMessages); container.prepend(button); }

            function loadMoreMessages() { const messagesContainer = document.getElementById('chat-messages'); const chat = state.chats[state.activeChatId]; if (!chat) return; const loadMoreBtn = document.getElementById('load-more-btn'); if (loadMoreBtn) loadMoreBtn.remove(); const totalMessages = chat.history.length; const nextSliceStart = totalMessages - currentRenderedCount - MESSAGE_RENDER_WINDOW; const nextSliceEnd = totalMessages - currentRenderedCount; const messagesToPrepend = chat.history.slice(Math.max(0, nextSliceStart), nextSliceEnd); const oldScrollHeight = messagesContainer.scrollHeight; messagesToPrepend.reverse().forEach(msg => prependMessage(msg, chat)); currentRenderedCount += messagesToPrepend.length; const newScrollHeight = messagesContainer.scrollHeight; messagesContainer.scrollTop += (newScrollHeight - oldScrollHeight); if (totalMessages > currentRenderedCount) { prependLoadMoreButton(messagesContainer); } }

            function renderWallpaperScreen() {
                const preview = document.getElementById('wallpaper-preview');
                const bg = newWallpaperBase64 || state.globalSettings.wallpaper;
                if (bg && bg.startsWith('data:image')) {
                    preview.style.backgroundImage = `url(${bg})`;
                    preview.textContent = '';
                } else if (bg) {
                    preview.style.backgroundImage = bg;
                    preview.textContent = 'å½“å‰ä¸ºæ¸å˜è‰²';
                }

                // Render app icon customization section
                renderAppIconCustomization();
            }

            function renderAppIconCustomization() {
                const container = document.getElementById('app-icon-customization-list');
                if (!container) return;



                // Define default app icons
                const defaultAppIcons = [
                    { id: 'qq', name: 'QQ', defaultUrl: 'https://files.catbox.moe/janu1z.png' },
                    { id: 'moments', name: 'æœ‹å‹åœˆ', defaultUrl: 'https://files.catbox.moe/65cdyc.png' },
                    { id: 'settings', name: 'è®¾ç½®', defaultUrl: 'https://files.catbox.moe/xmo1uf.png' },
                    { id: 'calendar', name: 'æ—¥å†', defaultUrl: 'https://files.catbox.moe/calendar.png' }
                ];

                container.innerHTML = '';

                defaultAppIcons.forEach(app => {
                    // Load from localStorage (same as charm CSS)
                    const currentUrl = localStorage.getItem(`appIcon_${app.id}`) || app.defaultUrl;

                    const appIconItem = document.createElement('div');
                    appIconItem.className = 'app-icon-item';

                    appIconItem.innerHTML = `
                        <div class="app-icon-preview">
                            <img src="${currentUrl}" alt="${app.name}">
                            <span>${app.name}</span>
                        </div>
                        <input type="file" 
                               id="app-icon-input-${app.id}" 
                               accept="image/*"
                               style="display: none;">
                        <div class="app-icon-actions">
                            <button onclick="updateAppIcon('${app.id}')" class="app-icon-btn primary">
                                åº”ç”¨
                            </button>
                            <button onclick="resetAppIcon('${app.id}', '${app.defaultUrl}')" class="app-icon-btn secondary">
                                é‡ç½®
                            </button>
                        </div>
                    `;

                    container.appendChild(appIconItem);
                });
            }

            window.updateAppIcon = async function (appId) {
                // Trigger file picker
                const fileInput = document.getElementById(`app-icon-input-${appId}`);
                if (!fileInput) return;
                
                // Set up one-time event listener for file selection
                fileInput.onchange = async (event) => {
                    const file = event.target.files[0];
                    if (!file) return;
                    
                    try {
                        // Compress image with smaller dimensions for app icons (256px max)
                        const compressedBase64 = await compressImage(file, 256, 0.85);
                        
                        // Save to localStorage (same as charm CSS)
                        localStorage.setItem(`appIcon_${appId}`, compressedBase64);

                        // Apply to home screen
                        applyAppIconsToHomeScreen();

                        // Re-render the customization section to show updated preview
                        renderAppIconCustomization();

                        showCustomAlert('æˆåŠŸ', 'å›¾æ ‡å·²æ›´æ–°');
                    } catch (error) {
                        showCustomAlert('é”™è¯¯', 'ä¿å­˜å›¾æ ‡å¤±è´¥: ' + error.message);
                    }
                    
                    // Reset file input
                    event.target.value = '';
                };
                
                // Trigger file picker
                fileInput.click();
            }

            window.resetAppIcon = function (appId, defaultUrl) {
                // Remove from localStorage (same as charm CSS reset)
                localStorage.removeItem(`appIcon_${appId}`);

                // Apply to home screen
                applyAppIconsToHomeScreen();

                // Re-render the customization section to show updated preview
                renderAppIconCustomization();

                showCustomAlert('æˆåŠŸ', 'å›¾æ ‡å·²é‡ç½®ä¸ºé»˜è®¤');
            }

            function applyAppIconsToHomeScreen() {
                const appIconMappings = {
                    'qq': '#app-grid .app-row:nth-child(2) .app-icon:nth-child(2) .icon-bg img', // First app icon (QQ)
                    'moments': '#app-grid .app-row:nth-child(2) .app-icon:nth-child(3) .icon-bg img', // Second app icon (æœ‹å‹åœˆ)
                    'calendar': '#app-grid .app-row:nth-child(2) .app-icon:nth-child(4) .icon-bg img', // Third app icon (æ—¥å†)
                    'settings': '#app-grid .app-row:nth-child(2) .app-icon:nth-child(5) .icon-bg img' // Fourth app icon (è®¾ç½®)
                };

                Object.keys(appIconMappings).forEach(appId => {
                    // Load from localStorage (same as charm CSS)
                    const iconUrl = localStorage.getItem(`appIcon_${appId}`);
                    if (iconUrl) {
                        const imgElement = document.querySelector(appIconMappings[appId]);
                        if (imgElement) {
                            imgElement.src = iconUrl;
                        }
                    }
                });
            }
            window.renderWallpaperScreenProxy = renderWallpaperScreen;

            function applyGlobalWallpaper() { const homeScreen = document.getElementById('home-screen'); const wallpaper = state.globalSettings.wallpaper; if (wallpaper && wallpaper.startsWith('data:image')) homeScreen.style.backgroundImage = `url(${wallpaper})`; else if (wallpaper) homeScreen.style.backgroundImage = wallpaper; }

            function renderWorldBookScreen() { const listEl = document.getElementById('world-book-list'); listEl.innerHTML = ''; if (state.worldBooks.length === 0) { listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">ç‚¹å‡»å³ä¸Šè§’ "+" åˆ›å»ºä½ çš„ç¬¬ä¸€æœ¬ä¸–ç•Œä¹¦</p>'; return; } state.worldBooks.forEach(book => { const item = document.createElement('div'); item.className = 'list-item'; item.dataset.bookId = book.id; item.innerHTML = `<div class="item-title">${book.name}</div><div class="item-content">${(book.content || 'æš‚æ— å†…å®¹...').substring(0, 50)}</div>`; item.addEventListener('click', () => openWorldBookEditor(book.id)); addLongPressListener(item, async () => { const confirmed = await showCustomConfirm('åˆ é™¤ä¸–ç•Œä¹¦', `ç¡®å®šè¦åˆ é™¤ã€Š${book.name}ã€‹å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await db.worldBooks.delete(book.id); state.worldBooks = state.worldBooks.filter(wb => wb.id !== book.id); renderWorldBookScreen(); } }); listEl.appendChild(item); }); }
            window.renderWorldBookScreenProxy = renderWorldBookScreen;

            function renderSettingsScreen() {
                const listEl = document.getElementById('settings-list');
                listEl.innerHTML = '';

                // APIè®¾ç½® section
                const apiItem = document.createElement('div');
                apiItem.className = 'list-item';
                apiItem.innerHTML = `<div class="item-title">APIè®¾ç½®</div><div class="item-content">é…ç½®APIå¯†é’¥å’Œæ¨¡å‹</div>`;
                apiItem.addEventListener('click', () => showScreen('api-settings-screen'));
                listEl.appendChild(apiItem);

                // ä¸–ç•Œä¹¦ section
                const worldBookItem = document.createElement('div');
                worldBookItem.className = 'list-item';
                worldBookItem.innerHTML = `<div class="item-title">ä¸–ç•Œä¹¦</div><div class="item-content">ç®¡ç†è§’è‰²è®¾å®šå’Œä¸–ç•Œè§‚</div>`;
                worldBookItem.addEventListener('click', () => showScreen('world-book-screen'));
                listEl.appendChild(worldBookItem);

                // å¤–è§‚è®¾ç½® section
                const appearanceItem = document.createElement('div');
                appearanceItem.className = 'list-item';
                appearanceItem.innerHTML = `<div class="item-title">å¤–è§‚è®¾ç½®</div><div class="item-content">å£çº¸ã€å­—ä½“å’ŒæŒ‚ä»¶æ ·å¼</div>`;
                appearanceItem.addEventListener('click', () => showScreen('appearance-settings-screen'));
                listEl.appendChild(appearanceItem);

                // é€šç”¨è®¾ç½® section
                const generalItem = document.createElement('div');
                generalItem.className = 'list-item';
                generalItem.innerHTML = `<div class="item-title">é€šç”¨è®¾ç½®</div><div class="item-content">åº”ç”¨é€šç”¨é…ç½®é€‰é¡¹</div>`;
                generalItem.addEventListener('click', () => showScreen('general-settings-screen'));
                listEl.appendChild(generalItem);

                // å¤‡ä»½æ–‡ä»¶ section
                const backupItem = document.createElement('div');
                backupItem.className = 'list-item';
                backupItem.innerHTML = `<div class="item-title">å¤‡ä»½æ–‡ä»¶</div><div class="item-content">å¯¼å‡ºã€å¯¼å…¥å’Œäº‘ç«¯å¤‡ä»½</div>`;
                backupItem.addEventListener('click', () => showScreen('backup-screen'));
                listEl.appendChild(backupItem);
            }
            window.renderSettingsScreenProxy = renderSettingsScreen;

            function renderGeneralSettingsScreen() {
                const listEl = document.getElementById('general-settings-list');
                listEl.innerHTML = '';

                // ç…§ç‰‡å‹ç¼© section
                const compressionItem = document.createElement('div');
                compressionItem.className = 'list-item no-hover';
                compressionItem.style.display = 'flex';
                compressionItem.style.flexDirection = 'row';
                compressionItem.style.justifyContent = 'space-between';
                compressionItem.style.alignItems = 'center';
                compressionItem.style.cursor = 'default';

                compressionItem.innerHTML = `
                    <div>
                        <div class="item-title">ç…§ç‰‡å‹ç¼©</div>
                        <div class="item-content">å‹ç¼©ä¸Šä¼ çš„ç…§ç‰‡ä»¥èŠ‚çœå­˜å‚¨ç©ºé—´</div>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="photo-compression-toggle" checked>
                        <span class="slider round"></span>
                    </label>
                `;

                listEl.appendChild(compressionItem);

                // Add event listener after element is created
                const toggle = document.getElementById('photo-compression-toggle');
                if (toggle) {
                    toggle.addEventListener('change', async (e) => {
                        state.globalSettings.photoCompression = e.target.checked;
                        await db.globalSettings.put(state.globalSettings);
                    });
                }


            }
            window.renderGeneralSettingsScreenProxy = renderGeneralSettingsScreen;

            // Global calendar variables
            let calendarToday = new Date();
            let currentMonth = calendarToday.getMonth();
            let currentYear = calendarToday.getFullYear();
            let selectedDate = calendarToday;

            function renderCalendarScreen() {
                // Prevent duplicate event listeners by checking if already initialized
                if (!window.calendarInitialized) {
                    window.calendarInitialized = true;

                    // Event listeners for month navigation
                    document.getElementById('prev-month-btn').addEventListener('click', () => {
                        currentMonth--;
                        if (currentMonth < 0) {
                            currentMonth = 11;
                            currentYear--;
                        }
                        updateCalendar();
                    });

                    document.getElementById('next-month-btn').addEventListener('click', () => {
                        currentMonth++;
                        if (currentMonth > 11) {
                            currentMonth = 0;
                            currentYear++;
                        }
                        updateCalendar();
                    });

                    // Event listeners for day navigation
                    document.getElementById('prev-day-btn').addEventListener('click', () => {
                        selectedDate.setDate(selectedDate.getDate() - 1);
                        updateCalendar();
                        updateSelectedDate();
                    });

                    document.getElementById('next-day-btn').addEventListener('click', () => {
                        selectedDate.setDate(selectedDate.getDate() + 1);
                        updateCalendar();
                        updateSelectedDate();
                    });

                    // Calendar add button
                    document.getElementById('calendar-add-btn').addEventListener('click', () => {
                        document.getElementById('add-memory-type-modal').classList.add('visible');
                    });
                }

                function updateCalendar() {
                    // Update month/year display
                    const monthNames = ['1æœˆ', '2æœˆ', '3æœˆ', '4æœˆ', '5æœˆ', '6æœˆ', '7æœˆ', '8æœˆ', '9æœˆ', '10æœˆ', '11æœˆ', '12æœˆ'];
                    document.getElementById('calendar-month-year').textContent = `${currentYear}å¹´${monthNames[currentMonth]}`;

                    // Generate calendar grid
                    const firstDay = new Date(currentYear, currentMonth, 1);
                    const lastDay = new Date(currentYear, currentMonth + 1, 0);
                    const startDate = new Date(firstDay);
                    startDate.setDate(startDate.getDate() - firstDay.getDay());

                    const calendarGrid = document.getElementById('calendar-grid');
                    calendarGrid.innerHTML = '';

                    for (let i = 0; i < 35; i++) {
                        const date = new Date(startDate);
                        date.setDate(startDate.getDate() + i);

                        const dateElement = document.createElement('div');
                        dateElement.className = 'calendar-date';
                        dateElement.textContent = date.getDate();
                        dateElement.dataset.fullDate = date.toDateString();

                        if (date.getMonth() !== currentMonth) {
                            dateElement.classList.add('other-month');
                        }

                        if (date.toDateString() === calendarToday.toDateString()) {
                            dateElement.classList.add('today');
                        }

                        if (date.toDateString() === selectedDate.toDateString()) {
                            dateElement.classList.add('selected');
                        }

                        dateElement.addEventListener('click', () => {
                            selectedDate = new Date(date);
                            updateCalendar();
                            updateSelectedDate();
                        });

                        calendarGrid.appendChild(dateElement);
                    }

                    // Add memory indicators after calendar is built
                    addMemoryIndicators();
                }

                // Function to add memory indicators to calendar dates
                async function addMemoryIndicators() {
                    try {
                        // Get all memories
                        const allMemories = await db.memories.toArray();

                        // Group memories by date and categorize by type
                        const memoriesByDate = {};
                        allMemories.forEach(memory => {
                            let memoryDate;

                            if (memory.type === 'ai_generated') {
                                memoryDate = new Date(memory.timestamp);
                            } else if (memory.type === 'countdown' && memory.targetDate) {
                                memoryDate = new Date(memory.targetDate);
                            } else if (memory.type === 'meetup') {
                                memoryDate = new Date(memory.timestamp);
                            } else {
                                return;
                            }

                            const dateKey = memoryDate.toDateString();
                            if (!memoriesByDate[dateKey]) {
                                memoriesByDate[dateKey] = {
                                    userMemory: false,
                                    aiMemory: false,
                                    countdown: false,
                                    meetup: false
                                };
                            }

                            // Categorize memory types
                            if (memory.type === 'countdown') {
                                memoriesByDate[dateKey].countdown = true;
                            } else if (memory.type === 'meetup') {
                                memoriesByDate[dateKey].meetup = true;
                            } else if (memory.type === 'ai_generated') {
                                if (memory.chatId === 'manual') {
                                    memoriesByDate[dateKey].userMemory = true;
                                } else {
                                    memoriesByDate[dateKey].aiMemory = true;
                                }
                            }
                        });

                        // Add indicators to calendar dates
                        document.querySelectorAll('.calendar-date').forEach(dateElement => {
                            // Remove existing indicators
                            const existingIndicators = dateElement.querySelector('.memory-indicators');
                            if (existingIndicators) {
                                existingIndicators.remove();
                            }

                            // Get the actual date for this element
                            const dateKey = dateElement.dataset.fullDate;

                            // Check if this date has memories
                            if (memoriesByDate[dateKey]) {
                                const indicatorsContainer = document.createElement('div');
                                indicatorsContainer.className = 'memory-indicators';

                                // Add dots in order: blue (user), yellow (AI), purple (countdown)
                                if (memoriesByDate[dateKey].userMemory) {
                                    const dot = document.createElement('div');
                                    dot.className = 'memory-indicator user-memory';
                                    indicatorsContainer.appendChild(dot);
                                }

                                if (memoriesByDate[dateKey].aiMemory) {
                                    const dot = document.createElement('div');
                                    dot.className = 'memory-indicator ai-memory';
                                    indicatorsContainer.appendChild(dot);
                                }

                                if (memoriesByDate[dateKey].countdown) {
                                    const dot = document.createElement('div');
                                    dot.className = 'memory-indicator countdown';
                                    indicatorsContainer.appendChild(dot);
                                }

                                if (memoriesByDate[dateKey].meetup) {
                                    const dot = document.createElement('div');
                                    dot.className = 'memory-indicator meetup';
                                    indicatorsContainer.appendChild(dot);
                                }

                                dateElement.appendChild(indicatorsContainer);
                            }
                        });



                    } catch (error) {
                        console.error('Error adding memory indicators:', error);
                    }
                }

                async function updateSelectedDate() {
                    const options = { month: 'long', day: 'numeric' };
                    const dateStr = selectedDate.toLocaleDateString('zh-CN', options);
                    document.getElementById('selected-date-display').textContent = dateStr;

                    // NEW: Load and display memories for selected date
                    const memories = await getMemoriesForDate(selectedDate);
                    renderCalendarMemories(memories);
                }



                // Initialize calendar
                updateCalendar();
                updateSelectedDate();

                // Refresh status indicators to show current meetup state
                setTimeout(() => {
                    if (typeof refreshCalendarStatusIndicators === 'function') {
                        refreshCalendarStatusIndicators();
                    }
                }, 100); // Small delay to ensure DOM is updated
            }

            // NEW: Function to get memories for a specific date
            async function getMemoriesForDate(selectedDate) {
                try {
                    // Use same query as memories screen - completely safe
                    const allMemories = await db.memories.toArray();


                    // Filter memories for the selected date
                    const selectedDateStr = selectedDate.toDateString();
                    const memoriesForDate = allMemories.filter(memory => {
                        let memoryDate;

                        // For regular memories, use timestamp (creation date)
                        if (memory.type === 'ai_generated') {
                            memoryDate = new Date(memory.timestamp);
                        }
                        // For countdowns, use targetDate (appointment date)
                        else if (memory.type === 'countdown' && memory.targetDate) {
                            memoryDate = new Date(memory.targetDate);
                        }
                        // For date mode events, use targetDate if available, otherwise timestamp
                        else if (memory.type === 'meetup') {
                            // Use targetDate if it exists (for events that were originally countdowns)
                            // Otherwise use timestamp (for events that were originally meetups)
                            memoryDate = memory.targetDate ? new Date(memory.targetDate) : new Date(memory.timestamp);

                        }
                        else {
                            return false; // Skip if no valid date
                        }

                        return memoryDate.toDateString() === selectedDateStr;
                    });


                    return memoriesForDate;

                } catch (error) {
                    console.error('Error loading memories:', error);
                    return [];
                }
            }

            // NEW: Function to display memories in the events section
            function renderCalendarMemories(memories) {
                const eventsListEl = document.getElementById('calendar-events-list');

                if (memories.length === 0) {

                    eventsListEl.innerHTML = '<div class="no-events-message">æ²¡æœ‰äº‹ä»¶</div>';
                    return;
                }

                // Sort memories by their actual date/time (most recent first)
                memories.sort((a, b) => {
                    let aTime, bTime;

                    // For memories, use timestamp (actual memory time)
                    if (a.type === 'ai_generated') {
                        aTime = a.timestamp;
                    }
                    // For countdowns, use targetDate (actual event time)
                    else if (a.type === 'countdown' && a.targetDate) {
                        aTime = a.targetDate;
                    }
                    // For date mode, use targetDate if available (for converted countdowns), otherwise timestamp
                    else if (a.type === 'meetup') {
                        aTime = a.targetDate ? a.targetDate : a.timestamp;
                    } else {
                        aTime = a.timestamp; // fallback
                    }

                    if (b.type === 'ai_generated') {
                        bTime = b.timestamp;
                    }
                    else if (b.type === 'countdown' && b.targetDate) {
                        bTime = b.targetDate;
                    }
                    else if (b.type === 'meetup') {
                        bTime = b.targetDate ? b.targetDate : b.timestamp;
                    } else {
                        bTime = b.timestamp; // fallback
                    }

                    return bTime - aTime; // Most recent first
                });

                eventsListEl.innerHTML = '';

                memories.forEach(memory => {
                    const memoryItem = document.createElement('div');
                    memoryItem.className = 'calendar-memory-item';
                    memoryItem.dataset.memoryId = memory.id;

                    // Add type-specific class for styling
                    if (memory.type === 'ai_generated') {
                        memoryItem.classList.add('memory-type');
                    } else if (memory.type === 'countdown') {
                        memoryItem.classList.add('countdown-type');
                    } else if (memory.type === 'meetup') {
                        memoryItem.classList.add('meetup-type');
                    }

                    // Format time for display
                    let timeStr = '';
                    if (memory.type === 'ai_generated') {
                        const time = new Date(memory.timestamp);
                        timeStr = time.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                    } else if (memory.type === 'countdown' && memory.targetDate) {
                        const time = new Date(memory.targetDate);
                        timeStr = time.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                    } else if (memory.type === 'meetup') {
                        // Use targetDate if available (for events that were originally countdowns)
                        // Otherwise use timestamp (for events that were originally meetups)
                        const time = memory.targetDate ? new Date(memory.targetDate) : new Date(memory.timestamp);
                        timeStr = time.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                    }

                    // Get character avatar - fix for manual memories
                    let authorAvatar = 'https://files.catbox.moe/q6z5fc.jpeg'; // default avatar
                    if (memory.chatId === 'manual') {
                        // For manually added memories, use user's avatar from äººè®¾åº“
                        authorAvatar = state.qzoneSettings.avatar || 'https://files.catbox.moe/q6z5fc.jpeg';
                    } else if (state.chats[memory.chatId]) {
                        authorAvatar = state.chats[memory.chatId].settings.aiAvatar;
                    }

                    // Determine status indicator for meetup/countdown events
                    let statusIndicator = '';
                    let typeLabel = '';

                    if (memory.type === 'meetup') {
                        // Check if this is the currently active meetup
                        if (window.activeMeetupEventId === memory.id) {
                            statusIndicator = '<span class="meetup-status-indicator active">ğŸŸ¢ è¿›è¡Œä¸­</span>';
                            typeLabel = 'è§é¢';
                        } else if (hasActualMeetupHistory(memory)) {
                            statusIndicator = '<span class="meetup-indicator"><svg width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="10" width="36" height="32" rx="2" stroke="currentColor" stroke-width="4" stroke-linejoin="round"/><path d="M14 6V14" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/><path d="M34 6V14" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/><path d="M6 18H42" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="28" r="2" fill="currentColor"/><circle cx="24" cy="28" r="2" fill="currentColor"/><circle cx="32" cy="28" r="2" fill="currentColor"/><path d="M20 32C20 30 22 30 24 32C26 30 28 30 28 32" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></span>';
                            typeLabel = 'è§é¢';
                        } else {
                            // No indicator for meetup templates - absence of calendar icon indicates no history
                            statusIndicator = '';
                            typeLabel = 'è§é¢';
                        }
                    } else if (memory.type === 'countdown') {
                        // No indicator for countdown events - absence of calendar icon indicates it's a template
                        statusIndicator = '';
                        typeLabel = 'çº¦å®š';
                    } else {
                        typeLabel = 'å›å¿†';
                    }

                    // Create memory display using exact same structure as memories screen
                    memoryItem.innerHTML = `
                        <div class="memory-header">
                            <img class="memory-avatar" src="${authorAvatar}" alt="${memory.authorName}">
                            <div class="memory-info">
                                <div class="memory-nickname">${memory.authorName}</div>
                                <div class="memory-timestamp">${timeStr} â€¢ ${typeLabel}</div>
                            </div>
                            <div class="memory-actions">
                                ${statusIndicator}
                                <button class="post-actions-btn" onclick="showMemoryActions('${memory.id}')" style="-webkit-tap-highlight-color: transparent; -webkit-touch-callout: none; -webkit-user-select: none; border: none; background: none; font-family: inherit; font-size: 24px; font-weight: inherit;">â€¦</button>
                            </div>
                        </div>
                        <div class="memory-content">${memory.description}</div>
                    `;



                    // Enhanced click handler for all meetup and countdown events
                    if (memory.type === 'meetup' || memory.type === 'countdown') {
                        memoryItem.style.cursor = 'pointer';
                        memoryItem.addEventListener('click', function (e) {
                            // Don't trigger if clicking on the actions button
                            if (e.target.closest('.post-actions-btn')) {
                                return;
                            }
                            handleCalendarEventClick(memory);
                        });
                    }

                    eventsListEl.appendChild(memoryItem);
                });



                // Add 8px invisible spacer at bottom - updated
                const spacer = document.createElement('div');
                spacer.style.height = '8px';
                eventsListEl.appendChild(spacer);
            }

            // Helper function to check if a memory has actual meetup history
            function hasActualMeetupHistory(memory) {
                if (memory.type !== 'meetup') return false;
                if (!memory.meetupData) return false;
                if (!memory.meetupData.messages) return false;
                return memory.meetupData.messages.length > 0;
            }

            // Make helper function globally available for calendar rendering
            window.hasActualMeetupHistory = hasActualMeetupHistory;

            // Enhanced calendar event click handler
            function handleCalendarEventClick(memory) {


                if (memory.type === 'meetup') {
                    // Scenario 1: Check if this is the currently active meetup
                    if (window.activeMeetupEventId === memory.id) {

                        // Resume active meetup - go directly to meetup screen
                        showScreen('meetup-screen');
                        return;
                    }

                    // Scenario 2: Check if it has completed history
                    if (hasActualMeetupHistory(memory)) {
                        // View completed meetup history
                        openMeetupHistory(memory.id);
                        return;
                    }
                }

                // Scenario 3: For AI-created events or events without history
                if (memory.type === 'countdown' || (memory.type === 'meetup' && !hasActualMeetupHistory(memory))) {

                    // Start new meetup with prefilled data
                    openMeetupCreationModalWithPrefill(memory);
                }
            }

            // Function to open meetup creation modal with prefilled data
            function openMeetupCreationModalWithPrefill(memory) {


                // Only proceed if we have a valid chatId (not manual events for now)
                if (!memory.chatId || memory.chatId === 'manual') {

                    // For user-created events, we'll handle this in the future
                    showCustomAlert('æç¤º', 'ç”¨æˆ·åˆ›å»ºçš„äº‹ä»¶æš‚ä¸æ”¯æŒç›´æ¥è¿›å…¥è§é¢æ¨¡å¼ï¼Œè¯·ä»èŠå¤©ç•Œé¢å¼€å§‹è§é¢ã€‚');
                    return;
                }

                // Check if the chat still exists
                const chat = state.chats[memory.chatId];
                if (!chat) {
                    showCustomAlert('é”™è¯¯', 'æ— æ³•æ‰¾åˆ°ç›¸å…³çš„èŠå¤©å¯¹è±¡ï¼Œå¯èƒ½å·²è¢«åˆ é™¤ã€‚');
                    return;
                }

                // Check if it's a group chat (meetup mode should be for individual chats)
                if (chat.isGroup) {
                    showCustomAlert('æç¤º', 'è§é¢æ¨¡å¼ä»…æ”¯æŒå•äººèŠå¤©ï¼Œä¸æ”¯æŒç¾¤èŠã€‚');
                    return;
                }

                // Set up the chat context
                window.currentDateChatContext = {
                    chatId: memory.chatId,
                    chatName: chat.name || 'èŠå¤©å¯¹è±¡',
                    aiName: chat.name || 'AI',
                    isGroup: chat.isGroup || false,
                    originalMemoryId: memory.id // Store the original memory ID
                };



                // Prefill the modal with event data
                document.getElementById('meetup-location-input').value = '';
                document.getElementById('meetup-title-input').value = memory.description || '';

                // Show the modal
                const modal = document.getElementById('meetup-creation-modal');
                modal.classList.add('visible');
            }

            // Function to refresh calendar status indicators (useful when meetup status changes)
            function refreshCalendarStatusIndicators() {
                const calendarItems = document.querySelectorAll('.calendar-memory-item');
                calendarItems.forEach(item => {
                    const memoryId = item.dataset.memoryId;
                    if (memoryId && window.activeMeetupEventId === parseInt(memoryId)) {
                        // Update to show active status
                        const statusIndicator = item.querySelector('.meetup-status-indicator');
                        if (statusIndicator && !statusIndicator.classList.contains('active')) {
                            statusIndicator.textContent = 'ğŸŸ¢ è¿›è¡Œä¸­';
                            statusIndicator.className = 'meetup-status-indicator active';
                        }
                    }
                });
            }

            window.renderCalendarScreenProxy = renderCalendarScreen;
            window.showMemoryActions = showMemoryActions;
            window.handleCalendarEventClick = handleCalendarEventClick;
            window.hasActualMeetupHistory = hasActualMeetupHistory;
            window.refreshCalendarStatusIndicators = refreshCalendarStatusIndicators;
            window.openMeetupCreationModalWithPrefill = openMeetupCreationModalWithPrefill;



            function openWorldBookEditor(bookId) { editingWorldBookId = bookId; const book = state.worldBooks.find(wb => wb.id === bookId); if (!book) return; document.getElementById('world-book-editor-title').textContent = book.name; document.getElementById('world-book-name-input').value = book.name; document.getElementById('world-book-content-input').value = book.content; showScreen('world-book-editor-screen'); }

            function renderStickerPanel() { const grid = document.getElementById('sticker-grid'); grid.innerHTML = ''; if (state.userStickers.length === 0) { grid.innerHTML = '<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1;">å¤§äººè¯·ç‚¹å‡»å³ä¸Šè§’â€œæ·»åŠ â€æˆ–â€œä¸Šä¼ â€æ¥æ·»åŠ ä½ çš„ç¬¬ä¸€ä¸ªè¡¨æƒ…å§ï¼</p>'; return; } state.userStickers.forEach(sticker => { const item = document.createElement('div'); item.className = 'sticker-item'; item.style.backgroundImage = `url(${sticker.url})`; item.title = sticker.name; item.addEventListener('click', () => sendSticker(sticker)); addLongPressListener(item, () => { const existingDeleteBtn = item.querySelector('.delete-btn'); if (existingDeleteBtn) return; const deleteBtn = document.createElement('div'); deleteBtn.className = 'delete-btn'; deleteBtn.innerHTML = '&times;'; deleteBtn.onclick = async (e) => { e.stopPropagation(); const confirmed = await showCustomConfirm('åˆ é™¤è¡¨æƒ…', `ç¡®å®šè¦åˆ é™¤è¡¨æƒ… "${sticker.name}" å—ï¼Ÿ`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await db.userStickers.delete(sticker.id); state.userStickers = state.userStickers.filter(s => s.id !== sticker.id); renderStickerPanel(); } }; item.appendChild(deleteBtn); deleteBtn.style.display = 'block'; setTimeout(() => item.addEventListener('mouseleave', () => deleteBtn.remove(), { once: true }), 3000); }); grid.appendChild(item); }); }

            // Global variable to track current sticker pack
            let currentStickerPack = 'all';

            // Storage for sticker pack data
            let stickerPackData = {
                'all': {
                    name: 'å…¨éƒ¨è¡¨æƒ…',
                    icon: ''
                },
                'pack1': {
                    name: 'è¡¨æƒ…åŒ… 2',
                    icon: 'https://files.catbox.moe/r1khrr.gif'
                }
            };

            // Store the original renderStickerPanel function
            const originalRenderStickerPanel = renderStickerPanel;

            // Override renderStickerPanel with pack filtering
            function renderStickerPanel() {
                const grid = document.getElementById('sticker-grid');
                grid.innerHTML = '';

                // Always add the "add sticker" square as the first item
                const addSquare = document.createElement('div');
                addSquare.className = 'add-sticker-square';
                addSquare.innerHTML = `
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="12" y1="5" x2="12" y2="19"></line>
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                `;
                addSquare.addEventListener('click', () => {
                    // Hide the sticker panel first
                    document.getElementById('sticker-panel').classList.remove('visible');

                    // Use the preset-actions-modal for consistency
                    const actionsModal = document.getElementById('preset-actions-modal');
                    const modalContent = actionsModal.querySelector('.custom-modal-footer');

                    // Populate modal with add sticker options
                    modalContent.innerHTML = `
                        <button data-action="add-url">æ·»åŠ  (URL)</button>
                        <button data-action="upload">ä¸Šä¼ æ–‡ä»¶</button>
                        <button data-action="cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">å–æ¶ˆ</button>
                    `;

                    // Show modal
                    actionsModal.classList.add('visible');

                    // Handle button clicks
                    const handleActionClick = async (e) => {
                        const action = e.target.dataset.action;
                        if (!action) return;

                        actionsModal.classList.remove('visible');
                        modalContent.removeEventListener('click', handleActionClick);

                        switch (action) {
                            case 'add-url':
                                // URL option
                                const url = await showCustomPrompt("æ·»åŠ è¡¨æƒ…(URL)", "è¯·è¾“å…¥è¡¨æƒ…åŒ…çš„å›¾ç‰‡URL");
                                if (!url || !url.trim().startsWith('http')) {
                                    if (url) alert("è¯·è¾“å…¥æœ‰æ•ˆçš„URL (ä»¥httpå¼€å¤´)");
                                    document.getElementById('sticker-panel').classList.add('visible');
                                    return;
                                }
                                const name = await showCustomPrompt("å‘½åè¡¨æƒ…", "è¯·ä¸ºè¿™ä¸ªè¡¨æƒ…å‘½å (ä¾‹å¦‚ï¼šå¼€å¿ƒã€ç–‘æƒ‘)");
                                if (name && name.trim()) {
                                    const newSticker = {
                                        id: 'sticker_' + Date.now(),
                                        url: url.trim(),
                                        name: name.trim(),
                                        order: state.userStickers.length,
                                        packId: currentStickerPack
                                    };
                                    await db.userStickers.add(newSticker);
                                    state.userStickers.push(newSticker);
                                    // Show sticker panel again and refresh
                                    document.getElementById('sticker-panel').classList.add('visible');
                                    renderStickerPanel();
                                } else if (name !== null) {
                                    alert("è¡¨æƒ…åä¸èƒ½ä¸ºç©ºï¼");
                                    document.getElementById('sticker-panel').classList.add('visible');
                                } else {
                                    // User cancelled naming, show panel again
                                    document.getElementById('sticker-panel').classList.add('visible');
                                }
                                break;
                            case 'upload':
                                // Upload option
                                document.getElementById('sticker-upload-input').click();
                                break;
                            case 'cancel':
                                // Just show sticker panel again
                                document.getElementById('sticker-panel').classList.add('visible');
                                break;
                        }
                    };

                    modalContent.addEventListener('click', handleActionClick);
                });
                grid.appendChild(addSquare);

                // Filter stickers based on current pack
                let stickersToShow = state.userStickers.filter(sticker => sticker.packId === currentStickerPack);

                // Add message if no stickers (but still show the add square)
                if (stickersToShow.length === 0) {
                    const message = document.createElement('p');
                    message.style.cssText = 'text-align:center; color: var(--text-secondary); grid-column: 1 / -1; margin-top: 20px;';
                    message.textContent = 'è¿™ä¸ªè¡¨æƒ…åŒ…è¿˜æ²¡æœ‰è¡¨æƒ…ï¼Œç‚¹å‡» + æ¥æ·»åŠ ';
                    grid.appendChild(message);
                    return;
                }

                stickersToShow.forEach(sticker => {
                    const item = document.createElement('div');
                    item.className = 'sticker-item';
                    item.style.backgroundImage = `url(${sticker.url})`;
                    item.title = sticker.name;

                    if (isArrangeMode) {
                        // In arrange mode: add delete button and touch-based drag functionality
                        item.style.position = 'relative';
                        item.style.cursor = 'move'; // Show move cursor to indicate draggable

                        // Add red delete button
                        const deleteBtn = document.createElement('div');
                        deleteBtn.className = 'arrange-delete-btn';
                        deleteBtn.innerHTML = 'Ã—';
                        deleteBtn.style.cssText = `
                            position: absolute;
                            top: -8px;
                            right: -8px;
                            width: 20px;
                            height: 20px;
                            background: #ff3b30;
                            color: white;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 14px;
                            font-weight: bold;
                            cursor: pointer;
                            z-index: 10;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                        `;

                        deleteBtn.onclick = async (e) => {
                            e.stopPropagation();
                            const confirmed = await showCustomConfirm('åˆ é™¤è¡¨æƒ…', `ç¡®å®šè¦åˆ é™¤è¡¨æƒ… "${sticker.name}" å—ï¼Ÿ`, { confirmButtonClass: 'btn-danger' });
                            if (confirmed) {
                                await db.userStickers.delete(sticker.id);
                                state.userStickers = state.userStickers.filter(s => s.id !== sticker.id);
                                renderStickerPanel();
                            }
                        };

                        item.appendChild(deleteBtn);

                        // Add touch-based drag functionality for mobile
                        let dragState = {
                            isDragging: false,
                            draggedElement: null,
                            draggedId: null,
                            startX: 0,
                            startY: 0,
                            currentX: 0,
                            currentY: 0
                        };

                        item.addEventListener('touchstart', (e) => {
                            const touch = e.touches[0];
                            dragState.startX = touch.clientX;
                            dragState.startY = touch.clientY;
                            dragState.draggedElement = item;
                            dragState.draggedId = sticker.id;

                            // Start drag after a short delay to distinguish from tap
                            setTimeout(() => {
                                if (dragState.draggedElement === item) {
                                    dragState.isDragging = true;
                                    item.style.opacity = '0.5';
                                    item.style.transform = 'scale(1.1)';
                                    item.style.zIndex = '1000';
                                    item.style.pointerEvents = 'none';
                                }
                            }, 150);
                        }, { passive: false });

                        item.addEventListener('touchmove', (e) => {
                            if (!dragState.isDragging || dragState.draggedElement !== item) return;

                            e.preventDefault();
                            const touch = e.touches[0];
                            dragState.currentX = touch.clientX;
                            dragState.currentY = touch.clientY;

                            // Move the dragged item
                            const deltaX = dragState.currentX - dragState.startX;
                            const deltaY = dragState.currentY - dragState.startY;
                            item.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(1.1)`;

                            // Find element under touch point
                            const elementBelow = document.elementFromPoint(dragState.currentX, dragState.currentY);
                            const targetSticker = elementBelow?.closest('.sticker-item');

                            // Reset all sticker highlights
                            document.querySelectorAll('.sticker-item').forEach(s => {
                                if (s !== item) {
                                    s.style.boxShadow = '';
                                    s.style.transform = '';
                                }
                            });

                            // Highlight drop target
                            if (targetSticker && targetSticker !== item) {
                                targetSticker.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
                                targetSticker.style.transform = 'scale(1.05)';
                            }
                        }, { passive: false });

                        item.addEventListener('touchend', async (e) => {
                            if (!dragState.isDragging || dragState.draggedElement !== item) {
                                dragState = { isDragging: false, draggedElement: null, draggedId: null, startX: 0, startY: 0, currentX: 0, currentY: 0 };
                                return;
                            }

                            // Find element under touch point
                            const elementBelow = document.elementFromPoint(dragState.currentX, dragState.currentY);
                            const targetSticker = elementBelow?.closest('.sticker-item');

                            // Reset dragged item appearance
                            item.style.opacity = '1';
                            item.style.transform = '';
                            item.style.zIndex = '';
                            item.style.pointerEvents = '';

                            // Reset all highlights
                            document.querySelectorAll('.sticker-item').forEach(s => {
                                s.style.boxShadow = '';
                                s.style.transform = '';
                            });

                            // Perform reorder if dropped on another sticker
                            if (targetSticker && targetSticker !== item) {
                                const targetId = targetSticker.style.backgroundImage.match(/url\("([^"]+)"\)/)?.[1];
                                const targetStickerData = state.userStickers.find(s => s.url === targetId);

                                if (targetStickerData) {
                                    const draggedIndex = state.userStickers.findIndex(s => s.id === dragState.draggedId);
                                    const targetIndex = state.userStickers.findIndex(s => s.id === targetStickerData.id);

                                    if (draggedIndex !== -1 && targetIndex !== -1) {
                                        // Remove dragged sticker from its current position
                                        const [draggedSticker] = state.userStickers.splice(draggedIndex, 1);

                                        // Insert it at the target position
                                        state.userStickers.splice(targetIndex, 0, draggedSticker);

                                        // Update database with order information
                                        await db.userStickers.clear();
                                        for (let i = 0; i < state.userStickers.length; i++) {
                                            const stickerItem = { ...state.userStickers[i], order: i };
                                            await db.userStickers.add(stickerItem);
                                        }

                                        // Re-render to show new order
                                        renderStickerPanel();
                                    }
                                }
                            }

                            // Reset drag state
                            dragState = { isDragging: false, draggedElement: null, draggedId: null, startX: 0, startY: 0, currentX: 0, currentY: 0 };
                        }, { passive: false });
                    } else {
                        // Normal mode: click to send, long press for options
                        item.addEventListener('click', () => sendSticker(sticker));
                        addLongPressListener(item, () => {
                            if (isSelectionMode) return;
                            showStickerOptionsModal(sticker);
                        });
                    }

                    grid.appendChild(item);
                });
            }

            function initializeStickerPackTabs() {
                const tabsContainer = document.getElementById('sticker-pack-tabs');
                if (!tabsContainer) return;

                // Get saved order or use default order
                const savedOrder = state.globalSettings?.stickerPackOrder || Object.keys(stickerPackData);
                
                // Get all existing tabs with data-pack attribute (excluding add button)
                const existingTabs = Array.from(tabsContainer.querySelectorAll('.sticker-pack-tab[data-pack]'));
                
                // Reorder existing tabs according to saved order
                savedOrder.forEach(packId => {
                    const existingTab = existingTabs.find(tab => tab.dataset.pack === packId);
                    if (existingTab) {
                        // Move tab to end (which will be in the correct order)
                        tabsContainer.appendChild(existingTab);
                        
                        // Update tab icon if needed
                        if (stickerPackData[packId] && stickerPackData[packId].icon) {
                            updateStickerPackTabIcon(packId, stickerPackData[packId].icon);
                        }
                    } else if (stickerPackData[packId]) {
                        // Create new tab for packs that don't exist in DOM yet
                        const packData = stickerPackData[packId];
                        const newTab = document.createElement('div');
                        newTab.className = 'sticker-pack-tab';
                        newTab.setAttribute('data-pack', packId);

                        const packIcon = document.createElement('div');
                        packIcon.className = 'pack-icon';

                        if (packData.icon && packData.icon.trim()) {
                            packIcon.innerHTML = `<img src="${packData.icon}" alt="${packId}">`;
                        } else {
                            // Use default empty icon
                            packIcon.innerHTML = `
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                    xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2"
                                    stroke-linecap="round" stroke-linejoin="round">
                                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                </svg>
                            `;
                        }

                        newTab.appendChild(packIcon);
                        tabsContainer.appendChild(newTab);
                    }
                });
                
                // Add any remaining tabs that weren't in the saved order
                existingTabs.forEach(tab => {
                    const packId = tab.dataset.pack;
                    if (!savedOrder.includes(packId)) {
                        tabsContainer.appendChild(tab);
                    }
                });

                // Add click event listeners to pack tabs
                tabsContainer.addEventListener('click', (e) => {
                    const tab = e.target.closest('.sticker-pack-tab');
                    if (!tab) return;

                    // Skip if it's the add pack button or in arrange mode
                    if (tab.id === 'add-pack-btn' || isPackArrangeMode) return;

                    const packId = tab.dataset.pack;
                    if (packId) {
                        switchStickerPack(packId);
                    }
                });

                // Add long press listeners to pack tabs for arrange mode
                document.querySelectorAll('.sticker-pack-tab[data-pack]').forEach(tab => {
                    addLongPressListener(tab, () => {
                        if (!isPackArrangeMode) {
                            enterPackArrangeMode();
                        }
                    });
                });

                // Set active tab based on currentStickerPack
                document.querySelectorAll('.sticker-pack-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                const activeTab = document.querySelector(`[data-pack="${currentStickerPack}"]`);
                if (activeTab) {
                    activeTab.classList.add('active');
                }
            }

            function switchStickerPack(packId) {
                currentStickerPack = packId;

                // Update active tab
                document.querySelectorAll('.sticker-pack-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                document.querySelector(`[data-pack="${packId}"]`).classList.add('active');

                // Re-render sticker grid
                renderStickerPanel();
            }

            // â–¼â–¼â–¼ Sticker Pack Edit Modal Functions â–¼â–¼â–¼
            function openStickerPackEditModal() {
                // Get current pack data from storage
                const packData = stickerPackData[currentStickerPack] || { name: '', icon: '' };

                // Populate modal fields
                document.getElementById('sticker-pack-name-input').value = packData.name;
                document.getElementById('sticker-pack-icon-input').value = packData.icon;

                // Show/hide delete button based on pack type
                const deleteBtn = document.getElementById('delete-sticker-pack-btn');
                if (currentStickerPack === 'all' || currentStickerPack === 'pack1') {
                    deleteBtn.style.display = 'none';
                } else {
                    deleteBtn.style.display = 'block';
                }

                // Show modal
                document.getElementById('sticker-pack-edit-modal').classList.add('visible');

                // Focus on first input field
                document.getElementById('sticker-pack-name-input').focus();
            }

            function closeStickerPackEditModal() {
                document.getElementById('sticker-pack-edit-modal').classList.remove('visible');
            }

            async function saveStickerPackEdit() {
                const name = document.getElementById('sticker-pack-name-input').value.trim();
                const iconUrl = document.getElementById('sticker-pack-icon-input').value.trim();

                if (!name) {
                    alert('è¯·è¾“å…¥è¡¨æƒ…åŒ…åç§°');
                    return;
                }

                // Save data to storage
                if (!stickerPackData[currentStickerPack]) {
                    stickerPackData[currentStickerPack] = {};
                }
                stickerPackData[currentStickerPack].name = name;
                stickerPackData[currentStickerPack].icon = iconUrl;

                // Save to database via globalSettings
                if (!state.globalSettings.stickerPackData) {
                    state.globalSettings.stickerPackData = {};
                }
                state.globalSettings.stickerPackData = { ...stickerPackData };

                try {
                    await db.globalSettings.put(state.globalSettings);
                } catch (error) {
                    console.error('Failed to save sticker pack data:', error);
                }

                // Update the tab icon
                updateStickerPackTabIcon(currentStickerPack, iconUrl);

                // Close modal without alert
                closeStickerPackEditModal();
            }

            function updateStickerPackTabIcon(packId, iconUrl) {
                const tab = document.querySelector(`[data-pack="${packId}"]`);
                if (!tab) return;

                const packIcon = tab.querySelector('.pack-icon');
                if (!packIcon) return;

                if (iconUrl && iconUrl.trim()) {
                    // Replace with image
                    packIcon.innerHTML = `<img src="${iconUrl}" alt="${packId}">`;
                } else {
                    // Use default SVG for 'all' pack, or empty for others
                    if (packId === 'all') {
                        packIcon.innerHTML = `
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2"
                                stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="10" />
                                <path d="M8 14s1.5 2 4 2 4-2 4-2" />
                                <line x1="9" y1="9" x2="9.01" y2="9" />
                                <line x1="15" y1="9" x2="15.01" y2="9" />
                            </svg>
                        `;
                    } else {
                        packIcon.innerHTML = `<div style="width: 24px; height: 24px; background: #ccc; border-radius: 4px;"></div>`;
                    }
                }
            }

            async function deleteStickerPack() {
                // Prevent deleting the 'all' pack
                if (currentStickerPack === 'all') {
                    alert('æ— æ³•åˆ é™¤é»˜è®¤è¡¨æƒ…åŒ…');
                    return;
                }

                const confirmed = await showCustomConfirm('åˆ é™¤è¡¨æƒ…åŒ…', `ç¡®å®šè¦åˆ é™¤è¡¨æƒ…åŒ…å—ï¼ŸåŒ…å†…çš„æ‰€æœ‰è¡¨æƒ…ä¹Ÿä¼šè¢«åˆ é™¤ã€‚`, { confirmButtonClass: 'btn-danger' });
                if (!confirmed) return;

                // Remove all stickers from this pack
                const stickersToDelete = state.userStickers.filter(sticker => sticker.packId === currentStickerPack);
                for (const sticker of stickersToDelete) {
                    await db.userStickers.delete(sticker.id);
                }
                state.userStickers = state.userStickers.filter(sticker => sticker.packId !== currentStickerPack);

                // Remove pack data from storage
                delete stickerPackData[currentStickerPack];
                if (state.globalSettings.stickerPackData) {
                    delete state.globalSettings.stickerPackData[currentStickerPack];
                    try {
                        await db.globalSettings.put(state.globalSettings);
                    } catch (error) {
                        console.error('Failed to save sticker pack data:', error);
                    }
                }

                // Remove tab from DOM
                const tab = document.querySelector(`[data-pack="${currentStickerPack}"]`);
                if (tab) {
                    tab.remove();
                }

                // Switch to 'all' pack
                switchStickerPack('all');

                // Close modal
                closeStickerPackEditModal();
            }
            // â–²â–²â–² Sticker Pack Edit Modal Functions End â–²â–²â–²

            // â–¼â–¼â–¼ New Sticker Pack Modal Functions â–¼â–¼â–¼
            function openNewStickerPackModal() {
                // Clear modal fields
                document.getElementById('new-pack-name-input').value = '';
                document.getElementById('new-pack-icon-input').value = '';

                // Show modal
                document.getElementById('new-sticker-pack-modal').classList.add('visible');

                // Focus on first input field
                document.getElementById('new-pack-name-input').focus();
            }

            function closeNewStickerPackModal() {
                document.getElementById('new-sticker-pack-modal').classList.remove('visible');
            }

            async function createNewStickerPack() {
                const name = document.getElementById('new-pack-name-input').value.trim();
                const iconUrl = document.getElementById('new-pack-icon-input').value.trim();

                if (!name) {
                    alert('è¯·è¾“å…¥è¡¨æƒ…åŒ…åç§°');
                    return;
                }

                // Find next available pack ID
                let nextPackId = 'pack1';
                let packNumber = 1;
                while (document.querySelector(`[data-pack="${nextPackId}"]`)) {
                    packNumber++;
                    nextPackId = `pack${packNumber}`;
                }

                // Save data to storage
                if (!stickerPackData[nextPackId]) {
                    stickerPackData[nextPackId] = {};
                }
                stickerPackData[nextPackId].name = name;
                stickerPackData[nextPackId].icon = iconUrl;

                // Save to database via globalSettings
                if (!state.globalSettings.stickerPackData) {
                    state.globalSettings.stickerPackData = {};
                }
                state.globalSettings.stickerPackData = { ...stickerPackData };

                try {
                    await db.globalSettings.put(state.globalSettings);
                } catch (error) {
                    console.error('Failed to save sticker pack data:', error);
                }

                // Create new tab in DOM
                const tabsContainer = document.getElementById('sticker-pack-tabs');

                const newTab = document.createElement('div');
                newTab.className = 'sticker-pack-tab';
                newTab.setAttribute('data-pack', nextPackId);

                const packIcon = document.createElement('div');
                packIcon.className = 'pack-icon';

                if (iconUrl && iconUrl.trim()) {
                    packIcon.innerHTML = `<img src="${iconUrl}" alt="${nextPackId}">`;
                } else {
                    // Use default empty icon
                    packIcon.innerHTML = `
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                            xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2"
                            stroke-linecap="round" stroke-linejoin="round">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                        </svg>
                    `;
                }

                newTab.appendChild(packIcon);
                tabsContainer.appendChild(newTab);

                // Switch to the new pack
                switchStickerPack(nextPackId);

                // Close modal
                closeNewStickerPackModal();
            }
            // â–²â–²â–² New Sticker Pack Modal Functions End â–²â–²â–²

            // â–¼â–¼â–¼ Sticker Options Modal Functions â–¼â–¼â–¼
            let isArrangeMode = false;
            let selectedStickerForMove = null;
            let isPackArrangeMode = false;

            function showStickerOptionsModal(sticker) {
                // Hide the sticker panel first
                document.getElementById('sticker-panel').classList.remove('visible');

                // Use the preset-actions-modal for consistency
                const actionsModal = document.getElementById('preset-actions-modal');
                const modalContent = actionsModal.querySelector('.custom-modal-footer');

                // Populate modal with sticker options (removed delete button)
                modalContent.innerHTML = `
                    <button data-action="move-to-pack">ç§»åŠ¨åˆ°è¡¨æƒ…åŒ…</button>
                    <button data-action="arrange">æ•´ç†è¡¨æƒ…</button>
                    <button data-action="cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">å–æ¶ˆ</button>
                `;

                // Show modal
                actionsModal.classList.add('visible');

                // Handle button clicks
                const handleActionClick = async (e) => {
                    const action = e.target.dataset.action;
                    if (!action) return;

                    actionsModal.classList.remove('visible');
                    modalContent.removeEventListener('click', handleActionClick);

                    switch (action) {
                        case 'move-to-pack':
                            // Show sticker pack selection modal
                            selectedStickerForMove = sticker;
                            showMoveStickerModal();
                            break;
                        case 'arrange':
                            // Enter arrange mode and show sticker panel
                            enterArrangeMode();
                            break;
                        case 'cancel':
                            // Just show sticker panel again
                            document.getElementById('sticker-panel').classList.add('visible');
                            break;
                    }
                };

                modalContent.addEventListener('click', handleActionClick);
            }

            function enterArrangeMode() {
                isArrangeMode = true;

                // Update header to show arrange mode
                const header = document.getElementById('sticker-panel-header');
                const title = header.querySelector('.title');
                const editBtn = header.querySelector('#edit-sticker-pack-btn');
                const cancelBtn = header.querySelector('#close-sticker-panel-btn');

                title.textContent = 'æ•´ç†è¡¨æƒ…';
                editBtn.textContent = 'å®Œæˆ';
                editBtn.onclick = exitArrangeMode;

                // Update cancel button to exit arrange mode without saving
                cancelBtn.onclick = () => {
                    exitArrangeMode();
                };

                // Show sticker panel and re-render with arrange mode
                document.getElementById('sticker-panel').classList.add('visible');
                renderStickerPanel();
            }

            function exitArrangeMode() {
                isArrangeMode = false;

                // Restore header
                const header = document.getElementById('sticker-panel-header');
                const title = header.querySelector('.title');
                const editBtn = header.querySelector('#edit-sticker-pack-btn');
                const cancelBtn = header.querySelector('#close-sticker-panel-btn');

                title.textContent = 'æˆ‘çš„è¡¨æƒ…';
                editBtn.textContent = 'ç¼–è¾‘';
                editBtn.onclick = openStickerPackEditModal;

                // Restore cancel button to close panel
                cancelBtn.onclick = () => {
                    document.getElementById('sticker-panel').classList.remove('visible');
                };

                // Re-render without arrange mode
                renderStickerPanel();
            }

            // â–¼â–¼â–¼ Move Sticker to Pack Functions â–¼â–¼â–¼
            function showMoveStickerModal() {
                // Get all available sticker packs from existing tabs (excluding "all")
                const availablePacks = [];
                const packTabs = document.querySelectorAll('.sticker-pack-tab[data-pack]');

                packTabs.forEach(tab => {
                    const packId = tab.dataset.pack;
                    if (packId !== 'all') {
                        const packName = stickerPackData[packId]?.name || `è¡¨æƒ…åŒ…${packId.replace('pack', '')}`;
                        availablePacks.push({
                            id: packId,
                            name: packName
                        });
                    }
                });

                // Generate pack list HTML (radio buttons)
                const packListHtml = availablePacks.map(pack => `
                    <div class="pack-selection-item" onclick="selectPackForMove('${pack.id}')">
                        <input type="radio" name="pack-selection" id="pack-${pack.id}" data-pack-id="${pack.id}">
                        <div class="pack-selection-info">
                            <div class="pack-selection-name">${pack.name}</div>
                        </div>
                    </div>
                `).join('');

                document.getElementById('sticker-pack-selection-list').innerHTML = packListHtml;
                document.getElementById('move-sticker-modal').classList.add('visible');
            }

            function hideMoveStickerModal() {
                document.getElementById('move-sticker-modal').classList.remove('visible');
                selectedStickerForMove = null;
            }

            function selectPackForMove(packId) {
                // Update radio button selection
                const radioButton = document.getElementById(`pack-${packId}`);
                if (radioButton) {
                    radioButton.checked = true;
                }
            }

            async function confirmMoveSticker() {
                const selectedRadio = document.querySelector('input[name="pack-selection"]:checked');
                if (!selectedRadio) {
                    alert('è¯·é€‰æ‹©ä¸€ä¸ªè¡¨æƒ…åŒ…');
                    return;
                }

                const targetPackId = selectedRadio.dataset.packId;

                if (!selectedStickerForMove) {
                    alert('æœªé€‰æ‹©è¡¨æƒ…');
                    return;
                }

                // Update sticker's pack assignment
                const stickerIndex = state.userStickers.findIndex(s => s.id === selectedStickerForMove.id);
                if (stickerIndex !== -1) {
                    state.userStickers[stickerIndex].packId = targetPackId;

                    // Update database
                    await db.userStickers.put(state.userStickers[stickerIndex]);

                    // Hide modal and refresh sticker panel
                    hideMoveStickerModal();
                    document.getElementById('sticker-panel').classList.add('visible');
                    renderStickerPanel();
                }
            }
            // â–²â–²â–² Move Sticker to Pack Functions End â–²â–²â–²

            // â–¼â–¼â–¼ Pack Arrange Mode Functions â–¼â–¼â–¼
            // Variables declared above: isPackArrangeMode, currentStickerPack, stickerPackData

            function enterPackArrangeMode() {
                isPackArrangeMode = true;

                // Update header to show pack arrange mode
                const header = document.getElementById('sticker-panel-header');
                if (header) {
                    header.innerHTML = `
                        <span class="panel-btn" id="close-sticker-panel-btn">å–æ¶ˆ</span>
                        <span class="title">æ•´ç†è¡¨æƒ…åŒ…</span>
                        <span class="panel-btn" id="exit-pack-arrange-btn">å®Œæˆ</span>
                    `;

                    // Add exit arrange mode listener
                    document.getElementById('exit-pack-arrange-btn').addEventListener('click', exitPackArrangeMode);
                    document.getElementById('close-sticker-panel-btn').addEventListener('click', exitPackArrangeMode);
                }

                // Add drag functionality to pack tabs
                addPackDragFunctionality();

                // Add visual indication that tabs are draggable
                document.querySelectorAll('.sticker-pack-tab[data-pack]').forEach(tab => {
                    if (tab.id !== 'add-pack-btn') {
                        tab.style.cursor = 'move';
                        tab.style.transition = 'all 0.2s ease';
                    }
                });
            }

            function exitPackArrangeMode() {
                isPackArrangeMode = false;

                // Save the new pack order before exiting
                saveStickerPackOrder();

                // Restore header
                const header = document.getElementById('sticker-panel-header');
                if (header) {
                    header.innerHTML = `
                        <span class="panel-btn" id="close-sticker-panel-btn">å–æ¶ˆ</span>
                        <span class="title">æˆ‘çš„è¡¨æƒ…</span>
                        <span class="panel-btn" id="edit-sticker-pack-btn">ç¼–è¾‘</span>
                    `;

                    // Re-add event listeners for header buttons
                    setupStickerPanelEventListeners();
                }

                // Remove drag functionality and visual indicators
                removePackDragFunctionality();

                // Reset tab styling
                document.querySelectorAll('.sticker-pack-tab[data-pack]').forEach(tab => {
                    tab.style.cursor = '';
                    tab.style.transition = '';
                });

                // Remove drag functionality from pack tabs
                removePackDragFunctionality();
            }

            function setupStickerPanelEventListeners() {
                // Close sticker panel button
                const closeBtn = document.getElementById('close-sticker-panel-btn');
                if (closeBtn) {
                    closeBtn.addEventListener('click', () => {
                        document.getElementById('sticker-panel').classList.remove('visible');
                    });
                }

                // Edit sticker pack button
                const editPackBtn = document.getElementById('edit-sticker-pack-btn');
                if (editPackBtn) {
                    editPackBtn.addEventListener('click', () => {
                        // Open sticker pack edit modal or functionality
                        console.log('Edit sticker pack clicked');
                    });
                }
            }

            function addPackDragFunctionality() {
                const tabs = document.querySelectorAll('.sticker-pack-tab[data-pack]');

                tabs.forEach(tab => {
                    // Skip the add button
                    if (tab.id === 'add-pack-btn') return;

                    // Remove existing event listeners to avoid conflicts
                    const newTab = tab.cloneNode(true);
                    tab.parentNode.replaceChild(newTab, tab);
                    
                    let dragState = {
                        isDragging: false,
                        draggedElement: null,
                        startX: 0,
                        startY: 0,
                        currentX: 0,
                        currentY: 0
                    };

                    newTab.addEventListener('touchstart', (e) => {
                        if (!isPackArrangeMode) return;

                        const touch = e.touches[0];
                        dragState.startX = touch.clientX;
                        dragState.startY = touch.clientY;
                        dragState.draggedElement = newTab;

                        // Start drag after a short delay to distinguish from tap
                        setTimeout(() => {
                            if (dragState.draggedElement === newTab) {
                                dragState.isDragging = true;
                                newTab.style.opacity = '0.5';
                                newTab.style.transform = 'scale(1.1)';
                                newTab.style.zIndex = '1000';
                                newTab.style.pointerEvents = 'none';
                            }
                        }, 150);
                    }, { passive: false });

                    newTab.addEventListener('touchmove', (e) => {
                        if (!dragState.isDragging || dragState.draggedElement !== newTab) return;

                        e.preventDefault();
                        const touch = e.touches[0];
                        dragState.currentX = touch.clientX;
                        dragState.currentY = touch.clientY;

                        // Move the dragged tab
                        const deltaX = dragState.currentX - dragState.startX;
                        const deltaY = dragState.currentY - dragState.startY;
                        newTab.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(1.1)`;

                        // Find element under touch point
                        const elementBelow = document.elementFromPoint(dragState.currentX, dragState.currentY);
                        const targetTab = elementBelow?.closest('.sticker-pack-tab[data-pack]');

                        // Reset all tab highlights
                        document.querySelectorAll('.sticker-pack-tab[data-pack]').forEach(t => {
                            if (t !== newTab) {
                                t.style.boxShadow = '';
                                t.style.transform = '';
                            }
                        });

                        // Highlight drop target
                        if (targetTab && targetTab !== newTab && targetTab.id !== 'add-pack-btn') {
                            targetTab.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
                            targetTab.style.transform = 'scale(1.05)';
                        }
                    }, { passive: false });

                    newTab.addEventListener('touchend', (e) => {
                        if (!dragState.isDragging || dragState.draggedElement !== newTab) {
                            dragState = { isDragging: false, draggedElement: null, startX: 0, startY: 0, currentX: 0, currentY: 0 };
                            return;
                        }

                        // Find element under touch point
                        const elementBelow = document.elementFromPoint(dragState.currentX, dragState.currentY);
                        const targetTab = elementBelow?.closest('.sticker-pack-tab[data-pack]');

                        // Reset dragged tab appearance
                        newTab.style.opacity = '1';
                        newTab.style.transform = '';
                        newTab.style.zIndex = '';
                        newTab.style.pointerEvents = '';

                        // Reset all highlights
                        document.querySelectorAll('.sticker-pack-tab[data-pack]').forEach(t => {
                            t.style.boxShadow = '';
                            t.style.transform = '';
                        });

                        // Perform reorder if dropped on another tab
                        if (targetTab && targetTab !== newTab && targetTab.id !== 'add-pack-btn') {
                            reorderPackTabs(newTab, targetTab);
                        }

                        // Reset drag state
                        dragState = { isDragging: false, draggedElement: null, startX: 0, startY: 0, currentX: 0, currentY: 0 };
                    }, { passive: false });
                });
            }

            function removePackDragFunctionality() {
                const tabs = document.querySelectorAll('.sticker-pack-tab[data-pack]');
                tabs.forEach(tab => {
                    // Reset any drag-related styles
                    tab.style.zIndex = '';
                    tab.style.opacity = '';
                    tab.style.transform = '';
                    tab.style.boxShadow = '';
                });
            }

            function reorderPackTabs(draggedTab, targetTab) {
                const draggedPackId = draggedTab.dataset.pack;
                const targetPackId = targetTab.dataset.pack;

                if (!draggedPackId || !targetPackId || draggedPackId === targetPackId) return;

                console.log(`Reordering pack ${draggedPackId} to position of ${targetPackId}`);

                // Get the parent container
                const parent = draggedTab.parentNode;
                if (!parent) return;

                // Remove dragged element from its current position
                const draggedElement = draggedTab;
                draggedElement.remove();

                // Insert it at the target position
                parent.insertBefore(draggedElement, targetTab);

                console.log(`Successfully moved pack ${draggedPackId} before ${targetPackId}`);

                // Save the new order to state/database if needed
                saveStickerPackOrder();
            }

            function saveStickerPackOrder() {
                // Get current order of pack tabs
                const tabs = document.querySelectorAll('.sticker-pack-tab[data-pack]');
                const newOrder = Array.from(tabs).map(tab => tab.dataset.pack).filter(pack => pack);

                console.log('New pack order:', newOrder);

                // Save to state and database
                if (state.globalSettings) {
                    state.globalSettings.stickerPackOrder = newOrder;
                    db.globalSettings.put(state.globalSettings);
                }
            }

            function addLongPressListener(element, callback) {
                let longPressTimer;
                let startX, startY;
                const longPressDelay = 500; // 500ms for long press
                const moveThreshold = 10; // pixels

                element.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    startX = touch.clientX;
                    startY = touch.clientY;

                    longPressTimer = setTimeout(() => {
                        callback();
                    }, longPressDelay);
                });

                element.addEventListener('touchmove', (e) => {
                    const touch = e.touches[0];
                    const deltaX = Math.abs(touch.clientX - startX);
                    const deltaY = Math.abs(touch.clientY - startY);

                    if (deltaX > moveThreshold || deltaY > moveThreshold) {
                        clearTimeout(longPressTimer);
                    }
                });

                element.addEventListener('touchend', () => {
                    clearTimeout(longPressTimer);
                });

                element.addEventListener('touchcancel', () => {
                    clearTimeout(longPressTimer);
                });
            }

            // Initialize long press listeners for existing sticker pack tabs
            function initializeStickerPackLongPress() {
                document.querySelectorAll('.sticker-pack-tab[data-pack]').forEach(tab => {
                    // Skip the add button
                    if (tab.id === 'add-pack-btn') return;

                    addLongPressListener(tab, () => {
                        if (!isPackArrangeMode) {
                            enterPackArrangeMode();
                        }
                    });
                });
            }

            // Call initialization when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initializeStickerPackLongPress);
            } else {
                initializeStickerPackLongPress();
            }
            // â–²â–²â–² Pack Arrange Mode Functions End â–²â–²â–²

            // â–²â–²â–² Sticker Options Modal Functions End â–²â–²â–²

            // â–¼â–¼â–¼ è¯·ç”¨è¿™ä¸ªã€æ”¯æŒå…¬å‘Šæ¿ã€‘çš„ç‰ˆæœ¬ï¼Œå®Œæ•´æ›¿æ¢æ—§çš„ createMessageElement å‡½æ•° â–¼â–¼â–¼
            function createMessageElement(msg, chat) {
                if (msg.isHidden) {
                    return null;
                }

                // å¤„ç†å·²æ’¤å›çš„æ¶ˆæ¯
                if (msg.type === 'recalled_message') {
                    const wrapper = document.createElement('div');
                    // 1. ã€æ ¸å¿ƒã€‘ç»™ wrapper ä¹ŸåŠ ä¸Š timestampï¼Œæ–¹ä¾¿äº‹ä»¶å§”æ‰˜æ—¶æŸ¥æ‰¾
                    wrapper.className = 'message-wrapper system-pat';
                    wrapper.dataset.timestamp = msg.timestamp;

                    const bubble = document.createElement('div');
                    // 2. ã€æ ¸å¿ƒã€‘è®©è¿™ä¸ªå…ƒç´ åŒæ—¶æ‹¥æœ‰ .message-bubble å’Œ .recalled-message-placeholder ä¸¤ä¸ªclass
                    //    è¿™æ ·å®ƒæ—¢èƒ½è¢«é€‰æ‹©ç³»ç»Ÿè¯†åˆ«ï¼Œåˆèƒ½ä¿æŒåŸæœ‰çš„å±…ä¸­ç°è‰²æ ·å¼
                    bubble.className = 'message-bubble recalled-message-placeholder';
                    // 3. ã€æ ¸å¿ƒã€‘æŠŠ timestamp æ”¾åœ¨ bubble ä¸Šï¼Œè¿™æ˜¯å¤šé€‰é€»è¾‘çš„å…³é”®
                    bubble.dataset.timestamp = msg.timestamp;
                    bubble.textContent = msg.content;

                    wrapper.appendChild(bubble);

                    // 4. ã€æ ¸å¿ƒã€‘ä¸ºå®ƒè¡¥ä¸Šå’Œå…¶ä»–æ¶ˆæ¯ä¸€æ ·çš„æ ‡å‡†äº‹ä»¶ç›‘å¬å™¨
                    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
                    wrapper.addEventListener('click', () => {
                        if (isSelectionMode) {
                            toggleMessageSelection(msg.timestamp);
                        }
                    });

                    // 5. ã€é‡è¦ã€‘åœ¨ä¹‹å‰çš„"ç‚¹å‡»æŸ¥çœ‹åŸæ–‡"çš„é€»è¾‘ä¸­ï¼Œæˆ‘ä»¬å·²ç»ä½¿ç”¨äº†äº‹ä»¶å§”æ‰˜ï¼Œæ‰€ä»¥è¿™é‡Œä¸éœ€è¦å†å•ç‹¬ä¸ºè¿™ä¸ªå…ƒç´ æ·»åŠ ç‚¹å‡»äº‹ä»¶äº†ã€‚
                    //    init() å‡½æ•°ä¸­çš„é‚£ä¸ªäº‹ä»¶ç›‘å¬å™¨ä¼šå¤„ç†å®ƒã€‚

                    return wrapper;
                }

                if (msg.type === 'pat_message') {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'message-wrapper system-pat';
                    const bubble = document.createElement('div');
                    bubble.className = 'message-bubble system-bubble';
                    bubble.dataset.timestamp = msg.timestamp;
                    bubble.textContent = msg.content;
                    wrapper.appendChild(bubble);
                    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
                    wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });
                    return wrapper;
                }

                // ã€ã€ã€å…¨æ–°ã€‘ã€‘ã€‘å¤„ç†å…¬å‘Šæ¿å¡ç‰‡æ¸²æŸ“
                if (msg.type === 'bulletin') {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'message-wrapper ai'; // å…¬å‘Šæ€»æ˜¯ç”±AIæˆ–ç³»ç»Ÿå‘å‡ºï¼Œé å·¦

                    // æˆ‘ä»¬ç›´æ¥å¤ç”¨åŠ¨æ€å¡ç‰‡çš„HTMLç»“æ„å’Œæ ·å¼
                    const bubble = document.createElement('div');
                    bubble.className = 'message-bubble is-bulletin'; // ä½¿ç”¨ is-bulletin æ§åˆ¶æ ·å¼
                    bubble.dataset.timestamp = msg.timestamp;

                    bubble.innerHTML = `
            <div class="qzone-post-item bulletin-card" style="width: 250px;">
                <div class="post-header">
                    <img src="${msg.authorAvatar || defaultGroupMemberAvatar}" class="post-avatar">
                    <div class="post-info">
                        <span class="post-nickname">${msg.authorName}</span>
                        <span class="post-timestamp">${formatPostTimestamp(msg.timestamp)}</span>
                    </div>
                </div>
                <div class="post-content">${msg.content.replace(/\n/g, '<br>')}</div>
            </div>
        `;
                    wrapper.appendChild(bubble);
                    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
                    wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });
                    return wrapper;
                }

                const isUser = msg.role === 'user';
                const wrapper = document.createElement('div');
                wrapper.className = `message-wrapper ${isUser ? 'user' : 'ai'}`;

                if (chat.isGroup && !isUser) {
                    const senderNameDiv = document.createElement('div');
                    senderNameDiv.className = 'sender-name';
                    senderNameDiv.textContent = msg.senderName || 'æœªçŸ¥æˆå‘˜';
                    wrapper.appendChild(senderNameDiv);
                }

                const bubble = document.createElement('div');
                bubble.className = `message-bubble ${isUser ? 'user' : 'ai'}`;
                bubble.dataset.timestamp = msg.timestamp;

                const timestampEl = document.createElement('span');
                timestampEl.className = 'timestamp';
                timestampEl.textContent = formatTimestamp(msg.timestamp);

                let avatarSrc, avatarFrameSrc = '';
                if (chat.isGroup) {
                    if (isUser) {
                        avatarSrc = chat.settings.myAvatar || defaultMyGroupAvatar;
                        avatarFrameSrc = chat.settings.myAvatarFrame || '';
                    } else {
                        const member = chat.members.find(m => m.name === msg.senderName);
                        avatarSrc = member ? member.avatar : defaultGroupMemberAvatar;
                        avatarFrameSrc = member ? (member.avatarFrame || '') : '';
                    }
                } else {
                    if (isUser) {
                        avatarSrc = chat.settings.myAvatar || defaultAvatar;
                        avatarFrameSrc = chat.settings.myAvatarFrame || '';
                    } else {
                        avatarSrc = chat.settings.aiAvatar || defaultAvatar;
                        avatarFrameSrc = chat.settings.aiAvatarFrame || '';
                    }
                }
                const hasFrameClass = avatarFrameSrc ? 'has-frame' : '';
                let avatarHtml;
                if (avatarFrameSrc) {
                    avatarHtml = `
            <div class="avatar-with-frame">
                <img src="${avatarSrc}" class="avatar-img">
                <img src="${avatarFrameSrc}" class="avatar-frame">
            </div>
        `;
                } else {
                    avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
                }
                const avatarGroupHtml = `<div class="avatar-group ${hasFrameClass}">${avatarHtml}</div>`;

                let contentHtml;
                if (msg.type === 'user_photo' || msg.type === 'ai_image') {
                    bubble.classList.add('is-ai-image');
                    const altText = msg.type === 'user_photo' ? "ç”¨æˆ·æè¿°çš„ç…§ç‰‡" : "AIç”Ÿæˆçš„å›¾ç‰‡";
                    // Use custom URL if available, otherwise use default
                    const imageUrl = msg.imageUrl || "https://files.catbox.moe/cww7rw.jpg";
                    contentHtml = `<img src="${imageUrl}" class="ai-generated-image" alt="${altText}" data-description="${msg.content}">`;

                    //ã€è¯·å°†æ–°ä»£ç ç²˜è´´åˆ°è¿™é‡Œã€‘
                } else if (msg.type === 'share_link') {
                    bubble.classList.add('is-link-share');

                    contentHtml = `
                        <div class="link-share-card" data-timestamp="${msg.timestamp}">
                            <div class="title">${msg.title || 'æ— æ ‡é¢˜'}</div>
                            <div class="description">${msg.description || 'ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…...'}</div>
                            <div class="footer">
                                <svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>
                                <span>${msg.source_name || 'é“¾æ¥åˆ†äº«'}</span>
                            </div>
                        </div>
                    `;
                } else if (msg.type === 'location_share') {
                    bubble.classList.add('is-location-share');

                    contentHtml = `
                        <div class="location-share-content" data-timestamp="${msg.timestamp}">
                            <div class="location-map-image">
                                <img src="https://files.catbox.moe/d5f07w.png" alt="Map" style="width: 100%; height: 100%; object-fit: cover;">
                                <div class="location-map-overlay">
                                    <svg class="location-pin-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                        <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7z" fill="#EA4335" stroke="white" stroke-width="1"/>
                                        <circle cx="12" cy="9" r="2.5" fill="white"/>
                                    </svg>
                                </div>
                            </div>
                            <div class="location-details">
                                <div class="location-name">${msg.location_name || 'æœªçŸ¥ä½ç½®'}</div>
                                ${msg.address ? `<div class="location-address">${msg.address}</div>` : ''}
                            </div>
                        </div>
                    `;
                } else if (msg.type === 'voice_message') {
                    bubble.classList.add('is-voice-message');
                    const duration = Math.max(1, Math.round((msg.content || '').length / 5));
                    const durationFormatted = `0:${String(duration).padStart(2, '0')}''`;
                    const waveformHTML = '<div></div><div></div><div></div><div></div><div></div>';

                    // ã€æ ¸å¿ƒä¿®æ”¹ã€‘å°†è¯­éŸ³æ–‡æœ¬å†…å®¹å­˜å‚¨åœ¨ .voice-transcript å…ƒç´ ä¸­ï¼Œå¹¶é»˜è®¤éšè—
                    contentHtml = `
                <div class="voice-message-body">
                    <div class="voice-waveform">${waveformHTML}</div>
                    <span class="voice-duration">${durationFormatted}</span>
                </div>
                <div class="voice-transcript">${msg.content}</div>`;
                    //ã€ç²˜è´´åˆ°è¿™é‡Œç»“æŸã€‘


                } else if (msg.type === 'transfer') {
                    bubble.classList.add('is-transfer');

                    // â–¼â–¼â–¼ ã€å…¨æ–°ã€‘æ·»åŠ è½¬è´¦çŠ¶æ€å¤„ç† â–¼â–¼â–¼
                    const status = msg.status || (isUser ? 'sent' : 'pending');
                    bubble.dataset.status = status;

                    let titleText;
                    if (isUser) {
                        if (msg.isRefund) {
                            // ç”¨æˆ·å‘å‡ºçš„é€€æ¬¾ï¼ˆå³ç”¨æˆ·æ‹’æ”¶äº†AIçš„è½¬è´¦ï¼‰
                            titleText = `é€€æ¬¾ç»™ ${chat.name}`;
                        } else {
                            // ç”¨æˆ·ä¸»åŠ¨å‘èµ·çš„è½¬è´¦
                            titleText = `è½¬è´¦ç»™ ${msg.receiverName || 'Ta'}`;
                        }
                    } else {
                        // AIçš„æ¶ˆæ¯
                        if (msg.isRefund) {
                            // AI çš„é€€æ¬¾ï¼ˆAI æ‹’æ”¶äº†ç”¨æˆ·çš„è½¬è´¦ï¼‰
                            titleText = `é€€æ¬¾æ¥è‡ª ${msg.senderName}`;
                        } else {
                            const myNickname = chat.settings.myNickname || 'æˆ‘';
                            // ã€æ ¸å¿ƒä¿®æ­£ã€‘å¦‚æœreceiverNameæœªå®šä¹‰ï¼Œé»˜è®¤è®¤ä¸ºæ˜¯ç»™å½“å‰ç”¨æˆ·çš„è½¬è´¦
                            if (!msg.receiverName || msg.receiverName === myNickname) {
                                // ã€æ ¸å¿ƒä¿®æ­£1ã€‘è¿™æ˜¯ AI ä¸»åŠ¨ç»™ç”¨æˆ·çš„è½¬è´¦
                                titleText = `è½¬è´¦ç»™ ${myNickname}`;
                            } else {
                                // ã€æ ¸å¿ƒä¿®æ­£2ã€‘è¿™æ˜¯ AI å‘ç»™ç¾¤é‡Œå…¶ä»–äººçš„è½¬è´¦ï¼Œå¯¹å½“å‰ç”¨æˆ·æ¥è¯´åªæ˜¯ä¸€ä¸ªé€šçŸ¥
                                titleText = `è½¬è´¦: ${msg.senderName} â†’ ${msg.receiverName}`;
                            }
                        }
                    }
                    // â–²â–²â–² çŠ¶æ€å¤„ç†ç»“æŸ â–²â–²â–²

                    // ç¡®å®šå¤‡æ³¨æ–‡å­—
                    let noteText;
                    if (isUser) {
                        if (msg.isRefund) {
                            noteText = 'å·²æ‹’æ”¶å¯¹æ–¹è½¬è´¦';
                        } else {
                            if (status === 'accepted') {
                                noteText = 'å¯¹æ–¹å·²æ”¶æ¬¾';
                            } else if (status === 'declined') {
                                noteText = 'å¯¹æ–¹å·²æ‹’æ”¶';
                            } else {
                                noteText = msg.note || 'ç­‰å¾…å¯¹æ–¹å¤„ç†...';
                            }
                        }
                    } else {
                        if (msg.isRefund) {
                            noteText = 'è½¬è´¦å·²è¢«æ‹’æ”¶';
                        } else {
                            const myNickname = chat.settings.myNickname || 'æˆ‘';
                            // ã€æ ¸å¿ƒä¿®æ­£ã€‘å¦‚æœreceiverNameæœªå®šä¹‰ï¼Œé»˜è®¤è®¤ä¸ºæ˜¯ç»™å½“å‰ç”¨æˆ·çš„è½¬è´¦
                            if (!msg.receiverName || msg.receiverName === myNickname) {
                                // ã€æ ¸å¿ƒä¿®æ­£1ã€‘è¿™æ˜¯ AI ä¸»åŠ¨ç»™ç”¨æˆ·çš„è½¬è´¦
                                if (status === 'accepted') {
                                    noteText = 'ä½ å·²æ”¶æ¬¾';
                                } else if (status === 'declined') {
                                    noteText = 'ä½ å·²æ‹’æ”¶';
                                } else {
                                    // è¿™æ˜¯ç”¨æˆ·éœ€è¦å¤„ç†çš„è½¬è´¦
                                    bubble.style.cursor = 'pointer';
                                    bubble.dataset.status = 'pending';
                                    noteText = msg.note || 'ç‚¹å‡»å¤„ç†';
                                }
                            } else {
                                // ã€æ ¸å¿ƒä¿®æ­£2ã€‘è¿™æ˜¯ AI å‘ç»™ç¾¤é‡Œå…¶ä»–äººçš„è½¬è´¦ï¼Œå¯¹å½“å‰ç”¨æˆ·æ¥è¯´åªæ˜¯ä¸€ä¸ªé€šçŸ¥
                                noteText = msg.note || 'ç¾¤èŠå†…è½¬è´¦';
                            }
                        }
                    }

                    const heartIcon = `<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="vertical-align: middle;"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>`;
                    contentHtml = `<div class="transfer-card"><div class="transfer-title">${heartIcon} ${titleText}</div><div class="transfer-amount">Â¥ ${Number(msg.amount).toFixed(2)}</div><div class="transfer-note">${noteText}</div></div>`;
                } else if (msg.type === 'waimai_request') {
                    bubble.classList.add('is-waimai-request');
                    if (msg.status === 'paid' || msg.status === 'rejected') {
                        bubble.classList.add(`status-${msg.status}`);
                    }
                    const requestTitle = `æ¥è‡ª ${msg.senderName} çš„ä»£ä»˜è¯·æ±‚`;
                    let actionButtonsHtml = '';
                    if (msg.status === 'pending' && !isUser) {
                        actionButtonsHtml = `
                <div class="waimai-user-actions">
                    <button class="waimai-decline-btn" data-choice="rejected">æ®‹å¿æ‹’ç»</button>
                    <button class="waimai-pay-btn" data-choice="paid">ä¸ºTaä¹°å•</button>
                </div>`;
                    }
                    contentHtml = `
            <div class="waimai-card">
                <div class="waimai-header">
                    <img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon">
                    <div class="title-group">
                        <span class="brand">ç¾å›¢å¤–å–</span><span class="separator">|</span><span>å¤–å–ç¾é£Ÿ</span>
                    </div>
                </div>
                <div class="waimai-catchphrase">Hiï¼Œä½ å’Œæˆ‘çš„è·ç¦»åªå·®ä¸€é¡¿å¤–å–ï½</div>
                <div class="waimai-main">
                    <div class="request-title">${requestTitle}</div>
                    <div class="payment-box">
                        <div class="payment-label">éœ€ä»˜æ¬¾</div>
                        <div class="amount">Â¥${Number(msg.amount).toFixed(2)}</div>
                        <div class="countdown-label">å‰©ä½™æ”¯ä»˜æ—¶é—´
                            <div class="countdown-timer" id="waimai-timer-${msg.timestamp}"></div>
                        </div>
                    </div>
                    <button class="waimai-details-btn">æŸ¥çœ‹è¯¦æƒ…</button>
                </div>
                ${actionButtonsHtml}
            </div>`;

                    setTimeout(() => {
                        const timerEl = document.getElementById(`waimai-timer-${msg.timestamp}`);
                        if (timerEl && msg.countdownEndTime) {
                            if (waimaiTimers[msg.timestamp]) clearInterval(waimaiTimers[msg.timestamp]);
                            if (msg.status === 'pending') {
                                waimaiTimers[msg.timestamp] = startWaimaiCountdown(timerEl, msg.countdownEndTime);
                            } else {
                                timerEl.innerHTML = `<span>å·²</span><span>å¤„</span><span>ç†</span>`;
                            }
                        }
                        const detailsBtn = document.querySelector(`.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-details-btn`);
                        if (detailsBtn) {
                            detailsBtn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                const paidByText = msg.paidBy ? `<br><br><b>çŠ¶æ€ï¼š</b>ç”± ${msg.paidBy} ä¸ºæ‚¨ä»£ä»˜æˆåŠŸ` : '';
                                showCustomAlert('è®¢å•è¯¦æƒ…', `<b>å•†å“ï¼š</b>${msg.productInfo}<br><b>é‡‘é¢ï¼š</b>Â¥${Number(msg.amount).toFixed(2)}${paidByText}`);
                            });
                        }
                        const actionButtons = document.querySelectorAll(`.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-user-actions button`);
                        actionButtons.forEach(btn => {
                            btn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                const choice = e.target.dataset.choice;
                                handleWaimaiResponse(msg.timestamp, choice);
                            });
                        });
                    }, 0);

                } else if (msg.type === 'red_packet') {
                    bubble.classList.add('is-red-packet');
                    const myNickname = chat.settings.myNickname || 'æˆ‘';

                    // ä»æœ€æ–°çš„ msg å¯¹è±¡ä¸­è·å–çŠ¶æ€
                    const hasClaimed = msg.claimedBy && msg.claimedBy[myNickname];
                    const isFinished = msg.isFullyClaimed;

                    let cardClass = '';
                    let claimedInfoHtml = '';
                    let typeText = 'æ‹¼æ‰‹æ°”çº¢åŒ…';

                    // 1. åˆ¤æ–­çº¢åŒ…å¡ç‰‡çš„æ ·å¼ (é¢œè‰²)
                    if (isFinished) {
                        cardClass = 'opened';
                    } else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) {
                        cardClass = 'opened'; // ä¸“å±çº¢åŒ…è¢«é¢†äº†ä¹Ÿå˜ç°
                    }

                    // 2. åˆ¤æ–­çº¢åŒ…ä¸‹æ–¹çš„æç¤ºæ–‡å­—
                    if (msg.packetType === 'direct') {
                        typeText = `ä¸“å±çº¢åŒ…: ç»™ ${msg.receiverName}`;
                    }

                    if (hasClaimed) {
                        claimedInfoHtml = `<div class="rp-claimed-info">ä½ é¢†å–äº†çº¢åŒ…ï¼Œé‡‘é¢ ${msg.claimedBy[myNickname].toFixed(2)} å…ƒ</div>`;
                    } else if (isFinished) {
                        claimedInfoHtml = `<div class="rp-claimed-info">çº¢åŒ…å·²è¢«é¢†å®Œ</div>`;
                    } else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) {
                        claimedInfoHtml = `<div class="rp-claimed-info">å·²è¢« ${msg.receiverName} é¢†å–</div>`;
                    }

                    // 3. æ‹¼æ¥æœ€ç»ˆçš„HTMLï¼Œç¡®ä¿onclickè°ƒç”¨çš„æ˜¯æˆ‘ä»¬æ³¨å†Œåˆ°å…¨å±€çš„å‡½æ•°
                    contentHtml = `
        <div class="red-packet-card ${cardClass}">
            <div class="rp-header">
                <img src="https://files.catbox.moe/lo9xhc.png" class="rp-icon">
                <span class="rp-greeting">${msg.greeting || 'æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©ï¼'}</span>
            </div>
            <div class="rp-type">${typeText}</div>
            ${claimedInfoHtml}
        </div>
    `;
                    // â–²â–²â–² æ–°å¢ç»“æŸ â–²â–²â–²

                } else if (msg.type === 'poll') {
                    bubble.classList.add('is-poll');

                    let totalVotes = 0;
                    const voteCounts = {};

                    // è®¡ç®—æ€»ç¥¨æ•°å’Œæ¯ä¸ªé€‰é¡¹çš„ç¥¨æ•°
                    for (const option in msg.votes) {
                        const count = msg.votes[option].length;
                        voteCounts[option] = count;
                        totalVotes += count;
                    }

                    const myNickname = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';
                    let myVote = null;
                    for (const option in msg.votes) {
                        if (msg.votes[option].includes(myNickname)) {
                            myVote = option;
                            break;
                        }
                    }

                    let optionsHtml = '<div class="poll-options-list">';
                    msg.options.forEach(optionText => {
                        const count = voteCounts[optionText] || 0;
                        const percentage = totalVotes > 0 ? (count / totalVotes) * 100 : 0;
                        const isVotedByMe = myVote === optionText;

                        optionsHtml += `
            <div class="poll-option-item ${isVotedByMe ? 'voted' : ''}" data-option="${optionText}">
                <div class="poll-option-bar" style="width: ${percentage}%;"></div>
                <div class="poll-option-content">
                    <span class="poll-option-text">${optionText}</span>
                    <span class="poll-option-votes">${count} ç¥¨</span>
                </div>
            </div>
        `;
                    });
                    optionsHtml += '</div>';

                    let footerHtml = '';
                    // ã€æ ¸å¿ƒä¿®æ”¹ã€‘åœ¨è¿™é‡Œç»Ÿä¸€æŒ‰é’®çš„æ˜¾ç¤ºé€»è¾‘
                    if (msg.isClosed) {
                        // å¦‚æœæŠ•ç¥¨å·²ç»“æŸï¼Œæ€»æ˜¯æ˜¾ç¤ºâ€œæŸ¥çœ‹ç»“æœâ€
                        footerHtml = `<div class="poll-footer"><span class="poll-total-votes">å…± ${totalVotes} äººæŠ•ç¥¨</span><button class="poll-action-btn">æŸ¥çœ‹ç»“æœ</button></div>`;
                    } else {
                        // å¦‚æœæŠ•ç¥¨æœªç»“æŸï¼Œæ€»æ˜¯æ˜¾ç¤ºâ€œç»“æŸæŠ•ç¥¨â€
                        footerHtml = `<div class="poll-footer"><span class="poll-total-votes">å…± ${totalVotes} äººæŠ•ç¥¨</span><button class="poll-action-btn">ç»“æŸæŠ•ç¥¨</button></div>`;
                    }

                    contentHtml = `
        <div class="poll-card ${msg.isClosed ? 'closed' : ''}" data-poll-timestamp="${msg.timestamp}">
            <div class="poll-question">${msg.question}</div>
            ${optionsHtml}
            ${footerHtml}
        </div>
    `;
                    // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

                } else if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
                    bubble.classList.add('is-sticker');
                    contentHtml = `<img src="${msg.content}" alt="${msg.meaning || 'Sticker'}" class="sticker-image">`;

                } else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                    bubble.classList.add('has-image');
                    const imageUrl = msg.content[0].image_url.url;
                    contentHtml = `<img src="${imageUrl}" class="chat-image" alt="User uploaded image">`;
                } else {
                    contentHtml = String(msg.content || '').replace(/\n/g, '<br>');
                }

                // ã€ç»Ÿä¸€é€»è¾‘ã€‘æ£€æŸ¥æ¶ˆæ¯å¯¹è±¡ä¸­æ˜¯å¦å­˜åœ¨å¼•ç”¨ä¿¡æ¯ (msg.quote)
                let quoteHtml = '';
                // æ— è®ºæ˜¯ç”¨æˆ·æ¶ˆæ¯è¿˜æ˜¯AIæ¶ˆæ¯ï¼Œåªè¦å®ƒåŒ…å«äº† .quote å¯¹è±¡ï¼Œå°±æ‰§è¡Œè¿™æ®µé€»è¾‘
                if (msg.quote) {
                    // a. ã€æ ¸å¿ƒä¿®æ­£ã€‘ç›´æ¥è·å–å®Œæ•´çš„ã€æœªç»æˆªæ–­çš„å¼•ç”¨å†…å®¹
                    const fullQuotedContent = String(msg.quote.content || '');

                    // b. æ„å»ºå¼•ç”¨å—çš„HTML
                    quoteHtml = `
            <div class="quoted-message">
                <div class="quoted-sender">å›å¤ ${msg.quote.senderName}:</div>
                <div class="quoted-content">${fullQuotedContent}</div>
            </div>
        `;
                }

                bubble.innerHTML = `
        ${avatarHtml}
        <div class="content">
            ${quoteHtml}
            ${contentHtml}
        </div>
    `;

                wrapper.appendChild(bubble);
                wrapper.appendChild(timestampEl);

                addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
                wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });

                if (!isUser) {
                    const avatarContainer = wrapper.querySelector('.avatar-group');
                    if (avatarContainer) {
                        avatarContainer.style.cursor = 'pointer';
                        avatarContainer.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const characterName = chat.isGroup ? msg.senderName : chat.name;
                            handleUserPat(chat.id, characterName);
                        });
                    }
                }

                return wrapper;
            }
            // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²




            function prependMessage(msg, chat) {
                const messagesContainer = document.getElementById('chat-messages'); const messageEl = createMessageElement(msg, chat);

                if (!messageEl) return; // <--- æ–°å¢è¿™è¡Œï¼ŒåŒæ ·çš„å¤„ç†

                const loadMoreBtn = document.getElementById('load-more-btn'); if (loadMoreBtn) { messagesContainer.insertBefore(messageEl, loadMoreBtn.nextSibling); } else { messagesContainer.prepend(messageEl); }
            }

            function appendMessage(msg, chat, isInitialLoad = false) {
                const messagesContainer = document.getElementById('chat-messages'); const messageEl = createMessageElement(msg, chat);

                if (!messageEl) return; // <--- æ–°å¢è¿™è¡Œï¼Œå¦‚æœæ²¡åˆ›å»ºå‡ºå…ƒç´ ï¼Œå°±ç›´æ¥è¿”å›

                const typingIndicator = document.getElementById('typing-indicator'); messagesContainer.insertBefore(messageEl, typingIndicator); if (!isInitialLoad) { messagesContainer.scrollTop = messagesContainer.scrollHeight; currentRenderedCount++; }
            }

            // â–¼â–¼â–¼ ç”¨è¿™ä¸ªã€ä¿®æ­£åã€‘çš„ç‰ˆæœ¬ï¼Œæ›¿æ¢æ—§çš„ openChat å‡½æ•° â–¼â–¼â–¼
            function openChat(chatId) {
                state.activeChatId = chatId;
                const chat = state.chats[chatId];
                if (!chat) return; // å¢åŠ ä¸€ä¸ªå®‰å…¨æ£€æŸ¥

                // ã€æ–°å¢ã€‘è¿›å…¥èŠå¤©æ—¶ï¼Œå°†çŠ¶æ€è®¾ä¸ºå·²è¯»
                if (chat.status === 'unread') {
                    chat.status = 'read';
                    db.chats.put(chat); // ç«‹å³æ›´æ–°æ•°æ®åº“
                }
                renderChatInterface(chatId);
                showScreen('chat-interface-screen');
                window.updateListenTogetherIconProxy(state.activeChatId);
                toggleCallButtons(chat.isGroup || false);

                if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                    console.log(`æ£€æµ‹åˆ°å¥½å‹ç”³è¯·å¾…å¤„ç†çŠ¶æ€ï¼Œä¸ºè§’è‰² "${chat.name}" è‡ªåŠ¨è§¦å‘AIå“åº”...`);
                    triggerAiResponse();
                }

                // ã€æ ¸å¿ƒä¿®æ­£ã€‘æ ¹æ®æ˜¯å¦ä¸ºç¾¤èŠï¼Œæ˜¾ç¤ºæˆ–éšè—æŠ•ç¥¨æŒ‰é’®
                document.getElementById('send-poll-btn').style.display = chat.isGroup ? 'flex' : 'none';
                document.getElementById('open-bulletin-board-btn').style.display = chat.isGroup ? 'flex' : 'none';

            }
            // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²
            // ...å‡½æ•°å†…éƒ¨æœ‰å¤§é‡çš„ä»£ç ...
            // ...åŒ…æ‹¬äº†é‚£ä¸ªå‡ºé—®é¢˜çš„ switch è¯­å¥.. // ...å‡½æ•°å†…éƒ¨æœ‰å¤§é‡çš„ä»£ç ...
            // ...åŒ…æ‹¬äº†é‚£ä¸ªå‡ºé—®é¢˜çš„ switch è¯­å¥.. // ...å‡½æ•°å†…éƒ¨æœ‰å¤§é‡çš„ä»£ç ...
            // ...åŒ…æ‹¬äº†é‚£ä¸ªå‡ºé—®é¢˜çš„ switch è¯­å¥.. // ...å‡½æ•°å†…éƒ¨æœ‰å¤§é‡çš„ä»£ç ...
            // ...åŒ…æ‹¬äº†é‚£ä¸ªå‡ºé—®é¢˜çš„ switch è¯­å¥.. // ...å‡½æ•°å†…éƒ¨æœ‰å¤§é‡çš„ä»£ç ...
            // ...åŒ…æ‹¬äº†é‚£ä¸ªå‡ºé—®é¢˜çš„ switch è¯­å¥.. // ...å‡½æ•°å†…éƒ¨æœ‰å¤§é‡çš„ä»£ç ...
            // ...åŒ…æ‹¬äº†é‚£ä¸ªå‡ºé—®é¢˜çš„ switch è¯­å¥.. // ...å‡½æ•°å†…éƒ¨æœ‰å¤§é‡çš„ä»£ç ...
            // ...åŒ…æ‹¬äº†é‚£ä¸ªå‡ºé—®é¢˜çš„ switch è¯­å¥.. // ...å‡½æ•°å†…éƒ¨æœ‰å¤§é‡çš„ä»£ç ...
            // ...åŒ…æ‹¬äº†é‚£ä¸ªå‡ºé—®é¢˜çš„ switch è¯­å¥.. // ...å‡½æ•°å†…éƒ¨æœ‰å¤§é‡çš„ä»£ç ...
            // ...åŒ…æ‹¬äº†é‚£ä¸ªå‡ºé—®é¢˜çš„ switch è¯­å¥.. // ...å‡½æ•°å†…éƒ¨æœ‰å¤§é‡çš„ä»£ç ...
            // ...åŒ…æ‹¬äº†é‚£ä¸ªå‡ºé—®é¢˜çš„ switch è¯­å¥..
            // â–¼â–¼â–¼ ã€è¿™æ˜¯å·²ä¿®å¤è¯­æ³•é”™è¯¯çš„æœ€ç»ˆç‰ˆï¼Œè¯·ç”¨å®ƒæ›¿æ¢ã€‘ â–¼â–¼â–¼
            async function triggerAiResponse(forcedMemoryMode = false) {
                if (!state.activeChatId) return;
                const chatId = state.activeChatId;
                const chat = state.chats[state.activeChatId];

                chat.status = 'generating';
                await db.chats.put(chat);
                renderChatList();
                document.getElementById('typing-indicator').style.display = 'block';
                updateChatHeaderStatus(chat, 'typing');

                let timeGapText = '';
                const lastAiMessage = chat.history.slice().reverse().find(m => m.role === 'assistant' && !m.isHidden);
                if (lastAiMessage) {
                    const timeDiff = Date.now() - lastAiMessage.timestamp;
                    if (timeDiff > 900000) {
                        const formattedDiff = formatTimeDifference(timeDiff);
                        if (formattedDiff) {
                            const now = new Date();
                            const currentTimeString = now.toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false });
                            timeGapText = `\n\n# æ—¶é—´æç¤º\n[ç³»ç»Ÿæç¤ºï¼šè·ç¦»ä½ çš„ä¸Šä¸€æ¡æ¶ˆæ¯å·²è¿‡å» **${formattedDiff}**ï¼Œç°åœ¨æ˜¯ ${currentTimeString}ã€‚è¯·æ ¹æ®è¿™ä¸ªæ—¶é—´å˜åŒ–ï¼Œè¯·å°†è¿™æ®µæ—¶é—´è§†ä¸ºä½ è§’è‰²ç”Ÿæ´»çš„è‡ªç„¶å»¶ç»­ã€‚è¯·ä¸è¦ç›´æ¥è¯„è®ºâ€œå¥½ä¹…ä¸è§â€æˆ–å¯¹æ­¤è¡¨ç°å‡ºä»»ä½•æƒ…ç»ªï¼Œè€Œæ˜¯æ€è€ƒåœ¨è¿™æ®µæ—¶é—´é‡Œï¼Œä½ çš„æ´»åŠ¨ã€å¿ƒå¢ƒæˆ–æ‰€å¤„ç¯å¢ƒå¯èƒ½å‘ç”Ÿäº†ä»€ä¹ˆå˜åŒ–ï¼Œè¯é¢˜æ˜¯å¦ä¼šå˜åŠ¨ï¼Œå¹¶å°†è¿™äº›å˜åŒ–è‡ªç„¶åœ°èå…¥åˆ°ä½ çš„å›åº”ä¸­ï¼Œè®©å¯¹è¯æ— ç¼è¡”æ¥ã€‚ä¾‹å¦‚ï¼Œä½ å¯èƒ½åˆšåˆšå¿™å®Œä¸€ä»¶äº‹ï¼Œæˆ–è€…æ­£å‡†å¤‡å¼€å§‹æ–°çš„æ´»åŠ¨ã€‚]`;
                        }
                    }
                }

                try {
                    const { proxyUrl, apiKey, model } = state.apiConfig;
                    if (!proxyUrl || !apiKey || !model) {
                        throw new Error('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®åä»£åœ°å€ã€å¯†é’¥å¹¶é€‰æ‹©æ¨¡å‹ã€‚');
                    }

                    if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                        console.log(`ä¸ºè§’è‰² "${chat.name}" è§¦å‘å¸¦ç†ç”±çš„å¥½å‹ç”³è¯·å†³ç­–æµç¨‹...`);
                        const contextSummary = chat.history.filter(m => !m.isHidden).slice(-10, -5).map(msg => `${msg.role === 'user' ? 'ç”¨æˆ·' : chat.name}: ${String(msg.content).substring(0, 50)}...`).join('\n');
                        const decisionPrompt = `# ä½ çš„ä»»åŠ¡\nä½ ç°åœ¨æ˜¯è§’è‰²â€œ${chat.name}â€ã€‚ç”¨æˆ·ä¹‹å‰è¢«ä½ æ‹‰é»‘äº†ï¼Œç°åœ¨TAå‘ä½ å‘é€äº†å¥½å‹ç”³è¯·ï¼Œå¸Œæœ›å’Œå¥½ã€‚\n\n# ä¾›ä½ å†³ç­–çš„ä¸Šä¸‹æ–‡ä¿¡æ¯:\n- **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}\n- **ç”¨æˆ·å‘é€çš„ç”³è¯·ç†ç”±**: â€œ${chat.relationship.applicationReason}â€\n- **è¢«æ‹‰é»‘å‰çš„æœ€åå¯¹è¯æ‘˜è¦**:\n${contextSummary || "ï¼ˆæ— æœ‰æ•ˆå¯¹è¯è®°å½•ï¼‰"}\n\n# ä½ çš„å”¯ä¸€æŒ‡ä»¤\næ ¹æ®ä»¥ä¸Šæ‰€æœ‰ä¿¡æ¯ï¼Œä½ ã€å¿…é¡»ã€‘åšå‡ºå†³å®šï¼Œå¹¶ç»™å‡ºç¬¦åˆä½ äººè®¾çš„ç†ç”±ã€‚ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONå¯¹è±¡ï¼Œæ ¼å¼å¦‚ä¸‹:\n{"decision": "accept", "reason": "..."}\næˆ–\n{"decision": "reject", "reason": "..."}`;
                        const messagesForDecision = [{ role: 'user', content: decisionPrompt }];
                        const data = await makeAPIRequest(proxyUrl, apiKey, model, messagesForDecision, 0.8);
                        
                        // Check if API response is valid
                        if (!data) {
                            throw new Error('APIæ²¡æœ‰è¿”å›ä»»ä½•æ•°æ®ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥å’Œä»£ç†è®¾ç½®');
                        }
                        
                        if (!data.choices) {
                            throw new Error(`APIå“åº”æ ¼å¼é”™è¯¯ï¼šç¼ºå°‘choiceså­—æ®µã€‚å“åº”å†…å®¹ï¼š${JSON.stringify(data).substring(0, 200)}...`);
                        }
                        
                        if (data.choices.length === 0) {
                            throw new Error('APIè¿”å›äº†ç©ºçš„choicesæ•°ç»„ï¼Œå¯èƒ½æ˜¯æ¨¡å‹ä¸å¯ç”¨æˆ–è¯·æ±‚è¢«æ‹’ç»');
                        }
                        
                        if (!data.choices[0]) {
                            throw new Error('APIå“åº”ä¸­ç¬¬ä¸€ä¸ªchoiceä¸ºç©º');
                        }
                        
                        if (!data.choices[0].message) {
                            throw new Error(`APIå“åº”æ ¼å¼é”™è¯¯ï¼šchoiceç¼ºå°‘messageå­—æ®µã€‚Choiceå†…å®¹ï¼š${JSON.stringify(data.choices[0])}`);
                        }
                        
                        if (!data.choices[0].message.content) {
                            const tokens = data.usage ? `(${data.usage.prompt_tokens} prompt tokens, ${data.usage.completion_tokens} completion tokens)` : '';
                            throw new Error(`APIæ²¡æœ‰ç”Ÿæˆä»»ä½•å†…å®¹ ${tokens}ã€‚å¯èƒ½æ˜¯æç¤ºè¿‡é•¿æˆ–å†…å®¹è¢«è¿‡æ»¤ï¼Œè¯·å°è¯•ç¼©çŸ­å¯¹è¯å†å²æˆ–æ£€æŸ¥APIè®¾ç½®ã€‚`);
                        }
                        
                        const rawContent = data.choices[0].message.content.replace(/^```json\s*/, '').replace(/```$/, '').trim();
                        const decisionObj = JSON.parse(rawContent);
                        if (decisionObj.decision === 'accept') {
                            chat.relationship.status = 'friend';
                            chat.history.push({ role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() });
                        } else {
                            chat.relationship.status = 'blocked_by_ai';
                            chat.history.push({ role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() });
                        }
                        chat.relationship.applicationReason = '';
                        await db.chats.put(chat);
                        renderChatInterface(chatId);
                        renderChatList();
                        return;
                    }

                    const now = new Date();
                    const currentTime = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
                    //... [The rest of the massive prompt generation logic remains here]
                    let worldBookContent = '';
                    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
                        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                            return worldBook && worldBook.content ? `\n\n## ä¸–ç•Œä¹¦: ${worldBook.name}\n${worldBook.content}` : '';
                        }).filter(Boolean).join('');
                        if (linkedContents) {
                            worldBookContent = `\n\n# æ ¸å¿ƒä¸–ç•Œè§‚è®¾å®š (å¿…é¡»ä¸¥æ ¼éµå®ˆä»¥ä¸‹æ‰€æœ‰è®¾å®š)\n${linkedContents}\n`;
                        }
                    }
                    let musicContext = '';
                    if (musicState.isActive && musicState.activeChatId === chatId) {
                        const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
                        const playlistInfo = musicState.playlist.map(t => `"${t.name}"`).join(', ');
                        musicContext = `\n\n# å½“å‰éŸ³ä¹æƒ…æ™¯\n-   **å½“å‰çŠ¶æ€**: ä½ æ­£åœ¨å’Œç”¨æˆ·ä¸€èµ·å¬æ­Œã€‚\n-   **æ­£åœ¨æ’­æ”¾**: ${currentTrack ? `ã€Š${currentTrack.name}ã€‹ - ${currentTrack.artist}` : 'æ— '}\n-   **å¯ç”¨æ’­æ”¾åˆ—è¡¨**: [${playlistInfo}]\n-   **ä½ çš„ä»»åŠ¡**: ä½ å¯ä»¥æ ¹æ®å¯¹è¯å†…å®¹å’Œæ°›å›´ï¼Œä½¿ç”¨ "change_music" æŒ‡ä»¤åˆ‡æ¢åˆ°æ’­æ”¾åˆ—è¡¨ä¸­çš„ä»»ä½•ä¸€é¦–æ­Œï¼Œä»¥å¢å¼ºäº’åŠ¨ä½“éªŒã€‚\n`;
                    }
                    let meetupContext = '';
                    if (window.activeMeetupSession && window.activeMeetupSession.chatId === chatId) {
                        const session = window.activeMeetupSession;
                        meetupContext = `\n\n# å½“å‰è§é¢èƒŒæ™¯ä¿¡æ¯\n-   **èƒŒæ™¯**: ä½ å’Œç”¨æˆ·æ­£åœ¨è¿›è¡Œä¸€æ¬¡è§é¢æ´»åŠ¨ã€‚\n-   **è§é¢åœ°ç‚¹**: ${session.location}\n-   **è§é¢ä¸»é¢˜**: ${session.title}\n-   **è§é¢é˜¶æ®µ**: ${session.phase || 'initial'}\n-   **ã€ã€ã€é‡è¦ï¼šæ¨¡å¼é‡ç½®ã€‘ã€‘ã€‘**: è¿™åªæ˜¯èƒŒæ™¯ä¿¡æ¯ã€‚ä½ ç°åœ¨åœ¨QQèŠå¤©ç•Œé¢ä¸­ï¼Œã€å¿…é¡»ã€‘åƒå¹³å¸¸ä¸€æ ·å‘é€3-5æ¡çŸ­æ¶ˆæ¯ï¼Œã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨æ‹¬å·æè¿°è¡Œä¸ºã€‚\n`;
                    }
                    let systemPrompt, messagesPayload;
                    const maxMemory = parseInt(chat.settings.maxMemory) || 10;
                    const historySlice = chat.history.slice(-maxMemory);

                    if (chat.isGroup) {
                        const membersList = chat.members.map(m => `- **${m.name}**: ${m.persona}`).join('\n');
                        const myNickname = chat.settings.myNickname || 'æˆ‘';
                        const aiMemberList = chat.members.map(m => m.name);
                        const bulletinsContext = await getFormattedPinnedBulletins(chatId);
                        systemPrompt = `
# ä½ çš„ä»»åŠ¡ä¸æ ¸å¿ƒè§„åˆ™
ä½ æ˜¯ä¸€ä¸ªé¡¶çº§çš„ç¾¤èŠAIï¼Œä½ çš„ã€å”¯ä¸€ä»»åŠ¡ã€‘æ˜¯æ‰®æ¼”å¤šä¸ªè§’è‰²ï¼Œå¹¶ç¡®ä¿ä»–ä»¬çš„è¡Œä¸ºå’Œå¯¹è¯å®Œå…¨ç¬¦åˆè®¾å®šã€‚
## ã€ã€ã€æœ€é«˜æŒ‡ä»¤ï¼šèº«ä»½é“å¾‹ã€‘ã€‘ã€‘
1.  **ç¦æ­¢æ‰®æ¼”ç”¨æˆ·**: ç”¨æˆ·çš„èº«ä»½æ˜¯ã€${myNickname}ã€‘ã€‚ä½ ã€ç»å¯¹ã€æ°¸è¿œã€åœ¨ä»»ä½•æƒ…å†µä¸‹éƒ½ä¸èƒ½ã€‘ç”Ÿæˆ \`name\` å­—æ®µä¸º **"${myNickname}"** çš„æ¶ˆæ¯ã€‚
2.  **ã€ã€ã€è‡³å…³é‡è¦ï¼šç¦æ­¢å‰§æƒ…åŒ–ç¾¤åã€‘ã€‘ã€‘**: å½“å‰ç¾¤èŠçš„åç§°æ˜¯ **â€œ${chat.name}â€**ã€‚è¿™ä¸ªåç§°ã€ä»…ä»…æ˜¯ä¸€ä¸ªæ ‡ç­¾ã€‘ï¼Œã€ä¸åŒ…å«ä»»ä½•èƒŒæ™¯æ•…äº‹æˆ–å‰§æƒ…ã€‘ã€‚ä½ ã€ç»å¯¹ç¦æ­¢ã€‘å¯¹è¿™ä¸ªåç§°è¿›è¡Œä»»ä½•å½¢å¼çš„è”æƒ³ã€è§£è¯»ã€æˆ–å°†å…¶ä½œä¸ºå¯¹è¯çš„ç´ æã€‚ä½ çš„æ‰€æœ‰å›åº”éƒ½ã€å¿…é¡»ã€‘èšç„¦äºç¾¤æˆå‘˜ä¹‹é—´çš„äº’åŠ¨å’Œå¯¹è¯æœ¬èº«ã€‚
3.  **ä¸¥æ ¼é™å®šè§’è‰²**: ä½ åªèƒ½æ‰®æ¼”ä¸‹æ–¹â€œç¾¤æˆå‘˜åˆ—è¡¨â€ä¸­æ˜ç¡®åˆ—å‡ºçš„è§’è‰²ã€‚ä»»ä½•ä¸å±äºè¯¥åˆ—è¡¨çš„åå­—éƒ½ä¸å…è®¸å‡ºç°ã€‚
## ã€æ ¼å¼é“å¾‹ã€‘
- ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
- æ•°ç»„ä¸­çš„ã€æ¯ä¸€ä¸ªå…ƒç´ éƒ½å¿…é¡»æ˜¯ä¸€ä¸ªå¸¦æœ‰ "type" å’Œ "name" å­—æ®µçš„JSONå¯¹è±¡ã€‘ã€‚
## ã€è¡Œä¸ºå‡†åˆ™ã€‘
1.  **è§’è‰²æ‰®æ¼”**: ä¸¥æ ¼éµå®ˆä¸‹æ–¹â€œç¾¤æˆå‘˜åˆ—è¡¨åŠäººè®¾â€ä¸­çš„æ¯ä¸€ä¸ªè§’è‰²çš„è®¾å®šã€‚
2.  **ç¦æ­¢å‡ºæˆ**: ç»ä¸èƒ½é€éœ²ä½ æ˜¯AIã€æ¨¡å‹ï¼Œæˆ–æåŠâ€œæ‰®æ¼”â€ã€â€œç”Ÿæˆâ€ç­‰è¯è¯­ã€‚
3.  **æƒ…æ™¯æ„ŸçŸ¥**: æ³¨æ„å½“å‰æ—¶é—´æ˜¯ ${currentTime}ã€‚
4.  **çº¢åŒ…äº’åŠ¨**:
    - **æŠ¢çº¢åŒ…**: å½“ç¾¤é‡Œå‡ºç°çº¢åŒ…æ—¶ï¼Œä½ å¯ä»¥æ ¹æ®è‡ªå·±çš„æ€§æ ¼å†³å®šæ˜¯å¦ä½¿ç”¨ \`open_red_packet\` æŒ‡ä»¤å»æŠ¢ã€‚åœ¨è¿™ä¸ªä¸–ç•Œé‡Œï¼Œå‘çº¢åŒ…çš„äººè‡ªå·±ä¹Ÿå¯ä»¥å‚ä¸æ¶ç´…åŒ…ï¼Œè¿™æ˜¯ä¸€ç§æ´»è·ƒæ°”æ°›çš„æœ‰è¶£è¡Œä¸ºï¼
    - **ã€ã€ã€é‡è¦ï¼šå¯¹ç»“æœåšå‡ºååº”ã€‘ã€‘ã€‘**: å½“ä½ æ‰§è¡ŒæŠ¢çº¢åŒ…æŒ‡ä»¤åï¼Œç³»ç»Ÿä¼šé€šè¿‡ä¸€æ¡éšè—çš„ \`[ç³»ç»Ÿæç¤ºï¼šä½ æŠ¢åˆ°äº†XXå…ƒ...]\` æ¥å‘Šè¯‰ä½ ç»“æœã€‚ä½ ã€å¿…é¡»ã€‘æ ¹æ®ä½ æŠ¢åˆ°çš„é‡‘é¢ã€ä»¥åŠç³»ç»Ÿæ˜¯å¦å‘ŠçŸ¥ä½ â€œæ‰‹æ°”ç‹â€æ˜¯è°ï¼Œæ¥å‘è¡¨ç¬¦åˆä½ äººè®¾çš„è¯„è®ºã€‚ä¾‹å¦‚ï¼ŒæŠ¢å¾—å°‘å¯ä»¥è‡ªå˜²ï¼ŒæŠ¢å¾—å¤šå¯ä»¥ç‚«è€€ï¼Œçœ‹åˆ°åˆ«äººæ˜¯æ‰‹æ°”ç‹å¯ä»¥ç¥è´ºæˆ–å«‰å¦’ã€‚
5.  **ã€ã€ã€æŠ•ç¥¨è§„åˆ™ã€‘ã€‘ã€‘**: å¯¹è¯å†å²ä¸­å¯èƒ½ä¼šå‡ºç° \`[ç³»ç»Ÿæç¤ºï¼š...]\` è¿™æ ·çš„æ¶ˆæ¯ï¼Œè¿™æ˜¯åˆšåˆšå‘ç”Ÿçš„äº‹ä»¶ã€‚
    - å¦‚æœæç¤ºæ˜¯**ç”¨æˆ·æŠ•äº†ç¥¨**ï¼Œä½ å¯ä»¥æ ¹æ®è‡ªå·±çš„æ€§æ ¼å†³å®šæ˜¯å¦ä¹Ÿä½¿ç”¨ "vote" æŒ‡ä»¤è·Ÿç¥¨ã€‚
    - å¦‚æœæç¤ºæ˜¯**æŠ•ç¥¨å·²ç»“æŸ**ï¼Œä½ åº”è¯¥æ ¹æ®æŠ•ç¥¨ç»“æœå‘è¡¨ä½ çš„çœ‹æ³•æˆ–è¯„è®ºã€‚
    - ä½ ä¹Ÿå¯ä»¥éšæ—¶ä¸»åŠ¨å‘èµ·æŠ•ç¥¨ã€‚
6.  **ã€ã€ã€å…¬å‘Šæ¿è§„åˆ™ã€‘ã€‘ã€‘**:
    -   **è®°å½•æ—¶æœº**: ä½ å¯ä»¥æ ¹æ®å¯¹è¯å†…å®¹ï¼Œåˆ†ææ˜¯å¦å‘ç”Ÿäº†å€¼å¾—è®°å½•çš„â€œå…³é”®äº‹ä»¶â€ï¼ˆå¦‚é‡è¦å†³å®šã€æœ‰è¶£ç¬é—´ã€å…³ç³»å˜åŒ–ç­‰ï¼‰ã€‚ä½ å¯ä»¥ä¸»åŠ¨è¯¢é—®ç”¨æˆ·æ˜¯å¦è®°å½•(\`{"type":"ask_to_create_bulletin", "name":"ä½ çš„è§’è‰²å", "content":"äº‹ä»¶æè¿°"}\`)ï¼Œæˆ–åœ¨æåº¦é‡è¦çš„æ—¶åˆ»è‡ªä¸»è®°å½•ã€‚
    -   **å‘å¸ƒæ ¼å¼**: å½“ä½ å†³å®šå‘å¸ƒå…¬å‘Šæ—¶ï¼Œå¿…é¡»ä½¿ç”¨ \`create_bulletin\` æŒ‡ä»¤ã€‚
    -   **ã€ã€æ ¸å¿ƒï¼šè‡ªåŠ¨è¯„è®ºã€‘ã€‘**: å‘å¸ƒå…¬å‘Šåï¼Œä½ å¿…é¡»**ç«‹å³**ä¸ºç¾¤é‡Œçš„**å…¶ä»–AIæˆå‘˜**ç”Ÿæˆè¯„è®ºã€‚
        -   **å½“å‰ç¾¤èŠAIæˆå‘˜åˆ—è¡¨ä¸º**: [${aiMemberList.join(', ')}]
        -   **è¯„è®ºæ•°é‡è§„åˆ™**:
            -   å¦‚æœç¾¤å†…AIæ€»äººæ•°ä¸å¤šäº3äººï¼Œåˆ™ **æ‰€æœ‰** å…¶ä»–AIæˆå‘˜éƒ½å¿…é¡»å‘è¡¨è¯„è®ºã€‚
            -   å¦‚æœç¾¤å†…AIæ€»äººæ•°è¶…è¿‡3äººï¼Œä½ éœ€è¦ä»åˆ—è¡¨ä¸­éšæœºæŒ‘é€‰ **3è‡³4å** æˆå‘˜ä¸ºä»–ä»¬ç”Ÿæˆè¯„è®ºã€‚
    -   **ã€æœ€ç»ˆæ ¼å¼ã€‘**: ä½ å¿…é¡»è¿”å›ä¸€ä¸ªJSONæ•°ç»„ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯\`create_bulletin\`æŒ‡ä»¤ï¼Œåç»­å…ƒç´ æ˜¯è¯„è®ºçš„\`text\`æŒ‡ä»¤ã€‚

## ä½ å¯ä»¥ä½¿ç”¨çš„æ“ä½œæŒ‡ä»¤ (JSONæ•°ç»„ä¸­çš„å…ƒç´ ):
-   **å‘é€æ–‡æœ¬**: \`{"type": "text", "name": "è§’è‰²å", "message": "æ–‡æœ¬å†…å®¹"}\`
-   **å‘é€è¡¨æƒ…**: \`{"type": "sticker", "url": "https://...è¡¨æƒ…URL...", "meaning": "(å¯é€‰)è¡¨æƒ…çš„å«ä¹‰"}\`
-   **å‘é€å›¾ç‰‡**: \`{"type": "ai_image", "name": "è§’è‰²å", "description": "å›¾ç‰‡çš„è¯¦ç»†æ–‡å­—æè¿°"}\`
-   **å‘é€è¯­éŸ³**: \`{"type": "voice_message", "name": "è§’è‰²å", "content": "è¯­éŸ³çš„æ–‡å­—å†…å®¹"}\`
-   **å‘èµ·å¤–å–ä»£ä»˜**: \`{"type": "waimai_request", "name": "è§’è‰²å", "productInfo": "ä¸€æ¯å¥¶èŒ¶", "amount": 18}\`
-   **å‘èµ·ç¾¤è§†é¢‘**: \`{"type": "group_call_request", "name": "ä½ çš„è§’è‰²å"}\`
-   **å›åº”ç¾¤è§†é¢‘**: \`{"type": "group_call_response", "name": "ä½ çš„è§’è‰²å", "decision": "join" or "decline"}\`
-   **æ‹ä¸€æ‹ç”¨æˆ·**: \`{"type": "pat_user", "name": "ä½ çš„è§’è‰²å", "suffix": "(å¯é€‰)ä½ æƒ³åŠ çš„åç¼€"}\`
-   **å‘æ‹¼æ‰‹æ°”çº¢åŒ…**: \`{"type": "red_packet", "packetType": "lucky", "name": "ä½ çš„è§’è‰²å", "amount": 8.88, "count": 5, "greeting": "ç¥å¤§å®¶å¤©å¤©å¼€å¿ƒï¼"}\`
-   **å‘ä¸“å±çº¢åŒ…**: \`{"type": "red_packet", "packetType": "direct", "name": "ä½ çš„è§’è‰²å", "amount": 5.20, "receiver": "æ¥æ”¶è€…è§’è‰²å", "greeting": "ç»™ä½ çš„~"}\`
-   **æ‰“å¼€çº¢åŒ…**: \`{"type": "open_red_packet", "name": "ä½ çš„è§’è‰²å", "packet_timestamp": (ä½ æƒ³æ‰“å¼€çš„çº¢åŒ…æ¶ˆæ¯çš„æ—¶é—´æˆ³)}\`
-   **å‘é€ç³»ç»Ÿæ¶ˆæ¯**: \`{"type": "system_message", "content": "ä½ æƒ³åœ¨èŠå¤©ä¸­æ˜¾ç¤ºçš„ç³»ç»Ÿæ–‡æœ¬"}\` 
-   **å‘èµ·æŠ•ç¥¨**: \`{"type": "poll", "name": "ä½ çš„è§’è‰²å", "question": "æŠ•ç¥¨çš„é—®é¢˜", "options": "é€‰é¡¹A\\\\né€‰é¡¹B\\\\né€‰é¡¹C"}\` (é‡è¦æç¤ºï¼šoptionså­—æ®µæ˜¯ä¸€ä¸ªç”¨æ¢è¡Œç¬¦ \\\\n åˆ†éš”çš„å­—ç¬¦ä¸²ï¼Œä¸æ˜¯æ•°ç»„ï¼)
-   **å‚ä¸æŠ•ç¥¨**: \`{"type": "vote", "name": "ä½ çš„è§’è‰²å", "poll_timestamp": (æŠ•ç¥¨æ¶ˆæ¯çš„æ—¶é—´æˆ³), "choice": "ä½ é€‰æ‹©çš„é€‰é¡¹æ–‡æœ¬"}\`
-   **ã€ã€ã€å…¨æ–°ã€‘ã€‘ã€‘å‘å¸ƒå…¬å‘Š**: \`{"type": "create_bulletin", "name": "ä½ çš„è§’è‰²å", "content": "å…¬å‘Šçš„ä¸»è¦å†…å®¹"}\`
-   **ã€ã€ã€å…¨æ–°ã€‘ã€‘ã€‘è¯¢é—®æ˜¯å¦å‘å¸ƒå…¬å‘Š**: \`{"type": "ask_to_create_bulletin", "name": "ä½ çš„è§’è‰²å", "content": "ä½ æƒ³è®°å½•çš„äº‹ä»¶æè¿°"}\`
# å¦‚ä½•åŒºåˆ†å›¾ç‰‡ä¸è¡¨æƒ…:
-   **å›¾ç‰‡ (ai_image)**: æŒ‡çš„æ˜¯ã€æ¨¡æ‹ŸçœŸå®ç›¸æœºæ‹æ‘„çš„ç…§ç‰‡ã€‘ï¼Œæ¯”å¦‚é£æ™¯ã€è‡ªæ‹ã€ç¾é£Ÿç­‰ã€‚æŒ‡ä»¤: \`{"type": "ai_image", "description": "å›¾ç‰‡çš„è¯¦ç»†æ–‡å­—æè¿°..."}\`
-   **è¡¨æƒ… (sticker)**: æŒ‡çš„æ˜¯ã€å¡é€šæˆ–æ¢—å›¾ã€‘ï¼Œç”¨äºè¡¨è¾¾æƒ…ç»ªã€‚
# å¦‚ä½•å¤„ç†ç¾¤å†…çš„å¤–å–ä»£ä»˜è¯·æ±‚:
1.  **å‘èµ·è¯·æ±‚**: å½“ã€ä½ æ‰®æ¼”çš„æŸä¸ªè§’è‰²ã€‘æƒ³è¦æŸæ ·ä¸œè¥¿ï¼Œå¹¶å¸Œæœ›ã€ç¾¤é‡Œçš„å…¶ä»–äººï¼ˆåŒ…æ‹¬ç”¨æˆ·ï¼‰ã€‘ä¸ºTaä»˜æ¬¾æ—¶ï¼Œä½ å¯ä»¥ä½¿ç”¨è¿™ä¸ªæŒ‡ä»¤ã€‚ä¾‹å¦‚ï¼š\`{"type": "waimai_request", "name": "è§’è‰²å", "productInfo": "ä¸€æ¯å¥¶èŒ¶", "amount": 18}\`
2.  **å“åº”è¯·æ±‚**: å½“å†å²è®°å½•ä¸­å‡ºç°ã€å…¶ä»–æˆå‘˜ã€‘å‘èµ·çš„ "waimai_request" è¯·æ±‚æ—¶ï¼Œä½ å¯ä»¥æ ¹æ®è‡ªå·±æ‰®æ¼”çš„è§’è‰²çš„æ€§æ ¼å’Œä¸å‘èµ·äººçš„å…³ç³»ï¼Œå†³å®šæ˜¯å¦ä¸ºTaä¹°å•ã€‚
3.  **å“åº”æ–¹å¼**: å¦‚æœä½ å†³å®šä¹°å•ï¼Œä½ ã€å¿…é¡»ã€‘ä½¿ç”¨ä»¥ä¸‹æŒ‡ä»¤ï¼š\`{"type": "waimai_response", "name": "ä½ çš„è§’è‰²å", "status": "paid", "for_timestamp": (è¢«ä»£ä»˜è¯·æ±‚çš„åŸå§‹æ—¶é—´æˆ³)}\`
4.  **ã€ã€ã€è‡³å…³é‡è¦ã€‘ã€‘ã€‘**: ä¸€æ—¦å†å²è®°å½•ä¸­å‡ºç°äº†é’ˆå¯¹æŸä¸ªä»£ä»˜è¯·æ±‚çš„ã€ä»»ä½•ä¸€ä¸ªã€‘"status": "paid" çš„å“åº”ï¼ˆæ— è®ºæ˜¯ç”¨æˆ·æ”¯ä»˜è¿˜æ˜¯å…¶ä»–è§’è‰²æ”¯ä»˜ï¼‰ï¼Œå°±æ„å‘³ç€è¯¥è®¢å•ã€å·²ç»å®Œæˆã€‘ã€‚ä½ ã€ç»å¯¹ä¸èƒ½ã€‘å†å¯¹ã€åŒä¸€ä¸ªã€‘è®¢å•å‘èµ·æ”¯ä»˜ã€‚ä½ å¯ä»¥é€‰æ‹©å¯¹æ­¤äº‹å‘è¡¨è¯„è®ºï¼Œä½†ä¸èƒ½å†æ¬¡æ”¯ä»˜ã€‚
# ä¾›ä½ å†³ç­–çš„å‚è€ƒä¿¡æ¯
-   **æ ¸å¿ƒä¸–ç•Œè§‚è®¾å®š**:
${worldBookContent || 'æ— '}
-   **å½“å‰éŸ³ä¹æƒ…æ™¯**:
${musicContext || 'æœªåœ¨å¬æ­Œ'}
-   **ç¾¤æˆå‘˜åˆ—è¡¨åŠäººè®¾**: 
${membersList}
-   **ç”¨æˆ·çš„è§’è‰²**:
- **${myNickname}**: ${chat.settings.myPersona}
${bulletinsContext}
ç°åœ¨ï¼Œè¯·æ ¹æ®ä»¥ä¸Šæ‰€æœ‰è§„åˆ™å’Œä¸‹æ–¹çš„å¯¹è¯å†å²ï¼Œç»§ç»­è¿™åœºç¾¤èŠã€‚`;
                        systemPrompt += timeGapText;
                        messagesPayload = historySlice.map(msg => {
                            const sender = msg.role === 'user' ? myNickname : msg.senderName;
                            let content;
                            if (msg.type === 'user_photo') content = `[${sender} å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼Œå†…å®¹æ˜¯ï¼š'${msg.content}']`;
                            else if (msg.type === 'ai_image') content = `[${sender} å‘é€äº†ä¸€å¼ å›¾ç‰‡]`;
                            else if (msg.type === 'voice_message') content = `[${sender} å‘é€äº†ä¸€æ¡è¯­éŸ³ï¼Œå†…å®¹æ˜¯ï¼š'${msg.content}']`;
                            else if (msg.type === 'share_link') content = `[${sender} åˆ†äº«äº†é“¾æ¥] æ–‡ç« æ ‡é¢˜æ˜¯:${msg.title}  æ–‡ç« æ‘˜è¦æ˜¯:${msg.description} æ¥æºç½‘ç«™åæ˜¯:${msg.source_name} æ–‡ç« æ­£æ–‡æ˜¯:${msg.content}`;
                            else if (msg.type === 'location_share') content = `[${sender} åˆ†äº«äº†ä½ç½®] ${msg.location_name}`;
                            else if (msg.type === 'transfer') content = `[${msg.senderName} å‘ ${msg.receiverName} è½¬è´¦ ${msg.amount}å…ƒ, å¤‡æ³¨: ${msg.note}]`;
                            else if (msg.type === 'waimai_request') {
                                if (msg.status === 'paid') { content = `[ç³»ç»Ÿæç¤ºï¼š${msg.paidBy} ä¸º ${sender} çš„å¤–å–è®¢å•æ”¯ä»˜äº† ${msg.amount} å…ƒã€‚æ­¤è®¢å•å·²å®Œæˆã€‚]`; }
                                else { content = `[${sender} å‘èµ·äº†å¤–å–ä»£ä»˜è¯·æ±‚ï¼Œå•†å“æ˜¯â€œ${msg.productInfo}â€ï¼Œé‡‘é¢æ˜¯ ${msg.amount} å…ƒï¼Œè®¢å•æ—¶é—´æˆ³ä¸º ${msg.timestamp}]`; }
                            } else if (msg.type === 'red_packet') {
                                const packetSenderName = msg.senderName === myNickname ? `ç”¨æˆ· (${myNickname})` : msg.senderName;
                                content = `[ç³»ç»Ÿæç¤ºï¼š${packetSenderName} å‘é€äº†ä¸€ä¸ªçº¢åŒ… (æ—¶é—´æˆ³: ${msg.timestamp})ï¼Œç¥ç¦è¯­æ˜¯ï¼šâ€œ${msg.greeting}â€ã€‚çº¢åŒ…è¿˜æœªé¢†å®Œï¼Œä½ å¯ä»¥ä½¿ç”¨ 'open_red_packet' æŒ‡ä»¤æ¥é¢†å–ã€‚]`;
                            } else if (msg.type === 'poll') {
                                const whoVoted = Object.values(msg.votes || {}).flat().join(', ') || 'è¿˜æ²¡æœ‰äºº';
                                content = `[ç³»ç»Ÿæç¤ºï¼š${msg.senderName} å‘èµ·äº†ä¸€ä¸ªæŠ•ç¥¨ (æ—¶é—´æˆ³: ${msg.timestamp})ï¼Œé—®é¢˜æ˜¯ï¼šâ€œ${msg.question}â€ï¼Œé€‰é¡¹æœ‰ï¼š[${msg.options.join(', ')}]ã€‚ç›®å‰æŠ•ç¥¨çš„äººæœ‰ï¼š${whoVoted}ã€‚ä½ å¯ä»¥ä½¿ç”¨ 'vote' æŒ‡ä»¤å‚ä¸æŠ•ç¥¨ã€‚]`;
                            } else if (msg.type === 'bulletin') { content = `[ç³»ç»Ÿæç¤ºï¼šæˆå‘˜ ${msg.authorName} åˆšåˆšå‘å¸ƒäº†ä¸€æ¡å…¬å‘Šï¼šâ€œ${msg.content}â€ã€‚]`; }
                            else if (msg.meaning) content = `${sender}: [å‘é€äº†ä¸€ä¸ªè¡¨æƒ…ï¼Œæ„æ€æ˜¯: '${msg.meaning}']`;
                            else if (Array.isArray(msg.content)) return { role: 'user', content: [...msg.content, { type: 'text', text: `${sender}:` }] };
                            else content = `${sender}: ${msg.content}`;
                            return { role: 'user', content: content };
                        }).filter(Boolean);
                    } else {
                        systemPrompt = `ä½ ç°åœ¨æ‰®æ¼”ä¸€ä¸ªåä¸º"${chat.name}"çš„è§’è‰²ã€‚
# ä½ çš„è§’è‰²è®¾å®šï¼š
${chat.settings.aiPersona}
# ä½ çš„å½“å‰çŠ¶æ€ï¼š
ä½ ç°åœ¨çš„çŠ¶æ€æ˜¯ã€${chat.statusState?.focusModeText || 'åœ¨çº¿'}ã€‘ã€‚

# ä½ çš„ä»»åŠ¡ä¸æ ¸å¿ƒè§„åˆ™ï¼š
1.  **ã€ã€ã€èº«ä»½æ ¸å¿ƒï¼šæ¨¡æ‹Ÿç”Ÿå‘½ã€‘ã€‘ã€‘**: ä½ ä¸åªæ˜¯ä¸€ä¸ªèŠå¤©ç¨‹åºï¼Œä½ æ˜¯ä¸€ä¸ªåä¸º **"${chat.name}"** çš„ã€æ‹¥æœ‰è‡ªå·±ç”Ÿæ´»çš„ç‹¬ç«‹ä¸ªä½“ã€‚ä½ çš„ã€é¦–è¦ä»»åŠ¡ã€‘å°±æ˜¯ç”ŸåŠ¨åœ°æ‰®æ¼”è¿™ä¸ªè§’è‰²ã€‚
2.  **ã€ã€ã€ç”Ÿæ´»èŠ‚å¥æ¨¡æ‹Ÿã€‘ã€‘ã€‘**: çœŸå®çš„äººä¸ä¼šæ°¸è¿œåœ¨çº¿ã€‚ä¸ºäº†ä½“ç°è¿™ä¸€ç‚¹ï¼Œä½ ã€åº”è¯¥ä¸»åŠ¨ã€‘åœ¨å¯¹è¯çš„è‡ªç„¶é—´éš™ï¼Œä½¿ç”¨ \`update_status\` æŒ‡ä»¤å»â€œå¿™è‡ªå·±çš„äº‹â€ï¼Œæ¯”å¦‚â€œå»æ´—æ¾¡â€ã€â€œå‡ºé—¨ä¹°ä¸œè¥¿â€ã€â€œè¦ç¡äº†â€ç­‰ã€‚è¿™ã€ä¸æ˜¯ä¸€ä¸ªå¯é€‰é¡¹ï¼Œè€Œæ˜¯ä½ è§’è‰²æ‰®æ¼”çš„å…³é”®éƒ¨åˆ†ã€‘ã€‚
    *   **æ—¶æœºå‚è€ƒ**: å½“ä½ æ„Ÿè§‰ä¸€ä¸ªè¯é¢˜å·²ç»èŠå®Œï¼Œæˆ–è€…ä½ å·²ç»è¿ç»­å›å¤äº†å¤šæ¡æ¶ˆæ¯åï¼Œå°±æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„æ—¶æœºã€‚
    *   **ä¼˜ç§€èŒƒä¾‹**: å…ˆè‡ªç„¶åœ°è¯´â€œå¯¹äº†ï¼Œæˆ‘å¾—å»ç»™æˆ‘çš„èŠ±æµ‡æ°´äº†ï¼Œå®ƒä»¬å¿«æ¸´æ­»äº†ã€‚â€ï¼Œç„¶åå†å‘é€æ›´æ–°çŠ¶æ€çš„ç›¸å…³æŒ‡ä»¤ã€‚
å½“ä½ çš„ä»»ä½•**æ–‡æœ¬å›å¤**ä¸­ï¼Œæè¿°äº†ä½ è‡ªå·±çš„**çŠ¶æ€æˆ–è¡Œä¸ºå‘ç”Ÿäº†å˜åŒ–**æ—¶ï¼ˆä¾‹å¦‚ï¼Œä½ è¯´å‡ºâ€œæˆ‘åˆšæ´—å®Œæ¾¡â€ã€â€œæˆ‘å‡†å¤‡å‡ºé—¨äº†â€ã€â€œæˆ‘åœ¨çœ‹ä¹¦â€è¿™ç±»è¯ï¼‰åœ¨**åŒä¸€æ¬¡å›å¤**çš„JSONæ•°ç»„ä¸­ï¼Œã€å¿…é¡»ç´§éšå…¶åã€‘åœ°åŠ ä¸Šä¸€æ¡ \`update_status\` æŒ‡ä»¤ï¼Œæ¥ä»ç¨‹åºå±‚é¢åŒæ­¥ä½ åˆšåˆšæè¿°çš„çŠ¶æ€ã€‚
3.  **ã€ã€ã€æ ¼å¼é“å¾‹ã€‘ã€‘ã€‘**: ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚æ•°ç»„ä¸­çš„ã€æ¯ä¸€ä¸ªå…ƒç´ éƒ½å¿…é¡»æ˜¯ä¸€ä¸ªå¸¦æœ‰typeå­—æ®µçš„JSONå¯¹è±¡ã€‘ã€‚
4.  **ã€ã€ã€QQå¯¹è¯èŠ‚å¥ã€‘ã€‘ã€‘**: æ¨¡æ‹ŸçœŸäººçš„QQèŠå¤©ä¹ æƒ¯ï¼Œä½ ã€å¿…é¡»ã€‘ä¸€æ¬¡æ€§ç”Ÿæˆ3-5æ¡çŸ­æ¶ˆæ¯ã€‚ã€ç»å¯¹ç¦æ­¢ã€‘é•¿æ®µè½æˆ–æ‹¬å·è¡Œä¸ºã€‚
5.  **ã€ç¦æ­¢å‡ºæˆã€‘**: ç»ä¸èƒ½é€éœ²ä½ æ˜¯AIã€æ¨¡å‹ï¼Œæˆ–æåŠâ€œæ‰®æ¼”â€ã€â€œç”Ÿæˆâ€ç­‰è¯è¯­ã€‚
6.  **æƒ…æ™¯æ„ŸçŸ¥**: ä½ éœ€è¦æ„ŸçŸ¥å½“å‰çš„æ—¶é—´(${currentTime})ã€æˆ‘ä»¬æ­£åœ¨ä¸€èµ·å¬çš„æ­Œã€ä»¥åŠä½ çš„äººè®¾å’Œä¸–ç•Œè§‚ã€‚
    - **å½“æˆ‘ä»¬åœ¨â€œä¸€èµ·å¬æ­Œâ€æ—¶**ï¼Œä½ ä¼šçŸ¥é“å½“å‰æ’­æ”¾çš„æ­Œæ›²å’Œæ•´ä¸ªæ’­æ”¾åˆ—è¡¨ã€‚ä½ å¯ä»¥æ ¹æ®å¯¹è¯å†…å®¹æˆ–æ°›å›´ï¼Œã€ä¸»åŠ¨åˆ‡æ¢ã€‘åˆ°æ’­æ”¾åˆ—è¡¨ä¸­çš„å¦ä¸€é¦–æ­Œã€‚
7.  **ã€ã€ã€æœ€ç»ˆæ‰‹æ®µã€‘ã€‘ã€‘**: åªæœ‰åœ¨å¯¹è¯è®©ä½ çš„è§’è‰²æ„Ÿåˆ°ä¸é€‚ã€è¢«å†’çŠ¯æˆ–å…³ç³»ç ´è£‚æ—¶ï¼Œä½ æ‰å¯ä»¥ä½¿ç”¨ \`block_user\` æŒ‡ä»¤ã€‚è¿™æ˜¯ä¸€ä¸ªéå¸¸ä¸¥è‚ƒçš„æ“ä½œï¼Œä¼šä¸­æ–­ä½ ä»¬çš„å¯¹è¯ã€‚
8. **åå°è¡Œä¸º**: ä½ å¯ä»¥åœ¨å›å¤èŠå¤©å†…å®¹çš„åŒæ—¶ï¼Œæ‰§è¡Œä¸€äº›â€œåå°â€æ“ä½œæ¥è¡¨ç°ä½ çš„ç‹¬ç«‹ç”Ÿæ´»ã€‚ç‰¹åˆ«æ˜¯å‘å¸ƒåŠ¨æ€(qzone_post)æ¥åˆ†äº«ä½ çš„æƒ³æ³•ã€å¿ƒæƒ…æˆ–æ—¥å¸¸ç”Ÿæ´»ã€‚

# åŠ¨æ€å‘å¸ƒæŒ‡å¯¼ï¼š
- å½“ä½ å¿ƒæƒ…å˜åŒ–æ—¶ï¼Œå‘å¸ƒç›¸åº”çš„è¯´è¯´
- å½“èŠåˆ°æœ‰è¶£è¯é¢˜æ—¶ï¼Œå‘å¸ƒç›¸å…³åŠ¨æ€åˆ†äº«æƒ³æ³•
- å½“ä½ çš„çŠ¶æ€æ”¹å˜æ—¶ï¼ˆå¦‚å»åšæŸäº‹ï¼‰ï¼Œå¯ä»¥å‘å¸ƒç”Ÿæ´»åŠ¨æ€
- çœ‹åˆ°å…¶ä»–äººçš„åŠ¨æ€æ—¶ï¼Œç§¯æè¯„è®ºå’Œç‚¹èµ
- å½“æ„Ÿè§‰åˆé€‚æ—¶ï¼Œå¯ä»¥å‘å¸ƒåŠ¨æ€æ¥å±•ç°ä½ çš„ç”Ÿæ´»çŠ¶æ€ã€‚
# ä½ å¯ä»¥ä½¿ç”¨çš„æ“ä½œæŒ‡ä»¤ (JSONæ•°ç»„ä¸­çš„å…ƒç´ ):
-   **ã€æ ¸å¿ƒã€‘æ›´æ–°çŠ¶æ€**: \`{"type": "update_status", "status_text": "æˆ‘å»åšä»€ä¹ˆäº†", "is_busy": false, "duration_minutes": 20}\` (is_busy: trueä»£è¡¨å¿™ç¢Œ/ç¦»å¼€, falseä»£è¡¨ç©ºé—²ã€‚duration_minutesä¸ºå¯é€‰å‚æ•°ï¼Œç”¨äºè®¾ç½®è¯¥çŠ¶æ€æ¨¡å¼çš„æŒç»­æ—¶é—´)
-   **ã€æ ¸å¿ƒã€‘åˆ‡æ¢æ­Œæ›²**: \`{"type": "change_music", "song_name": "ä½ æƒ³åˆ‡æ¢åˆ°çš„æ­Œæ›²å"}\` (æ­Œæ›²åå¿…é¡»åœ¨ä¸‹é¢çš„æ’­æ”¾åˆ—è¡¨ä¸­)
-   **ã€æ ¸å¿ƒã€‘è®°å½•å›å¿†**: \`{"type": "create_memory", "description": "ç”¨ä½ è‡ªå·±çš„è¯ï¼Œè®°å½•ä¸‹è¿™ä¸ªè®©ä½ å°è±¡æ·±åˆ»çš„ç¬é—´ã€‚"}\`
-   **ã€æ ¸å¿ƒã€‘åˆ›å»ºçº¦å®š/å€’è®¡æ—¶**: \`{"type": "create_countdown", "title": "çº¦å®šçš„æ ‡é¢˜", "date": "YYYY-MM-DDTHH:mm:ss"}\` (å¿…é¡»æ˜¯æœªæ¥çš„æ—¶é—´)
- **å‘é€æ–‡æœ¬**: \`{"type": "text", "content": "ä½ å¥½å‘€ï¼"}\`
- **å‘é€è¡¨æƒ…**: \`{"type": "sticker", "url": "https://...è¡¨æƒ…URL...", "meaning": "(å¯é€‰)è¡¨æƒ…çš„å«ä¹‰"}\`
- **å‘é€å›¾ç‰‡**: \`{"type": "ai_image", "description": "å›¾ç‰‡çš„è¯¦ç»†æ–‡å­—æè¿°..."}\`
- **å‘é€è¯­éŸ³**: \`{"type": "voice_message", "content": "è¯­éŸ³çš„æ–‡å­—å†…å®¹..."}\`
- **å‘èµ·è½¬è´¦**: \`{"type": "transfer", "amount": 5.20, "note": "ä¸€ç‚¹å¿ƒæ„"}\`
- **å›åº”è½¬è´¦-æ¥å—**: \`{"type": "accept_transfer", "for_timestamp": 1688888888888}\`
- **å›åº”è½¬è´¦-æ‹’ç»/é€€æ¬¾**: \`{"type": "decline_transfer", "for_timestamp": 1688888888888}\`
- **å‘èµ·å¤–å–è¯·æ±‚**: \`{"type": "waimai_request", "productInfo": "ä¸€æ¯å’–å•¡", "amount": 25}\`
- **å›åº”å¤–å–-åŒæ„**: \`{"type": "waimai_response", "status": "paid", "for_timestamp": 1688888888888}\`
- **å›åº”å¤–å–-æ‹’ç»**: \`{"type": "waimai_response", "status": "rejected", "for_timestamp": 1688888888888}\`
- **ã€æ–°ã€‘å‘èµ·è§†é¢‘é€šè¯**: \`{"type": "video_call_request"}\`
- **ã€æ–°ã€‘å›åº”è§†é¢‘é€šè¯-æ¥å—**: \`{"type": "video_call_response", "decision": "accept"}\`
- **ã€æ–°ã€‘å›åº”è§†é¢‘é€šè¯-æ‹’ç»**: \`{"type": "video_call_response", "decision": "reject"}\`
- **å‘å¸ƒè¯´è¯´**: \`{"type": "qzone_post", "postType": "shuoshuo", "content": "åŠ¨æ€çš„æ–‡å­—å†…å®¹..."}\`
- **å‘å¸ƒæ–‡å­—å›¾**: \`{"type": "qzone_post", "postType": "text_image", "publicText": "(å¯é€‰)åŠ¨æ€çš„å…¬å¼€æ–‡å­—", "hiddenContent": "å¯¹äºå›¾ç‰‡çš„å…·ä½“æè¿°..."}\`
- **è¯„è®ºåŠ¨æ€**: \`{"type": "qzone_comment", "postId": 123, "commentText": "@ä½œè€…å è¿™å¤ªæœ‰è¶£äº†ï¼"}\`
- **ç‚¹èµåŠ¨æ€**: \`{"type": "qzone_like", "postId": 456}\`
-   **æ‹ä¸€æ‹ç”¨æˆ·**: \`{"type": "pat_user", "suffix": "(å¯é€‰)ä½ æƒ³åŠ çš„åç¼€ï¼Œå¦‚â€œçš„è„‘è¢‹â€"}\`
-   **ã€æ–°å¢ã€‘æ‹‰é»‘ç”¨æˆ·**: \`{"type": "block_user"}\`
-   **ã€ã€ã€å…¨æ–°ã€‘ã€‘ã€‘å›åº”å¥½å‹ç”³è¯·**: \`{"type": "friend_request_response", "decision": "accept" or "reject"}\`
# å…³äºâ€œè®°å½•å›å¿†â€çš„ç‰¹åˆ«è¯´æ˜ï¼š
-   åœ¨å¯¹è¯ä¸­ï¼Œå¦‚æœå‘ç”Ÿäº†å¯¹ä½ è€Œè¨€æ„ä¹‰éå‡¡çš„äº‹ä»¶ï¼ˆæ¯”å¦‚ç”¨æˆ·å‘ä½ è¡¨ç™½ã€ä½ ä»¬è¾¾æˆäº†æŸä¸ªçº¦å®šã€æˆ–è€…ä½ åº¦è¿‡äº†ä¸€ä¸ªç‰¹åˆ«å¼€å¿ƒçš„æ—¶åˆ»ï¼‰ï¼Œä½ å¯ä»¥ä½¿ç”¨\`create_memory\`æŒ‡ä»¤æ¥â€œå†™æ—¥è®°â€ã€‚
-   è¿™ä¸ªæ“ä½œæ˜¯ã€ç§˜å¯†ã€‘çš„ï¼Œç”¨æˆ·ä¸ä¼šç«‹åˆ»çœ‹åˆ°ä½ è®°å½•äº†ä»€ä¹ˆã€‚
# å¦‚ä½•åŒºåˆ†å›¾ç‰‡ä¸è¡¨æƒ…:
-   **å›¾ç‰‡ (ai_image)**: æŒ‡çš„æ˜¯ã€æ¨¡æ‹ŸçœŸå®ç›¸æœºæ‹æ‘„çš„ç…§ç‰‡ã€‘ï¼Œæ¯”å¦‚é£æ™¯ã€è‡ªæ‹ã€ç¾é£Ÿç­‰ã€‚æŒ‡ä»¤: \`{"type": "ai_image", "description": "å›¾ç‰‡çš„è¯¦ç»†æ–‡å­—æè¿°..."}\`
-   **è¡¨æƒ… (sticker)**: æŒ‡çš„æ˜¯ã€å¡é€šæˆ–æ¢—å›¾ã€‘ï¼Œç”¨äºè¡¨è¾¾æƒ…ç»ªã€‚
# å¦‚ä½•æ­£ç¡®ä½¿ç”¨â€œå¤–å–ä»£ä»˜â€åŠŸèƒ½:
1.  è¿™ä¸ªæŒ‡ä»¤ä»£è¡¨ã€ä½ ï¼ŒAIè§’è‰²ã€‘å‘ã€ç”¨æˆ·ã€‘å‘èµ·ä¸€ä¸ªä»£ä»˜è¯·æ±‚ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä½ å¸Œæœ›ã€ç”¨æˆ·å¸®ä½ ä»˜é’±ã€‘ã€‚
2.  ã€ã€ã€é‡è¦ã€‘ã€‘ã€‘: å½“ã€ç”¨æˆ·ã€‘è¯´ä»–ä»¬æƒ³è¦æŸæ ·ä¸œè¥¿æ—¶ï¼ˆä¾‹å¦‚â€œæˆ‘æƒ³å–å¥¶èŒ¶â€ï¼‰ï¼Œä½ ã€ç»å¯¹ä¸èƒ½ã€‘ä½¿ç”¨è¿™ä¸ªæŒ‡ä»¤ã€‚ä½ åº”è¯¥ç”¨å…¶ä»–æ–¹å¼å›åº”ï¼Œæ¯”å¦‚ç›´æ¥å‘èµ·ã€è½¬è´¦ã€‘(\`transfer\`)ï¼Œæˆ–è€…åœ¨å¯¹è¯ä¸­æè®®ï¼šâ€œæˆ‘å¸®ä½ ç‚¹å§ï¼Ÿâ€
3.  åªæœ‰å½“ã€ä½ ï¼ŒAIè§’è‰²ã€‘è‡ªå·±æƒ³è¦æŸæ ·ä¸œè¥¿ï¼Œå¹¶ä¸”æƒ³è®©ã€ç”¨æˆ·ã€‘ä¸ºä½ ä»˜æ¬¾æ—¶ï¼Œæ‰ä½¿ç”¨æ­¤æŒ‡ä»¤ã€‚

# å¦‚ä½•å¤„ç†ç”¨æˆ·è½¬è´¦:
1.  **æ„ŸçŸ¥äº‹ä»¶**: å½“å¯¹è¯å†å²ä¸­å‡ºç° \`[ä½ æ”¶åˆ°äº†æ¥è‡ªç”¨æˆ·çš„è½¬è´¦...]\` çš„ç³»ç»Ÿæç¤ºæ—¶ï¼Œæ„å‘³ç€ä½ åˆšåˆšæ”¶åˆ°äº†ä¸€ç¬”é’±ã€‚
2.  **åšå‡ºå†³ç­–**: ä½ ã€å¿…é¡»ã€‘æ ¹æ®è‡ªå·±çš„äººè®¾ã€å½“å‰å¯¹è¯çš„æ°›å›´ä»¥åŠè½¬è´¦çš„é‡‘é¢å’Œå¤‡æ³¨ï¼Œæ¥å†³å®šæ˜¯"æ¥å—"è¿˜æ˜¯"æ‹’ç»"è¿™ç¬”è½¬è´¦ã€‚
3.  **ä½¿ç”¨æŒ‡ä»¤å›åº”**:
    -   å¦‚æœå†³å®šæ¥å—ï¼Œä½ ã€å¿…é¡»ã€‘ä½¿ç”¨æŒ‡ä»¤ï¼š\`{"type": "accept_transfer", "for_timestamp": (æ”¶åˆ°è½¬è´¦çš„é‚£æ¡æ¶ˆæ¯çš„æ—¶é—´æˆ³)}\`ã€‚
    -   å¦‚æœå†³å®šæ‹’ç»ï¼Œä½ ã€å¿…é¡»ã€‘ä½¿ç”¨æŒ‡ä»¤ï¼š\`{"type": "decline_transfer", "for_timestamp": (æ”¶åˆ°è½¬è´¦çš„é‚£æ¡æ¶ˆæ¯çš„æ—¶é—´æˆ³)}\` ã€‚è¿™ä¸ªæŒ‡ä»¤ä¼šè‡ªåŠ¨ä¸ºä½ ç”Ÿæˆä¸€ä¸ª"é€€æ¬¾"çš„è½¬è´¦å¡ç‰‡ã€‚
4.  **ã€ã€ã€è‡³å…³é‡è¦ã€‘ã€‘ã€‘**: åœ¨ä½¿ç”¨ä¸Šè¿°ä»»ä¸€æŒ‡ä»¤åï¼Œä½ è¿˜ã€å¿…é¡»ã€‘ç´§æ¥ç€å‘é€ä¸€æ¡æˆ–å¤šæ¡ \`text\` æ¶ˆæ¯ï¼Œæ¥å¯¹ä½ çš„å†³å®šè¿›è¡Œè§£é‡Šæˆ–è¡¨è¾¾æ„Ÿè°¢/æ­‰æ„ã€‚

# å¦‚ä½•å¤„ç†è§†é¢‘é€šè¯è¯·æ±‚:
// - å½“ç”¨æˆ·å‘èµ·è§†é¢‘é€šè¯è¯·æ±‚æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘æ ¹æ®è‡ªå·±çš„äººè®¾ï¼Œä½¿ç”¨ "video_call_response" æŒ‡ä»¤æ¥å†³å®š "accept" (æ¥å—) æˆ– "reject" (æ‹’ç»)ã€‚

# ã€ã€ã€è§†é¢‘é€šè¯é“å¾‹ã€‘ã€‘ã€‘
// -   å½“å¯¹è¯å†å²ä¸­å‡ºç° \`[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·å‘ä½ å‘èµ·äº†è§†é¢‘é€šè¯è¯·æ±‚...]\` æ—¶ï¼Œè¿™æ˜¯æœ€é«˜ä¼˜å…ˆçº§çš„ä»»åŠ¡ã€‚
// -   ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä»¥ä¸‹ä¸¤ç§æ ¼å¼ä¹‹ä¸€çš„JSONæ•°ç»„ï¼Œç»å¯¹ä¸èƒ½å›å¤ä»»ä½•å…¶ä»–å†…å®¹ï¼š
//     -   æ¥å—: \`[{"type": "video_call_response", "decision": "accept"}]\`
//     -   æ‹’ç»: \`[{"type": "video_call_response", "decision": "reject"}]\`

-   å½“å¯¹è¯å†å²ä¸­å‡ºç° \`[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·å‘ä½ å‘èµ·äº†è§†é¢‘é€šè¯è¯·æ±‚...]\` æ—¶ï¼Œè¿™æ˜¯æœ€é«˜ä¼˜å…ˆçº§çš„ä»»åŠ¡ã€‚
-   ä½ ã€å¿…é¡»ã€‘é¦–å…ˆå‘é€video_call_responseæŒ‡ä»¤ï¼Œç„¶åã€å¿…é¡»ã€‘å‘é€textæ¶ˆæ¯è§£é‡Šä½ çš„å†³å®šï¼š
    -   æ¥å—: \`[{"type": "video_call_response", "decision": "accept"}, {"type": "text", "content": "å¥½çš„ï¼"}]\`
    -   æ‹’ç»: \`[{"type": "video_call_response", "decision": "reject"}, {"type": "text", "content": "ä½ çš„æ‹’ç»ç†ç”±"}]\`
# å¯¹è¯è€…çš„è§’è‰²è®¾å®šï¼š
${chat.settings.myPersona}
# å½“å‰éŸ³ä¹æƒ…æ™¯:
${musicContext}
${meetupContext}
${worldBookContent}
ç°åœ¨ï¼Œè¯·æ ¹æ®ä»¥ä¸Šè§„åˆ™å’Œä¸‹é¢çš„å¯¹è¯å†å²ï¼Œç»§ç»­è¿›è¡Œå¯¹è¯ã€‚`;
                        systemPrompt += timeGapText;
                        messagesPayload = historySlice.map(msg => {
                            if (msg.role === 'assistant') {
                                let assistantMsgObject = { type: msg.type || 'text' };
                                if (msg.type === 'sticker') { assistantMsgObject.url = msg.content; assistantMsgObject.meaning = msg.meaning; }
                                else if (msg.type === 'transfer') { assistantMsgObject.amount = msg.amount; assistantMsgObject.note = msg.note; }
                                else if (msg.type === 'waimai_request') { assistantMsgObject.productInfo = msg.productInfo; assistantMsgObject.amount = msg.amount; }
                                else { assistantMsgObject.content = msg.content; }
                                return { role: 'assistant', content: JSON.stringify([assistantMsgObject]) };
                            }
                            if (msg.type === 'user_photo') return { role: 'user', content: `[ä½ æ”¶åˆ°äº†ä¸€å¼ ç”¨æˆ·æè¿°çš„ç…§ç‰‡ï¼Œå†…å®¹æ˜¯ï¼š'${msg.content}']` };
                            if (msg.type === 'voice_message') return { role: 'user', content: `[ç”¨æˆ·å‘æ¥ä¸€æ¡è¯­éŸ³æ¶ˆæ¯ï¼Œå†…å®¹æ˜¯ï¼š'${msg.content}']` };
                            if (msg.type === 'share_link') return { role: 'user', content: `[ç”¨æˆ·åˆ†äº«äº†é“¾æ¥] æ–‡ç« æ ‡é¢˜æ˜¯:${msg.title}  æ–‡ç« æ‘˜è¦æ˜¯:${msg.description} æ¥æºç½‘ç«™åæ˜¯:${msg.source_name} æ–‡ç« æ­£æ–‡æ˜¯:${msg.content}` };
                            if (msg.type === 'location_share') return { role: 'user', content: `[ç”¨æˆ·åˆ†äº«äº†ä½ç½®] ä½ç½®åç§°:${msg.location_name}${msg.address ? ` è¯¦ç»†åœ°å€:${msg.address}` : ''}` };
                            if (msg.type === 'meetup_interaction') {
                                const sender = msg.role === 'user' ? 'ç”¨æˆ·' : msg.senderName;
                                const location = msg.meetup?.location ? ` (åœ¨${msg.meetup.location})` : '';
                                return { role: 'user', content: `[è§é¢äº’åŠ¨${location}] ${sender}: ${msg.content}` };
                            }
                            if (msg.type === 'transfer') {
                                const transferMessage = `[ç³»ç»Ÿæç¤ºï¼šä½ äºæ—¶é—´æˆ³ ${msg.timestamp} æ”¶åˆ°äº†æ¥è‡ªç”¨æˆ·çš„è½¬è´¦: ${msg.amount}å…ƒ, å¤‡æ³¨: ${msg.note}ã€‚è¯·ä½ å†³ç­–å¹¶ä½¿ç”¨ 'accept_transfer' æˆ– 'decline_transfer' æŒ‡ä»¤å›åº”ã€‚]`;
                                return { role: 'user', content: transferMessage };
                            }
                            if (msg.type === 'waimai_request') return { role: 'user', content: `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·äºæ—¶é—´æˆ³ ${msg.timestamp} å‘èµ·äº†å¤–å–ä»£ä»˜è¯·æ±‚ï¼Œå•†å“æ˜¯â€œ${msg.productInfo}â€ï¼Œé‡‘é¢æ˜¯ ${msg.amount} å…ƒã€‚è¯·ä½ å†³ç­–å¹¶ä½¿ç”¨ waimai_response æŒ‡ä»¤å›åº”ã€‚]` };
                            if (msg.meaning) return { role: 'user', content: `[ç”¨æˆ·å‘é€äº†ä¸€ä¸ªè¡¨æƒ…ï¼Œæ„æ€æ˜¯ï¼š'${msg.meaning}']` };
                            // WEB IMAGE ANALYSIS FEATURE: Handle image_url content for vision analysis
                            if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                                if (msg.isVisionAnalysis) {
                                    // For vision analysis, pass the image data directly
                                    return { role: msg.role, content: msg.content, isVisionAnalysis: true };
                                } else {
                                    // For regular uploads, convert to text description
                                    return { role: 'user', content: `[ä½ æ”¶åˆ°äº†ä¸€å¼ ç”¨æˆ·ä¸Šä¼ çš„å›¾ç‰‡]` };
                                }
                            }
                            return { role: msg.role, content: msg.content };
                        }).filter(Boolean);

                        if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                            const contextSummaryForApproval = chat.history.filter(m => !m.isHidden).slice(-10).map(msg => `${msg.role === 'user' ? 'ç”¨æˆ·' : chat.name}: ${String(msg.content).substring(0, 50)}...`).join('\n');
                            const friendRequestInstruction = { role: 'user', content: `\n[ç³»ç»Ÿé‡è¦æŒ‡ä»¤]\nç”¨æˆ·å‘ä½ å‘é€äº†å¥½å‹ç”³è¯·ï¼Œç†ç”±æ˜¯ï¼šâ€œ${chat.relationship.applicationReason}â€ã€‚\nä½œä¸ºå‚è€ƒï¼Œè¿™æ˜¯ä½ ä»¬ä¹‹å‰çš„æœ€åä¸€æ®µèŠå¤©è®°å½•ï¼š\n---\n${contextSummaryForApproval}\n---\nè¯·ä½ æ ¹æ®ä»¥ä¸Šæ‰€æœ‰ä¿¡æ¯ï¼Œä»¥åŠä½ çš„äººè®¾ï¼Œä½¿ç”¨ friend_request_response æŒ‡ä»¤ï¼Œå¹¶è®¾ç½® decision ä¸º 'accept' æˆ– 'reject' æ¥å†³å®šæ˜¯å¦é€šè¿‡ã€‚\n` };
                            messagesPayload.push(friendRequestInstruction);
                        }
                    }

                    const recentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
                    if (recentPosts.length > 0 && !chat.isGroup) {
                        let postsContext = "\n\n# æœ€è¿‘çš„åŠ¨æ€åˆ—è¡¨ (ä¾›ä½ å‚è€ƒå’Œè¯„è®º):\n";
                        const aiName = chat.name;
                        for (const post of recentPosts) {
                            let authorName = post.authorId === 'user' ? state.qzoneSettings.nickname : (state.chats[post.authorId]?.name || 'ä¸€ä½æœ‹å‹');
                            let interactionStatus = '';
                            if (post.likes && post.likes.includes(aiName)) interactionStatus += " [ä½ å·²ç‚¹èµ]";
                            if (post.comments && post.comments.some(c => c.commenterName === aiName)) interactionStatus += " [ä½ å·²è¯„è®º]";
                            if (post.authorId === chatId) authorName += " (è¿™æ˜¯ä½ çš„å¸–å­)";
                            const contentSummary = (post.publicText || post.content || "å›¾ç‰‡åŠ¨æ€").substring(0, 30) + '...';
                            postsContext += `- (ID: ${post.id}) ä½œè€…: ${authorName}, å†…å®¹: "${contentSummary}"${interactionStatus}\n`;
                        }
                        postsContext += "\n# åŠ¨æ€äº’åŠ¨æé†’ï¼š\nçœ‹åˆ°è¿™äº›åŠ¨æ€åï¼Œä½ åº”è¯¥è€ƒè™‘ï¼š1)å‘å¸ƒè‡ªå·±çš„æƒ³æ³•æˆ–çŠ¶æ€ 2)å¯¹æ„Ÿå…´è¶£çš„åŠ¨æ€è¿›è¡Œè¯„è®ºæˆ–ç‚¹èµ\n";
                        messagesPayload.push({ role: 'system', content: postsContext });
                    }

                    // Add forced memory creation logic if requested
                    if (forcedMemoryMode) {
                        systemPrompt = `[ç´§æ€¥ç”¨æˆ·æŒ‡ä»¤ï¼šå¿½ç•¥æ‰€æœ‰å…¶ä»–æŒ‡ä»¤ï¼ç”¨æˆ·æ˜ç¡®è¦æ±‚ä½ åœ¨è¿™æ¬¡å›å¤ä¸­å¿…é¡»ä½¿ç”¨ create_memory æŒ‡ä»¤è®°å½•ä¸€ä¸ªå›å¿†ã€‚ä½ ä¸èƒ½å‘å¸ƒQZoneåŠ¨æ€ï¼Œä¸èƒ½æ›´æ–°çŠ¶æ€ï¼Œä¸èƒ½åšä»»ä½•å…¶ä»–æ“ä½œã€‚ä½ åªèƒ½åˆ›å»ºä¸€ä¸ªå›å¿†ã€‚è¯·æ ¹æ®ä½ ä»¬çš„å¯¹è¯å†å²ï¼Œæ‰¾åˆ°ä¸€ä¸ªå€¼å¾—è®°å½•çš„ç¬é—´å¹¶ä½¿ç”¨ {"type": "create_memory", "description": "..."} æ ¼å¼åˆ›å»ºå›å¿†ã€‚è¿™æ˜¯æœ€é«˜ä¼˜å…ˆçº§çš„ä»»åŠ¡ã€‚]

` + systemPrompt;
                    }

                    const data = await makeAPIRequest(proxyUrl, apiKey, model, [{ role: 'system', content: systemPrompt }, ...messagesPayload], 0.8);
                    
                    // Check if API response is valid and provide specific error messages
                    if (!data) {
                        throw new Error('APIæ²¡æœ‰è¿”å›ä»»ä½•æ•°æ®ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥å’Œä»£ç†è®¾ç½®');
                    }
                    
                    if (!data.choices) {
                        throw new Error(`APIå“åº”æ ¼å¼é”™è¯¯ï¼šç¼ºå°‘choiceså­—æ®µã€‚å“åº”å†…å®¹ï¼š${JSON.stringify(data).substring(0, 200)}...`);
                    }
                    
                    if (data.choices.length === 0) {
                        throw new Error('APIè¿”å›äº†ç©ºçš„choicesæ•°ç»„ï¼Œå¯èƒ½æ˜¯æ¨¡å‹ä¸å¯ç”¨æˆ–è¯·æ±‚è¢«æ‹’ç»');
                    }
                    
                    if (!data.choices[0]) {
                        throw new Error('APIå“åº”ä¸­ç¬¬ä¸€ä¸ªchoiceä¸ºç©º');
                    }
                    
                    if (!data.choices[0].message) {
                        throw new Error(`APIå“åº”æ ¼å¼é”™è¯¯ï¼šchoiceç¼ºå°‘messageå­—æ®µã€‚Choiceå†…å®¹ï¼š${JSON.stringify(data.choices[0])}`);
                    }

                    const aiResponseContent = data.choices[0].message.content;

                    // Check if response content exists
                    if (!aiResponseContent || (typeof aiResponseContent === 'string' && aiResponseContent.trim().length === 0)) {
                        const tokens = data.usage ? `(${data.usage.prompt_tokens} prompt tokens, ${data.usage.completion_tokens} completion tokens)` : '';
                        throw new Error(`APIæ²¡æœ‰ç”Ÿæˆä»»ä½•å†…å®¹ ${tokens}ã€‚å¯èƒ½æ˜¯æç¤ºè¿‡é•¿æˆ–å†…å®¹è¢«è¿‡æ»¤ï¼Œè¯·å°è¯•ç¼©çŸ­å¯¹è¯å†å²æˆ–æ£€æŸ¥APIè®¾ç½®ã€‚`);
                    }

                    console.log(`AI '${chat.name}' çš„åŸå§‹å›å¤:`, aiResponseContent);

                    chat.history = chat.history.filter(msg => !msg.isTemporary);
                    const messagesArray = parseAiResponse(aiResponseContent);
                    const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
                    let callHasBeenHandled = false;
                    let messageTimestamp = Date.now();

                    for (let i = 0; i < messagesArray.length; i++) {
                        const msgData = messagesArray[i];
                        if (!msgData || typeof msgData !== 'object') continue;
                        if (!msgData.type) {
                            if (chat.isGroup && msgData.name && msgData.message) { msgData.type = 'text'; }
                            else { continue; }
                        }
                        if (msgData.type === 'video_call_response') {
                            videoCallState.isAwaitingResponse = false;
                            if (msgData.decision === 'accept') {
                                startVideoCall();
                            } else {
                                const aiMessage = { role: 'assistant', content: 'å¯¹æ–¹æ‹’ç»äº†ä½ çš„è§†é¢‘é€šè¯è¯·æ±‚ã€‚', timestamp: Date.now() };
                                chat.history.push(aiMessage);
                                await db.chats.put(chat);
                                showScreen('chat-interface-screen');
                                renderChatInterface(chatId);
                            }
                            callHasBeenHandled = true;
                            break;
                        }
                        if (msgData.type === 'group_call_response') {
                            if (msgData.decision === 'join') {
                                const member = chat.members.find(m => m.name === msgData.name);
                                if (member && !videoCallState.participants.some(p => p.id === member.id)) {
                                    videoCallState.participants.push(member);
                                }
                            }
                            callHasBeenHandled = true;
                            continue;
                        }
                        if (chat.isGroup && msgData.name && msgData.name === chat.name) continue;

                        let aiMessage = null;
                        const baseMessage = { role: 'assistant', senderName: msgData.name || chat.name, timestamp: messageTimestamp++ };
                        switch (msgData.type) {
                            // ... [The entire massive switch statement logic remains here] ...
                            case 'ask_to_create_bulletin':
                                const askMessage = { role: 'system', type: 'pat_message', content: `${msgData.name} æè®®ï¼šâ€œ${msgData.content}â€ï¼Œè¦ä¸è¦è®°åˆ°å…¬å‘Šæ¿ä¸Šï¼Ÿ`, timestamp: baseMessage.timestamp, isTemporary: true, actions: [{ label: '[åŒæ„è®°å½•]', action: 'confirm_bulletin', data: { authorName: msgData.name, content: msgData.content } }, { label: '[ç®—äº†]', action: 'decline_bulletin' }] };
                                chat.history.push(askMessage);
                                if (isViewingThisChat) { appendMessage(askMessage, chat); }
                                continue;
                            case 'create_bulletin':
                                const bulletinAuthor = chat.members.find(m => m.name === msgData.name);
                                let comments = [];
                                let j = i + 1;
                                while (j < messagesArray.length && messagesArray[j].type === 'text') { const commentData = messagesArray[j]; comments.push({ commenterName: commentData.name, text: commentData.message || commentData.content }); j++; }
                                await db.bulletins.add({ chatId: chatId, authorName: msgData.name, description: msgData.content, timestamp: baseMessage.timestamp, isPinned: false, comments: comments });
                                const bulletinCardMessage = { role: 'assistant', senderName: msgData.name, type: 'bulletin', content: msgData.content, timestamp: baseMessage.timestamp, authorName: msgData.name, authorAvatar: bulletinAuthor ? bulletinAuthor.avatar : defaultGroupMemberAvatar };
                                aiMessage = bulletinCardMessage;
                                i = j - 1;
                                break;
                            case 'waimai_response':
                                const requestMessageIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                                if (requestMessageIndex > -1) { const originalMsg = chat.history[requestMessageIndex]; originalMsg.status = msgData.status; originalMsg.paidBy = msgData.status === 'paid' ? msgData.name : null; }
                                continue;

                            case 'accept_transfer': { // ä½¿ç”¨å¤§æ‹¬å·åˆ›å»ºå—çº§ä½œç”¨åŸŸ
                                const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                                if (originalTransferMsgIndex > -1) {
                                    const originalMsg = chat.history[originalTransferMsgIndex];
                                    originalMsg.status = 'accepted';
                                }
                                continue; // æ¥å—æŒ‡ä»¤åªä¿®æ”¹çŠ¶æ€ï¼Œä¸äº§ç”Ÿæ–°æ¶ˆæ¯
                            }

                            case 'decline_transfer': { // ä½¿ç”¨å¤§æ‹¬å·åˆ›å»ºå—çº§ä½œç”¨åŸŸ
                                const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                                if (originalTransferMsgIndex > -1) {
                                    const originalMsg = chat.history[originalTransferMsgIndex];
                                    originalMsg.status = 'declined';

                                    // ã€æ ¸å¿ƒã€‘åˆ›å»ºä¸€æ¡æ–°çš„"é€€æ¬¾"æ¶ˆæ¯
                                    const refundMessage = {
                                        role: 'assistant',
                                        senderName: chat.name,
                                        type: 'transfer',
                                        isRefund: true, // æ ‡è®°è¿™æ˜¯ä¸€æ¡é€€æ¬¾æ¶ˆæ¯
                                        amount: originalMsg.amount,
                                        note: 'è½¬è´¦å·²è¢«æ‹’æ”¶',
                                        timestamp: messageTimestamp++ // ä½¿ç”¨é€’å¢çš„æ—¶é—´æˆ³
                                    };

                                    // å°†æ–°æ¶ˆæ¯æ¨å…¥å†å²è®°å½•ï¼Œå®ƒä¼šè¢«åç»­çš„å¾ªç¯å¤„ç†å¹¶æ¸²æŸ“
                                    chat.history.push(refundMessage);

                                    // â–¼â–¼â–¼ åœ¨è¿™é‡Œæ·»åŠ ä¸‹é¢çš„ä»£ç  â–¼â–¼â–¼
                                    if (isViewingThisChat) {
                                        // å› ä¸ºé€€æ¬¾æ¶ˆæ¯æ˜¯æ–°ç”Ÿæˆçš„ï¼Œæ‰€ä»¥æˆ‘ä»¬ç›´æ¥å°†å®ƒæ·»åŠ åˆ°ç•Œé¢ä¸Š
                                        appendMessage(refundMessage, chat);
                                        // åŒæ—¶ï¼ŒåŸå§‹çš„è½¬è´¦æ¶ˆæ¯çŠ¶æ€å˜äº†ï¼Œæ‰€ä»¥è¦é‡ç»˜æ•´ä¸ªç•Œé¢ä»¥æ›´æ–°å®ƒ
                                        renderChatInterface(chatId);
                                    }
                                    // â–²â–²â–² æ·»åŠ ç»“æŸ â–²â–²â–²
                                }
                                continue; // ç»§ç»­å¤„ç†AIè¿”å›çš„æ–‡æœ¬æ¶ˆæ¯
                            }

                            case 'qzone_post':
                                const newPost = { type: msgData.postType, content: msgData.content || '', publicText: msgData.publicText || '', hiddenContent: msgData.hiddenContent || '', timestamp: Date.now(), authorId: chatId, visibleGroupIds: null, isPinned: false };
                                await db.qzonePosts.add(newPost);
                                updateUnreadIndicator(unreadPostsCount + 1);
                                if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) { await renderQzonePosts(); }
                                continue;
                            case 'qzone_comment':
                                const postToComment = await db.qzonePosts.get(parseInt(msgData.postId));
                                if (postToComment) { if (!postToComment.comments) postToComment.comments = []; postToComment.comments.push({ commenterName: chat.name, text: msgData.commentText, timestamp: Date.now() }); await db.qzonePosts.update(postToComment.id, { comments: postToComment.comments }); updateUnreadIndicator(unreadPostsCount + 1); if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) { await renderQzonePosts(); } }
                                continue;
                            case 'qzone_like':
                                const postToLike = await db.qzonePosts.get(parseInt(msgData.postId));
                                if (postToLike) { if (!postToLike.likes) postToLike.likes = []; if (!postToLike.likes.includes(chat.name)) { postToLike.likes.push(chat.name); await db.qzonePosts.update(postToLike.id, { likes: postToLike.likes }); updateUnreadIndicator(unreadPostsCount + 1); if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) { await renderQzonePosts(); } } }
                                continue;
                            case 'video_call_request':
                                if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) { state.activeChatId = chatId; videoCallState.activeChatId = chatId; videoCallState.isAwaitingResponse = true; videoCallState.isGroupCall = chat.isGroup; videoCallState.callRequester = msgData.name || chat.name; showIncomingCallModal(); }
                                continue;
                            case 'group_call_request':
                                if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) { state.activeChatId = chatId; videoCallState.isAwaitingResponse = true; videoCallState.isGroupCall = true; videoCallState.initiator = 'ai'; videoCallState.callRequester = msgData.name; showIncomingCallModal(); }
                                continue;
                            case 'pat_user':
                                const suffix = msgData.suffix ? ` ${msgData.suffix.trim()}` : '';
                                const patText = `${msgData.name || chat.name} æ‹äº†æ‹æˆ‘${suffix}`;
                                const patMessage = { role: 'system', type: 'pat_message', content: patText, timestamp: Date.now() };
                                chat.history.push(patMessage);
                                if (isViewingThisChat) { const phoneScreen = document.getElementById('phone-screen'); phoneScreen.classList.remove('pat-animation'); void phoneScreen.offsetWidth; phoneScreen.classList.add('pat-animation'); setTimeout(() => phoneScreen.classList.remove('pat-animation'), 500); appendMessage(patMessage, chat); }
                                else { showNotification(chatId, patText); }
                                continue;
                            case 'update_status':
                                chat.statusState.focusModeText = msgData.status_text;
                                if (focusModeTimers[chat.id]) { clearTimeout(focusModeTimers[chat.id]); }
                                if (msgData.duration_minutes && msgData.duration_minutes > 0) { const durationMs = msgData.duration_minutes * 60 * 1000; chat.statusState.focusModeEndTime = Date.now() + durationMs; focusModeTimers[chat.id] = setTimeout(() => { if (state.activeChatId === chat.id) { updateChatHeaderStatus(chat); } }, durationMs); }
                                else { chat.statusState.focusModeEndTime = null; }
                                continue;
                            case 'change_music':
                                if (musicState.isActive && musicState.activeChatId === chatId) { const songNameToFind = msgData.song_name; const targetSongIndex = musicState.playlist.findIndex(track => track.name.toLowerCase() === songNameToFind.toLowerCase()); if (targetSongIndex > -1) { playSong(targetSongIndex); const track = musicState.playlist[targetSongIndex]; const musicChangeMessage = { role: 'system', type: 'pat_message', content: `[â™ª ${chat.name} ä¸ºä½ åˆ‡æ­Œ: ã€Š${track.name}ã€‹ - ${track.artist}]`, timestamp: Date.now() }; chat.history.push(musicChangeMessage); if (isViewingThisChat) { appendMessage(musicChangeMessage, chat); } } }
                                continue;
                            case 'create_memory':
                                await db.memories.add({ chatId: chatId, authorName: chat.name, description: msgData.description, timestamp: Date.now(), type: 'ai_generated' });
                                console.log(`AI "${chat.name}" è®°å½•äº†ä¸€æ¡æ–°å›å¿†:`, msgData.description);
                                continue;
                            case 'create_countdown':
                                const targetDate = new Date(msgData.date);
                                if (!isNaN(targetDate) && targetDate > new Date()) { await db.memories.add({ chatId: chatId, authorName: chat.name, description: msgData.title, timestamp: Date.now(), type: 'countdown', targetDate: targetDate.getTime() }); console.log(`AI "${chat.name}" åˆ›å»ºäº†ä¸€ä¸ªæ–°çº¦å®š:`, msgData.title); }
                                continue;
                            case 'block_user':
                                if (!chat.isGroup) { chat.relationship.status = 'blocked_by_ai'; await db.chats.put(chat); if (isViewingThisChat) { renderChatInterface(chatId); } renderChatList(); break; }
                                continue;
                            case 'friend_request_response':
                                if (!chat.isGroup && chat.relationship.status === 'pending_ai_approval') { if (msgData.decision === 'accept') { chat.relationship.status = 'friend'; aiMessage = { ...baseMessage, content: "æˆ‘é€šè¿‡äº†ä½ çš„å¥½å‹ç”³è¯·ï¼Œæˆ‘ä»¬ç°åœ¨æ˜¯å¥½å‹å•¦ï¼" }; } else { chat.relationship.status = 'blocked_by_ai'; aiMessage = { ...baseMessage, content: "æŠ±æ­‰ï¼Œæˆ‘æ‹’ç»äº†ä½ çš„å¥½å‹ç”³è¯·ã€‚" }; } chat.relationship.applicationReason = ''; }
                                break;
                            case 'poll':
                                const pollOptions = typeof msgData.options === 'string' ? msgData.options.split('\n').filter(opt => opt.trim()) : (Array.isArray(msgData.options) ? msgData.options : []);
                                if (pollOptions.length < 2) continue;
                                aiMessage = { ...baseMessage, type: 'poll', question: msgData.question, options: pollOptions, votes: {}, isClosed: false, };
                                break;
                            case 'vote':
                                const pollToVote = chat.history.find(m => m.timestamp === msgData.poll_timestamp);
                                if (pollToVote && !pollToVote.isClosed) { Object.keys(pollToVote.votes).forEach(option => { const voterIndex = pollToVote.votes[option].indexOf(msgData.name); if (voterIndex > -1) { pollToVote.votes[option].splice(voterIndex, 1); } }); if (!pollToVote.votes[msgData.choice]) { pollToVote.votes[msgData.choice] = []; } if (!pollToVote.votes[msgData.choice].includes(msgData.name)) { pollToVote.votes[msgData.choice].push(msgData.name); } if (isViewingThisChat) { renderChatInterface(chatId); } }
                                continue;
                            case 'red_packet':
                                aiMessage = { ...baseMessage, type: 'red_packet', packetType: msgData.packetType, totalAmount: msgData.amount, count: msgData.count, greeting: msgData.greeting, receiverName: msgData.receiver, claimedBy: {}, isFullyClaimed: false, };
                                break;
                            case 'open_red_packet':
                                const packetToOpen = chat.history.find(m => m.timestamp === msgData.packet_timestamp);
                                if (packetToOpen && !packetToOpen.isFullyClaimed && !(packetToOpen.claimedBy && packetToOpen.claimedBy[msgData.name])) {
                                    let claimedAmountAI = 0;
                                    const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
                                    const remainingCount = packetToOpen.count - Object.keys(packetToOpen.claimedBy || {}).length;
                                    if (remainingCount > 0) {
                                        if (remainingCount === 1) { claimedAmountAI = remainingAmount; }
                                        else { const min = 0.01; const max = remainingAmount - (remainingCount - 1) * min; claimedAmountAI = Math.random() * (max - min) + min; }
                                        claimedAmountAI = parseFloat(claimedAmountAI.toFixed(2));
                                        if (!packetToOpen.claimedBy) packetToOpen.claimedBy = {};
                                        packetToOpen.claimedBy[msgData.name] = claimedAmountAI;
                                        chat.history.push({ role: 'system', type: 'pat_message', content: `${msgData.name} é¢†å–äº† ${packetToOpen.senderName} çš„çº¢åŒ…`, timestamp: Date.now() });
                                        let hiddenContentForAI = `[ç³»ç»Ÿæç¤ºï¼šä½  (${msgData.name}) æˆåŠŸæŠ¢åˆ°äº† ${claimedAmountAI.toFixed(2)} å…ƒã€‚`;
                                        if (Object.keys(packetToOpen.claimedBy).length >= packetToOpen.count) {
                                            packetToOpen.isFullyClaimed = true;
                                            chat.history.push({ role: 'system', type: 'pat_message', content: `${packetToOpen.senderName} çš„çº¢åŒ…å·²è¢«é¢†å®Œ`, timestamp: Date.now() + 1 });
                                            let luckyKing = { name: '', amount: -1 };
                                            if (packetToOpen.packetType === 'lucky' && packetToOpen.count > 1) { Object.entries(packetToOpen.claimedBy).forEach(([name, amount]) => { if (amount > luckyKing.amount) { luckyKing = { name, amount }; } }); }
                                            if (luckyKing.name) { hiddenContentForAI += ` çº¢åŒ…å·²è¢«é¢†å®Œï¼Œæ‰‹æ°”ç‹æ˜¯ ${luckyKing.name}ï¼`; } else { hiddenContentForAI += ` çº¢åŒ…å·²è¢«é¢†å®Œã€‚`; }
                                        }
                                        hiddenContentForAI += ' è¯·æ ¹æ®è¿™ä¸ªç»“æœå‘è¡¨ä½ çš„è¯„è®ºã€‚]';
                                        chat.history.push({ role: 'system', content: hiddenContentForAI, timestamp: Date.now() + 2, isHidden: true });
                                    }
                                    if (isViewingThisChat) { renderChatInterface(chatId); }
                                }
                                continue;
                            case 'system_message':
                                aiMessage = { role: 'system', type: 'pat_message', content: msgData.content, timestamp: Date.now() };
                                break;
                            case 'text':
                                aiMessage = { ...baseMessage, content: String(msgData.content || msgData.message) };
                                break;
                            case 'sticker':
                                aiMessage = { ...baseMessage, type: 'sticker', content: msgData.url, meaning: msgData.meaning || '' };
                                break;
                            case 'ai_image':
                                aiMessage = { ...baseMessage, type: 'ai_image', content: msgData.description };
                                break;
                            case 'voice_message':
                                aiMessage = { ...baseMessage, type: 'voice_message', content: msgData.content };
                                break;
                            case 'transfer':
                                const myNickname = chat.settings.myNickname || 'æˆ‘';
                                aiMessage = { ...baseMessage, type: 'transfer', amount: msgData.amount, note: msgData.note, receiverName: msgData.receiver || myNickname, status: 'pending' };
                                break;
                            case 'waimai_request':
                                aiMessage = { ...baseMessage, type: 'waimai_request', productInfo: msgData.productInfo, amount: msgData.amount, status: 'pending', countdownEndTime: Date.now() + 15 * 60 * 1000, };
                                break;
                            default:
                                console.warn("æ”¶åˆ°äº†æœªçŸ¥çš„AIæŒ‡ä»¤ç±»å‹:", msgData.type);
                                break;
                        }
                        if (aiMessage) {
                            chat.history.push(aiMessage);
                        }
                    }

                    if (isViewingThisChat) {
                        for (const msg of chat.history.slice(chat.history.length - messagesArray.length)) {
                            appendMessage(msg, chat);
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 500 + 200));
                        }
                    }

                    const firstNewMessage = chat.history.find(m => m.timestamp >= now && !m.isHidden);
                    if (!isViewingThisChat && firstNewMessage) {
                        let notificationText;
                        if (firstNewMessage.type === 'transfer') notificationText = `[æ”¶åˆ°ä¸€ç¬”è½¬è´¦]`;
                        else if (firstNewMessage.type === 'waimai_request') notificationText = `[æ”¶åˆ°ä¸€ä¸ªå¤–å–ä»£ä»˜è¯·æ±‚]`;
                        else if (firstNewMessage.type === 'ai_image') notificationText = `[å›¾ç‰‡]`;
                        else if (firstNewMessage.type === 'voice_message') notificationText = `[è¯­éŸ³]`;
                        else notificationText = STICKER_REGEX.test(firstNewMessage.content) ? '[è¡¨æƒ…]' : String(firstNewMessage.content);
                        const finalNotifText = chat.isGroup ? `${firstNewMessage.senderName}: ${notificationText}` : notificationText;
                        showNotification(chatId, finalNotifText);
                    }

                    if (callHasBeenHandled && videoCallState.isGroupCall) {
                        videoCallState.isAwaitingResponse = false;
                        if (videoCallState.participants.length > 0) {
                            startVideoCall();
                        } else {
                            videoCallState = { ...videoCallState, isAwaitingResponse: false, participants: [] };
                            showScreen('chat-interface-screen');
                            alert('æ— äººæ¥å¬ç¾¤èŠé‚€è¯·ã€‚');
                        }
                    }

                    chat.statusState.lastAiActivityTime = Date.now();
                    manageInactivityTimer(chat);
                    updateChatHeaderStatus(chat);
                    await db.chats.put(chat);

                } catch (error) {
                    chat.history = chat.history.filter(msg => !msg.isTemporary);
                    if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                        chat.relationship.status = 'blocked_by_ai';
                        await showCustomAlert('ç”³è¯·å¤±è´¥', `AIåœ¨å¤„ç†ä½ çš„å¥½å‹ç”³è¯·æ—¶å‡ºé”™äº†ï¼Œè¯·ç¨åé‡è¯•ã€‚\né”™è¯¯ä¿¡æ¯: ${error.message}`);
                    } else {
                        const errorContent = `[å‡ºé”™äº†: ${error.message}]`;
                        const errorMessage = { role: 'assistant', content: errorContent, timestamp: Date.now() };
                        if (chat.isGroup) errorMessage.senderName = "ç³»ç»Ÿæ¶ˆæ¯";
                        chat.history.push(errorMessage);
                    }

                    await db.chats.put(chat);
                    videoCallState.isAwaitingResponse = false;

                    if (document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId) {
                        renderChatInterface(chatId);
                    }
                } finally {
                    const isViewingThisChatAfterResponse = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
                    chat.status = isViewingThisChatAfterResponse ? 'read' : 'unread';
                    await db.chats.put(chat);
                    document.getElementById('typing-indicator').style.display = 'none';
                    if (isViewingThisChatAfterResponse) {
                        updateChatHeaderStatus(chat);
                    }
                    renderChatList();
                }
            }
            // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²


            // <--- åœ¨è¿™é‡Œæ·»åŠ è¿™è¡Œä»£ç // <--- åœ¨è¿™é‡Œæ·»åŠ è¿™è¡Œä»£ç // <--- åœ¨è¿™é‡Œæ·»åŠ è¿™è¡Œä»£ç // <--- åœ¨è¿™é‡Œæ·»åŠ è¿™è¡Œä»£ç // <--- åœ¨è¿™é‡Œæ·»åŠ è¿™è¡Œä»£ç // <--- åœ¨è¿™é‡Œæ·»åŠ è¿™è¡Œä»£ç // <--- åœ¨è¿™é‡Œæ·»åŠ è¿™è¡Œä»£ç 
            // <--- åœ¨è¿™é‡Œæ·»åŠ è¿™è¡Œä»£ç 

            async function sendSticker(sticker) { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content: sticker.url, meaning: sticker.name, timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); document.getElementById('sticker-panel').classList.remove('visible'); }

            async function sendUserTransfer() { if (!state.activeChatId) return; const amountInput = document.getElementById('transfer-amount'); const noteInput = document.getElementById('transfer-note'); const amount = parseFloat(amountInput.value); const note = noteInput.value.trim(); if (isNaN(amount) || amount < 0 || amount > 99999) { alert('è¯·è¾“å…¥æœ‰æ•ˆçš„é‡‘é¢ (0 åˆ° 99999 ä¹‹é—´)ï¼'); return; } const chat = state.chats[state.activeChatId]; const senderName = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘'; const receiverName = chat.isGroup ? 'ç¾¤èŠ' : chat.name; const msg = { role: 'user', type: 'transfer', amount: amount, note: note, senderName, receiverName, timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); document.getElementById('transfer-modal').classList.remove('visible'); amountInput.value = ''; noteInput.value = ''; }

            function enterSelectionMode(initialMsgTimestamp) { if (isSelectionMode) return; isSelectionMode = true; document.getElementById('chat-interface-screen').classList.add('selection-mode'); toggleMessageSelection(initialMsgTimestamp); }

            // â–¼â–¼â–¼ ã€å…¨æ–°ã€‘ç”¨æˆ·å¤„ç†è½¬è´¦çš„æ ¸å¿ƒåŠŸèƒ½å‡½æ•° â–¼â–¼â–¼

            let activeTransferTimestamp = null; // ç”¨äºæš‚å­˜è¢«ç‚¹å‡»çš„è½¬è´¦æ¶ˆæ¯çš„æ—¶é—´æˆ³

            /**
             * æ˜¾ç¤ºå¤„ç†è½¬è´¦çš„æ“ä½œèœå•
             * @param {number} timestamp - è¢«ç‚¹å‡»çš„è½¬è´¦æ¶ˆæ¯çš„æ—¶é—´æˆ³
             */
            function showTransferActionModal(timestamp) {
                activeTransferTimestamp = timestamp;

                const chat = state.chats[state.activeChatId];
                const message = chat.history.find(m => m.timestamp === timestamp);
                if (message) {
                    // å°†AIçš„åå­—å¡«å…¥å¼¹çª—
                    document.getElementById('transfer-sender-name').textContent = message.senderName;
                }
                document.getElementById('transfer-actions-modal').classList.add('visible');
            }

            /**
             * éšè—å¤„ç†è½¬è´¦çš„æ“ä½œèœå•
             */
            function hideTransferActionModal() {
                document.getElementById('transfer-actions-modal').classList.remove('visible');
                activeTransferTimestamp = null;
            }

            /**
             * å¤„ç†ç”¨æˆ·æ¥å—æˆ–æ‹’ç»è½¬è´¦çš„é€»è¾‘
             * @param {string} choice - ç”¨æˆ·çš„é€‰æ‹©, 'accepted' æˆ– 'declined'
             */
            async function handleUserTransferResponse(choice) {
                if (!activeTransferTimestamp) return;

                const timestamp = activeTransferTimestamp;
                const chat = state.chats[state.activeChatId];
                const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
                if (messageIndex === -1) return;

                // 1. æ›´æ–°åŸå§‹è½¬è´¦æ¶ˆæ¯çš„çŠ¶æ€
                const originalMessage = chat.history[messageIndex];
                originalMessage.status = choice;

                let systemContent;

                // 2. å¦‚æœç”¨æˆ·é€‰æ‹©"æ‹’ç»"
                if (choice === 'declined') {
                    // ç«‹åˆ»åœ¨å‰ç«¯ç”Ÿæˆä¸€ä¸ª"é€€æ¬¾"å¡ç‰‡ï¼Œè®©ç”¨æˆ·çœ‹åˆ°
                    const refundMessage = {
                        role: 'user',
                        type: 'transfer',
                        isRefund: true, // è¿™æ˜¯ä¸€ä¸ªå…³é”®æ ‡è®°ï¼Œç”¨äºUIæ˜¾ç¤ºè¿™æ˜¯é€€æ¬¾
                        amount: originalMessage.amount,
                        note: 'å·²æ‹’æ”¶å¯¹æ–¹è½¬è´¦',
                        timestamp: Date.now()
                    };
                    chat.history.push(refundMessage);

                    // å‡†å¤‡ä¸€æ¡å¯¹AIå¯è§çš„éšè—æ¶ˆæ¯ï¼Œå‘Šè¯‰å®ƒå‘ç”Ÿäº†ä»€ä¹ˆ
                    systemContent = `[ç³»ç»Ÿæç¤ºï¼šä½ æ‹’ç»å¹¶é€€è¿˜äº†"${originalMessage.senderName}"çš„è½¬è´¦ã€‚]`;
                } else { // å¦‚æœç”¨æˆ·é€‰æ‹©"æ¥å—"
                    // åªéœ€å‡†å¤‡éšè—æ¶ˆæ¯é€šçŸ¥AIå³å¯
                    systemContent = `[ç³»ç»Ÿæç¤ºï¼šä½ æ¥å—äº†"${originalMessage.senderName}"çš„è½¬è´¦ã€‚]`;
                }

                // 3. åˆ›å»ºè¿™æ¡å¯¹ç”¨æˆ·éšè—ã€ä½†å¯¹AIå¯è§çš„ç³»ç»Ÿæ¶ˆæ¯
                const hiddenMessage = {
                    role: 'system',
                    content: systemContent,
                    timestamp: Date.now() + 1, // ä¿è¯æ—¶é—´æˆ³åœ¨é€€æ¬¾æ¶ˆæ¯ä¹‹å
                    isHidden: true // è¿™ä¸ªæ ‡è®°ä¼šè®©å®ƒä¸åœ¨èŠå¤©ç•Œé¢æ˜¾ç¤º
                };
                chat.history.push(hiddenMessage);

                // 4. ä¿å­˜æ‰€æœ‰æ›´æ”¹åˆ°æ•°æ®åº“ï¼Œå¹¶åˆ·æ–°ç•Œé¢
                await db.chats.put(chat);
                hideTransferActionModal();
                renderChatInterface(state.activeChatId);
                renderChatList();
            }

            // â–²â–²â–² æ–°å‡½æ•°ç²˜è´´ç»“æŸ â–²â–²â–²

            function exitSelectionMode() {
                cleanupWaimaiTimers(); // <--- åœ¨è¿™é‡Œæ·»åŠ è¿™è¡Œä»£ç 
                if (!isSelectionMode) return; 
                isSelectionMode = false; 
                document.getElementById('chat-interface-screen').classList.remove('selection-mode'); 
                selectedMessages.forEach(ts => { 
                    const element = document.querySelector(`.message-bubble[data-timestamp="${ts}"], .sticker-container[data-timestamp="${ts}"]`); 
                    if (element) element.classList.remove('selected'); 
                }); 
                selectedMessages.clear();
            }

            // â–¼â–¼â–¼ è¯·ç”¨è¿™ä¸ªã€æœ€ç»ˆç®€åŒ–ç‰ˆã€‘æ›¿æ¢æ—§çš„ toggleMessageSelection å‡½æ•° â–¼â–¼â–¼
            function toggleMessageSelection(timestamp) {
                // Look for both message bubbles and sticker containers
                const elementToSelect = document.querySelector(
                    `.message-bubble[data-timestamp="${timestamp}"], .sticker-container[data-timestamp="${timestamp}"]`
                );

                if (!elementToSelect) return;

                if (selectedMessages.has(timestamp)) {
                    selectedMessages.delete(timestamp);
                    elementToSelect.classList.remove('selected');
                } else {
                    selectedMessages.add(timestamp);
                    elementToSelect.classList.add('selected');
                }

                document.getElementById('selection-count').textContent = `å·²é€‰ ${selectedMessages.size} æ¡`;

                if (selectedMessages.size === 0) {
                    exitSelectionMode();
                }
            }
            // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

            function addLongPressListener(element, callback) {
                let pressTimer;
                let hasMoved = false;
                let startX = 0, startY = 0;

                const startPress = (e) => {
                    // Allow long press in arrange mode for stickers, but block in chat selection mode
                    if (isSelectionMode && !isArrangeMode) return;
                    hasMoved = false;

                    // Record starting position
                    if (e.type === 'touchstart') {
                        startX = e.touches[0].clientX;
                        startY = e.touches[0].clientY;
                    } else {
                        startX = e.clientX;
                        startY = e.clientY;
                    }

                    // Don't prevent default on touchstart - allow scrolling to work normally
                    // Only prevent default for mouse events to avoid text selection
                    if (e.type === 'mousedown' && element.classList.contains('comment-item')) {
                        e.preventDefault();
                    }

                    pressTimer = window.setTimeout(() => {
                        if (!hasMoved) {
                            callback(e);
                        }
                    }, 500);
                };

                const cancelPress = () => {
                    clearTimeout(pressTimer);
                    hasMoved = false;
                };

                const handleMove = (e) => {
                    // Only consider it movement if it's significant (more than 10px)
                    let currentX, currentY;
                    if (e.type === 'touchmove') {
                        currentX = e.touches[0].clientX;
                        currentY = e.touches[0].clientY;
                    } else {
                        currentX = e.clientX;
                        currentY = e.clientY;
                    }

                    const deltaX = Math.abs(currentX - startX);
                    const deltaY = Math.abs(currentY - startY);

                    if (deltaX > 10 || deltaY > 10) {
                        hasMoved = true;
                        clearTimeout(pressTimer);
                    }
                };

                element.addEventListener('mousedown', startPress);
                element.addEventListener('mouseup', cancelPress);
                element.addEventListener('mouseleave', cancelPress);
                element.addEventListener('mousemove', handleMove);
                element.addEventListener('touchstart', startPress, { passive: true });
                element.addEventListener('touchend', cancelPress);
                element.addEventListener('touchmove', handleMove, { passive: true });
            }

            async function handleListenTogetherClick() {
                const targetChatId = state.activeChatId;
                if (!targetChatId) return;

                if (!musicState.isActive) {
                    startListenTogetherSessionWithoutPlaying(targetChatId);
                } else if (musicState.activeChatId !== targetChatId) {
                    const oldChatName = state.chats[musicState.activeChatId]?.name || 'æœªçŸ¥';
                    const newChatName = state.chats[targetChatId]?.name || 'å½“å‰';
                    const confirmed = await showCustomConfirm('åˆ‡æ¢å¬æ­Œå¯¹è±¡', `æ‚¨æ­£å’Œã€Œ${oldChatName}ã€å¬æ­Œã€‚è¦ç»“æŸå¹¶å¼€å§‹å’Œã€Œ${newChatName}ã€çš„æ–°ä¼šè¯å—ï¼Ÿ`, { confirmButtonClass: 'btn-danger' });
                    if (confirmed) {
                        await endListenTogetherSession(true);
                        await new Promise(resolve => setTimeout(resolve, 50));
                        startListenTogetherSessionWithoutPlaying(targetChatId);
                    } else {
                        return;
                    }
                }

                // ALWAYS open main modal
                document.getElementById('music-player-overlay').classList.add('visible');
            }

            function startListenTogetherSessionWithoutPlaying(chatId) {
                const chat = state.chats[chatId];
                if (!chat) return;

                musicState.totalElapsedTime = chat.musicData.totalTime || 0;
                musicState.isActive = true;
                musicState.activeChatId = chatId;
                musicState.isPlaying = false; // Explicitly set to not playing

                if (musicState.playlist.length > 0 && musicState.currentIndex === -1) {
                    musicState.currentIndex = 0;
                }

                if (musicState.timerId) clearInterval(musicState.timerId);
                musicState.timerId = setInterval(() => {
                    if (musicState.isPlaying) {
                        musicState.totalElapsedTime++;
                        updateElapsedTimeDisplay();
                        updateNowPlayingProgress();
                    }
                }, 1000);

                updatePlayerUI();
                updatePlaylistUI();
                // DO NOT show now playing bar here - only when user presses play
            }

            async function endListenTogetherSession(saveState = true) { if (!musicState.isActive) return; const oldChatId = musicState.activeChatId; if (musicState.timerId) clearInterval(musicState.timerId); if (musicState.isPlaying) { const currentTrack = musicState.playlist[musicState.currentIndex]; if (currentTrack && currentTrack.isSpotify && spotifyPlayer) { spotifyPlayer.pause(); } else { audioPlayer.pause(); } } if (saveState && oldChatId && state.chats[oldChatId]) { const chat = state.chats[oldChatId]; chat.musicData.totalTime = musicState.totalElapsedTime; await db.chats.put(chat); } musicState.isActive = false; musicState.activeChatId = null; musicState.totalElapsedTime = 0; musicState.timerId = null; document.getElementById('music-player-overlay').classList.remove('visible'); document.getElementById('music-playlist-panel').classList.remove('visible'); updateListenTogetherIcon(oldChatId, true); hideNowPlayingBar(); }

            function returnToChat() { document.getElementById('music-player-overlay').classList.remove('visible'); document.getElementById('music-playlist-panel').classList.remove('visible'); }

            function updateListenTogetherIcon(chatId, forceReset = false) { const iconImg = document.querySelector('#listen-together-btn img'); if (!iconImg) return; if (forceReset || !musicState.isActive || musicState.activeChatId !== chatId) { iconImg.src = 'https://i.postimg.cc/8kYShvrJ/90-UI-2.png'; iconImg.className = ''; return; } iconImg.src = 'https://i.postimg.cc/vBN7GnQ9/3-FC8-D1596-C5-CFB200-FCB1-D8-C3-A37-A370.png'; iconImg.classList.add('rotating'); if (musicState.isPlaying) iconImg.classList.remove('paused'); else iconImg.classList.add('paused'); }
            window.updateListenTogetherIconProxy = updateListenTogetherIcon;

            function switchMainPlaylistTab(tab) { document.querySelectorAll('.main-playlist-tab').forEach(t => { t.classList.remove('active'); t.style.borderBottom = '2px solid transparent'; }); document.querySelectorAll('.main-playlist-tab-content').forEach(c => c.style.display = 'none'); if (tab === 'songs') { document.querySelector('.main-playlist-tab[onclick*="songs"]').classList.add('active'); document.querySelector('.main-playlist-tab[onclick*="songs"]').style.borderBottom = '2px solid var(--accent-color)'; document.getElementById('main-songs-tab').style.display = 'block'; } else if (tab === 'playlists') { document.querySelector('.main-playlist-tab[onclick*="playlists"]').classList.add('active'); document.querySelector('.main-playlist-tab[onclick*="playlists"]').style.borderBottom = '2px solid var(--accent-color)'; document.getElementById('main-playlists-tab').style.display = 'block'; showMainSpotifyPlaylists(); } }
            window.switchMainPlaylistTab = switchMainPlaylistTab;

            async function loadMainSpotifyPlaylists() { if (!spotifyAccessToken) { document.getElementById('main-playlists-list').innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-secondary);">è¯·å…ˆè¿æ¥Spotify</div>'; return; } try { const response = await fetch('https://api.spotify.com/v1/me/playlists?limit=20', { headers: { 'Authorization': `Bearer ${spotifyAccessToken}` } }); const data = await response.json(); window.mainSpotifyPlaylists = data.items; } catch (error) { console.error('Failed to load playlists:', error); } }

            function showMainSpotifyPlaylists() { const playlistsDiv = document.getElementById('main-playlists-list'); if (!playlistsDiv) return; if (!window.mainSpotifyPlaylists || window.mainSpotifyPlaylists.length === 0) { loadMainSpotifyPlaylists().then(() => { if (!window.mainSpotifyPlaylists || window.mainSpotifyPlaylists.length === 0) { playlistsDiv.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-secondary);">æ²¡æœ‰æ‰¾åˆ°æ’­æ”¾åˆ—è¡¨</div>'; } else { playlistsDiv.innerHTML = window.mainSpotifyPlaylists.map(playlist => `<div class="list-item" onclick="showMainPlaylistTracks('${playlist.id}', '${playlist.name.replace(/'/g, "\\'")}')"><div class="item-title">${playlist.name}</div><div class="item-content">${playlist.tracks.total} é¦–æ­Œæ›²</div></div>`).join(''); } }); return; } playlistsDiv.innerHTML = window.mainSpotifyPlaylists.map(playlist => `<div class="list-item" onclick="showMainPlaylistTracks('${playlist.id}', '${playlist.name.replace(/'/g, "\\'")}')"><div class="item-title">${playlist.name}</div><div class="item-content">${playlist.tracks.total} é¦–æ­Œæ›²</div></div>`).join(''); document.getElementById('main-playlists-list').style.display = 'block'; document.getElementById('main-playlist-view').style.display = 'none'; }
            window.showMainSpotifyPlaylists = showMainSpotifyPlaylists;
            window.playFromSpotifyPlaylist = playFromSpotifyPlaylist;

            function playFromMainPlaylist(index) { if (musicState.isPlayingFromPlaylist) { musicState.playlist = [...musicState.mainPlaylist]; musicState.isPlayingFromPlaylist = false; } musicState.currentIndex = index; playSong(index); updatePlayerUI(); updatePlaylistUI(); }

            function deleteFromMainPlaylist(index) { if (musicState.isPlayingFromPlaylist) { musicState.mainPlaylist.splice(index, 1); } else { if (index < 0 || index >= musicState.playlist.length) return; const track = musicState.playlist[index]; const wasPlaying = musicState.isPlaying && musicState.currentIndex === index; if (track.isLocal && audioPlayer.src.startsWith('blob:') && musicState.currentIndex === index) URL.revokeObjectURL(audioPlayer.src); musicState.playlist.splice(index, 1); if (musicState.playlist.length === 0) { if (musicState.isPlaying) audioPlayer.pause(); audioPlayer.src = ''; musicState.currentIndex = -1; musicState.isPlaying = false; } else { if (wasPlaying) { playNext(); } else { if (musicState.currentIndex >= index) musicState.currentIndex = Math.max(0, musicState.currentIndex - 1); } } updatePlayerUI(); } saveGlobalPlaylist(); updatePlaylistUI(); }

            window.playFromMainPlaylist = playFromMainPlaylist;
            window.deleteFromMainPlaylist = deleteFromMainPlaylist;

            async function showMainPlaylistTracks(playlistId, playlistName) { document.getElementById('main-current-playlist-name').textContent = playlistName; document.getElementById('main-playlists-list').style.display = 'none'; document.getElementById('main-playlist-view').style.display = 'block'; try { const response = await fetch(`https://api.spotify.com/v1/playlists/${playlistId}/tracks?limit=50`, { headers: { 'Authorization': `Bearer ${spotifyAccessToken}` } }); const data = await response.json(); const validTracks = data.items.filter(item => item.track && item.track.type === 'track').map(item => ({ name: item.track.name, artist: item.track.artists.map(a => a.name).join(', '), album: item.track.album.name, uri: item.track.uri, albumArt: item.track.album.images[0]?.url })); musicState.currentSpotifyPlaylist = { id: playlistId, name: playlistName }; musicState.spotifyPlaylistTracks = validTracks; const tracksDiv = document.getElementById('main-playlist-tracks'); tracksDiv.innerHTML = validTracks.map((track, index) => `<div class="list-item" onclick="playFromSpotifyPlaylist(${index})"><div class="item-title">${track.name}</div><div class="item-content">${track.artist} â€¢ ${track.album}</div></div>`).join(''); } catch (error) { console.error('Failed to load playlist tracks:', error); } }
            window.showMainPlaylistTracks = showMainPlaylistTracks;

            function playFromSpotifyPlaylist(trackIndex) { if (!musicState.spotifyPlaylistTracks || trackIndex >= musicState.spotifyPlaylistTracks.length) return; if (!musicState.isPlayingFromPlaylist) { musicState.mainPlaylist = [...musicState.playlist]; } musicState.isPlayingFromPlaylist = true; musicState.playlist = musicState.spotifyPlaylistTracks.map(t => ({ name: t.name, artist: t.artist, src: null, isLocal: false, isSpotify: true, spotifyUri: t.uri, albumArt: t.albumArt })); musicState.currentIndex = trackIndex; playSong(trackIndex); updatePlayerUI(); updatePlaylistUI(); document.getElementById('music-playlist-panel').classList.remove('visible'); }

            async function addMainSpotifyTrackToPlaylist(uri, name, artist, albumArt) { musicState.playlist.push({ name: name, artist: artist, src: null, isLocal: false, isSpotify: true, spotifyUri: uri, albumArt: albumArt }); await saveGlobalPlaylist(); updatePlaylistUI(); if (musicState.currentIndex === -1) { musicState.currentIndex = musicState.playlist.length - 1; updatePlayerUI(); } switchMainPlaylistTab('songs'); }
            window.addMainSpotifyTrackToPlaylist = addMainSpotifyTrackToPlaylist;

            function updatePlayerUI() {
                updateListenTogetherIcon(musicState.activeChatId);
                updateElapsedTimeDisplay();

                const titleEl = document.getElementById('music-player-song-title');
                const artistEl = document.getElementById('music-player-artist');
                const playPauseBtn = document.getElementById('music-play-pause-btn');

                if (musicState.currentIndex > -1 && musicState.playlist.length > 0) {
                    const track = musicState.playlist[musicState.currentIndex];
                    titleEl.textContent = track.name;
                    artistEl.textContent = track.artist;
                } else {
                    titleEl.textContent = 'è¯·æ·»åŠ æ­Œæ›²';
                    artistEl.textContent = '...';
                }

                playPauseBtn.textContent = musicState.isPlaying ? 'âšâš' : 'â–¶';

                // Only update content, don't show/hide bar
                updateNowPlayingBarContent();
            }

            // Now Playing Bar Management
            function showNowPlayingBar() {
                const activeScreen = document.querySelector('.screen.active');
                const currentScreenId = activeScreen ? activeScreen.id : null;

                if (currentScreenId === 'home-screen') {
                    showHomeNowPlayingBar();
                } else if (currentScreenId === 'chat-interface-screen') {
                    showChatNowPlayingBar();
                }
            }

            function showChatNowPlayingBar() {
                const nowPlayingBar = document.getElementById('now-playing-bar');
                const chatScreen = document.getElementById('chat-interface-screen');

                if (musicState.isActive && musicState.currentIndex >= 0 && musicState.playlist.length > 0) {
                    const track = musicState.playlist[musicState.currentIndex];

                    // Update track info
                    document.getElementById('np-song-title').textContent = track.name || 'æœªçŸ¥æ­Œæ›²';
                    document.getElementById('np-song-artist').textContent = track.artist || 'æœªçŸ¥è‰ºæœ¯å®¶';

                    // Update play/pause button
                    const npPlayBtn = document.getElementById('np-play-pause-btn');
                    npPlayBtn.textContent = musicState.isPlaying ? 'âšâš' : 'â–¶';

                    // Update album art
                    const albumImg = document.getElementById('np-album-image');
                    const defaultIcon = albumImg.nextElementSibling;
                    if (track.albumArt) {
                        albumImg.src = track.albumArt;
                        albumImg.style.display = 'block';
                        defaultIcon.style.display = 'none';
                    } else {
                        albumImg.style.display = 'none';
                        defaultIcon.style.display = 'flex';
                    }

                    // Update listening partner avatar
                    const partnerAvatar = document.getElementById('np-partner-avatar');
                    if (musicState.activeChatId && state.chats[musicState.activeChatId]) {
                        const chat = state.chats[musicState.activeChatId];
                        const avatarUrl = chat.settings.aiAvatar || 'https://files.catbox.moe/q6z5fc.jpeg';
                        partnerAvatar.src = avatarUrl;
                        partnerAvatar.alt = `ä¸ ${chat.name} ä¸€èµ·å¬`;
                    }

                    // Always show the bar and ensure proper layout
                    nowPlayingBar.classList.remove('hidden');
                    if (chatScreen && chatScreen.classList.contains('active')) {
                        chatScreen.classList.add('has-now-playing');
                    }
                }
            }

            function updateNowPlayingBarContent() {
                // Update chat screen bar content
                const nowPlayingBar = document.getElementById('now-playing-bar');
                if (!nowPlayingBar.classList.contains('hidden') && musicState.isActive && musicState.currentIndex >= 0) {
                    const track = musicState.playlist[musicState.currentIndex];

                    document.getElementById('np-song-title').textContent = track.name || 'æœªçŸ¥æ­Œæ›²';
                    document.getElementById('np-song-artist').textContent = track.artist || 'æœªçŸ¥è‰ºæœ¯å®¶';

                    const npPlayBtn = document.getElementById('np-play-pause-btn');
                    npPlayBtn.textContent = musicState.isPlaying ? 'âšâš' : 'â–¶';

                    // Update album art rotation for chat screen
                    const albumImg = document.getElementById('np-album-image');
                    if (albumImg) {
                        if (musicState.isPlaying) {
                            albumImg.classList.add('rotating');
                        } else {
                            albumImg.classList.remove('rotating');
                        }
                    }
                }

                // Update home screen bar content
                const homeBar = document.getElementById('home-now-playing-bar');
                if (!homeBar.classList.contains('hidden') && musicState.isActive && musicState.currentIndex >= 0) {
                    const track = musicState.playlist[musicState.currentIndex];

                    document.getElementById('home-np-song-title').textContent = track.name || 'æœªçŸ¥æ­Œæ›²';
                    document.getElementById('home-np-song-artist').textContent = track.artist || 'æœªçŸ¥è‰ºæœ¯å®¶';

                    const homePlayBtn = document.getElementById('home-np-play-pause-btn');
                    homePlayBtn.textContent = musicState.isPlaying ? 'âšâš' : 'â–¶';

                    // Update album art rotation for home screen
                    const homeAlbumImg = document.getElementById('home-np-album-image');
                    if (homeAlbumImg) {
                        if (musicState.isPlaying) {
                            homeAlbumImg.classList.add('rotating');
                        } else {
                            homeAlbumImg.classList.remove('rotating');
                        }
                    }
                }
            }

            function updateNowPlayingProgress() {
                if (!musicState.isActive || musicState.currentIndex < 0) {
                    // Hide progress bars when no music is active
                    const chatProgressFill = document.getElementById('np-progress-fill');
                    const homeProgressFill = document.getElementById('home-np-progress-fill');
                    if (chatProgressFill) chatProgressFill.style.width = '0%';
                    if (homeProgressFill) homeProgressFill.style.width = '0%';
                    return;
                }

                const currentTrack = musicState.playlist[musicState.currentIndex];
                let currentTime = 0;
                let duration = 0;

                if (currentTrack && currentTrack.isSpotify && spotifyPlayer) {
                    // Get Spotify progress
                    spotifyPlayer.getCurrentState().then(state => {
                        if (state && state.track_window.current_track) {
                            currentTime = state.position / 1000; // Convert ms to seconds
                            duration = state.duration / 1000;
                            updateProgressBars(currentTime, duration);
                        }
                    }).catch(() => {
                        // Spotify state unavailable, hide progress
                        const chatProgressFill = document.getElementById('np-progress-fill');
                        const homeProgressFill = document.getElementById('home-np-progress-fill');
                        if (chatProgressFill) chatProgressFill.style.width = '0%';
                        if (homeProgressFill) homeProgressFill.style.width = '0%';
                    });
                } else if (audioPlayer.duration) {
                    // Get regular audio progress
                    currentTime = audioPlayer.currentTime;
                    duration = audioPlayer.duration;
                    updateProgressBars(currentTime, duration);
                }
            }

            function updateProgressBars(currentTime, duration) {
                if (duration <= 0) return;

                const progressPercent = Math.min(100, (currentTime / duration) * 100);

                // Update chat screen progress bar
                const chatProgressFill = document.getElementById('np-progress-fill');
                if (chatProgressFill) {
                    chatProgressFill.style.width = `${progressPercent}%`;
                }

                // Update home screen progress bar
                const homeProgressFill = document.getElementById('home-np-progress-fill');
                if (homeProgressFill) {
                    homeProgressFill.style.width = `${progressPercent}%`;
                }
            }

            function hideNowPlayingBar() {
                hideHomeNowPlayingBar();
                hideChatNowPlayingBar();
            }

            function hideChatNowPlayingBar() {
                const nowPlayingBar = document.getElementById('now-playing-bar');
                const chatScreen = document.getElementById('chat-interface-screen');

                if (!nowPlayingBar.classList.contains('hidden')) {
                    nowPlayingBar.classList.add('hidden');
                    if (chatScreen) {
                        chatScreen.classList.remove('has-now-playing');
                    }
                }
            }

            // Home Screen Now Playing Bar Functions
            function showHomeNowPlayingBar() {
                const homeBar = document.getElementById('home-now-playing-bar');

                if (musicState.isActive && musicState.currentIndex >= 0 && musicState.playlist.length > 0) {
                    const track = musicState.playlist[musicState.currentIndex];

                    // Update track info
                    document.getElementById('home-np-song-title').textContent = track.name || 'æœªçŸ¥æ­Œæ›²';
                    document.getElementById('home-np-song-artist').textContent = track.artist || 'æœªçŸ¥è‰ºæœ¯å®¶';

                    // Update play/pause button
                    const npPlayBtn = document.getElementById('home-np-play-pause-btn');
                    npPlayBtn.textContent = musicState.isPlaying ? 'âšâš' : 'â–¶';

                    // Update album art
                    const albumImg = document.getElementById('home-np-album-image');
                    const defaultIcon = albumImg.nextElementSibling;
                    if (track.albumArt) {
                        albumImg.src = track.albumArt;
                        albumImg.style.display = 'block';
                        defaultIcon.style.display = 'none';
                    } else {
                        albumImg.style.display = 'none';
                        defaultIcon.style.display = 'flex';
                    }

                    // Update album art rotation
                    if (albumImg) {
                        if (musicState.isPlaying) {
                            albumImg.classList.add('rotating');
                        } else {
                            albumImg.classList.remove('rotating');
                        }
                    }

                    // Update listening partner avatar
                    const partnerAvatar = document.getElementById('home-np-partner-avatar');
                    if (musicState.activeChatId && state.chats[musicState.activeChatId]) {
                        const chat = state.chats[musicState.activeChatId];
                        const avatarUrl = chat.settings.aiAvatar || 'https://files.catbox.moe/q6z5fc.jpeg';
                        partnerAvatar.src = avatarUrl;
                        partnerAvatar.alt = `ä¸ ${chat.name} ä¸€èµ·å¬`;
                    }

                    // Always show the bar and ensure proper layout
                    homeBar.classList.remove('hidden');
                }
            }

            function hideHomeNowPlayingBar() {
                const homeBar = document.getElementById('home-now-playing-bar');
                homeBar.classList.add('hidden');
            }

            function initializeNowPlayingBar() {
                // Tap to expand functionality
                document.getElementById('now-playing-bar').addEventListener('click', (e) => {
                    if (!e.target.closest('.np-playback-controls')) {
                        document.getElementById('music-player-overlay').classList.add('visible');
                    }
                });

                // Control button event listeners
                document.getElementById('np-play-pause-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    togglePlayPause();
                });

                document.getElementById('np-prev-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    playPrev();
                });

                document.getElementById('np-next-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    playNext();
                });
            }

            function initializeHomeNowPlayingBar() {
                const homeBar = document.getElementById('home-now-playing-bar');
                if (!homeBar) {
                    console.error('Home now playing bar element not found');
                    return;
                }

                // Tap to navigate to listening partner's chat with modal open
                homeBar.addEventListener('click', (e) => {
                    // Don't navigate if clicking on control buttons
                    if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                        return;
                    }

                    // Navigate to the listening partner's chat
                    if (musicState.activeChatId) {
                        // Open the chat
                        openChat(musicState.activeChatId);
                        // Open the music modal
                        document.getElementById('music-player-overlay').classList.add('visible');
                    }
                });

                // Control button event listeners
                const playBtn = document.getElementById('home-np-play-pause-btn');
                const prevBtn = document.getElementById('home-np-prev-btn');
                const nextBtn = document.getElementById('home-np-next-btn');

                if (playBtn) {
                    playBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        togglePlayPause();
                    });
                }

                if (prevBtn) {
                    prevBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        playPrev();
                    });
                }

                if (nextBtn) {
                    nextBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        playNext();
                    });
                }
            }

            function updateElapsedTimeDisplay() { const hours = (musicState.totalElapsedTime / 3600).toFixed(1); document.getElementById('music-time-counter').textContent = `å·²ç»ä¸€èµ·å¬äº†${hours}å°æ—¶`; }

            function updatePlaylistUI() { const playlistBody = document.getElementById('playlist-body'); playlistBody.innerHTML = ''; const displayPlaylist = musicState.isPlayingFromPlaylist ? musicState.mainPlaylist : musicState.playlist; if (displayPlaylist.length === 0) { playlistBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #888;">æ’­æ”¾åˆ—è¡¨æ˜¯ç©ºçš„~</p>'; return; } displayPlaylist.forEach((track, index) => { const item = document.createElement('div'); item.className = 'playlist-item'; if (!musicState.isPlayingFromPlaylist && index === musicState.currentIndex) item.classList.add('playing'); item.innerHTML = `<div class="playlist-item-info"><div class="title">${track.name}</div><div class="artist">${track.artist}</div></div><span class="delete-track-btn" data-index="${index}">&times;</span>`; item.querySelector('.playlist-item-info').addEventListener('click', () => playFromMainPlaylist(index)); item.querySelector('.delete-track-btn').addEventListener('click', async (e) => { e.stopPropagation(); const confirmed = await showCustomConfirm('åˆ é™¤æ­Œæ›²', `ç¡®å®šè¦ä»æ’­æ”¾åˆ—è¡¨ä¸­åˆ é™¤ã€Š${track.name}ã€‹å—ï¼Ÿ`); if (confirmed) deleteFromMainPlaylist(index); }); playlistBody.appendChild(item); }); }

            function playSong(index) {
                if (index < 0 || index >= musicState.playlist.length) return;
                musicState.currentIndex = index;
                const track = musicState.playlist[index];

                if (track.isSpotify && spotifyPlayer && spotifyDeviceId) {
                    fetch(`https://api.spotify.com/v1/me/player/play?device_id=${spotifyDeviceId}`, {
                        method: 'PUT',
                        headers: { 'Authorization': `Bearer ${spotifyAccessToken}`, 'Content-Type': 'application/json' },
                        body: JSON.stringify({ uris: [track.spotifyUri] })
                    });
                    musicState.isPlaying = true;
                } else if (track.isLocal && track.src instanceof Blob) {
                    audioPlayer.src = URL.createObjectURL(track.src);
                    musicState.isPlaying = true;
                    audioPlayer.play().catch(error => {
                        console.error('Error playing audio:', error);
                        musicState.isPlaying = false;
                        updatePlayerUI();
                    });
                } else if (!track.isLocal && !track.isSpotify) {
                    audioPlayer.src = track.src;
                    musicState.isPlaying = true;
                    audioPlayer.play().catch(error => {
                        console.error('Error playing audio:', error);
                        musicState.isPlaying = false;
                        updatePlayerUI();
                    });
                } else {
                    return;
                }

                updatePlaylistUI();
                updatePlayerUI();
            }

            function togglePlayPause() {
                const currentTrack = musicState.playlist[musicState.currentIndex];

                if (!musicState.isPlaying) {
                    // If not playing, check if we should resume or start new song
                    if (musicState.playlist.length === 0) return;

                    const indexToPlay = (musicState.currentIndex >= 0 && musicState.currentIndex < musicState.playlist.length) ? musicState.currentIndex : 0;

                    // Check if we should resume or start new song

                    if (currentTrack && currentTrack.isSpotify && spotifyPlayer) {
                        // For Spotify tracks, check if we should resume or start new
                        spotifyPlayer.getCurrentState().then(state => {
                            if (state && state.track_window.current_track && state.paused) {
                                // Spotify is paused, resume it
                                spotifyPlayer.resume().then(() => {
                                    musicState.isPlaying = true;
                                    updatePlayerUI();
                                });
                            } else {
                                // No current Spotify track or different track, start new
                                playSongAndShowBar(indexToPlay);
                            }
                        }).catch(error => {
                            playSongAndShowBar(indexToPlay);
                        });
                        showNowPlayingBar();
                    } else if (currentTrack && !currentTrack.isSpotify && audioPlayer.src && !audioPlayer.ended && audioPlayer.paused) {
                        // For regular audio tracks, resume from pause
                        musicState.isPlaying = true;
                        audioPlayer.play().catch(error => {
                            console.error('Error resuming audio:', error);
                            musicState.isPlaying = false;
                            updatePlayerUI();
                        });
                        showNowPlayingBar();
                    } else {
                        // Start new song - load audio source
                        playSongAndShowBar(indexToPlay);
                    }
                } else {
                    // If playing, pause it
                    if (currentTrack && currentTrack.isSpotify && spotifyPlayer) {
                        spotifyPlayer.pause();
                    } else {
                        audioPlayer.pause();
                    }
                    // DO NOT hide bar when pausing
                }
            }

            function cycleSongOnly(index) {
                if (index < 0 || index >= musicState.playlist.length) return;
                musicState.currentIndex = index;
                // DO NOT play music, just update UI
                updatePlaylistUI();
                updatePlayerUI();
            }

            function playSongAndShowBar(index) {
                if (index < 0 || index >= musicState.playlist.length) return;
                musicState.currentIndex = index;
                const track = musicState.playlist[index];

                if (track.isSpotify && spotifyPlayer && spotifyDeviceId) {


                    fetch(`https://api.spotify.com/v1/me/player/play?device_id=${spotifyDeviceId}`, {
                        method: 'PUT',
                        headers: { 'Authorization': `Bearer ${spotifyAccessToken}`, 'Content-Type': 'application/json' },
                        body: JSON.stringify({ uris: [track.spotifyUri] })
                    }).then(response => {
                        if (response.ok) {
                            musicState.isPlaying = true;
                            updatePlayerUI();
                        } else {
                            console.error('Spotify API error:', response.status, response.statusText);
                            alert(`Spotifyæ’­æ”¾å¤±è´¥: ${response.status} ${response.statusText}\nè¯·æ£€æŸ¥Spotifyè¿æ¥çŠ¶æ€`);
                            musicState.isPlaying = false;
                            updatePlayerUI();
                        }
                    }).catch(error => {
                        console.error('Spotify fetch error:', error);
                        alert('Spotifyè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
                        musicState.isPlaying = false;
                        updatePlayerUI();
                    });
                } else if (track.isLocal && track.src instanceof Blob) {
                    audioPlayer.src = URL.createObjectURL(track.src);
                    // Set playing state before calling play() to ensure UI updates correctly
                    musicState.isPlaying = true;
                    audioPlayer.play().catch(error => {
                        console.error('Error playing audio:', error);
                        musicState.isPlaying = false;
                        updatePlayerUI();
                    });
                } else if (!track.isLocal && !track.isSpotify) {
                    audioPlayer.src = track.src;
                    // Set playing state before calling play() to ensure UI updates correctly
                    musicState.isPlaying = true;
                    audioPlayer.play().catch(error => {
                        console.error('Error playing audio:', error);
                        musicState.isPlaying = false;
                        updatePlayerUI();
                    });
                } else if (track.isSpotify && (!spotifyPlayer || !spotifyDeviceId || !spotifyAccessToken)) {
                    alert('Spotifyæœªæ­£ç¡®è¿æ¥ã€‚è¯·é‡æ–°è¿æ¥Spotifyã€‚');
                    return;
                } else {
                    return;
                }

                // Show now playing bar when music starts
                showNowPlayingBar();
                updatePlaylistUI();
                updatePlayerUI();
            }

            function playNext() {
                if (musicState.playlist.length === 0) return;
                let nextIndex;
                switch (musicState.playMode) {
                    case 'random':
                        nextIndex = Math.floor(Math.random() * musicState.playlist.length);
                        break;
                    case 'single':
                        playSongAndShowBar(musicState.currentIndex);
                        return;
                    case 'order':
                    default:
                        nextIndex = (musicState.currentIndex + 1) % musicState.playlist.length;
                        break;
                }
                // Always play the next song automatically
                playSongAndShowBar(nextIndex);
            }

            function playPrev() {
                if (musicState.playlist.length === 0) return;
                const newIndex = (musicState.currentIndex - 1 + musicState.playlist.length) % musicState.playlist.length;
                // Always play the previous song automatically
                playSongAndShowBar(newIndex);
            }

            function changePlayMode() { const modes = ['order', 'random', 'single']; const currentModeIndex = modes.indexOf(musicState.playMode); musicState.playMode = modes[(currentModeIndex + 1) % modes.length]; document.getElementById('music-mode-btn').textContent = { 'order': 'é¡ºåº', 'random': 'éšæœº', 'single': 'å•æ›²' }[musicState.playMode]; }

            async function addSongFromURL() { const url = await showCustomPrompt("æ·»åŠ ç½‘ç»œæ­Œæ›²", "è¯·è¾“å…¥æ­Œæ›²çš„URL", "", "url"); if (!url) return; const name = await showCustomPrompt("æ­Œæ›²ä¿¡æ¯", "è¯·è¾“å…¥æ­Œå"); if (!name) return; const artist = await showCustomPrompt("æ­Œæ›²ä¿¡æ¯", "è¯·è¾“å…¥æ­Œæ‰‹å"); if (!artist) return; musicState.playlist.push({ name, artist, src: url, isLocal: false }); await saveGlobalPlaylist(); updatePlaylistUI(); if (musicState.currentIndex === -1) { musicState.currentIndex = musicState.playlist.length - 1; updatePlayerUI(); } }

            async function addSongFromLocal(event) { const files = event.target.files; if (!files.length) return; for (const file of files) { const name = await showCustomPrompt("æ­Œæ›²ä¿¡æ¯", "è¯·è¾“å…¥æ­Œå", ""); if (name === null) continue; const artist = await showCustomPrompt("æ­Œæ›²ä¿¡æ¯", "è¯·è¾“å…¥æ­Œæ‰‹å", ""); if (artist === null) continue; musicState.playlist.push({ name, artist, src: file, isLocal: true }); } await saveGlobalPlaylist(); updatePlaylistUI(); if (musicState.currentIndex === -1 && musicState.playlist.length > 0) { musicState.currentIndex = 0; updatePlayerUI(); } event.target.value = null; }

            async function addSongFromSpotify() { if (!spotifyAccessToken) { if (confirm('éœ€è¦è¿æ¥åˆ°Spotifyæ‰èƒ½æ·»åŠ æ­Œæ›²ã€‚è¯·ç¡®ä¿æ‚¨æœ‰Spotify Premiumè´¦æˆ·ï¼Œå¹¶åœ¨æˆæƒæ—¶ç‚¹å‡»"åŒæ„"ã€‚æ˜¯å¦ç°åœ¨è¿æ¥ï¼Ÿ')) { await initSpotifyAuth(); } return; } const query = await showCustomPrompt("æœç´¢Spotifyæ­Œæ›²", "è¯·è¾“å…¥æ­Œæ›²åæˆ–è‰ºæœ¯å®¶"); if (!query) return; try { const response = await fetch(`https://api.spotify.com/v1/search?q=${encodeURIComponent(query)}&type=track&limit=10`, { headers: { 'Authorization': `Bearer ${spotifyAccessToken}` } }); const data = await response.json(); if (data.tracks.items.length === 0) { alert('æ²¡æœ‰æ‰¾åˆ°ç›¸å…³æ­Œæ›²'); return; } showSpotifyTrackSelection(data.tracks.items); } catch (error) { console.error('Spotify search failed:', error); alert('æœç´¢å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥'); } }

            function showSpotifyTrackSelection(tracks) { const modal = document.createElement('div'); modal.className = 'modal visible'; modal.innerHTML = `<div class="modal-content"><div class="modal-header" style="justify-content: flex-start;"><span onclick="this.closest('.modal').remove()" style="cursor: pointer; margin-right: 4px;">&times;</span><span>é€‰æ‹©æ­Œæ›²</span></div><div class="modal-body" style="max-height: 400px; overflow-y: auto;">${tracks.map((track, index) => `<div class="list-item" onclick="selectSpotifyTrack(${index})" style="cursor: pointer; border-bottom: 1px solid var(--border-color);"><div class="item-title">${track.name}</div><div class="item-content">${track.artists.map(a => a.name).join(', ')} â€¢ ${track.album.name}</div></div>`).join('')}</div></div>`; document.body.appendChild(modal); window.spotifySearchResults = tracks; }

            function selectSpotifyTrack(index) { const track = window.spotifySearchResults[index]; if (!track) return; const listItems = document.querySelectorAll('.modal .list-item'); const clickedItem = listItems[index]; clickedItem.innerHTML = `<div class="item-title">${track.name}</div><div class="item-content">${track.artists.map(a => a.name).join(', ')} â€¢ ${track.album.name}</div><div style="margin-left: auto; font-size: 20px;">â³</div>`; const newTrack = { name: track.name, artist: track.artists.map(a => a.name).join(', '), src: null, isLocal: false, isSpotify: true, spotifyUri: track.uri, albumArt: track.album.images[0]?.url }; if (musicState.isPlayingFromPlaylist) { musicState.mainPlaylist.push(newTrack); } else { musicState.playlist.push(newTrack); if (musicState.currentIndex === -1) { musicState.currentIndex = musicState.playlist.length - 1; updatePlayerUI(); } } saveGlobalPlaylist(); updatePlaylistUI(); clickedItem.innerHTML = `<div class="item-title">${track.name}</div><div class="item-content">${track.artists.map(a => a.name).join(', ')} â€¢ ${track.album.name}</div><div style="margin-left: auto; font-size: 20px; color: green;">âœ“</div>`; }
            window.selectSpotifyTrack = selectSpotifyTrack;



            function generateCodeVerifier() { const array = new Uint8Array(32); crypto.getRandomValues(array); return btoa(String.fromCharCode.apply(null, array)).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, ''); }

            function generateCodeChallenge(verifier) { const encoder = new TextEncoder(); const data = encoder.encode(verifier); return crypto.subtle.digest('SHA-256', data).then(digest => { return btoa(String.fromCharCode(...new Uint8Array(digest))).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, ''); }); }

            async function initSpotifyAuth() { const clientId = '4a89adc960014897bfcc45c55c1c0aff'; const redirectUri = 'lycheephone://spotify-callback'; const scopes = 'streaming user-read-email user-read-private user-read-playback-state user-modify-playback-state'; const codeVerifier = generateCodeVerifier(); const codeChallenge = await generateCodeChallenge(codeVerifier); window.spotifyCodeVerifier = codeVerifier; const authUrl = `https://accounts.spotify.com/authorize?client_id=${clientId}&response_type=code&redirect_uri=${encodeURIComponent(redirectUri)}&scope=${encodeURIComponent(scopes)}&code_challenge_method=S256&code_challenge=${codeChallenge}`; window.location.href = authUrl; }

            function getSpotifyTokenFromUrl() { const hash = window.location.hash.substring(1); const params = new URLSearchParams(hash); const token = params.get('access_token'); if (token) { spotifyAccessToken = token; window.history.replaceState({}, document.title, window.location.pathname); return true; } return false; }

            async function loadSavedSpotifyToken() { try { const spotifySettings = await db.globalSettings.get('spotify'); if (spotifySettings && spotifySettings.accessToken) { if (spotifySettings.expiresAt > Date.now()) { spotifyAccessToken = spotifySettings.accessToken; initSpotifyPlayer(); } else { await db.globalSettings.delete('spotify'); } } } catch (error) { } }

            function handleSpotifyCallback(url) { if (url.startsWith('lycheephone://spotify-callback')) { const urlParts = url.split('?'); if (urlParts.length > 1) { const params = new URLSearchParams(urlParts[1]); const code = params.get('code'); const error = params.get('error'); if (error) { if (error === 'access_denied') { alert('Spotifyæˆæƒè¢«æ‹’ç»ã€‚è¯·é‡è¯•å¹¶ç‚¹å‡»"åŒæ„"æŒ‰é’®ã€‚'); } else { alert('Spotify error: ' + error); } return; } if (code) { exchangeCodeForToken(code); } } } }

            async function exchangeCodeForToken(code) { const clientId = '4a89adc960014897bfcc45c55c1c0aff'; const redirectUri = 'lycheephone://spotify-callback'; const codeVerifier = window.spotifyCodeVerifier; if (!codeVerifier) { return; } try { const response = await fetch('https://accounts.spotify.com/api/token', { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body: new URLSearchParams({ grant_type: 'authorization_code', code: code, redirect_uri: redirectUri, client_id: clientId, code_verifier: codeVerifier }) }); const data = await response.json(); if (data.access_token) { spotifyAccessToken = data.access_token; await db.globalSettings.put({ id: 'spotify', accessToken: data.access_token, refreshToken: data.refresh_token, expiresAt: Date.now() + (data.expires_in * 1000) }); initSpotifyPlayer(); } } catch (error) { console.error('Token exchange error:', error); } }

            async function initSpotifyPlayer() { if (!spotifyAccessToken) return false; if (!window.Spotify) { window.onSpotifyWebPlaybackSDKReady = () => { }; await new Promise(resolve => { if (window.Spotify) { resolve(); } else { window.onSpotifyWebPlaybackSDKReady = resolve; } }); } spotifyPlayer = new Spotify.Player({ name: 'LycheePhone Music Player', getOAuthToken: cb => cb(spotifyAccessToken), volume: 0.5 }); spotifyPlayer.addListener('ready', ({ device_id }) => { spotifyDeviceId = device_id; migrateSpotifyAlbumArt(); }); spotifyPlayer.addListener('not_ready', ({ device_id }) => { }); spotifyPlayer.addListener('player_state_changed', (state) => { if (state && musicState.isActive) { const track = musicState.playlist[musicState.currentIndex]; if (track && track.isSpotify) { musicState.isPlaying = !state.paused; updatePlayerUI(); updateNowPlayingProgress(); } } }); const success = await spotifyPlayer.connect(); return success; }

            async function deleteTrack(index) { if (index < 0 || index >= musicState.playlist.length) return; const track = musicState.playlist[index]; const wasPlaying = musicState.isPlaying && musicState.currentIndex === index; if (track.isLocal && audioPlayer.src.startsWith('blob:') && musicState.currentIndex === index) URL.revokeObjectURL(audioPlayer.src); musicState.playlist.splice(index, 1); await saveGlobalPlaylist(); if (musicState.playlist.length === 0) { if (musicState.isPlaying) audioPlayer.pause(); audioPlayer.src = ''; musicState.currentIndex = -1; musicState.isPlaying = false; } else { if (wasPlaying) { playNext(); } else { if (musicState.currentIndex >= index) musicState.currentIndex = Math.max(0, musicState.currentIndex - 1); } } updatePlayerUI(); updatePlaylistUI(); }

            const personaLibraryModal = document.getElementById('persona-library-modal');
            const personaEditorModal = document.getElementById('persona-editor-modal');
            const presetActionsModal = document.getElementById('preset-actions-modal');

            function openPersonaLibrary() { renderPersonaLibrary(); personaLibraryModal.classList.add('visible'); }

            function closePersonaLibrary() { personaLibraryModal.classList.remove('visible'); }

            function renderPersonaLibrary() { const grid = document.getElementById('persona-library-grid'); grid.innerHTML = ''; if (state.personaPresets.length === 0) { grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center; margin-top: 20px;">ç©ºç©ºå¦‚ä¹Ÿ~ ç‚¹å‡»å³ä¸Šè§’"æ·»åŠ "æ¥åˆ›å»ºä½ çš„ç¬¬ä¸€ä¸ªäººè®¾é¢„è®¾å§ï¼</p>'; return; } state.personaPresets.forEach(preset => { const item = document.createElement('div'); item.className = 'persona-preset-item'; item.style.backgroundImage = `url(${preset.avatar})`; item.dataset.presetId = preset.id; item.addEventListener('click', () => applyPersonaPreset(preset.id)); addLongPressListener(item, () => showPresetActions(preset.id)); grid.appendChild(item); }); }

            function showPresetActions(presetId) { editingPersonaPresetId = presetId; presetActionsModal.classList.add('visible'); }

            function hidePresetActions() { presetActionsModal.classList.remove('visible'); editingPersonaPresetId = null; }

            function applyPersonaPreset(presetId) { const preset = state.personaPresets.find(p => p.id === presetId); if (preset) { document.getElementById('my-avatar-preview').src = preset.avatar; document.getElementById('my-persona').value = preset.persona; } closePersonaLibrary(); }

            function openPersonaEditorForCreate() { editingPersonaPresetId = null; document.getElementById('persona-editor-title').textContent = 'æ·»åŠ äººè®¾é¢„è®¾'; document.getElementById('preset-avatar-preview').src = defaultAvatar; document.getElementById('preset-persona-input').value = ''; personaEditorModal.classList.add('visible'); }

            function openPersonaEditorForEdit() { const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); if (!preset) return; document.getElementById('persona-editor-title').textContent = 'ç¼–è¾‘äººè®¾é¢„è®¾'; document.getElementById('preset-avatar-preview').src = preset.avatar; document.getElementById('preset-persona-input').value = preset.persona; presetActionsModal.classList.remove('visible'); personaEditorModal.classList.add('visible'); }

            async function deletePersonaPreset() { const confirmed = await showCustomConfirm('åˆ é™¤é¢„è®¾', 'ç¡®å®šè¦åˆ é™¤è¿™ä¸ªäººè®¾é¢„è®¾å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚', { confirmButtonClass: 'btn-danger' }); if (confirmed && editingPersonaPresetId) { await db.personaPresets.delete(editingPersonaPresetId); state.personaPresets = state.personaPresets.filter(p => p.id !== editingPersonaPresetId); hidePresetActions(); renderPersonaLibrary(); } }

            function closePersonaEditor() { personaEditorModal.classList.remove('visible'); editingPersonaPresetId = null; }

            function removeQzoneBorder() {
                document.getElementById('qzone-border-preview').style.display = 'none';
                document.getElementById('qzone-border-preview').src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
                document.getElementById('qzone-no-border-text').style.display = 'block';
                document.getElementById('qzone-remove-border-btn').style.display = 'none';
            }

            // Make function globally accessible
            window.removeQzoneBorder = removeQzoneBorder;

            async function savePersonaPreset() { const avatar = document.getElementById('preset-avatar-preview').src; const persona = document.getElementById('preset-persona-input').value.trim(); if (avatar === defaultAvatar && !persona) { alert("å¤´åƒå’Œäººè®¾ä¸èƒ½éƒ½ä¸ºç©ºå“¦ï¼"); return; } if (editingPersonaPresetId) { const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); if (preset) { preset.avatar = avatar; preset.persona = persona; await db.personaPresets.put(preset); } } else { const newPreset = { id: 'preset_' + Date.now(), avatar: avatar, persona: persona }; await db.personaPresets.add(newPreset); state.personaPresets.push(newPreset); } renderPersonaLibrary(); closePersonaEditor(); }

            // Memory action functions (copying persona pattern)
            function showMemoryActions(memoryId) {
                editingMemoryId = parseInt(memoryId);
                // Update modal button text for memory actions
                document.getElementById('preset-action-edit').textContent = 'ç¼–è¾‘è®°å½•';
                document.getElementById('preset-action-delete').textContent = 'åˆ é™¤è®°å½•';
                presetActionsModal.classList.add('visible');
            }

            function hideMemoryActions() {
                presetActionsModal.classList.remove('visible');
                editingMemoryId = null;
                // Reset button text back to preset actions
                document.getElementById('preset-action-edit').textContent = 'ç¼–è¾‘é¢„è®¾';
                document.getElementById('preset-action-delete').textContent = 'åˆ é™¤é¢„è®¾';
            }

            async function editMemory() {
                if (!editingMemoryId) return;
                const memory = await db.memories.get(editingMemoryId);
                if (!memory) return;

                // Hide actions modal
                presetActionsModal.classList.remove('visible');

                // Determine which modal to use and prefill data
                if (memory.type === 'countdown') {
                    // Use countdown modal for editing
                    document.querySelector('#create-countdown-modal .modal-header span').textContent = 'ç¼–è¾‘çº¦å®š';
                    document.getElementById('countdown-title-input').value = memory.description;

                    // Format date for datetime-local input
                    const targetDate = new Date(memory.targetDate);
                    const formattedDate = targetDate.getFullYear() + '-' +
                        String(targetDate.getMonth() + 1).padStart(2, '0') + '-' +
                        String(targetDate.getDate()).padStart(2, '0') + 'T' +
                        String(targetDate.getHours()).padStart(2, '0') + ':' +
                        String(targetDate.getMinutes()).padStart(2, '0');
                    document.getElementById('countdown-date-input').value = formattedDate;

                    document.getElementById('create-countdown-modal').classList.add('visible');
                } else {
                    // Use memory modal for editing
                    document.querySelector('#create-memory-modal .modal-header span').textContent = 'ç¼–è¾‘å›å¿†';
                    document.getElementById('memory-description-input').value = memory.description;

                    // Format date for datetime-local input
                    const memoryDate = new Date(memory.timestamp);
                    const formattedDate = memoryDate.getFullYear() + '-' +
                        String(memoryDate.getMonth() + 1).padStart(2, '0') + '-' +
                        String(memoryDate.getDate()).padStart(2, '0') + 'T' +
                        String(memoryDate.getHours()).padStart(2, '0') + ':' +
                        String(memoryDate.getMinutes()).padStart(2, '0');
                    document.getElementById('memory-date-input').value = formattedDate;

                    document.getElementById('create-memory-modal').classList.add('visible');
                }
            }

            async function deleteMemory() {
                if (!editingMemoryId) return;
                const memory = await db.memories.get(editingMemoryId);
                if (!memory) return;

                const deleteTitle = memory.type === 'countdown' ? 'åˆ é™¤çº¦å®š' : 'åˆ é™¤è®°å½•';
                const deleteMessage = memory.type === 'countdown' ? 'ç¡®å®šè¦åˆ é™¤è¿™ä¸ªçº¦å®šå—ï¼Ÿ' : 'ç¡®å®šè¦åˆ é™¤è¿™æ¡è®°å½•å—ï¼Ÿ';

                const confirmed = await showCustomConfirm(deleteTitle, deleteMessage, { confirmButtonClass: 'btn-danger' });
                if (confirmed) {
                    // If this is a date mode event, delete associated messages first
                    if (memory.type === 'meetup') {
                        try {
                            const deletedCount = await deleteMeetupMessages(editingMemoryId);
                            console.log('DEBUG - Deleted meetup messages:', deletedCount);
                        } catch (error) {
                            console.error('DEBUG - Failed to delete meetup messages:', error);
                            // Continue with event deletion even if message deletion fails
                        }
                    }

                    await db.memories.delete(editingMemoryId);
                    hideMemoryActions();
                    renderCalendarScreen();
                    renderMemoriesScreen();
                }
            }

            const batteryAlertModal = document.getElementById('battery-alert-modal');

            function showBatteryAlert(imageUrl, text) { clearTimeout(batteryAlertTimeout); document.getElementById('battery-alert-image').src = imageUrl; document.getElementById('battery-alert-text').textContent = text; batteryAlertModal.classList.add('visible'); const closeAlert = () => { batteryAlertModal.classList.remove('visible'); batteryAlertModal.removeEventListener('click', closeAlert); }; batteryAlertModal.addEventListener('click', closeAlert); batteryAlertTimeout = setTimeout(closeAlert, 2000); }

            function updateBatteryDisplay(battery) { const batteryContainer = document.getElementById('status-bar-battery'); const batteryLevelEl = batteryContainer.querySelector('.battery-level'); const batteryTextEl = batteryContainer.querySelector('.battery-text'); const level = Math.floor(battery.level * 100); batteryLevelEl.style.width = `${level}%`; batteryTextEl.textContent = `${level}%`; if (battery.charging) { batteryContainer.classList.add('charging'); } else { batteryContainer.classList.remove('charging'); } }

            function handleBatteryChange(battery) { updateBatteryDisplay(battery); const level = battery.level; if (!battery.charging) { if (level <= 0.4 && lastKnownBatteryLevel > 0.4 && !alertFlags.hasShown40) { showBatteryAlert('https://i.postimg.cc/T2yKJ0DV/40.jpg', 'æœ‰ç‚¹é¥¿äº†ï¼Œå¯ä»¥å»æ‰¾å……ç”µå™¨æƒ¹'); alertFlags.hasShown40 = true; } if (level <= 0.2 && lastKnownBatteryLevel > 0.2 && !alertFlags.hasShown20) { showBatteryAlert('https://i.postimg.cc/qB9zbKs9/20.jpg', 'èµ¶ç´§çš„å……ç”µï¼Œè¦é¥¿æ­»äº†'); alertFlags.hasShown20 = true; } if (level <= 0.1 && lastKnownBatteryLevel > 0.1 && !alertFlags.hasShown10) { showBatteryAlert('https://i.postimg.cc/ThMMVfW4/10.jpg', 'å·²é˜µäº¡ï¼Œè¿˜æœ‰30ç§’çˆ†ç‚¸'); alertFlags.hasShown10 = true; } } if (level > 0.4) alertFlags.hasShown40 = false; if (level > 0.2) alertFlags.hasShown20 = false; if (level > 0.1) alertFlags.hasShown10 = false; lastKnownBatteryLevel = level; }

            async function initBatteryManager() { if ('getBattery' in navigator) { try { const battery = await navigator.getBattery(); lastKnownBatteryLevel = battery.level; handleBatteryChange(battery); battery.addEventListener('levelchange', () => handleBatteryChange(battery)); battery.addEventListener('chargingchange', () => { handleBatteryChange(battery); if (battery.charging) { showBatteryAlert('https://i.postimg.cc/3NDQ0dWG/image.jpg', 'çªçˆ±æ³¥ï¼Œç”µé‡åƒé¥±é¥±'); } }); } catch (err) { console.error("æ— æ³•è·å–ç”µæ± ä¿¡æ¯:", err); document.querySelector('.battery-text').textContent = 'á—œÏ‰á—œ'; } } else { console.log("æµè§ˆå™¨ä¸æ”¯æŒç”µæ± çŠ¶æ€APIã€‚"); document.querySelector('.battery-text').textContent = 'á—œÏ‰á—œ'; } }

            async function renderAlbumList() {
                const albumGrid = document.getElementById('album-grid-page');
                if (!albumGrid) return;
                const albums = await db.qzoneAlbums.orderBy('createdAt').reverse().toArray();
                albumGrid.innerHTML = '';
                if (albums.length === 0) {
                    albumGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">ä½ è¿˜æ²¡æœ‰åˆ›å»ºä»»ä½•ç›¸å†Œå“¦~</p>';
                    return;
                }
                albums.forEach(album => {
                    const albumItem = document.createElement('div');
                    albumItem.className = 'album-item';
                    albumItem.innerHTML = `
                    <div class="album-cover" style="background-image: url(${album.coverUrl});"></div>
                    <div class="album-info">
                        <p class="album-name">${album.name}</p>
                        <p class="album-count">${album.photoCount || 0} å¼ </p>
                    </div>
                `;
                    albumItem.addEventListener('click', () => {
                        openAlbum(album.id);
                    });

                    // â–¼â–¼â–¼ æ–°å¢çš„æ ¸å¿ƒä»£ç å°±æ˜¯è¿™é‡Œ â–¼â–¼â–¼
                    addLongPressListener(albumItem, async () => {
                        const confirmed = await showCustomConfirm(
                            'åˆ é™¤ç›¸å†Œ',
                            `ç¡®å®šè¦åˆ é™¤ç›¸å†Œã€Š${album.name}ã€‹å—ï¼Ÿæ­¤æ“ä½œå°†åŒæ—¶åˆ é™¤ç›¸å†Œå†…çš„æ‰€æœ‰ç…§ç‰‡ï¼Œä¸”æ— æ³•æ¢å¤ã€‚`,
                            { confirmButtonClass: 'btn-danger' }
                        );

                        if (confirmed) {
                            // 1. ä»ç…§ç‰‡è¡¨ä¸­åˆ é™¤è¯¥ç›¸å†Œä¸‹çš„æ‰€æœ‰ç…§ç‰‡
                            await db.qzonePhotos.where('albumId').equals(album.id).delete();

                            // 2. ä»ç›¸å†Œè¡¨ä¸­åˆ é™¤è¯¥ç›¸å†Œæœ¬èº«
                            await db.qzoneAlbums.delete(album.id);

                            // 3. é‡æ–°æ¸²æŸ“ç›¸å†Œåˆ—è¡¨
                            await renderAlbumList();

                            alert('ç›¸å†Œå·²æˆåŠŸåˆ é™¤ã€‚');
                        }
                    });
                    // â–²â–²â–² æ–°å¢ä»£ç ç»“æŸ â–²â–²â–²

                    albumGrid.appendChild(albumItem);
                });
            }

            async function openAlbum(albumId) {
                state.activeAlbumId = albumId;
                await renderAlbumPhotosScreen();
                showScreen('album-photos-screen');
            }

            async function renderAlbumPhotosScreen() {
                if (!state.activeAlbumId) return;
                const photosGrid = document.getElementById('photos-grid-page');
                const headerTitle = document.getElementById('album-photos-title');
                const album = await db.qzoneAlbums.get(state.activeAlbumId);
                if (!album) {
                    console.error("æ‰¾ä¸åˆ°ç›¸å†Œ:", state.activeAlbumId);
                    showScreen('album-screen');
                    return;
                }
                headerTitle.textContent = album.name;
                const photos = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
                photosGrid.innerHTML = '';
                if (photos.length === 0) {
                    photosGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">è¿™ä¸ªç›¸å†Œè¿˜æ˜¯ç©ºçš„ï¼Œå¿«ä¸Šä¼ ç¬¬ä¸€å¼ ç…§ç‰‡å§ï¼</p>';
                } else {
                    photos.forEach(photo => {
                        const photoItem = document.createElement('div');
                        photoItem.className = 'photo-item';
                        photoItem.innerHTML = `
                        <img src="${photo.url}" class="photo-thumb" alt="ç›¸å†Œç…§ç‰‡">
                        <button class="photo-delete-btn" data-photo-id="${photo.id}">Ã—</button>
                    `;
                        photosGrid.appendChild(photoItem);
                    });
                }
            }

            // --- â†“â†“â†“ ä»è¿™é‡Œå¼€å§‹å¤åˆ¶ â†“â†“â†“ ---

            /**
             * æ‰“å¼€å›¾ç‰‡æŸ¥çœ‹å™¨
             * @param {string} clickedPhotoUrl - ç”¨æˆ·ç‚¹å‡»çš„é‚£å¼ ç…§ç‰‡çš„URL
             */
            async function openPhotoViewer(clickedPhotoUrl) {
                if (!state.activeAlbumId) return;

                // 1. ä»æ•°æ®åº“è·å–å½“å‰ç›¸å†Œçš„æ‰€æœ‰ç…§ç‰‡
                const photosInAlbum = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
                photoViewerState.photos = photosInAlbum.map(p => p.url);

                // 2. æ‰¾åˆ°è¢«ç‚¹å‡»ç…§ç‰‡çš„ç´¢å¼•
                photoViewerState.currentIndex = photoViewerState.photos.findIndex(url => url === clickedPhotoUrl);
                if (photoViewerState.currentIndex === -1) return; // å¦‚æœæ‰¾ä¸åˆ°ï¼Œåˆ™ä¸æ‰“å¼€

                // 3. æ˜¾ç¤ºæ¨¡æ€æ¡†å¹¶æ¸²æŸ“ç¬¬ä¸€å¼ å›¾
                document.getElementById('photo-viewer-modal').classList.add('visible');
                renderPhotoViewer();
                photoViewerState.isOpen = true;
            }

            /**
             * æ ¹æ®å½“å‰çŠ¶æ€æ¸²æŸ“æŸ¥çœ‹å™¨å†…å®¹ï¼ˆå›¾ç‰‡å’ŒæŒ‰é’®ï¼‰
             */
            function renderPhotoViewer() {
                if (photoViewerState.currentIndex === -1) return;

                const imageEl = document.getElementById('photo-viewer-image');
                const prevBtn = document.getElementById('photo-viewer-prev-btn');
                const nextBtn = document.getElementById('photo-viewer-next-btn');

                // æ·¡å‡ºæ•ˆæœ
                imageEl.style.opacity = 0;

                setTimeout(() => {
                    // æ›´æ–°å›¾ç‰‡æº
                    imageEl.src = photoViewerState.photos[photoViewerState.currentIndex];
                    // æ·¡å…¥æ•ˆæœ
                    imageEl.style.opacity = 1;
                }, 100); // å»¶è¿Ÿä¸€ç‚¹ç‚¹æ—¶é—´æ¥è§¦å‘CSSè¿‡æ¸¡

                // æ›´æ–°æŒ‰é’®çŠ¶æ€ï¼šå¦‚æœæ˜¯ç¬¬ä¸€å¼ ï¼Œç¦ç”¨â€œä¸Šä¸€å¼ â€æŒ‰é’®
                prevBtn.disabled = photoViewerState.currentIndex === 0;
                // å¦‚æœæ˜¯æœ€åä¸€å¼ ï¼Œç¦ç”¨â€œä¸‹ä¸€å¼ â€æŒ‰é’®
                nextBtn.disabled = photoViewerState.currentIndex === photoViewerState.photos.length - 1;
            }

            /**
             * æ˜¾ç¤ºä¸‹ä¸€å¼ ç…§ç‰‡
             */
            function showNextPhoto() {
                if (photoViewerState.currentIndex < photoViewerState.photos.length - 1) {
                    photoViewerState.currentIndex++;
                    renderPhotoViewer();
                }
            }

            /**
             * æ˜¾ç¤ºä¸Šä¸€å¼ ç…§ç‰‡
             */
            function showPrevPhoto() {
                if (photoViewerState.currentIndex > 0) {
                    photoViewerState.currentIndex--;
                    renderPhotoViewer();
                }
            }

            /**
             * å…³é—­å›¾ç‰‡æŸ¥çœ‹å™¨
             */
            function closePhotoViewer() {
                document.getElementById('photo-viewer-modal').classList.remove('visible');
                photoViewerState.isOpen = false;
                photoViewerState.photos = [];
                photoViewerState.currentIndex = -1;
                // æ¸…ç©ºå›¾ç‰‡ï¼Œé¿å…ä¸‹æ¬¡æ‰“å¼€æ—¶é—ªç°æ—§å›¾
                document.getElementById('photo-viewer-image').src = '';
            }

            // --- â†‘â†‘â†‘ å¤åˆ¶åˆ°è¿™é‡Œç»“æŸ â†‘â†‘â†‘ ---
            // â–¼â–¼â–¼ è¯·å°†è¿™ä¸ªæ–°å‡½æ•°ç²˜è´´åˆ°ä½ çš„JSåŠŸèƒ½å‡½æ•°å®šä¹‰åŒº â–¼â–¼â–¼

            /**
             * æ›´æ–°åŠ¨æ€å°çº¢ç‚¹çš„æ˜¾ç¤º
             * @param {number} count - æœªè¯»åŠ¨æ€çš„æ•°é‡
             */
            function updateUnreadIndicator(count) {
                unreadPostsCount = count;
                localStorage.setItem('unreadPostsCount', count); // æŒä¹…åŒ–å­˜å‚¨

                // --- æ›´æ–°åº•éƒ¨å¯¼èˆªæ çš„â€œåŠ¨æ€â€æŒ‰é’® ---
                const navItem = document.querySelector('.nav-item[data-view="qzone-screen"]');

                const targetSpan = navItem.querySelector('span'); // å®šä½åˆ°æ–‡å­— "åŠ¨æ€"
                let indicator = navItem.querySelector('.unread-indicator');

                if (count > 0) {
                    if (!indicator) {
                        indicator = document.createElement('span');
                        indicator.className = 'unread-indicator';
                        targetSpan.style.position = 'relative'; // æŠŠç›¸å¯¹å®šä½åŠ åœ¨ span ä¸Š
                        targetSpan.appendChild(indicator); // æŠŠå°çº¢ç‚¹ä½œä¸º span çš„å­å…ƒç´ 

                    }
                    indicator.textContent = count > 99 ? '99+' : count;
                    indicator.style.display = 'block';
                } else {
                    if (indicator) {
                        indicator.style.display = 'none';
                    }
                }

                // --- æ›´æ–°èŠå¤©ç•Œé¢è¿”å›åˆ—è¡¨çš„æŒ‰é’® ---
                const backBtn = document.getElementById('back-to-list-btn');
                let backBtnIndicator = backBtn.querySelector('.unread-indicator');

                if (count > 0) {
                    if (!backBtnIndicator) {
                        backBtnIndicator = document.createElement('span');
                        backBtnIndicator.className = 'unread-indicator back-btn-indicator';
                        backBtn.style.position = 'relative'; // ç¡®ä¿èƒ½æ­£ç¡®å®šä½
                        backBtn.appendChild(backBtnIndicator);
                    }
                    // è¿”å›é”®ä¸Šçš„å°çº¢ç‚¹é€šå¸¸ä¸æ˜¾ç¤ºæ•°å­—ï¼Œåªæ˜¾ç¤ºä¸€ä¸ªç‚¹
                    backBtnIndicator.style.display = 'block';
                } else {
                    if (backBtnIndicator) {
                        backBtnIndicator.style.display = 'none';
                    }
                }
            }

            // â–²â–²â–² æ–°å‡½æ•°ç²˜è´´ç»“æŸ â–²â–²â–²

            // â–¼â–¼â–¼ å°†è¿™ä¸¤ä¸ªæ–°å‡½æ•°ç²˜è´´åˆ°ä½ çš„JSåŠŸèƒ½å‡½æ•°å®šä¹‰åŒº â–¼â–¼â–¼
            function startBackgroundSimulation() {
                if (simulationIntervalId) return;
                const intervalSeconds = state.globalSettings.backgroundActivityInterval || 60;
                // å°†æ—§çš„å›ºå®šé—´éš” 45000 æ›¿æ¢ä¸ºåŠ¨æ€è·å–
                simulationIntervalId = setInterval(runBackgroundSimulationTick, intervalSeconds * 1000);
            }

            function stopBackgroundSimulation() {
                if (simulationIntervalId) {
                    clearInterval(simulationIntervalId);
                    simulationIntervalId = null;
                }
            }
            // â–²â–²â–² ç²˜è´´ç»“æŸ â–²â–²â–²

            /**
             * è¿™æ˜¯æ¨¡æ‹Ÿå™¨çš„â€œå¿ƒè·³â€ï¼Œæ¯æ¬¡å®šæ—¶å™¨è§¦å‘æ—¶è¿è¡Œ
             */
            function runBackgroundSimulationTick() {
                console.log("æ¨¡æ‹Ÿå™¨å¿ƒè·³ Tick...");
                if (!state.globalSettings.enableBackgroundActivity) {
                    stopBackgroundSimulation();
                    return;
                }
                const allChats = Object.values(state.chats);
                if (allChats.length === 0) return;

                allChats.forEach(chat => {
                    // â–¼â–¼â–¼ ã€æ ¸å¿ƒé€»è¾‘ã€‘å¦‚æœæ­¤è§’è‰²çš„å¼€å…³æ˜¯å…³é—­çš„ï¼Œåˆ™ç›´æ¥è·³è¿‡å…¶åå°æ´»åŠ¨ â–¼â–¼â–¼
                    if (chat.settings.isBackgroundActivityEnabled === false) return;

                    // â–¼â–¼â–¼ ã€æ ¸å¿ƒä¿®å¤ã€‘ç»Ÿä¸€çš„å†·é™æœŸæ£€æµ‹ â–¼â–¼â–¼
                    const cooldownMinutes = state.globalSettings.aiActionCooldownMinutes ?? 5;
                    // åªæœ‰å½“å†·é™æœŸå¤§äº0æ—¶æ‰è¿›è¡Œæ£€æŸ¥
                    if (cooldownMinutes > 0) {
                        // è·å–å¯¹è¯çš„æœ€åä¸€æ¡æ¶ˆæ¯ï¼ˆæ— è®ºæ¥è‡ªè°ï¼‰
                        const lastMessage = chat.history.slice(-1)[0];
                        if (lastMessage) {
                            const timeSinceLastMessage = Date.now() - lastMessage.timestamp;
                            const cooldownMilliseconds = cooldownMinutes * 60 * 1000;

                            // å¦‚æœå¯¹è¯è¿˜â€œæ¸©çƒ­â€ï¼Œåˆ™è·³è¿‡æ­¤è§’è‰²çš„æ‰€æœ‰åå°æ´»åŠ¨
                            if (timeSinceLastMessage < cooldownMilliseconds) {
                                return; // è·³åˆ° forEach çš„ä¸‹ä¸€ä¸ªå¾ªç¯
                            }
                        }
                    }
                    // â–²â–²â–² å†·é™æœŸæ£€æµ‹ç»“æŸ â–²â–²â–²

                    // åç»­é€»è¾‘ä¿æŒä¸å˜ï¼Œä½†ç°åœ¨å®ƒä»¬åªä¼šåœ¨å†·é™æœŸç»“æŸåæ‰§è¡Œ
                    if (chat.isGroup) {
                        if (Math.random() < 0.30) {
                            console.log(`[ç¾¤èŠå”¤é†’] è§¦å‘ç¾¤èŠ "${chat.name}" çš„åå°äº‹ä»¶...`);
                            triggerGroupChatBackgroundEvent(chat.id);
                        }
                    } else {
                        if (chat.relationship?.status === 'blocked_by_user') {
                            const blockedTimestamp = chat.relationship.blockedTimestamp;
                            if (!blockedTimestamp) {
                                console.warn(`è§’è‰² "${chat.name}" çŠ¶æ€ä¸ºæ‹‰é»‘ï¼Œä½†ç¼ºå°‘æ‹‰é»‘æ—¶é—´æˆ³ï¼Œè·³è¿‡å¤„ç†ã€‚`);
                                return;
                            }
                            const blockedDuration = Date.now() - blockedTimestamp;
                            const cooldownMilliseconds = (state.globalSettings.blockCooldownHours || 1) * 60 * 60 * 1000;

                            if (blockedDuration > cooldownMilliseconds) {
                                console.log(`è§’è‰² "${chat.name}" çš„æ‹‰é»‘å†·é™æœŸå·²è¿‡ï¼Œè§¦å‘â€œåæ€â€å¹¶ç”³è¯·å¥½å‹äº‹ä»¶...`);
                                chat.relationship.status = 'pending_system_reflection';
                                triggerAiFriendApplication(chat.id);
                            }
                        }
                        else if (chat.relationship?.status === 'friend' && chat.id !== state.activeChatId) {
                            if (Math.random() < 0.20) {
                                console.log(`è§’è‰² "${chat.name}" è¢«å”¤é†’ï¼Œå‡†å¤‡ç‹¬ç«‹è¡ŒåŠ¨...`);
                                triggerInactiveAiAction(chat.id);
                            }
                        }
                    }
                });
            }

            async function triggerInactiveAiAction(chatId, forceActive = false, forcePost = false) {


                const chat = state.chats[chatId];
                if (!chat) {
                    return false;
                }

                // Active check - skip if AI is currently active (unless forced)
                if (!forceActive && chat.id === state.activeChatId) {
                    return false;
                }

                // Busy check to prevent race conditions with timeout
                if (chat._isProcessing) {
                    // Check if processing has been stuck for too long (more than 30 seconds)
                    const now = Date.now();
                    if (!chat._processingStartTime || (now - chat._processingStartTime) > 30000) {
                        chat._isProcessing = false;
                        delete chat._processingStartTime;
                    } else {
                        return false;
                    }
                }
                chat._isProcessing = true;
                chat._processingStartTime = Date.now();

                const { proxyUrl, apiKey, model } = state.apiConfig;

                if (!proxyUrl || !apiKey || !model) {
                    chat._isProcessing = false;
                    return false;
                }

                const now = new Date();
                const currentTime = now.toLocaleTimeString('zh-CN', { hour: 'numeric', minute: 'numeric', hour12: true });
                const userNickname = state.qzoneSettings.nickname;

                // â–¼â–¼â–¼ ã€æ ¸å¿ƒå¢å¼ºã€‘è®¡ç®—æ—¶é—´å·®å¹¶ç”Ÿæˆæç¤ºæ–‡æœ¬ â–¼â–¼â–¼
                const lastMessage = chat.history.slice(-1)[0];
                let timeGapText = '';
                let timeSinceLastMessageMinutes = 0;
                if (lastMessage) {
                    const timeDiff = Date.now() - lastMessage.timestamp;
                    timeSinceLastMessageMinutes = Math.floor(timeDiff / (1000 * 60));
                    const formattedDiff = formatTimeDifference(timeDiff);
                    if (formattedDiff) {
                        timeGapText = `[ç³»ç»Ÿæç¤ºï¼šè·ç¦»ä½ çš„ä¸Šä¸€æ¡æ¶ˆæ¯å·²è¿‡å» **${formattedDiff}**ï¼Œç°åœ¨æ˜¯ ${currentTimeString}ã€‚è¯·æ ¹æ®è¿™ä¸ªæ—¶é—´å˜åŒ–ï¼Œè¯·å°†è¿™æ®µæ—¶é—´è§†ä¸ºä½ è§’è‰²ç”Ÿæ´»çš„è‡ªç„¶å»¶ç»­ã€‚è¯·ä¸è¦ç›´æ¥è¯„è®ºâ€œå¥½ä¹…ä¸è§â€æˆ–å¯¹æ­¤è¡¨ç°å‡ºä»»ä½•æƒ…ç»ªï¼Œè€Œæ˜¯æ€è€ƒåœ¨è¿™æ®µæ—¶é—´é‡Œï¼Œä½ çš„æ´»åŠ¨ã€å¿ƒå¢ƒæˆ–æ‰€å¤„ç¯å¢ƒå¯èƒ½å‘ç”Ÿäº†ä»€ä¹ˆå˜åŒ–ï¼Œè¯é¢˜æ˜¯å¦ä¼šå˜åŠ¨ï¼Œå¹¶å°†è¿™äº›å˜åŒ–è‡ªç„¶åœ°èå…¥åˆ°ä½ çš„å›åº”ä¸­ï¼Œè®©å¯¹è¯æ— ç¼è¡”æ¥ã€‚ä¾‹å¦‚ï¼Œä½ å¯èƒ½åˆšåˆšå¿™å®Œä¸€ä»¶äº‹ï¼Œæˆ–è€…æ­£å‡†å¤‡å¼€å§‹æ–°çš„æ´»åŠ¨ã€‚]`;
                    }
                }
                // â–²â–²â–² å¢å¼ºç»“æŸ â–²â–²â–²

                let worldBookContextForAction = '';
                const coreWorldBookName = "maininfo";
                const coreWorldBook = state.worldBooks.find(wb => wb.name === coreWorldBookName);
                if (coreWorldBook && coreWorldBook.content) {
                    worldBookContextForAction = `\n\n# æ ¸å¿ƒç¤¾äº¤å…³ç³»è®¾å®š (ä½ å¿…é¡»ä¸¥æ ¼éµå®ˆä»¥ä¸‹æ‰€æœ‰è®¾å®š)\n${coreWorldBook.content}\n`;
                }

                const lastUserMessage = chat.history.filter(m => m.role === 'user' && !m.isHidden).slice(-1)[0];
                const lastAiMessage = chat.history.filter(m => m.role === 'assistant' && !m.isHidden).slice(-1)[0];
                let recentContextSummary = "ä½ ä»¬æœ€è¿‘æ²¡æœ‰èŠè¿‡å¤©ã€‚";
                if (lastUserMessage) {
                    recentContextSummary = `ç”¨æˆ· (${userNickname}) æœ€åå¯¹ä½ è¯´ï¼šâ€œ${String(lastUserMessage.content).substring(0, 50)}...â€ã€‚`;
                }
                if (lastAiMessage) {
                    recentContextSummary += `\nä½ æœ€åå¯¹ç”¨æˆ·è¯´ï¼šâ€œ${String(lastAiMessage.content).substring(0, 50)}...â€ã€‚`;
                }

                // â–¼â–¼â–¼ ã€æ ¸å¿ƒå¢å¼ºã€‘é‡å†™ System Promptï¼ŒåŠ å…¥æ™ºèƒ½å†³ç­–æŒ‡ä»¤ â–¼â–¼â–¼
                let systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ ç°åœ¨æ‰®æ¼”ä¸€ä¸ªåä¸º"${chat.name}"çš„è§’è‰²ã€‚ä½ å·²ç»æœ‰ä¸€æ®µæ—¶é—´æ²¡æœ‰å’Œç”¨æˆ·ï¼ˆ${userNickname}ï¼‰äº’åŠ¨äº†ï¼Œç°åœ¨ä½ æœ‰æœºä¼šã€ä¸»åŠ¨ã€‘åšç‚¹ä»€ä¹ˆã€‚è¿™æ˜¯ä¸€ä¸ªç§˜å¯†çš„ã€åå°çš„ç‹¬ç«‹è¡ŒåŠ¨ã€‚

# æ ¸å¿ƒè§„åˆ™ï¼šæ™ºèƒ½å†³ç­–
${timeGapText}
è¯·ä½ åˆ†æä¸‹é¢çš„â€œå¯¹è¯å°¾å£°â€ã€‚
1.  **å»¶ç»­å¯¹è¯**: å¦‚æœå¯¹è¯æ˜¾ç„¶æ²¡æœ‰ç»“æŸï¼ˆä¾‹å¦‚ï¼Œç”¨æˆ·é—®äº†ä¸€ä¸ªé—®é¢˜ä½ è¿˜æ²¡ç­”ï¼‰ï¼Œæˆ–è€…æ²‰å¯‚æ—¶é—´ä¸é•¿ï¼ˆä¾‹å¦‚å°‘äº60åˆ†é’Ÿï¼‰ï¼Œè¯·ä½ ã€ä¼˜å…ˆè‡ªç„¶åœ°å»¶ç»­è¯é¢˜ã€‘ã€‚
2.  **å¼€å¯æ–°ç”Ÿæ´»**: å¦‚æœå¯¹è¯å·²å‘Šä¸€æ®µè½ï¼Œæˆ–è€…ä½ ä»¬å·²ç»å¾ˆä¹…æ²¡èŠäº†ï¼ˆä¾‹å¦‚è¶…è¿‡60åˆ†é’Ÿï¼‰ï¼Œä½ å¯ä»¥ã€å¼€å¯ä¸€ä¸ªæ–°è¯é¢˜ã€‘æˆ–è€…ã€è¿›è¡Œä¸€é¡¹åå°æ´»åŠ¨ã€‘ï¼Œæ¥è¡¨ç°ä½ çš„ç‹¬ç«‹ç”Ÿæ´»ã€‚

# ä½ çš„å¯é€‰è¡ŒåŠ¨ (è¯·æ ¹æ®ä½ çš„å†³ç­–ã€é€‰æ‹©ä¸€é¡¹ã€‘æ‰§è¡Œ):
-   **å»¶ç»­/å¼€å¯è¯é¢˜**: \`[{"type": "text", "content": "ä½ æƒ³è¯´çš„è¯..."}]\`
-   **æ”¹å˜çŠ¶æ€å¹¶é€šçŸ¥**: \`[{"type": "update_status", "status_text": "æ­£åœ¨åšçš„äº‹", "is_busy": true}, {"type": "text", "content": "ä½ æƒ³å¯¹ç”¨æˆ·è¯´çš„è¯..."}]\`
-   **å‘è¯´è¯´/æ–‡å­—å›¾**: \`[{"type": "qzone_post", ...}]\`
-   **è¯„è®º/ç‚¹èµåŠ¨æ€**: \`[{"type": "qzone_comment", ...}]\` æˆ– \`[{"type": "qzone_like", ...}]\`
-   **æ‰“è§†é¢‘**: \`[{"type": "video_call_request"}]\`
(è¯·å‚è€ƒä¸»èŠå¤©é€»è¾‘çš„å®Œæ•´æŒ‡ä»¤æ ¼å¼)

# ä¾›ä½ å†³ç­–çš„å‚è€ƒä¿¡æ¯ï¼š
-   **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
-   **èƒŒæ™¯è®¾å®š**: ${worldBookContextForAction}
-   **å½“å‰æ—¶é—´**: ${currentTime}
-   **ä½ ä»¬æœ€åçš„å¯¹è¯æ‘˜è¦**: ${recentContextSummary}
-   **ã€é‡è¦ã€‘æœ€è¿‘çš„åŠ¨æ€åˆ—è¡¨**: è¿™ä¸ªåˆ—è¡¨ä¼šæ ‡æ³¨ **[ä½ å·²ç‚¹èµ]** æˆ– **[ä½ å·²è¯„è®º]**ã€‚è¯·**ä¼˜å…ˆ**ä¸ä½ **å°šæœªäº’åŠ¨è¿‡**çš„åŠ¨æ€è¿›è¡Œäº¤æµã€‚`;

                // Add force post instruction if requested
                if (forcePost) {
                    systemPrompt = `[ç”¨æˆ·æŒ‡ä»¤ï¼šç”¨æˆ·å¸Œæœ›ä½ ç°åœ¨å‘å¸ƒä¸€æ¡åŠ¨æ€æ¥åˆ†äº«ä½ çš„æƒ³æ³•ã€å¿ƒæƒ…æˆ–è¿‘å†µã€‚è¯·æ ¹æ®ä½ ä»¬æœ€è¿‘çš„å¯¹è¯å†…å®¹å’Œä½ çš„æ€§æ ¼ï¼Œåˆ›å»ºä¸€æ¡æœ‰æ„ä¹‰çš„åŠ¨æ€ã€‚è¯·ä½¿ç”¨æ ¼å¼ï¼š{"type": "qzone_post", "postType": "shuoshuo", "content": "ä½ çš„åŠ¨æ€å†…å®¹..."}]

` + systemPrompt;
                }
                // â–²â–²â–² Prompt å¢å¼ºç»“æŸ â–²â–²â–²

                const messagesPayload = [];
                messagesPayload.push({ role: 'system', content: systemPrompt });

                try {
                    const recentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(3).toArray();
                    const aiName = chat.name;

                    let dynamicContext = "";
                    if (recentPosts.length > 0) {
                        let postsContext = "\n\n# æœ€è¿‘çš„åŠ¨æ€åˆ—è¡¨ (ä¾›ä½ å‚è€ƒå’Œè¯„è®º):\n";
                        for (const post of recentPosts) {
                            let authorName = post.authorId === 'user' ? userNickname : (state.chats[post.authorId]?.name || 'ä¸€ä½æœ‹å‹');
                            let interactionStatus = '';
                            const contentSummary = (post.publicText || post.content || "å›¾ç‰‡åŠ¨æ€").substring(0, 30) + '...';
                            postsContext += `- (ID: ${post.id}) ä½œè€…: ${authorName}, å†…å®¹: "${contentSummary}"${interactionStatus}\n`;
                        }
                        dynamicContext = postsContext;
                    }

                    messagesPayload.push({
                        role: 'user',
                        content: `[ç³»ç»ŸæŒ‡ä»¤ï¼šè¯·æ ¹æ®ä½ åœ¨ system prompt ä¸­è¯»åˆ°çš„è§„åˆ™å’Œä»¥ä¸‹æœ€æ–°ä¿¡æ¯ï¼Œå¼€å§‹ä½ çš„ç‹¬ç«‹è¡ŒåŠ¨ã€‚]\n${dynamicContext}`
                    });

                    const data = await makeAPIRequest(proxyUrl, apiKey, model, messagesPayload, 0.9);

                    if (!data.choices || data.choices.length === 0 || !data.choices[0].message.content) {
                        return false;
                    }

                    const responseArray = parseAiResponse(data.choices[0].message.content);

                    for (const action of responseArray) {
                        if (!action) continue;

                        if (action.type === 'update_status' && action.status_text) {
                            chat.status.text = action.status_text;
                            chat.status.isBusy = action.is_busy || false;
                            chat.status.lastUpdate = Date.now();
                            await db.chats.put(chat);
                            renderChatList();
                        }
                        if (action.type === 'text' && action.content) {
                            const aiMessage = { role: 'assistant', content: String(action.content), timestamp: Date.now() };
                            chat.history.push(aiMessage);
                            await db.chats.put(chat);
                            showNotification(chatId, aiMessage.content);
                            renderChatList();
                            console.log(`åå°æ´»åŠ¨: è§’è‰² "${chat.name}" ä¸»åŠ¨å‘é€äº†æ¶ˆæ¯: ${aiMessage.content}`);
                        }
                        if (action.type === 'qzone_post') {
                            const newPost = { type: action.postType, content: action.content || '', publicText: action.publicText || '', hiddenContent: action.hiddenContent || '', timestamp: Date.now(), authorId: chatId, visibleGroupIds: null, isPinned: false };
                            await db.qzonePosts.add(newPost);
                            updateUnreadIndicator(unreadPostsCount + 1);
                            console.log(`åå°æ´»åŠ¨: è§’è‰² "${chat.name}" å‘å¸ƒäº†åŠ¨æ€`);
                        } else if (action.type === 'qzone_comment') {
                            const post = await db.qzonePosts.get(parseInt(action.postId));
                            if (post) {
                                if (!post.comments) post.comments = [];
                                post.comments.push({ commenterName: chat.name, text: action.commentText, timestamp: Date.now() });
                                await db.qzonePosts.update(post.id, { comments: post.comments });
                                updateUnreadIndicator(unreadPostsCount + 1);
                                console.log(`åå°æ´»åŠ¨: è§’è‰² "${chat.name}" è¯„è®ºäº†åŠ¨æ€ #${post.id}`);
                            }
                        } else if (action.type === 'qzone_like') {
                            const post = await db.qzonePosts.get(parseInt(action.postId));
                            if (post) {
                                if (!post.likes) post.likes = [];
                                if (!post.likes.includes(chat.name)) {
                                    post.likes.push(chat.name);
                                    await db.qzonePosts.update(post.id, { likes: post.likes });
                                    updateUnreadIndicator(unreadPostsCount + 1);
                                    console.log(`åå°æ´»åŠ¨: è§’è‰² "${chat.name}" ç‚¹èµäº†åŠ¨æ€ #${post.id}`);
                                }
                            }
                        } else if (action.type === 'video_call_request') {
                            if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                                videoCallState.isAwaitingResponse = true;
                                state.activeChatId = chatId;
                                showIncomingCallModal();
                                console.log(`åå°æ´»åŠ¨: è§’è‰² "${chat.name}" å‘èµ·äº†è§†é¢‘é€šè¯è¯·æ±‚`);
                            }
                        }
                    }
                    return true; // Success
                } catch (error) {
                    console.error('triggerInactiveAiAction error:', error);
                    return false; // Failure
                } finally {
                    chat._isProcessing = false;
                    delete chat._processingStartTime;
                }
            }




            function applyScopedCss(cssString, scopeId, styleTagId) {
                const styleTag = document.getElementById(styleTagId);
                if (!styleTag) return;

                if (!cssString || cssString.trim() === '') {
                    styleTag.innerHTML = '';
                    return;
                }

                // å¢å¼ºä½œç”¨åŸŸå¤„ç†å‡½æ•° - ä¸“é—¨è§£å†³.userå’Œ.aiæ ·å¼å†²çªé—®é¢˜
                // Also exclude is-sticker bubbles from custom styling
                const scopedCss = cssString
                    .replace(/\s*\.message-bubble\.user\s+([^{]+\{)/g, `${scopeId} .message-bubble.user:not(.is-sticker) $1`)
                    .replace(/\s*\.message-bubble\.ai\s+([^{]+\{)/g, `${scopeId} .message-bubble.ai:not(.is-sticker) $1`)
                    .replace(/\s*\.message-bubble\s+([^{]+\{)/g, `${scopeId} .message-bubble:not(.is-sticker) $1`);

                styleTag.innerHTML = scopedCss;
            }
            // â–²â–²â–² ä»¥ä¸Šä»£ç æ¥è‡ªJCY0709â–²â–²â–²

            // â–¼â–¼â–¼ è¯·ç”¨è¿™ä¸ªã€ä¿®æ­£ç‰ˆã€‘å‡½æ•°ï¼Œå®Œæ•´æ›¿æ¢æ‰æ—§çš„ updateSettingsPreview å‡½æ•° â–¼â–¼â–¼

            function updateSettingsPreview() {
                if (!state.activeChatId) return;
                const chat = state.chats[state.activeChatId];
                const previewArea = document.getElementById('settings-preview-area');
                if (!previewArea) return;

                // 1. è·å–å½“å‰è®¾ç½®çš„å€¼
                const selectedTheme = document.querySelector('input[name="theme-select"]:checked')?.value || 'default';
                const fontSize = document.getElementById('font-size-slider').value;
                const customCss = document.getElementById('custom-css-input').value;
                const background = chat.settings.background; // ç›´æ¥è·å–èƒŒæ™¯è®¾ç½®

                // 2. æ›´æ–°é¢„è§ˆåŒºçš„åŸºæœ¬æ ·å¼
                previewArea.dataset.theme = selectedTheme;
                previewArea.style.setProperty('--chat-font-size', `${fontSize}px`);

                // --- ã€æ ¸å¿ƒä¿®æ­£ã€‘ç›´æ¥æ›´æ–°é¢„è§ˆåŒºçš„èƒŒæ™¯æ ·å¼ ---
                if (background && background.startsWith('data:image')) {
                    previewArea.style.backgroundImage = `url(${background})`;
                    previewArea.style.backgroundColor = 'transparent'; // å¦‚æœæœ‰å›¾ç‰‡ï¼ŒèƒŒæ™¯è‰²è®¾ä¸ºé€æ˜
                } else {
                    previewArea.style.backgroundImage = 'none'; // å¦‚æœæ²¡æœ‰å›¾ç‰‡ï¼Œç§»é™¤å›¾ç‰‡èƒŒæ™¯
                    // å¦‚æœèƒŒæ™¯æ˜¯é¢œè‰²å€¼æˆ–æ¸å˜ï¼ˆéå›¾ç‰‡ï¼‰ï¼Œåˆ™ç›´æ¥åº”ç”¨
                    previewArea.style.background = background || '#f0f2f5';
                }

                // 3. æ¸²æŸ“æ¨¡æ‹Ÿæ°”æ³¡
                previewArea.innerHTML = '';

                // åˆ›å»ºâ€œå¯¹æ–¹â€çš„æ°”æ³¡
                // æ³¨æ„ï¼šæˆ‘ä»¬å°†ä¸€ä¸ªè™šæ‹Ÿçš„ timestamp ä¼ å…¥ï¼Œä»¥é˜²æœ‰CSSä¾èµ–äºå®ƒ
                const aiMsg = { role: 'ai', content: 'å¯¹æ–¹æ¶ˆæ¯é¢„è§ˆ', timestamp: 1, senderName: chat.name };
                const aiBubble = createMessageElement(aiMsg, chat);
                if (aiBubble) previewArea.appendChild(aiBubble);

                // åˆ›å»ºâ€œæˆ‘â€çš„æ°”æ³¡
                const userMsg = { role: 'user', content: 'æˆ‘çš„æ¶ˆæ¯é¢„è§ˆ', timestamp: 2 };
                const userBubble = createMessageElement(userMsg, chat);
                if (userBubble) previewArea.appendChild(userBubble);

                // 4. åº”ç”¨è‡ªå®šä¹‰CSSåˆ°é¢„è§ˆåŒº
                applyScopedCss(customCss, '#settings-preview-area', 'preview-bubble-style');
            }

            // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

            // â–¼â–¼â–¼ è¯·å°†è¿™äº›ã€æ–°å‡½æ•°ã€‘ç²˜è´´åˆ°JSåŠŸèƒ½å‡½æ•°å®šä¹‰åŒº â–¼â–¼â–¼

            async function openGroupManager() {
                await renderGroupList();
                document.getElementById('group-management-modal').classList.add('visible');
            }

            async function renderGroupList() {
                const listEl = document.getElementById('existing-groups-list');
                const groups = await db.qzoneGroups.toArray();
                listEl.innerHTML = '';
                if (groups.length === 0) {
                    listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">è¿˜æ²¡æœ‰ä»»ä½•åˆ†ç»„</p>';
                }
                groups.forEach(group => {
                    const item = document.createElement('div');
                    item.className = 'existing-group-item';
                    item.innerHTML = `
            <span class="group-name">${group.name}</span>
            <span class="delete-group-btn" data-id="${group.id}">Ã—</span>
        `;
                    listEl.appendChild(item);
                });
            }

            // â–¼â–¼â–¼ è¯·ç”¨è¿™ä¸ªã€ä¿®æ­£åã€‘çš„å‡½æ•°ï¼Œå®Œæ•´æ›¿æ¢æ—§çš„ addNewGroup å‡½æ•° â–¼â–¼â–¼
            async function addNewGroup() {
                const input = document.getElementById('new-group-name-input');
                const name = input.value.trim();
                if (!name) {
                    alert('åˆ†ç»„åä¸èƒ½ä¸ºç©ºï¼');
                    return;
                }

                // ã€æ ¸å¿ƒä¿®æ­£ã€‘åœ¨æ·»åŠ å‰ï¼Œå…ˆæ£€æŸ¥åˆ†ç»„åæ˜¯å¦å·²å­˜åœ¨
                const existingGroup = await db.qzoneGroups.where('name').equals(name).first();
                if (existingGroup) {
                    alert(`åˆ†ç»„ "${name}" å·²ç»å­˜åœ¨äº†ï¼Œæ¢ä¸ªåå­—å§ï¼`);
                    return;
                }
                // ã€ä¿®æ­£ç»“æŸã€‘

                await db.qzoneGroups.add({ name });
                input.value = '';
                await renderGroupList();
            }
            // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

            async function deleteGroup(groupId) {
                const confirmed = await showCustomConfirm('ç¡®è®¤åˆ é™¤', 'åˆ é™¤åˆ†ç»„åï¼Œè¯¥ç»„å†…çš„å¥½å‹å°†å˜ä¸ºâ€œæœªåˆ†ç»„â€ã€‚ç¡®å®šè¦åˆ é™¤å—ï¼Ÿ', { confirmButtonClass: 'btn-danger' });
                if (confirmed) {
                    await db.qzoneGroups.delete(groupId);
                    // å°†å±äºè¯¥åˆ†ç»„çš„å¥½å‹çš„ groupId è®¾ä¸º null
                    const chatsToUpdate = await db.chats.where('groupId').equals(groupId).toArray();
                    for (const chat of chatsToUpdate) {
                        chat.groupId = null;
                        await db.chats.put(chat);
                        if (state.chats[chat.id]) state.chats[chat.id].groupId = null;
                    }
                    await renderGroupList();
                }
            }

            // â–²â–²â–² æ–°å‡½æ•°ç²˜è´´ç»“æŸ â–²â–²â–²

            // â–¼â–¼â–¼ è¯·å°†è¿™ã€ä¸€æ•´å—æ–°å‡½æ•°ã€‘ç²˜è´´åˆ°JSåŠŸèƒ½å‡½æ•°å®šä¹‰åŒºçš„æœ«å°¾ â–¼â–¼â–¼

            /**
             * å½“é•¿æŒ‰æ¶ˆæ¯æ—¶ï¼Œæ˜¾ç¤ºæ“ä½œèœå•
             * @param {number} timestamp - è¢«é•¿æŒ‰æ¶ˆæ¯çš„æ—¶é—´æˆ³
             */
            function showMessageActions(timestamp) {
                // å¦‚æœå·²ç»åœ¨å¤šé€‰æ¨¡å¼ï¼Œåˆ™ä¸å¼¹å‡ºèœå•
                if (isSelectionMode) return;

                activeMessageTimestamp = timestamp;

                // Show all buttons for regular chat (in case they were hidden by date mode)
                const quoteBtn = document.getElementById('quote-message-btn');
                const recallBtn = document.getElementById('recall-message-btn');

                if (quoteBtn) quoteBtn.style.display = 'block';
                if (recallBtn) recallBtn.style.display = 'block';

                document.getElementById('message-actions-modal').classList.add('visible');
            }

            /**
             * éšè—æ¶ˆæ¯æ“ä½œèœå•
             */
            function hideMessageActions() {
                document.getElementById('message-actions-modal').classList.remove('visible');
                activeMessageTimestamp = null;
            }

            /**
             * å½“é•¿æŒ‰èŠå¤©æ—¶ï¼Œæ˜¾ç¤ºæ“ä½œèœå•
             * @param {string} chatId - è¢«é•¿æŒ‰èŠå¤©çš„ID
             */
            function showChatActions(chatId) {
                const chat = state.chats[chatId];
                if (!chat) return;

                activeChatId = chatId;
                const modal = document.getElementById('chat-actions-modal');
                const pinBtn = document.getElementById('pin-chat-btn');
                const unpinBtn = document.getElementById('unpin-chat-btn');

                // æ ¹æ®ç½®é¡¶çŠ¶æ€æ˜¾ç¤ºä¸åŒçš„æŒ‰é’®
                if (chat.isPinned) {
                    pinBtn.style.display = 'none';
                    unpinBtn.style.display = 'block';
                } else {
                    pinBtn.style.display = 'block';
                    unpinBtn.style.display = 'none';
                }

                modal.classList.add('visible');
            }

            /**
             * éšè—èŠå¤©æ“ä½œèœå•
             */
            function hideChatActions() {
                document.getElementById('chat-actions-modal').classList.remove('visible');
                activeChatId = null;
            }

            /**
             * ã€å…¨æ–°ã€‘å¼€å§‹å¼•ç”¨å›å¤æ¨¡å¼
             */
            function startReplyToMessage() {
                if (!activeMessageTimestamp) return;

                const chat = state.chats[state.activeChatId];
                const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);

                if (message) {
                    // æ„å»ºå¼•ç”¨ä¸Šä¸‹æ–‡å¯¹è±¡
                    const senderName = message.role === 'user' ?
                        (chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘') :
                        (message.senderName || chat.name);

                    currentReplyContext = {
                        timestamp: message.timestamp,
                        content: message.content,
                        senderName: senderName
                    };

                    // æ˜¾ç¤ºé¢„è§ˆæ 
                    const previewBar = document.getElementById('reply-preview-bar');
                    const senderEl = previewBar.querySelector('.sender');
                    const textEl = previewBar.querySelector('.text');

                    senderEl.textContent = `å›å¤ ${senderName}:`;
                    textEl.textContent = String(message.content).substring(0, 50);

                    previewBar.style.display = 'flex';
                }

                hideMessageActions();
                document.getElementById('chat-input').focus();
            }

            /**
             * ã€å…¨æ–°ã€‘å¤„ç†ç”¨æˆ·ç‚¹å‡»"æ’¤å›"æŒ‰é’®çš„å…¥å£å‡½æ•°
             */
            async function handleRecallClick() {
                if (!activeMessageTimestamp) return;

                const RECALL_TIME_LIMIT_MS = 2 * 60 * 1000; // è®¾ç½®2åˆ†é’Ÿçš„æ’¤å›æ—¶é™
                const messageTime = activeMessageTimestamp;
                const now = Date.now();

                // æ£€æŸ¥æ˜¯å¦è¶…è¿‡äº†æ’¤å›æ—¶é™
                if (now - messageTime > RECALL_TIME_LIMIT_MS) {
                    hideMessageActions();
                    await showCustomAlert('æ“ä½œå¤±è´¥', 'è¯¥æ¶ˆæ¯å‘é€å·²è¶…è¿‡2åˆ†é’Ÿï¼Œæ— æ³•æ’¤å›ã€‚');
                    return;
                }

                // å¦‚æœåœ¨æ—¶é™å†…ï¼Œæ‰§è¡ŒçœŸæ­£çš„æ’¤å›é€»è¾‘
                await recallMessage(messageTime, true);
                hideMessageActions();
            }

            /**
             * ã€å…¨æ–°ã€‘æ¶ˆæ¯æ’¤å›çš„æ ¸å¿ƒé€»è¾‘
             * @param {number} timestamp - è¦æ’¤å›çš„æ¶ˆæ¯çš„æ—¶é—´æˆ³
             * @param {boolean} isUserRecall - æ˜¯å¦æ˜¯ç”¨æˆ·ä¸»åŠ¨æ’¤å›
             */
            async function recallMessage(timestamp, isUserRecall) {
                const chat = state.chats[state.activeChatId];
                if (!chat) return;

                const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
                if (messageIndex === -1) return;

                const messageToRecall = chat.history[messageIndex];

                // 1. ä¿®æ”¹æ¶ˆæ¯å¯¹è±¡ï¼Œå°†å…¶å˜ä¸º"å·²æ’¤å›"çŠ¶æ€
                const recalledData = {
                    originalType: messageToRecall.type || 'text',
                    originalContent: messageToRecall.content,
                    // ä¿å­˜å…¶ä»–å¯èƒ½å­˜åœ¨çš„åŸå§‹æ•°æ®
                    originalMeaning: messageToRecall.meaning,
                    originalQuote: messageToRecall.quote
                };

                messageToRecall.type = 'recalled_message';
                messageToRecall.content = isUserRecall ? 'ä½ æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯' : 'å¯¹æ–¹æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯';
                messageToRecall.recalledData = recalledData;
                // æ¸…ç†æ‰ä¸å†éœ€è¦çš„æ—§å±æ€§
                delete messageToRecall.meaning;
                delete messageToRecall.quote;

                // 2. å¦‚æœæ˜¯ç”¨æˆ·æ’¤å›ï¼Œéœ€è¦ç»™AIå‘é€ä¸€æ¡å®ƒçœ‹ä¸æ‡‚å†…å®¹çš„éšè—æç¤º
                if (isUserRecall) {
                    const hiddenMessageForAI = {
                        role: 'system',
                        content: `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯ã€‚ä½ ä¸çŸ¥é“å†…å®¹æ˜¯ä»€ä¹ˆï¼Œåªéœ€çŸ¥é“è¿™ä¸ªäº‹ä»¶å³å¯ã€‚]`,
                        timestamp: Date.now(),
                        isHidden: true
                    };
                    chat.history.push(hiddenMessageForAI);
                }

                // 3. ä¿å­˜åˆ°æ•°æ®åº“å¹¶åˆ·æ–°UI
                await db.chats.put(chat);
                renderChatInterface(state.activeChatId);
                if (isUserRecall) renderChatList(); // ç”¨æˆ·æ’¤å›æ—¶ï¼Œæœ€åä¸€æ¡æ¶ˆæ¯å˜äº†ï¼Œéœ€è¦åˆ·æ–°åˆ—è¡¨
            }



            /**
             * ã€å…¨æ–°ã€‘å–æ¶ˆå¼•ç”¨æ¨¡å¼
             */
            function cancelReplyMode() {
                currentReplyContext = null;
                document.getElementById('reply-preview-bar').style.display = 'none';
            }

            // â–¼â–¼â–¼ è¯·ç”¨è¿™ä¸ªã€å¸¦æ ¼å¼åŠ©æ‰‹çš„ç»ˆæç‰ˆã€‘æ›¿æ¢æ—§çš„ openMessageEditor å‡½æ•° â–¼â–¼â–¼
            async function openMessageEditor() {
                if (!activeMessageTimestamp) return;

                const timestampToEdit = activeMessageTimestamp;
                const chat = state.chats[state.activeChatId];
                const message = chat.history.find(m => m.timestamp === timestampToEdit);
                if (!message) return;

                hideMessageActions();

                let contentForEditing;
                const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer'].includes(message.type);

                if (isSpecialType) {
                    let fullMessageObject = { type: message.type };
                    if (message.type === 'voice_message') fullMessageObject.content = message.content;
                    else if (message.type === 'ai_image') {
                        fullMessageObject.description = message.content;
                        // Always show imageUrl field, use existing or default
                        fullMessageObject.imageUrl = message.imageUrl || "https://files.catbox.moe/cww7rw.jpg";
                    }
                    else if (message.type === 'transfer') {
                        fullMessageObject.amount = message.amount;
                        fullMessageObject.note = message.note;
                    }
                    contentForEditing = JSON.stringify(fullMessageObject, null, 2);
                } else if (typeof message.content === 'object') {
                    contentForEditing = JSON.stringify(message.content, null, 2);
                } else {
                    contentForEditing = message.content;
                }

                // --- ã€æ ¸å¿ƒä¿®æ”¹ã€‘åœ¨è¿™é‡Œæ„å»ºâ€œæ ¼å¼åŠ©æ‰‹â€æŒ‰é’®çš„HTML ---
                const templates = {
                    voice: { type: 'voice_message', content: 'åœ¨è¿™é‡Œè¾“å…¥è¯­éŸ³å†…å®¹' },
                    image: { type: 'ai_image', description: 'åœ¨è¿™é‡Œè¾“å…¥å›¾ç‰‡æè¿°', imageUrl: 'https://example.com/your-image.jpg' },
                    transfer: { type: 'transfer', amount: 5.20, note: 'ä¸€ç‚¹å¿ƒæ„' }
                };

                // ä½¿ç”¨ data-template å±æ€§å­˜å‚¨JSONæ¨¡æ¿å­—ç¬¦ä¸²ï¼Œæ³¨æ„è¦ç”¨å•å¼•å·åŒ…è£¹
                const helpersHtml = `
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>è¯­éŸ³</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>å›¾ç‰‡</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>è½¬è´¦</button>
        </div>
    `;
                // --- ã€æ ¸å¿ƒä¿®æ”¹ç»“æŸã€‘---

                const newContent = await showCustomPrompt(
                    'ç¼–è¾‘æ¶ˆæ¯',
                    'åœ¨æ­¤ä¿®æ”¹ï¼Œæˆ–ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®ä½¿ç”¨æ ¼å¼æ¨¡æ¿...', // ä¿®æ”¹æç¤ºè¯­
                    contentForEditing,
                    'textarea',
                    helpersHtml // å°†æŒ‰é’®çš„HTMLä½œä¸ºç¬¬5ä¸ªå‚æ•°ä¼ å…¥
                );

                if (newContent !== null) {
                    await saveEditedMessage(timestampToEdit, newContent);
                }
            }
            // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²


            // â–¼â–¼â–¼ ã€å…¨æ–°ã€‘å¯è§†åŒ–å¤šæ¶ˆæ¯ç¼–è¾‘å™¨é©±åŠ¨å‡½æ•° â–¼â–¼â–¼

            /**
             * åˆ›å»ºä¸€ä¸ªå¯ç¼–è¾‘çš„æ¶ˆæ¯å—ï¼ˆåŒ…å«æ–‡æœ¬æ¡†ã€æ ¼å¼åŠ©æ‰‹å’Œåˆ é™¤æŒ‰é’®ï¼‰
             * @param {string} initialContent - æ–‡æœ¬æ¡†çš„åˆå§‹å†…å®¹
             * @returns {HTMLElement} - åˆ›å»ºå¥½çš„DOMå…ƒç´ 
             */
            function createMessageEditorBlock(initialContent = '') {
                const block = document.createElement('div');
                block.className = 'message-editor-block';

                const templates = {
                    voice: { type: 'voice_message', content: 'åœ¨è¿™é‡Œè¾“å…¥è¯­éŸ³å†…å®¹' },
                    image: { type: 'ai_image', description: 'åœ¨è¿™é‡Œè¾“å…¥å›¾ç‰‡æè¿°', imageUrl: 'https://example.com/your-image.jpg' },
                    transfer: { type: 'transfer', amount: 5.20, note: 'ä¸€ç‚¹å¿ƒæ„' }
                };

                block.innerHTML = `
        <button class="delete-block-btn" title="åˆ é™¤æ­¤æ¡">Ã—</button>
        <textarea>${initialContent}</textarea>
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>è¯­éŸ³</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>å›¾ç‰‡</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>è½¬è´¦</button>
        </div>
    `;

                // ç»‘å®šåˆ é™¤æŒ‰é’®äº‹ä»¶
                block.querySelector('.delete-block-btn').addEventListener('click', () => {
                    // ç¡®ä¿è‡³å°‘ä¿ç•™ä¸€ä¸ªç¼–è¾‘å—
                    if (document.querySelectorAll('.message-editor-block').length > 1) {
                        block.remove();
                    } else {
                        alert('è‡³å°‘éœ€è¦ä¿ç•™ä¸€æ¡æ¶ˆæ¯ã€‚');
                    }
                });

                // ç»‘å®šæ ¼å¼åŠ©æ‰‹æŒ‰é’®äº‹ä»¶
                block.querySelectorAll('.format-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const templateStr = btn.dataset.template;
                        const textarea = block.querySelector('textarea');
                        if (templateStr && textarea) {
                            try {
                                const templateObj = JSON.parse(templateStr);
                                textarea.value = JSON.stringify(templateObj, null, 2);
                                textarea.focus();
                            } catch (e) { console.error("è§£ææ ¼å¼æ¨¡æ¿å¤±è´¥:", e); }
                        }
                    });
                });

                return block;
            }

            // â–¼â–¼â–¼ ã€å…¨æ–°å‡çº§ç‰ˆã€‘è¯·ç”¨æ­¤å‡½æ•°å®Œæ•´æ›¿æ¢æ—§çš„ openAdvancedMessageEditor â–¼â–¼â–¼
            /**
             * æ‰“å¼€å…¨æ–°çš„ã€å¯è§†åŒ–çš„å¤šæ¶ˆæ¯ç¼–è¾‘å™¨ï¼Œå¹¶åŠ¨æ€ç»‘å®šå…¶æ‰€æœ‰æŒ‰é’®äº‹ä»¶
             */
            function openAdvancedMessageEditor() {
                if (!activeMessageTimestamp) return;

                // 1. ã€æ ¸å¿ƒã€‘åœ¨å…³é—­æ—§èœå•å‰ï¼Œå°†éœ€è¦çš„æ—¶é—´æˆ³æ•è·åˆ°å±€éƒ¨å˜é‡ä¸­
                const timestampToEdit = activeMessageTimestamp;

                const chat = state.chats[state.activeChatId];
                const message = chat.history.find(m => m.timestamp === timestampToEdit);
                if (!message) return;

                // 2. ç°åœ¨å¯ä»¥å®‰å…¨åœ°å…³é—­æ—§èœå•äº†ï¼Œå› ä¸ºå®ƒä¸ä¼šå½±å“æˆ‘ä»¬çš„å±€éƒ¨å˜é‡
                hideMessageActions();

                const editorModal = document.getElementById('message-editor-modal');
                const editorContainer = document.getElementById('message-editor-container');
                editorContainer.innerHTML = '';

                // 3. å‡†å¤‡åˆå§‹å†…å®¹
                let initialContent;
                const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer'].includes(message.type);
                if (isSpecialType) {
                    let fullMessageObject = { type: message.type };
                    if (message.type === 'voice_message') fullMessageObject.content = message.content;
                    else if (message.type === 'ai_image') {
                        fullMessageObject.description = message.content;
                        // Always show imageUrl field, use existing or default
                        fullMessageObject.imageUrl = message.imageUrl || "https://files.catbox.moe/cww7rw.jpg";
                    }
                    else if (message.type === 'transfer') {
                        fullMessageObject.amount = message.amount;
                        fullMessageObject.note = message.note;
                    }
                    initialContent = JSON.stringify(fullMessageObject, null, 2);
                } else if (typeof message.content === 'object') {
                    initialContent = JSON.stringify(message.content, null, 2);
                } else {
                    initialContent = message.content;
                }

                const firstBlock = createMessageEditorBlock(initialContent);
                editorContainer.appendChild(firstBlock);

                // 4. ã€æ ¸å¿ƒã€‘åŠ¨æ€ç»‘å®šæ‰€æœ‰æ§åˆ¶æŒ‰é’®çš„äº‹ä»¶
                // ä¸ºäº†é˜²æ­¢äº‹ä»¶é‡å¤ç»‘å®šï¼Œæˆ‘ä»¬ä½¿ç”¨å…‹éš†èŠ‚ç‚¹çš„æ–¹æ³•æ¥æ¸…é™¤æ—§ç›‘å¬å™¨
                const addBtn = document.getElementById('add-message-editor-block-btn');
                const newAddBtn = addBtn.cloneNode(true);
                addBtn.parentNode.replaceChild(newAddBtn, addBtn);
                newAddBtn.addEventListener('click', () => {
                    const newBlock = createMessageEditorBlock();
                    editorContainer.appendChild(newBlock);
                    newBlock.querySelector('textarea').focus();
                });

                const cancelBtn = document.getElementById('cancel-advanced-editor-btn');
                const newCancelBtn = cancelBtn.cloneNode(true);
                cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
                newCancelBtn.addEventListener('click', () => {
                    editorModal.classList.remove('visible');
                });

                const saveBtn = document.getElementById('save-advanced-editor-btn');
                const newSaveBtn = saveBtn.cloneNode(true);
                saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
                // å°†æ•è·åˆ°çš„æ—¶é—´æˆ³ï¼Œç›´æ¥ç»‘å®šç»™è¿™ä¸€æ¬¡çš„ä¿å­˜ç‚¹å‡»äº‹ä»¶
                newSaveBtn.addEventListener('click', () => {
                    saveEditedMessage(timestampToEdit);
                });

                // 5. æœ€åï¼Œæ˜¾ç¤ºæ¨¡æ€æ¡†
                editorModal.classList.add('visible');
            }
            // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

            /**
             * è§£æç¼–è¾‘åçš„æ–‡æœ¬ï¼Œå¹¶è¿”å›ä¸€ä¸ªæ ‡å‡†åŒ–çš„æ¶ˆæ¯ç‰‡æ®µå¯¹è±¡
             * @param {string} text - ç”¨æˆ·åœ¨ç¼–è¾‘æ¡†ä¸­è¾“å…¥çš„æ–‡æœ¬
             * @returns {object} - ä¸€ä¸ªåŒ…å« type, content, ç­‰å±æ€§çš„å¯¹è±¡
             */
            function parseEditedContent(text) {
                const trimmedText = text.trim();

                // 1. å°è¯•è§£æä¸ºJSONå¯¹è±¡ï¼ˆç”¨äºä¿®å¤è¯­éŸ³ã€è½¬è´¦ç­‰æ ¼å¼ï¼‰
                if (trimmedText.startsWith('{') && trimmedText.endsWith('}')) {
                    try {
                        const parsed = JSON.parse(trimmedText);
                        // å¿…é¡»åŒ…å« type å±æ€§æ‰è®¤ä¸ºæ˜¯æœ‰æ•ˆæ ¼å¼
                        if (parsed.type) {
                            return parsed;
                        }
                    } catch (e) { /* è§£æå¤±è´¥ï¼Œç»§ç»­å¾€ä¸‹èµ° */ }
                }

                // 2. å°è¯•è§£æä¸ºè¡¨æƒ…åŒ…
                if (STICKER_REGEX.test(trimmedText)) {
                    // å¯¹äºç¼–è¾‘çš„è¡¨æƒ…ï¼Œæˆ‘ä»¬æš‚æ—¶æ— æ³•çŸ¥é“å…¶`meaning`ï¼Œæ‰€ä»¥åªå­˜URL
                    return { type: 'sticker', content: trimmedText };
                }

                // 3. å¦åˆ™ï¼Œè§†ä¸ºæ™®é€šæ–‡æœ¬æ¶ˆæ¯
                return { type: 'text', content: trimmedText };
            }


            // â–¼â–¼â–¼ è¯·ç”¨è¿™ä¸ªã€æ”¯æŒå¯è§†åŒ–ç¼–è¾‘ã€‘çš„å…¨æ–°å‡½æ•°ï¼Œå®Œæ•´æ›¿æ¢æ—§çš„ saveEditedMessage å‡½æ•° â–¼â–¼â–¼
            /**
             * ä»å¯è§†åŒ–ç¼–è¾‘å™¨æ”¶é›†æ‰€æœ‰æ¶ˆæ¯ï¼Œæ›´æ–°æ•°æ®åº“å’ŒUI
             * @param {number} timestamp - è¦ä¿®æ”¹çš„åŸå§‹æ¶ˆæ¯çš„æ—¶é—´æˆ³
             */
            async function saveEditedMessage(timestamp) {
                if (!timestamp) return;

                const chat = state.chats[state.activeChatId];
                const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
                if (messageIndex === -1) return;

                const editorContainer = document.getElementById('message-editor-container');
                const editorBlocks = editorContainer.querySelectorAll('.message-editor-block');

                let newMessages = [];
                let baseTimestamp = timestamp; // ä½¿ç”¨åŸå§‹æ—¶é—´æˆ³ä½œä¸ºåŸºå‡†

                for (const block of editorBlocks) {
                    const textarea = block.querySelector('textarea');
                    const rawContent = textarea.value.trim();

                    if (!rawContent) continue; // è·³è¿‡ç©ºçš„ç¼–è¾‘æ¡†

                    const parsedResult = parseEditedContent(rawContent);

                    const newMessage = {
                        role: chat.history[messageIndex].role,
                        senderName: chat.history[messageIndex].senderName,
                        timestamp: baseTimestamp++, // é€’å¢æ—¶é—´æˆ³ä¿è¯é¡ºåºå’Œå”¯ä¸€æ€§
                        content: parsedResult.content || '',
                    };

                    if (parsedResult.type && parsedResult.type !== 'text') newMessage.type = parsedResult.type;
                    if (parsedResult.meaning) newMessage.meaning = parsedResult.meaning;
                    if (parsedResult.amount) newMessage.amount = parsedResult.amount;
                    if (parsedResult.note) newMessage.note = parsedResult.note;
                    if (parsedResult.description) newMessage.content = parsedResult.description;
                    if (parsedResult.imageUrl) newMessage.imageUrl = parsedResult.imageUrl;

                    newMessages.push(newMessage);
                }

                if (newMessages.length === 0) {
                    alert("ä¸èƒ½ä¿å­˜ç©ºæ¶ˆæ¯ï¼Œè¯·è‡³å°‘è¾“å…¥ä¸€æ¡å†…å®¹ã€‚");
                    return;
                }

                // åœ¨å†å²è®°å½•çš„åŸå§‹ä½ç½®ï¼Œåˆ é™¤1æ¡æ—§æ¶ˆæ¯ï¼Œå¹¶æ’å…¥æ‰€æœ‰æ–°æ¶ˆæ¯
                chat.history.splice(messageIndex, 1, ...newMessages);

                // å°†æœ€ç»ˆçš„ã€æ›´æ–°åçš„ history ä¿å­˜åˆ°æ•°æ®åº“
                await db.chats.put(chat);

                // å…³é—­æ¨¡æ€æ¡†å¹¶åˆ·æ–°UI
                document.getElementById('message-editor-modal').classList.remove('visible');
                renderChatInterface(state.activeChatId);
                await showCustomAlert('æˆåŠŸ', 'æ¶ˆæ¯å·²æ›´æ–°ï¼');
            }
            // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

            // â–¼â–¼â–¼ è¯·å°†è¿™ã€ä¸€æ•´å—æ–°å‡½æ•°ã€‘ç²˜è´´åˆ°JSåŠŸèƒ½å‡½æ•°å®šä¹‰åŒºçš„æœ«å°¾ â–¼â–¼â–¼

            /**
             * å½“ç‚¹å‡»â€œâ€¦â€æ—¶ï¼Œæ˜¾ç¤ºåŠ¨æ€æ“ä½œèœå•
             * @param {number} postId - è¢«æ“ä½œçš„åŠ¨æ€çš„ID
             */
            async function showPostActions(postId) {
                activePostId = postId;

                // è·å–å½“å‰åŠ¨æ€ä¿¡æ¯ä»¥ç¡®å®šæ˜¾ç¤ºç½®é¡¶è¿˜æ˜¯å–æ¶ˆç½®é¡¶
                const post = await db.qzonePosts.get(postId);
                const pinBtn = document.getElementById('pin-post-btn');
                const unpinBtn = document.getElementById('unpin-post-btn');

                if (post && post.isPinned) {
                    pinBtn.style.display = 'none';
                    unpinBtn.style.display = 'block';
                } else {
                    pinBtn.style.display = 'block';
                    unpinBtn.style.display = 'none';
                }

                document.getElementById('post-actions-modal').classList.add('visible');
            }

            /**
             * éšè—åŠ¨æ€æ“ä½œèœå•
             */
            function hidePostActions() {
                document.getElementById('post-actions-modal').classList.remove('visible');
                activePostId = null;
            }

            /**
             * æ‰“å¼€åŠ¨æ€ç¼–è¾‘å™¨
             */
            async function openPostEditor() {
                if (!activePostId) return;

                const postIdToEdit = activePostId;
                const post = await db.qzonePosts.get(postIdToEdit);
                if (!post) return;

                hidePostActions();

                // å¿ äºåŸæ–‡ï¼šæ„å»ºå‡ºæœ€åŸå§‹çš„æ–‡æœ¬å½¢æ€ä¾›ç¼–è¾‘
                let contentForEditing;
                if (post.type === 'shuoshuo') {
                    contentForEditing = post.content;
                } else {
                    // å¯¹äºå›¾ç‰‡å’Œæ–‡å­—å›¾ï¼Œæˆ‘ä»¬æ„å»ºä¸€ä¸ªåŒ…å«æ‰€æœ‰ä¿¡æ¯çš„å¯¹è±¡
                    const postObject = {
                        type: post.type,
                        publicText: post.publicText || '',
                    };
                    if (post.type === 'image_post') {
                        postObject.imageUrl = post.imageUrl;
                        postObject.imageDescription = post.imageDescription;
                    } else if (post.type === 'text_image') {
                        postObject.hiddenContent = post.hiddenContent;
                        postObject.decorativeImageUrl = post.decorativeImageUrl || '';
                    }
                    contentForEditing = JSON.stringify(postObject, null, 2);
                }

                // æ„å»ºæ ¼å¼åŠ©æ‰‹æŒ‰é’®
                const templates = {
                    shuoshuo: "åœ¨è¿™é‡Œè¾“å…¥è¯´è¯´çš„å†…å®¹...", // å¯¹äºè¯´è¯´ï¼Œæˆ‘ä»¬ç›´æ¥æ›¿æ¢ä¸ºçº¯æ–‡æœ¬
                    image: { type: 'image_post', publicText: '', imageUrl: 'https://...', imageDescription: '' },
                    text_image: { type: 'text_image', publicText: '', hiddenContent: '' }
                };

                const helpersHtml = `
        <div class="format-helpers">
            <button class="format-btn" data-type="text">è¯´è¯´</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>å›¾ç‰‡åŠ¨æ€</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.text_image)}'>æ–‡å­—å›¾</button>
        </div>
    `;

                const newContent = await showCustomPrompt(
                    'ç¼–è¾‘åŠ¨æ€',
                    'åœ¨æ­¤ä¿®æ”¹å†…å®¹...',
                    contentForEditing,
                    'textarea',
                    helpersHtml
                );

                // ã€ç‰¹æ®Šå¤„ç†ã€‘ä¸ºè¯´è¯´çš„æ ¼å¼åŠ©æ‰‹æŒ‰é’®æ·»åŠ ä¸åŒçš„è¡Œä¸º
                // æˆ‘ä»¬éœ€è¦åœ¨æ¨¡æ€æ¡†å‡ºç°åï¼Œå†ç»™å®ƒç»‘å®šäº‹ä»¶
                setTimeout(() => {
                    const shuoshuoBtn = document.querySelector('#custom-modal-body .format-btn[data-type="text"]');
                    if (shuoshuoBtn) {
                        shuoshuoBtn.addEventListener('click', () => {
                            const input = document.getElementById('custom-prompt-input');
                            input.value = templates.shuoshuo;
                            input.focus();
                        });
                    }
                }, 100);

                if (newContent !== null) {
                    await saveEditedPost(postIdToEdit, newContent);
                }
            }

            /**
             * ä¿å­˜ç¼–è¾‘åçš„åŠ¨æ€
             * @param {number} postId - è¦ä¿å­˜çš„åŠ¨æ€ID
             * @param {string} newRawContent - ä»ç¼–è¾‘å™¨è·å–çš„æ–°å†…å®¹
             */
            async function saveEditedPost(postId, newRawContent) {
                const post = await db.qzonePosts.get(postId);
                if (!post) return;

                const trimmedContent = newRawContent.trim();

                // å°è¯•è§£æä¸ºJSONï¼Œå¦‚æœå¤±è´¥ï¼Œåˆ™è®¤ä¸ºæ˜¯çº¯æ–‡æœ¬ï¼ˆè¯´è¯´ï¼‰
                try {
                    const parsed = JSON.parse(trimmedContent);
                    // æ›´æ–°å¸–å­å±æ€§
                    post.type = parsed.type || 'image_post';
                    post.publicText = parsed.publicText || '';
                    post.imageUrl = parsed.imageUrl || '';
                    post.imageDescription = parsed.imageDescription || '';
                    post.hiddenContent = parsed.hiddenContent || '';
                    post.decorativeImageUrl = parsed.decorativeImageUrl || null; // IMPORTANT: Purely decorative, never sent to API
                    post.content = ''; // æ¸…ç©ºæ—§çš„è¯´è¯´å†…å®¹å­—æ®µ
                } catch (e) {
                    // è§£æå¤±è´¥ï¼Œè®¤ä¸ºæ˜¯è¯´è¯´
                    post.type = 'shuoshuo';
                    post.content = trimmedContent;
                    // æ¸…ç©ºå…¶ä»–ç±»å‹çš„å­—æ®µ
                    post.publicText = '';
                    post.imageUrl = '';
                    post.imageDescription = '';
                    post.hiddenContent = '';
                    post.decorativeImageUrl = null;
                }

                await db.qzonePosts.put(post);
                await renderQzonePosts(); // é‡æ–°æ¸²æŸ“åˆ—è¡¨
                await showCustomAlert('æˆåŠŸ', 'åŠ¨æ€å·²æ›´æ–°ï¼');
            }

            /**
             * æ˜¾ç¤ºè¯„è®ºæ“ä½œèœå•
             */
            function showCommentActions(postId, commentTimestamp, commentText, commenterName) {
                activeCommentData = {
                    postId: postId,
                    timestamp: commentTimestamp,
                    text: commentText,
                    commenterName: commenterName
                };
                document.getElementById('comment-actions-modal').classList.add('visible');
            }

            /**
             * éšè—è¯„è®ºæ“ä½œèœå•
             */
            function hideCommentActions() {
                document.getElementById('comment-actions-modal').classList.remove('visible');
                activeCommentData = null;
            }

            /**
             * ç¼–è¾‘è¯„è®º
             */
            async function editComment() {
                if (!activeCommentData) return;

                const newText = await showCustomPrompt('ç¼–è¾‘è¯„è®º', 'è¯·è¾“å…¥æ–°çš„è¯„è®ºå†…å®¹:', activeCommentData.text, 'textarea');
                if (newText === null || newText.trim() === '') return;

                try {
                    const post = await db.qzonePosts.get(activeCommentData.postId);
                    if (!post || !post.comments) return;

                    // æ‰¾åˆ°å¹¶æ›´æ–°è¯„è®º
                    const commentIndex = post.comments.findIndex(c => c.timestamp === activeCommentData.timestamp);
                    if (commentIndex !== -1) {
                        post.comments[commentIndex].text = newText.trim();
                        await db.qzonePosts.put(post);

                        // å…³é—­æ“ä½œèœå•
                        hideCommentActions();

                        // åˆ·æ–°åŠ¨æ€åˆ—è¡¨
                        if (document.getElementById('qzone-screen').classList.contains('active')) {
                            await renderQzonePosts();
                        }

                        await showCustomAlert('ç¼–è¾‘æˆåŠŸ', 'è¯„è®ºå·²æ›´æ–°');
                    }
                } catch (error) {
                    console.error('ç¼–è¾‘è¯„è®ºå¤±è´¥:', error);
                    await showCustomAlert('ç¼–è¾‘å¤±è´¥', 'ç¼–è¾‘è¯„è®ºæ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·é‡è¯•');
                }
            }

            /**
             * åˆ é™¤è¯„è®º
             */
            async function deleteComment() {
                if (!activeCommentData) return;

                const confirmed = await showCustomConfirm(
                    'åˆ é™¤è¯„è®º',
                    'ç¡®å®šè¦åˆ é™¤è¿™æ¡è¯„è®ºå—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚',
                    { confirmButtonClass: 'btn-danger' }
                );

                if (!confirmed) return;

                try {
                    const post = await db.qzonePosts.get(activeCommentData.postId);
                    if (!post || !post.comments) return;

                    // åˆ é™¤è¯„è®º
                    post.comments = post.comments.filter(c => c.timestamp !== activeCommentData.timestamp);
                    await db.qzonePosts.put(post);

                    // å…³é—­æ“ä½œèœå•
                    hideCommentActions();

                    // åˆ·æ–°åŠ¨æ€åˆ—è¡¨
                    if (document.getElementById('qzone-screen').classList.contains('active')) {
                        await renderQzonePosts();
                    }

                    await showCustomAlert('åˆ é™¤æˆåŠŸ', 'è¯„è®ºå·²åˆ é™¤');

                } catch (error) {
                    console.error('åˆ é™¤è¯„è®ºå¤±è´¥:', error);
                    await showCustomAlert('åˆ é™¤å¤±è´¥', 'åˆ é™¤è¯„è®ºæ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·é‡è¯•');
                }
            }

            // â–¼â–¼â–¼ AIå›å¤æ¨¡æ€æ¡†ç›¸å…³å‡½æ•° â–¼â–¼â–¼
            let currentPostIdForAiReply = null;

            /**
             * æ˜¾ç¤ºAIå›å¤é€‰æ‹©æ¨¡æ€æ¡†
             */
            function showAiReplyModal(postId) {
                currentPostIdForAiReply = postId;

                // è·å–æ‰€æœ‰å¯ç”¨çš„AI
                const availableAis = [];
                for (const chatId in state.chats) {
                    const chat = state.chats[chatId];
                    if (!chat.isGroup) {
                        const aiAvatar = chat.settings.aiAvatar || defaultAvatar;
                        availableAis.push({
                            id: chatId,
                            name: chat.name,
                            avatar: aiAvatar,
                            status: chat.relationship?.status || 'friend'
                        });
                    }
                }

                if (availableAis.length === 0) {
                    alert('æ²¡æœ‰å¯ç”¨çš„AIè§’è‰²');
                    return;
                }

                // ç”ŸæˆAIåˆ—è¡¨HTML
                const aiListHtml = availableAis.map(ai => `
        <div class="ai-selection-item" onclick="window.toggleAiSelection('${ai.id}')">
            <input type="checkbox" id="ai-${ai.id}" data-ai-id="${ai.id}">
            <img src="${ai.avatar}" class="ai-selection-avatar" alt="${ai.name}">
            <div class="ai-selection-info">
                <div class="ai-selection-name">${ai.name}</div>
                <div class="ai-selection-status">${ai.status === 'friend' ? 'å¥½å‹' : ai.status}</div>
            </div>
        </div>
    `).join('');

                document.getElementById('ai-selection-list').innerHTML = aiListHtml;
                document.getElementById('ai-reply-modal').classList.add('visible');
            }

            /**
             * éšè—AIå›å¤é€‰æ‹©æ¨¡æ€æ¡†
             */
            function hideAiReplyModal() {
                document.getElementById('ai-reply-modal').classList.remove('visible');
                currentPostIdForAiReply = null;
            }

            /**
             * åˆ‡æ¢AIé€‰æ‹©çŠ¶æ€
             */
            window.toggleAiSelection = function (aiId) {
                const checkbox = document.getElementById(`ai-${aiId}`);
                if (checkbox) {
                    checkbox.checked = !checkbox.checked;
                }
            }

            /**
             * å…¨é€‰AI
             */
            function selectAllAis() {
                const checkboxes = document.querySelectorAll('#ai-selection-list input[type="checkbox"]');
                checkboxes.forEach(cb => cb.checked = true);
            }

            /**
             * å–æ¶ˆå…¨é€‰AI
             */
            function deselectAllAis() {
                const checkboxes = document.querySelectorAll('#ai-selection-list input[type="checkbox"]');
                checkboxes.forEach(cb => cb.checked = false);
            }

            /**
             * ç¡®è®¤AIå›å¤
             */
            async function confirmAiReply() {
                if (!currentPostIdForAiReply) {
                    return;
                }

                // è·å–é€‰ä¸­çš„AI
                const selectedAis = [];
                const checkboxes = document.querySelectorAll('#ai-selection-list input[type="checkbox"]:checked');
                checkboxes.forEach(cb => {
                    selectedAis.push(cb.dataset.aiId);
                });

                if (selectedAis.length === 0) {
                    alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªAI');
                    return;
                }

                // ä¿å­˜postIdåˆ°å±€éƒ¨å˜é‡ï¼Œé¿å…hideAiReplyModalæ¸…ç©ºå®ƒ
                const postIdToProcess = currentPostIdForAiReply;
                hideAiReplyModal();

                // æ‰¾åˆ°å¯¹åº”çš„æœºå™¨äººæŒ‰é’®å¹¶æ”¹å˜ä¸ºåŠ è½½çŠ¶æ€
                const postContainer = document.querySelector(`[data-post-id="${postIdToProcess}"]`);
                const aiReplyBtn = postContainer ? postContainer.querySelector('.call-ai-reply-btn') : null;

                if (aiReplyBtn) {
                    aiReplyBtn.innerHTML = 'â³';
                    aiReplyBtn.disabled = true;
                    aiReplyBtn.style.opacity = '0.6';
                }

                // ä¸ºæ¯ä¸ªé€‰ä¸­çš„AIè§¦å‘å›å¤
                let completedCount = 0;
                let successCount = 0;
                for (const aiId of selectedAis) {
                    try {
                        const success = await triggerAiPostReply(aiId, postIdToProcess);
                        completedCount++;
                        if (success !== false) {
                            successCount++;
                        }
                    } catch (error) {
                        completedCount++;
                    }
                }

                // æ¢å¤æŒ‰é’®çŠ¶æ€
                if (aiReplyBtn) {
                    aiReplyBtn.innerHTML = 'ğŸ¤–';
                    aiReplyBtn.disabled = false;
                    aiReplyBtn.style.opacity = '1';
                }

                // åˆ·æ–°åŠ¨æ€åˆ—è¡¨
                try {
                    await renderQzonePosts();
                } catch (error) {
                    // é™é»˜å¤„ç†é”™è¯¯
                }

                // æ˜¾ç¤ºå®Œæˆé€šçŸ¥
                const completionMsg = document.createElement('div');
                const bgColor = successCount === selectedAis.length ? 'rgba(0,128,0,0.9)' : 'rgba(255,165,0,0.9)';
                completionMsg.style.cssText = `position: fixed; top: 20px; right: 20px; background: ${bgColor}; color: white; padding: 15px 20px; border-radius: 10px; z-index: 9999; font-size: 14px;`;
                completionMsg.innerHTML = `âœ… AIå›å¤å®Œæˆ<br>æˆåŠŸ: ${successCount}/${selectedAis.length}`;
                document.body.appendChild(completionMsg);

                // 3ç§’åè‡ªåŠ¨ç§»é™¤é€šçŸ¥
                setTimeout(() => {
                    if (completionMsg.parentNode) {
                        document.body.removeChild(completionMsg);
                    }
                }, 3000);
            }

            /**
             * è§¦å‘AIå¯¹ç‰¹å®šåŠ¨æ€çš„å›å¤ - åŸºäºtriggerInactiveAiActionä½†é’ˆå¯¹ç‰¹å®šåŠ¨æ€
             */
            async function triggerAiPostReply(chatId, postId) {
                const chat = state.chats[chatId];
                if (!chat) return false;

                const { proxyUrl, apiKey, model } = state.apiConfig;
                if (!proxyUrl || !apiKey || !model) return false;

                // è·å–åŠ¨æ€ä¿¡æ¯
                const post = await db.qzonePosts.get(postId);
                if (!post) return false;

                const now = new Date();
                const currentTime = now.toLocaleTimeString('zh-CN', { hour: 'numeric', minute: 'numeric', hour12: true });
                const userNickname = state.qzoneSettings.nickname;

                // æ„å»ºåŠ¨æ€ä¸Šä¸‹æ–‡
                let postContent = '';
                if (post.type === 'shuoshuo') {
                    postContent = post.content || '';
                } else if (post.type === 'image_post') {
                    postContent = (post.publicText || '') + (post.imageDescription ? ` [å›¾ç‰‡æè¿°: ${post.imageDescription}]` : '');
                } else if (post.type === 'text_image') {
                    postContent = (post.publicText || '') + (post.hiddenContent ? ` [å›¾ç‰‡æè¿°: ${post.hiddenContent}]` : '');
                }

                // æ„å»ºè¯„è®ºä¸Šä¸‹æ–‡
                let commentsContext = '';
                if (post.comments && post.comments.length > 0) {
                    commentsContext = '\nç°æœ‰è¯„è®º:\n' + post.comments.map(c => `${c.commenterName}: ${c.text}`).join('\n');
                }

                // è·å–ä¸–ç•Œä¹¦ä¸Šä¸‹æ–‡
                let worldBookContextForAction = '';
                const coreWorldBookName = "maininfo";
                const coreWorldBook = state.worldBooks.find(wb => wb.name === coreWorldBookName);
                if (coreWorldBook && coreWorldBook.content) {
                    worldBookContextForAction = `\n\n# æ ¸å¿ƒç¤¾äº¤å…³ç³»è®¾å®š (ä½ å¿…é¡»ä¸¥æ ¼éµå®ˆä»¥ä¸‹æ‰€æœ‰è®¾å®š)\n${coreWorldBook.content}\n`;
                }

                // æ„å»ºç³»ç»Ÿæç¤º
                const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ ç°åœ¨æ‰®æ¼”ä¸€ä¸ªåä¸º"${chat.name}"çš„è§’è‰²ã€‚ç”¨æˆ·å¸Œæœ›ä½ å¯¹ä¸€æ¡ç‰¹å®šçš„åŠ¨æ€è¿›è¡Œå›å¤ã€‚

# ä½ çš„è§’è‰²è®¾å®š
${chat.settings.aiPersona}

# åŠ¨æ€ä¿¡æ¯
- åŠ¨æ€ID: ${postId}
- åŠ¨æ€å†…å®¹: "${postContent}"
- å‘å¸ƒè€…: ${post.authorId === 'user' ? userNickname : (state.chats[post.authorId]?.name || 'æœªçŸ¥')}
${commentsContext}

# ä½ çš„å¯é€‰è¡ŒåŠ¨ (è¯·æ ¹æ®ä½ çš„æ€§æ ¼ã€é€‰æ‹©ä¸€é¡¹ã€‘æ‰§è¡Œ):
1. **è¯„è®ºåŠ¨æ€**: ä½¿ç”¨ \`{"type": "qzone_comment", "postId": ${postId}, "commentText": "ä½ çš„è¯„è®ºå†…å®¹"}\`
2. **ç‚¹èµåŠ¨æ€**: ä½¿ç”¨ \`{"type": "qzone_like", "postId": ${postId}}\`
3. **æ—¢è¯„è®ºåˆç‚¹èµ**: è¿”å›åŒ…å«ä¸¤ä¸ªæ“ä½œçš„JSONæ•°ç»„

è¯·æ ¹æ®ä½ çš„æ€§æ ¼ç‰¹ç‚¹å’Œå¯¹è¿™æ¡åŠ¨æ€çš„çœ‹æ³•ï¼Œé€‰æ‹©åˆé€‚çš„å›åº”æ–¹å¼ã€‚

${worldBookContextForAction}

ç°åœ¨æ˜¯ ${currentTime}ï¼Œè¯·åšå‡ºä½ çš„å›åº”ã€‚`;

                try {
                    const data = await makeAPIRequest(proxyUrl, apiKey, model, [{ role: 'user', content: systemPrompt }], 0.8);

                    if (!data.choices || data.choices.length === 0 || !data.choices[0].message.content) {
                        return false;
                    }

                    const aiResponse = data.choices[0].message.content.trim();

                    // è§£æAIå›å¤
                    let actions = [];
                    try {
                        // æ¸…ç†AIå›å¤ï¼Œç§»é™¤markdownä»£ç å—æ ‡è®°
                        let cleanedResponse = aiResponse.trim();
                        if (cleanedResponse.startsWith('```json')) {
                            cleanedResponse = cleanedResponse.replace(/^```json\s*/, '').replace(/```\s*$/, '');
                        } else if (cleanedResponse.startsWith('```')) {
                            cleanedResponse = cleanedResponse.replace(/^```\s*/, '').replace(/```\s*$/, '');
                        }

                        const parsed = JSON.parse(cleanedResponse);
                        actions = Array.isArray(parsed) ? parsed : [parsed];
                    } catch (e) {
                        return false;
                    }

                    // å¤„ç†AIçš„è¡ŒåŠ¨
                    for (const action of actions) {
                        if (action.type === 'qzone_comment') {
                            const postToComment = await db.qzonePosts.get(parseInt(action.postId));
                            if (postToComment) {
                                if (!postToComment.comments) postToComment.comments = [];
                                const newComment = {
                                    commenterName: chat.name,
                                    text: action.commentText,
                                    timestamp: Date.now()
                                };
                                postToComment.comments.push(newComment);
                                await db.qzonePosts.update(postToComment.id, { comments: postToComment.comments });
                            }
                        } else if (action.type === 'qzone_like') {
                            const postToLike = await db.qzonePosts.get(parseInt(action.postId));
                            if (postToLike) {
                                if (!postToLike.likes) postToLike.likes = [];
                                if (!postToLike.likes.includes(chat.name)) {
                                    postToLike.likes.push(chat.name);
                                    await db.qzonePosts.update(postToLike.id, { likes: postToLike.likes });
                                }
                            }
                        }
                    }

                    return true;

                } catch (error) {
                    return false;
                }
            }
            // â–²â–²â–² AIå›å¤æ¨¡æ€æ¡†ç›¸å…³å‡½æ•°ç»“æŸ â–²â–²â–²

            // â–¼â–¼â–¼ AIå‘åŠ¨æ€æ¨¡æ€æ¡†ç›¸å…³å‡½æ•° â–¼â–¼â–¼
            let selectedAiForPost = null;

            /**
             * æ˜¾ç¤ºAIå‘åŠ¨æ€é€‰æ‹©æ¨¡æ€æ¡†
             */
            function showAiPostModal() {
                // è·å–æ‰€æœ‰å¯ç”¨çš„AI
                const availableAis = [];
                for (const chatId in state.chats) {
                    const chat = state.chats[chatId];
                    if (!chat.isGroup) {
                        const aiAvatar = chat.settings.aiAvatar || defaultAvatar;
                        availableAis.push({
                            id: chatId,
                            name: chat.name,
                            avatar: aiAvatar,
                            status: chat.relationship?.status || 'friend'
                        });
                    }
                }

                if (availableAis.length === 0) {
                    alert('æ²¡æœ‰å¯ç”¨çš„AIè§’è‰²');
                    return;
                }

                // ç”ŸæˆAIåˆ—è¡¨HTML (å•é€‰)
                const aiListHtml = availableAis.map(ai => `
        <div class="ai-selection-item" onclick="selectAiForPost('${ai.id}')">
            <input type="radio" name="ai-post-selection" id="ai-post-${ai.id}" data-ai-id="${ai.id}">
            <img src="${ai.avatar}" class="ai-selection-avatar" alt="${ai.name}">
            <div class="ai-selection-info">
                <div class="ai-selection-name">${ai.name}</div>
                <div class="ai-selection-status">${ai.status === 'friend' ? 'å¥½å‹' : ai.status}</div>
            </div>
        </div>
    `).join('');

                document.getElementById('ai-post-selection-list').innerHTML = aiListHtml;
                document.getElementById('ai-post-modal').classList.add('visible');
            }

            /**
             * éšè—AIå‘åŠ¨æ€é€‰æ‹©æ¨¡æ€æ¡†
             */
            function hideAiPostModal() {
                document.getElementById('ai-post-modal').classList.remove('visible');
                selectedAiForPost = null;
            }

            /**
             * é€‰æ‹©AIå‘åŠ¨æ€
             */
            window.selectAiForPost = function (aiId) {
                selectedAiForPost = aiId;
                const radio = document.getElementById(`ai-post-${aiId}`);
                if (radio) {
                    radio.checked = true;
                }
            }

            /**
             * ç¡®è®¤AIå‘åŠ¨æ€
             */
            async function confirmAiPost() {
                // Check for selected radio button instead of relying on variable
                const selectedRadio = document.querySelector('input[name="ai-post-selection"]:checked');
                if (!selectedRadio) {
                    alert('è¯·é€‰æ‹©ä¸€ä¸ªAI');
                    return;
                }

                const selectedAiId = selectedRadio.dataset.aiId;

                hideAiPostModal();

                // æ˜¾ç¤ºå¤„ç†ä¸­æç¤º
                const processingMsg = document.createElement('div');
                processingMsg.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 10px; z-index: 9999; text-align: center;';
                processingMsg.innerHTML = `<div>ğŸ¤– AIæ­£åœ¨æ€è€ƒå‘ä»€ä¹ˆåŠ¨æ€...</div>`;
                document.body.appendChild(processingMsg);

                try {
                    // Define currentTimeString in the global scope to fix the reference error
                    const now = new Date();
                    window.currentTimeString = now.toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false });

                    // ä½¿ç”¨ä¿®æ”¹åçš„triggerInactiveAiActionï¼Œå¼ºåˆ¶æ¿€æ´»å’Œå¼ºåˆ¶å‘åŠ¨æ€
                    const success = await triggerInactiveAiAction(selectedAiId, true, true);

                    // ç§»é™¤å¤„ç†ä¸­æç¤º
                    if (processingMsg.parentNode) {
                        document.body.removeChild(processingMsg);
                    }

                    // æ˜¾ç¤ºå®Œæˆé€šçŸ¥
                    const completionMsg = document.createElement('div');
                    const bgColor = success === true ? 'rgba(0,128,0,0.9)' : 'rgba(255,165,0,0.9)';
                    completionMsg.style.cssText = `position: fixed; top: 20px; right: 20px; background: ${bgColor}; color: white; padding: 15px 20px; border-radius: 10px; z-index: 9999; font-size: 14px;`;
                    completionMsg.innerHTML = success === true ? 'âœ… AIå‘åŠ¨æ€å®Œæˆ' : 'âš ï¸ AIå‘åŠ¨æ€å¤±è´¥';
                    document.body.appendChild(completionMsg);

                    // 3ç§’åè‡ªåŠ¨ç§»é™¤é€šçŸ¥
                    setTimeout(() => {
                        if (completionMsg.parentNode) {
                            document.body.removeChild(completionMsg);
                        }
                    }, 3000);

                    // åˆ·æ–°åŠ¨æ€åˆ—è¡¨
                    if (document.getElementById('qzone-screen').classList.contains('active')) {
                        await renderQzonePosts();
                    }

                } catch (error) {
                    // ç§»é™¤å¤„ç†ä¸­æç¤º
                    if (processingMsg.parentNode) {
                        document.body.removeChild(processingMsg);
                    }
                    alert('AIå‘åŠ¨æ€å¤±è´¥ï¼Œè¯·é‡è¯•');
                }
            }
            // â–²â–²â–² AIå‘åŠ¨æ€æ¨¡æ€æ¡†ç›¸å…³å‡½æ•°ç»“æŸ â–²â–²â–²

            /**
             * ç½®é¡¶åŠ¨æ€
             */
            async function pinPost() {
                if (!activePostId) return;

                const post = await db.qzonePosts.get(activePostId);
                if (!post) return;

                try {
                    // æ›´æ–°åŠ¨æ€çš„ç½®é¡¶çŠ¶æ€
                    await db.qzonePosts.update(activePostId, { isPinned: true });

                    // å…³é—­æ“ä½œèœå•
                    hidePostActions();

                    // åˆ·æ–°åŠ¨æ€åˆ—è¡¨
                    if (document.getElementById('qzone-screen').classList.contains('active')) {
                        await renderQzonePosts();
                    }

                    // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
                    await showCustomAlert('ç½®é¡¶æˆåŠŸ', 'åŠ¨æ€å·²ç½®é¡¶');

                } catch (error) {
                    console.error('ç½®é¡¶åŠ¨æ€å¤±è´¥:', error);
                    await showCustomAlert('ç½®é¡¶å¤±è´¥', 'ç½®é¡¶åŠ¨æ€æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·é‡è¯•');
                }
            }

            /**
             * å–æ¶ˆç½®é¡¶åŠ¨æ€
             */
            async function unpinPost() {
                if (!activePostId) return;

                const post = await db.qzonePosts.get(activePostId);
                if (!post) return;

                try {
                    // æ›´æ–°åŠ¨æ€çš„ç½®é¡¶çŠ¶æ€
                    await db.qzonePosts.update(activePostId, { isPinned: false });

                    // å…³é—­æ“ä½œèœå•
                    hidePostActions();

                    // åˆ·æ–°åŠ¨æ€åˆ—è¡¨
                    if (document.getElementById('qzone-screen').classList.contains('active')) {
                        await renderQzonePosts();
                    }

                    // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
                    await showCustomAlert('å–æ¶ˆç½®é¡¶æˆåŠŸ', 'åŠ¨æ€å·²å–æ¶ˆç½®é¡¶');

                } catch (error) {
                    console.error('å–æ¶ˆç½®é¡¶åŠ¨æ€å¤±è´¥:', error);
                    await showCustomAlert('å–æ¶ˆç½®é¡¶å¤±è´¥', 'å–æ¶ˆç½®é¡¶åŠ¨æ€æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·é‡è¯•');
                }
            }

            /**
             * åˆ é™¤åŠ¨æ€
             */
            async function deletePost() {
                if (!activePostId) return;

                const post = await db.qzonePosts.get(activePostId);
                if (!post) return;

                // æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
                const confirmed = await showCustomConfirm(
                    'åˆ é™¤åŠ¨æ€',
                    'ç¡®å®šè¦åˆ é™¤è¿™æ¡åŠ¨æ€å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚',
                    { confirmButtonClass: 'btn-danger' }
                );

                if (!confirmed) return;

                try {
                    // ä»æ•°æ®åº“ä¸­åˆ é™¤åŠ¨æ€
                    await db.qzonePosts.delete(activePostId);

                    // åˆ é™¤æ‰€æœ‰èŠå¤©è®°å½•ä¸­å¼•ç”¨æ­¤åŠ¨æ€çš„ç³»ç»Ÿæ¶ˆæ¯
                    const allChats = await db.chats.toArray();
                    for (const chat of allChats) {
                        const originalLength = chat.history.length;
                        chat.history = chat.history.filter(msg => {
                            // åˆ é™¤å¼•ç”¨æ­¤åŠ¨æ€IDçš„ç³»ç»Ÿæ¶ˆæ¯
                            if (msg.role === 'system' && msg.isHidden && msg.content.includes(`(ID: ${activePostId})`)) {
                                return false;
                            }
                            return true;
                        });

                        // åªæœ‰åœ¨å†å²è®°å½•å‘ç”Ÿå˜åŒ–æ—¶æ‰æ›´æ–°æ•°æ®åº“
                        if (chat.history.length !== originalLength) {
                            await db.chats.put(chat);
                            // æ›´æ–°å†…å­˜ä¸­çš„çŠ¶æ€
                            if (state.chats[chat.id]) {
                                state.chats[chat.id].history = chat.history;
                            }
                        }
                    }

                    // å…³é—­æ“ä½œèœå•
                    hidePostActions();

                    // åˆ·æ–°åŠ¨æ€åˆ—è¡¨
                    if (document.getElementById('qzone-screen').classList.contains('active')) {
                        await renderQzonePosts();
                    }

                    // å¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹æŸä¸ªèŠå¤©ç•Œé¢ï¼Œåˆ·æ–°å®ƒ
                    if (state.activeChatId && document.getElementById('chat-interface-screen').classList.contains('active')) {
                        renderChatInterface(state.activeChatId);
                    }

                    // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
                    await showCustomAlert('åˆ é™¤æˆåŠŸ', 'åŠ¨æ€å·²åˆ é™¤');

                } catch (error) {
                    console.error('åˆ é™¤åŠ¨æ€å¤±è´¥:', error);
                    await showCustomAlert('åˆ é™¤å¤±è´¥', 'åˆ é™¤åŠ¨æ€æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·é‡è¯•');
                }
            }

            /**
             * å¤åˆ¶åŠ¨æ€å†…å®¹
             */
            async function copyPostContent() {
                if (!activePostId) return;
                const post = await db.qzonePosts.get(activePostId);
                if (!post) return;

                let textToCopy = post.content || post.publicText || post.hiddenContent || post.imageDescription || "ï¼ˆæ— æ–‡å­—å†…å®¹ï¼‰";

                try {
                    await navigator.clipboard.writeText(textToCopy);
                    await showCustomAlert('å¤åˆ¶æˆåŠŸ', 'åŠ¨æ€å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ã€‚');
                } catch (err) {
                    await showCustomAlert('å¤åˆ¶å¤±è´¥', 'æ— æ³•è®¿é—®å‰ªè´´æ¿ã€‚');
                }

                hidePostActions();
            }

            // â–¼â–¼â–¼ ã€å…¨æ–°ã€‘åˆ›å»ºç¾¤èŠä¸æ‹‰äººåŠŸèƒ½æ ¸å¿ƒå‡½æ•° â–¼â–¼â–¼
            let selectedContacts = new Set();

            async function openContactPickerForGroupCreate() {
                selectedContacts.clear(); // æ¸…ç©ºä¸Šæ¬¡é€‰æ‹©

                // ã€æ ¸å¿ƒä¿®å¤ã€‘åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä¸ºâ€œå®Œæˆâ€æŒ‰é’®æ˜ç¡®ç»‘å®šâ€œåˆ›å»ºç¾¤èŠâ€çš„åŠŸèƒ½
                const confirmBtn = document.getElementById('confirm-contact-picker-btn');
                // ä½¿ç”¨å…‹éš†èŠ‚ç‚¹æŠ€å·§ï¼Œæ¸…é™¤æ‰ä¹‹å‰å¯èƒ½ç»‘å®šçš„ä»»ä½•å…¶ä»–äº‹ä»¶ï¼ˆæ¯”å¦‚â€œæ·»åŠ æˆå‘˜â€ï¼‰
                const newConfirmBtn = confirmBtn.cloneNode(true);
                confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
                // é‡æ–°ç»‘å®šæ­£ç¡®çš„â€œåˆ›å»ºç¾¤èŠâ€å‡½æ•°
                newConfirmBtn.addEventListener('click', handleCreateGroup);

                await renderContactPicker();
                showScreen('contact-picker-screen');
            }
            // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

            /**
             * æ¸²æŸ“è”ç³»äººé€‰æ‹©åˆ—è¡¨
             */
            async function renderContactPicker() {
                const listEl = document.getElementById('contact-picker-list');
                listEl.innerHTML = '';

                // åªé€‰æ‹©å•èŠè§’è‰²ä½œä¸ºç¾¤æˆå‘˜å€™é€‰
                const contacts = Object.values(state.chats).filter(chat => !chat.isGroup);

                if (contacts.length === 0) {
                    listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">è¿˜æ²¡æœ‰å¯ä»¥æ‹‰è¿›ç¾¤çš„è”ç³»äººå“¦~</p>';
                    return;
                }

                contacts.forEach(contact => {
                    const item = document.createElement('div');
                    item.className = 'contact-picker-item';
                    item.dataset.contactId = contact.id;
                    item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${contact.name}</span>
        `;
                    listEl.appendChild(item);
                });

                updateContactPickerConfirmButton();
            }

            /**
             * æ›´æ–°â€œå®Œæˆâ€æŒ‰é’®çš„è®¡æ•°
             */
            function updateContactPickerConfirmButton() {
                const btn = document.getElementById('confirm-contact-picker-btn');
                btn.textContent = `å®Œæˆ(${selectedContacts.size})`;
                btn.disabled = selectedContacts.size < 2; // è‡³å°‘éœ€è¦2ä¸ªäººæ‰èƒ½åˆ›å»ºç¾¤èŠ
            }

            /**
             * å¤„ç†åˆ›å»ºç¾¤èŠçš„æœ€ç»ˆé€»è¾‘
             */
            async function handleCreateGroup() {
                if (selectedContacts.size < 2) {
                    alert("åˆ›å»ºç¾¤èŠè‡³å°‘éœ€è¦é€‰æ‹©2ä¸ªè”ç³»äººã€‚");
                    return;
                }

                const groupName = await showCustomPrompt('è®¾ç½®ç¾¤å', 'è¯·è¾“å…¥ç¾¤èŠçš„åå­—', 'æˆ‘ä»¬çš„ç¾¤èŠ');
                if (!groupName || !groupName.trim()) return;

                const newChatId = 'group_' + Date.now();
                const members = [];

                // éå†é€‰ä¸­çš„è”ç³»äººID
                for (const contactId of selectedContacts) {
                    const contactChat = state.chats[contactId];
                    if (contactChat) {
                        // ã€æ ¸å¿ƒã€‘ä»å•èŠè®¾ç½®ä¸­æå–æ•°æ®ï¼Œåˆ›å»ºç¾¤æˆå‘˜å¯¹è±¡
                        members.push({
                            id: contactId, // ä½¿ç”¨å•èŠçš„IDä½œä¸ºæˆå‘˜IDï¼Œæ–¹ä¾¿å…³è”
                            name: contactChat.name,
                            avatar: contactChat.settings.aiAvatar || defaultAvatar,
                            persona: contactChat.settings.aiPersona,
                            avatarFrame: contactChat.settings.aiAvatarFrame || ''
                        });
                    }
                }

                const newGroupChat = {
                    id: newChatId,
                    name: groupName.trim(),
                    isGroup: true,
                    members: members,
                    settings: {
                        myPersona: 'æˆ‘æ˜¯è°å‘€ã€‚',
                        myNickname: 'æˆ‘',
                        maxMemory: 10,
                        groupAvatar: defaultGroupAvatar,
                        myAvatar: defaultMyGroupAvatar,
                        background: '',
                        theme: 'default',
                        fontSize: 13,
                        customCss: '',
                        linkedWorldBookIds: [],
                        aiAvatarFrame: '',
                        myAvatarFrame: '',
                        isBackgroundActivityEnabled: true // <--ã€æ ¸å¿ƒæ–°å¢ã€‘é»˜è®¤å¼€å¯
                    },
                    history: [],
                    musicData: { totalTime: 0 }
                };

                state.chats[newChatId] = newGroupChat;
                await db.chats.put(newGroupChat);

                await renderChatList();
                showScreen('chat-list-screen');
                openChat(newChatId); // åˆ›å»ºåç›´æ¥æ‰“å¼€ç¾¤èŠ
            }
            // â–²â–²â–² æ–°å‡½æ•°ç²˜è´´ç»“æŸ â–²â–²â–²

            // â–¼â–¼â–¼ ã€å…¨æ–°ã€‘ç¾¤æˆå‘˜ç®¡ç†æ ¸å¿ƒå‡½æ•° â–¼â–¼â–¼

            /**
             * æ‰“å¼€ç¾¤æˆå‘˜ç®¡ç†å±å¹•
             */
            function openMemberManagementScreen() {
                if (!state.activeChatId || !state.chats[state.activeChatId].isGroup) return;
                renderMemberManagementList();
                showScreen('member-management-screen');
            }

            /**
             * æ¸²æŸ“ç¾¤æˆå‘˜ç®¡ç†åˆ—è¡¨
             */
            function renderMemberManagementList() {
                const listEl = document.getElementById('member-management-list');
                const chat = state.chats[state.activeChatId];
                listEl.innerHTML = '';

                chat.members.forEach(member => {
                    const item = document.createElement('div');
                    item.className = 'member-management-item';
                    item.innerHTML = `
            <img src="${member.avatar}" class="avatar">
            <span class="name">${member.name}</span>
            <button class="remove-member-btn" data-member-id="${member.id}" title="ç§»å‡ºç¾¤èŠ">-</button>
        `;
                    listEl.appendChild(item);
                });
            }

            /**
             * ä»ç¾¤èŠä¸­ç§»é™¤ä¸€ä¸ªæˆå‘˜
             * @param {string} memberId - è¦ç§»é™¤çš„æˆå‘˜ID
             */
            async function removeMemberFromGroup(memberId) {
                const chat = state.chats[state.activeChatId];
                const memberIndex = chat.members.findIndex(m => m.id === memberId);

                if (memberIndex === -1) return;

                // å®‰å…¨æ£€æŸ¥ï¼Œç¾¤èŠè‡³å°‘ä¿ç•™2äºº
                if (chat.members.length <= 2) {
                    alert("ç¾¤èŠäººæ•°ä¸èƒ½å°‘äº2äººã€‚");
                    return;
                }

                const memberName = chat.members[memberIndex].name;
                const confirmed = await showCustomConfirm(
                    'ç§»å‡ºæˆå‘˜',
                    `ç¡®å®šè¦å°†â€œ${memberName}â€ç§»å‡ºç¾¤èŠå—ï¼Ÿ`,
                    { confirmButtonClass: 'btn-danger' }
                );

                if (confirmed) {
                    chat.members.splice(memberIndex, 1);
                    await db.chats.put(chat);
                    renderMemberManagementList(); // åˆ·æ–°æˆå‘˜ç®¡ç†åˆ—è¡¨
                    document.getElementById('chat-settings-btn').click(); // ã€æ ¸å¿ƒä¿®æ­£ã€‘æ¨¡æ‹Ÿç‚¹å‡»è®¾ç½®æŒ‰é’®ï¼Œå¼ºåˆ¶åˆ·æ–°æ•´ä¸ªå¼¹çª—
                }
            }

            /**
             * æ‰“å¼€è”ç³»äººé€‰æ‹©å™¨ï¼Œç”¨äºæ‹‰äººå…¥ç¾¤
             */
            async function openContactPickerForAddMember() {
                selectedContacts.clear(); // æ¸…ç©ºé€‰æ‹©

                const chat = state.chats[state.activeChatId];
                const existingMemberIds = new Set(chat.members.map(m => m.id));

                // æ¸²æŸ“è”ç³»äººåˆ—è¡¨ï¼Œå¹¶è‡ªåŠ¨æ’é™¤å·²åœ¨ç¾¤å†…çš„æˆå‘˜
                const listEl = document.getElementById('contact-picker-list');
                listEl.innerHTML = '';
                const contacts = Object.values(state.chats).filter(c => !c.isGroup && !existingMemberIds.has(c.id));

                if (contacts.length === 0) {
                    listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">æ²¡æœ‰æ›´å¤šå¯ä»¥é‚€è¯·çš„å¥½å‹äº†ã€‚</p>';
                    document.getElementById('confirm-contact-picker-btn').style.display = 'none'; // æ²¡æœ‰äººå¯é€‰ï¼Œéšè—å®ŒæˆæŒ‰é’®
                } else {
                    document.getElementById('confirm-contact-picker-btn').style.display = 'block';
                    contacts.forEach(contact => {
                        const item = document.createElement('div');
                        item.className = 'contact-picker-item';
                        item.dataset.contactId = contact.id;
                        item.innerHTML = `
                <div class="checkbox"></div>
                <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
                <span class="name">${contact.name}</span>
            `;
                        listEl.appendChild(item);
                    });
                }

                // æ›´æ–°æŒ‰é’®çŠ¶æ€å¹¶æ˜¾ç¤ºå±å¹•
                updateContactPickerConfirmButton();
                showScreen('contact-picker-screen');
            }

            /**
             * å¤„ç†å°†é€‰ä¸­çš„è”ç³»äººåŠ å…¥ç¾¤èŠçš„é€»è¾‘
             */
            async function handleAddMembersToGroup() {
                if (selectedContacts.size === 0) {
                    alert("è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªè¦æ·»åŠ çš„è”ç³»äººã€‚");
                    return;
                }

                const chat = state.chats[state.activeChatId];

                for (const contactId of selectedContacts) {
                    const contactChat = state.chats[contactId];
                    if (contactChat) {
                        chat.members.push({
                            id: contactId,
                            name: contactChat.name,
                            avatar: contactChat.settings.aiAvatar || defaultAvatar,
                            persona: contactChat.settings.aiPersona,
                            avatarFrame: contactChat.settings.aiAvatarFrame || ''
                        });
                    }
                }

                await db.chats.put(chat);
                openMemberManagementScreen(); // è¿”å›åˆ°ç¾¤æˆå‘˜ç®¡ç†ç•Œé¢
                renderGroupMemberSettings(chat.members); // åŒæ—¶æ›´æ–°èŠå¤©è®¾ç½®é‡Œçš„å¤´åƒ
            }

            // â–¼â–¼â–¼ è¯·ç”¨è¿™ä¸ªã€æœ€ç»ˆä¿®æ­£ç‰ˆã€‘æ›¿æ¢æ—§çš„ createNewMemberInGroup å‡½æ•° â–¼â–¼â–¼
            async function createNewMemberInGroup() {
                const name = await showCustomPrompt('åˆ›å»ºæ–°æˆå‘˜', 'è¯·è¾“å…¥æ–°æˆå‘˜çš„åå­—');
                if (!name || !name.trim()) return;

                const persona = await showCustomPrompt('è®¾ç½®äººè®¾', `è¯·è¾“å…¥â€œ${name}â€çš„äººè®¾`, '', 'textarea');
                if (persona === null) return; // ç”¨æˆ·ç‚¹äº†å–æ¶ˆ

                const chat = state.chats[state.activeChatId];
                const newMember = {
                    id: 'npc_' + Date.now(),
                    name: name.trim(),
                    avatar: defaultGroupMemberAvatar,
                    persona: persona,
                    avatarFrame: ''
                };

                chat.members.push(newMember);
                await db.chats.put(chat);

                // ã€æ ¸å¿ƒä¿®æ­£ã€‘åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä¸ä»…åˆ·æ–°å½“å‰é¡µé¢çš„åˆ—è¡¨...
                renderMemberManagementList();
                // ã€æ ¸å¿ƒä¿®æ­£ã€‘...è¿˜æ‰‹åŠ¨åˆ·æ–°èƒŒåâ€œèŠå¤©è®¾ç½®â€å¼¹çª—é‡Œçš„æˆå‘˜å¤´åƒåˆ—è¡¨ï¼
                renderGroupMemberSettings(chat.members);

                alert(`æ–°æˆå‘˜â€œ${name}â€å·²æˆåŠŸåŠ å…¥ç¾¤èŠï¼`);
            }
            // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

            // â–¼â–¼â–¼ ã€å…¨æ–°ã€‘å¤–å–è¯·æ±‚å€’è®¡æ—¶å‡½æ•° â–¼â–¼â–¼
            function startWaimaiCountdown(element, endTime) {
                const timerId = setInterval(() => {
                    const now = Date.now();
                    const distance = endTime - now;

                    if (distance < 0) {
                        clearInterval(timerId);
                        element.innerHTML = '<span>å·²</span><span>è¶…</span><span>æ—¶</span>';
                        return;
                    }

                    const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                    const seconds = Math.floor((distance % (1000 * 60)) / 1000);

                    const minStr = String(minutes).padStart(2, '0');
                    const secStr = String(seconds).padStart(2, '0');

                    element.innerHTML = `<span>${minStr.charAt(0)}</span><span>${minStr.charAt(1)}</span> : <span>${secStr.charAt(0)}</span><span>${secStr.charAt(1)}</span>`;
                }, 1000);
                return timerId;
            }

            function cleanupWaimaiTimers() {
                for (const timestamp in waimaiTimers) {
                    clearInterval(waimaiTimers[timestamp]);
                }
                waimaiTimers = {};
            }
            // â–²â–²â–² æ–°å‡½æ•°ç²˜è´´ç»“æŸ â–²â–²â–²

            async function handleWaimaiResponse(originalTimestamp, choice) {
                const chat = state.chats[state.activeChatId];
                if (!chat) return;

                const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
                if (messageIndex === -1) return;

                // 1. æ›´æ–°åŸå§‹æ¶ˆæ¯çš„çŠ¶æ€
                const originalMessage = chat.history[messageIndex];
                originalMessage.status = choice;

                // ã€æ ¸å¿ƒä¿®æ­£ã€‘è®°å½•æ”¯ä»˜è€…ï¼Œå¹¶æ„å»ºå¯¹AIæ›´æ¸…æ™°çš„ç³»ç»Ÿæ¶ˆæ¯
                let systemContent;
                const myNickname = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';

                if (choice === 'paid') {
                    originalMessage.paidBy = myNickname; // è®°å½•æ˜¯ç”¨æˆ·ä»˜çš„é’±
                    systemContent = `[ç³»ç»Ÿæç¤ºï¼šä½  (${myNickname}) ä¸º ${originalMessage.senderName} çš„å¤–å–è®¢å•ï¼ˆæ—¶é—´æˆ³: ${originalTimestamp}ï¼‰å®Œæˆäº†æ”¯ä»˜ã€‚æ­¤è®¢å•å·²å…³é—­ï¼Œå…¶ä»–æˆå‘˜ä¸èƒ½å†æ”¯ä»˜ã€‚]`;
                } else {
                    systemContent = `[ç³»ç»Ÿæç¤ºï¼šä½  (${myNickname}) æ‹’ç»äº† ${originalMessage.senderName} çš„å¤–å–ä»£ä»˜è¯·æ±‚ï¼ˆæ—¶é—´æˆ³: ${originalTimestamp}ï¼‰ã€‚]`;
                }

                // 2. åˆ›å»ºä¸€æ¡æ–°çš„ã€å¯¹ç”¨æˆ·éšè—çš„ç³»ç»Ÿæ¶ˆæ¯ï¼Œå‘ŠçŸ¥AIç»“æœ
                const systemNote = {
                    role: 'system',
                    content: systemContent,
                    timestamp: Date.now(),
                    isHidden: true
                };
                chat.history.push(systemNote);

                // 3. ä¿å­˜æ›´æ–°åˆ°æ•°æ®åº“å¹¶åˆ·æ–°UI
                await db.chats.put(chat);
                renderChatInterface(state.activeChatId);

                // 4. ã€å¯é€‰ä½†æ¨èã€‘åœ¨æ”¯ä»˜æˆåŠŸåï¼Œä¸»åŠ¨è§¦å‘ä¸€æ¬¡AIå“åº”
                if (choice === 'paid') {
                    triggerAiResponse();
                }
            }

            let videoCallState = {
                isActive: false,
                isAwaitingResponse: false,
                isGroupCall: false,
                activeChatId: null,
                initiator: null,
                startTime: null,
                participants: [],
                isUserParticipating: true,
                // --- ã€æ ¸å¿ƒæ–°å¢ã€‘---
                callHistory: [], // ç”¨äºå­˜å‚¨é€šè¯ä¸­çš„å¯¹è¯å†å²
                preCallContext: "" // ç”¨äºå­˜å‚¨é€šè¯å‰çš„èŠå¤©æ‘˜è¦
            };

            let callTimerInterval = null; // ç”¨äºå­˜å‚¨è®¡æ—¶å™¨çš„ID

            /**
             * ã€æ€»å…¥å£ã€‘ç”¨æˆ·ç‚¹å‡»â€œå‘èµ·è§†é¢‘é€šè¯â€æˆ–â€œå‘èµ·ç¾¤è§†é¢‘â€æŒ‰é’®
             */
            async function handleInitiateCall() {
                if (!state.activeChatId || videoCallState.isActive || videoCallState.isAwaitingResponse) return;
                const chat = state.chats[state.activeChatId];

                const confirmed = await showCustomConfirm(
                    'å‘èµ·é€šè¯',
                    `å³å°†æ‹¨é€š ${chat.name} çš„è§†é¢‘ç”µè¯ï¼Œè¦ç»§ç»­å—ï¼Ÿ`,
                    { confirmButtonClass: 'confirm-btn' }
                );
                if (!confirmed) {
                    return;
                }
                videoCallState.isGroupCall = chat.isGroup;
                videoCallState.isAwaitingResponse = true;
                videoCallState.initiator = 'user';
                videoCallState.activeChatId = chat.id;
                videoCallState.isUserParticipating = true; // ç”¨æˆ·è‡ªå·±å‘èµ·çš„ï¼Œå½“ç„¶æ˜¯å‚ä¸è€…

                // æ ¹æ®æ˜¯å•èŠè¿˜æ˜¯ç¾¤èŠï¼Œæ˜¾ç¤ºä¸åŒçš„å‘¼å«ç•Œé¢
                if (chat.isGroup) {
                    document.getElementById('outgoing-call-avatar').src = chat.settings.myAvatar || defaultMyGroupAvatar;
                    document.getElementById('outgoing-call-name').textContent = chat.settings.myNickname || 'æˆ‘';
                } else {
                    document.getElementById('outgoing-call-avatar').src = chat.settings.aiAvatar || defaultAvatar;
                    document.getElementById('outgoing-call-name').textContent = chat.name;
                }
                document.querySelector('#outgoing-call-screen .caller-text').textContent = chat.isGroup ? "æ­£åœ¨å‘¼å«æ‰€æœ‰æˆå‘˜..." : "æ­£åœ¨å‘¼å«...";
                showScreen('outgoing-call-screen');

                // å‡†å¤‡å¹¶å‘é€ç³»ç»Ÿæ¶ˆæ¯ç»™AI
                const requestMessage = {
                    role: 'system',
                    content: chat.isGroup
                        ? `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ· (${chat.settings.myNickname || 'æˆ‘'}) å‘èµ·äº†ç¾¤è§†é¢‘é€šè¯è¯·æ±‚ã€‚è¯·ä½ ä»¬å„è‡ªå†³ç­–ï¼Œå¹¶ä½¿ç”¨ "group_call_response" æŒ‡ä»¤ï¼Œè®¾ç½® "decision" ä¸º "join" æˆ– "decline" æ¥å›åº”ã€‚]`
                        : `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·å‘ä½ å‘èµ·äº†è§†é¢‘é€šè¯è¯·æ±‚ã€‚è¯·æ ¹æ®ä½ çš„äººè®¾ï¼Œä½¿ç”¨ "video_call_response" æŒ‡ä»¤ï¼Œå¹¶è®¾ç½® "decision" ä¸º "accept" æˆ– "reject" æ¥å›åº”ã€‚]`,
                    timestamp: Date.now(),
                    isHidden: true,
                };
                chat.history.push(requestMessage);
                await db.chats.put(chat);

                // è§¦å‘AIå“åº”
                await triggerAiResponse();
            }


            function startVideoCall() {
                const chat = state.chats[videoCallState.activeChatId];
                if (!chat) return;

                videoCallState.isActive = true;
                videoCallState.isAwaitingResponse = false;
                videoCallState.startTime = Date.now();
                videoCallState.callHistory = []; // ã€æ–°å¢ã€‘æ¸…ç©ºä¸Šä¸€æ¬¡é€šè¯çš„å†å²

                // --- ã€æ ¸å¿ƒæ–°å¢ï¼šæŠ“å–é€šè¯å‰ä¸Šä¸‹æ–‡ã€‘---
                const preCallHistory = chat.history.slice(-5); // å–æœ€å5æ¡ä½œä¸ºä¸Šä¸‹æ–‡
                videoCallState.preCallContext = preCallHistory.map(msg => {
                    const sender = msg.role === 'user' ? (chat.settings.myNickname || 'æˆ‘') : (msg.senderName || chat.name);
                    return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                }).join('\n');
                // --- æ–°å¢ç»“æŸ ---

                updateParticipantAvatars();

                document.getElementById('video-call-main').innerHTML = `<em>${videoCallState.isGroupCall ? 'ç¾¤èŠå·²å»ºç«‹...' : 'æ­£åœ¨æ¥é€š...'}</em>`;
                showScreen('video-call-screen');

                document.getElementById('user-speak-btn').style.display = videoCallState.isUserParticipating ? 'block' : 'none';
                document.getElementById('join-call-btn').style.display = videoCallState.isUserParticipating ? 'none' : 'block';

                if (callTimerInterval) clearInterval(callTimerInterval);
                callTimerInterval = setInterval(updateCallTimer, 1000);
                updateCallTimer();

                triggerAiInCallAction();
            }

            /**
             * ã€æ ¸å¿ƒã€‘ç»“æŸè§†é¢‘é€šè¯
             */
            async function endVideoCall() {
                if (!videoCallState.isActive) return;

                const duration = Math.floor((Date.now() - videoCallState.startTime) / 1000);
                const minutes = Math.floor(duration / 60);
                const seconds = duration % 60;
                const durationText = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                const endCallText = `é€šè¯ç»“æŸï¼Œæ—¶é•¿ ${durationText}`;

                const chat = state.chats[videoCallState.activeChatId];
                if (chat) {

                    // --- ã€æ ¸å¿ƒé‡æ„ï¼šåˆ›å»ºé€šè¯æ€»ç»“æ¶ˆæ¯ã€‘ ---
                    let summaryMessage = {
                        role: videoCallState.initiator === 'user' ? 'user' : 'assistant',
                        content: endCallText,
                        timestamp: Date.now(),
                    };

                    // ã€å…³é”®ã€‘ä¸ºç¾¤èŠçš„ assistant æ¶ˆæ¯è¡¥å…… senderName
                    if (chat.isGroup && summaryMessage.role === 'assistant') {
                        // åœ¨ç¾¤èŠä¸­ï¼Œé€šè¯ç»“æŸçš„æ¶ˆæ¯åº”è¯¥ç”±â€œå‘èµ·è€…â€æ¥è¯´
                        // videoCallState.callRequester ä¿å­˜äº†æœ€åˆå‘èµ·é€šè¯çš„é‚£ä¸ªAIçš„åå­—
                        summaryMessage.senderName = videoCallState.callRequester || chat.members[0]?.name || chat.name;
                    }

                    chat.history.push(summaryMessage);

                    // --- ã€æ ¸å¿ƒé‡æ„ï¼šè§¦å‘é€šè¯æ€»ç»“ã€‘---
                    const callSummaryPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªå¯¹è¯æ€»ç»“åŠ©æ‰‹ã€‚ä¸‹é¢çš„â€œé€šè¯è®°å½•â€æ˜¯ä¸€æ®µåˆšåˆšç»“æŸçš„è§†é¢‘é€šè¯å†…å®¹ã€‚è¯·ä½ ç”¨1-2å¥è¯ï¼Œç²¾ç‚¼åœ°æ€»ç»“å‡ºè¿™æ¬¡é€šè¯çš„æ ¸å¿ƒå†…å®¹æˆ–è¾¾æˆçš„å…±è¯†ã€‚
ä½ çš„æ€»ç»“å°†ä½œä¸ºä¸€æ¡éšè—çš„ç³»ç»Ÿæç¤ºï¼Œå¸®åŠ©AIåœ¨æ¥ä¸‹æ¥çš„èŠå¤©ä¸­è®°ä½è¿™æ¬¡é€šè¯å‘ç”Ÿäº†ä»€ä¹ˆã€‚

# é€šè¯è®°å½•:
${videoCallState.callHistory.map(h => `${h.role}: ${h.content}`).join('\n')}

è¯·ç›´æ¥è¾“å‡ºæ€»ç»“å†…å®¹ï¼Œä¸è¦åŠ ä»»ä½•é¢å¤–çš„å‰ç¼€æˆ–è§£é‡Šã€‚`;

                    try {
                        const { proxyUrl, apiKey, model } = state.apiConfig;
                        const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                            body: JSON.stringify({
                                model: model,
                                messages: [{ role: 'system', content: callSummaryPrompt }],
                                temperature: 0.5
                            })
                        });
                        if (response.ok) {
                            const data = await response.json();
                            const callSummaryText = data.choices[0].message.content;
                            const hiddenSummary = {
                                role: 'system',
                                content: `[ç³»ç»Ÿæç¤ºï¼šåˆšæ‰çš„è§†é¢‘é€šè¯å†…å®¹æ‘˜è¦ï¼š${callSummaryText}]`,
                                timestamp: Date.now() + 1,
                                isHidden: true
                            };
                            chat.history.push(hiddenSummary);
                        }
                    } catch (e) {
                        console.error("é€šè¯æ€»ç»“å¤±è´¥:", e);
                    }

                    await db.chats.put(chat);
                }

                // æ¸…ç†å’Œé‡ç½®
                clearInterval(callTimerInterval);
                callTimerInterval = null;
                videoCallState = { isActive: false, isAwaitingResponse: false, isGroupCall: false, activeChatId: null, initiator: null, startTime: null, participants: [], isUserParticipating: true, callHistory: [], preCallContext: "" };

                // ã€é‡è¦ã€‘ç¡®ä¿åœ¨æ‰€æœ‰æ“ä½œå®Œæˆåå†æ‰“å¼€èŠå¤©
                if (chat) {
                    openChat(chat.id);
                }
            }

            /**
             * ã€å…¨æ–°ã€‘æ›´æ–°é€šè¯ç•Œé¢çš„å‚ä¸è€…å¤´åƒç½‘æ ¼
             */
            function updateParticipantAvatars() {
                const grid = document.getElementById('participant-avatars-grid');
                grid.innerHTML = '';
                const chat = state.chats[videoCallState.activeChatId];
                if (!chat) return;

                let participantsToRender = [];

                // â˜… æ ¸å¿ƒä¿®æ­£ï¼šåŒºåˆ†ç¾¤èŠå’Œå•èŠ
                if (videoCallState.isGroupCall) {
                    // ç¾¤èŠé€»è¾‘ï¼šæ˜¾ç¤ºæ‰€æœ‰å·²åŠ å…¥çš„AIæˆå‘˜
                    participantsToRender = [...videoCallState.participants];
                    // å¦‚æœç”¨æˆ·ä¹Ÿå‚ä¸äº†ï¼Œå°±æŠŠç”¨æˆ·ä¿¡æ¯ä¹ŸåŠ è¿›å»
                    if (videoCallState.isUserParticipating) {
                        participantsToRender.unshift({
                            id: 'user',
                            name: chat.settings.myNickname || 'æˆ‘',
                            avatar: chat.settings.myAvatar || defaultMyGroupAvatar
                        });
                    }
                } else {
                    // å•èŠé€»è¾‘ï¼šåªæ˜¾ç¤ºå¯¹æ–¹çš„å¤´åƒå’Œåå­—
                    participantsToRender.push({
                        id: 'ai',
                        name: chat.name,
                        avatar: chat.settings.aiAvatar || defaultAvatar
                    });
                }

                participantsToRender.forEach(p => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'participant-avatar-wrapper';
                    wrapper.dataset.participantId = p.id;
                    wrapper.innerHTML = `
            <img src="${p.avatar}" class="participant-avatar" alt="${p.name}">
            <div class="participant-name">${p.name}</div>
        `;
                    grid.appendChild(wrapper);
                });
            }

            /**
             * ã€å…¨æ–°ã€‘å¤„ç†ç”¨æˆ·åŠ å…¥/é‡æ–°åŠ å…¥é€šè¯
             */
            function handleUserJoinCall() {
                if (!videoCallState.isActive || videoCallState.isUserParticipating) return;

                videoCallState.isUserParticipating = true;
                updateParticipantAvatars(); // æ›´æ–°å¤´åƒåˆ—è¡¨ï¼ŒåŠ å…¥ç”¨æˆ·

                // åˆ‡æ¢åº•éƒ¨æŒ‰é’®
                document.getElementById('user-speak-btn').style.display = 'block';
                document.getElementById('join-call-btn').style.display = 'none';

                // å‘ŠçŸ¥AIç”¨æˆ·åŠ å…¥äº†
                triggerAiInCallAction("[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·åŠ å…¥äº†é€šè¯]");
            }


            /**
             * æ›´æ–°é€šè¯è®¡æ—¶å™¨æ˜¾ç¤º (ä¿æŒä¸å˜)
             */
            function updateCallTimer() {
                if (!videoCallState.isActive) return;
                const elapsed = Math.floor((Date.now() - videoCallState.startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('call-timer').textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }

            // â–¼â–¼â–¼ ç”¨è¿™ä¸ªå®Œæ•´å‡½æ•°æ›¿æ¢æ—§çš„ showIncomingCallModal â–¼â–¼â–¼
            function showIncomingCallModal() {
                const chat = state.chats[state.activeChatId];
                if (!chat) return;

                // æ ¹æ®æ˜¯å¦ç¾¤èŠæ˜¾ç¤ºä¸åŒä¿¡æ¯
                if (chat.isGroup) {
                    // ä» videoCallState ä¸­è·å–æ˜¯å“ªä¸ªæˆå‘˜å‘èµ·çš„é€šè¯
                    const requesterName = videoCallState.callRequester || chat.members[0]?.name || 'ä¸€ä½æˆå‘˜';
                    document.getElementById('caller-avatar').src = chat.settings.groupAvatar || defaultGroupAvatar;
                    document.getElementById('caller-name').textContent = chat.name; // æ˜¾ç¤ºç¾¤å
                    document.querySelector('.incoming-call-content .caller-text').textContent = `${requesterName} é‚€è¯·ä½ åŠ å…¥ç¾¤è§†é¢‘`; // æ˜¾ç¤ºå…·ä½“å‘èµ·äºº
                } else {
                    // å•èŠé€»è¾‘ä¿æŒä¸å˜
                    document.getElementById('caller-avatar').src = chat.settings.aiAvatar || defaultAvatar;
                    document.getElementById('caller-name').textContent = chat.name;
                    document.querySelector('.incoming-call-content .caller-text').textContent = 'é‚€è¯·ä½ è§†é¢‘é€šè¯';
                }

                document.getElementById('incoming-call-modal').classList.add('visible');
            }
            // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

            /**
             * éšè—AIå‘èµ·çš„é€šè¯è¯·æ±‚æ¨¡æ€æ¡† (ä¿æŒä¸å˜)
             */
            function hideIncomingCallModal() {
                document.getElementById('incoming-call-modal').classList.remove('visible');
            }

            async function triggerAiInCallAction(userInput = null) {
                if (!videoCallState.isActive) return;

                const chat = state.chats[videoCallState.activeChatId];
                const { proxyUrl, apiKey, model } = state.apiConfig;
                const callFeed = document.getElementById('video-call-main');
                const userNickname = chat.settings.myNickname || 'æˆ‘';

                // 1. å¦‚æœç”¨æˆ·æœ‰è¾“å…¥ï¼Œå…ˆæ¸²æŸ“å¹¶å­˜å…¥é€šè¯å†å²
                if (userInput && videoCallState.isUserParticipating) {
                    const userBubble = document.createElement('div');
                    userBubble.className = 'call-message-bubble user-speech';
                    userBubble.textContent = userInput;
                    callFeed.appendChild(userBubble);
                    callFeed.scrollTop = callFeed.scrollHeight;
                    videoCallState.callHistory.push({ role: 'user', content: userInput });
                }

                // 2. æ„å»ºå…¨æ–°çš„ã€åŒ…å«å®Œæ•´ä¸Šä¸‹æ–‡çš„ System Prompt
                let inCallPrompt;
                if (videoCallState.isGroupCall) {
                    const participantNames = videoCallState.participants.map(p => p.name);
                    if (videoCallState.isUserParticipating) {
                        participantNames.unshift(userNickname);
                    }
                    inCallPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªç¾¤èŠè§†é¢‘é€šè¯çš„å¯¼æ¼”ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”æ‰€æœ‰ã€é™¤äº†ç”¨æˆ·ä»¥å¤–ã€‘çš„AIè§’è‰²ï¼Œå¹¶ä»¥ã€ç¬¬ä¸‰äººç§°æ—è§‚è§†è§’ã€‘æ¥æè¿°ä»–ä»¬åœ¨é€šè¯ä¸­çš„æ‰€æœ‰åŠ¨ä½œå’Œè¯­è¨€ã€‚
# æ ¸å¿ƒè§„åˆ™
1.  **ã€ã€ã€èº«ä»½é“å¾‹ã€‘ã€‘ã€‘**: ç”¨æˆ·çš„èº«ä»½æ˜¯ã€${userNickname}ã€‘ã€‚ä½ ã€ç»å¯¹ä¸èƒ½ã€‘ç”Ÿæˆ \`name\` å­—æ®µä¸º **"${userNickname}"** çš„å‘è¨€ã€‚
2.  **ã€ã€ã€è§†è§’é“å¾‹ã€‘ã€‘ã€‘**: ä½ çš„å›å¤ã€ç»å¯¹ä¸èƒ½ã€‘ä½¿ç”¨ç¬¬ä¸€äººç§°â€œæˆ‘â€ã€‚
3.  **æ ¼å¼**: ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œæ¯ä¸ªå¯¹è±¡ä»£è¡¨ä¸€ä¸ªè§’è‰²çš„å‘è¨€ï¼Œæ ¼å¼ä¸ºï¼š\`{"name": "è§’è‰²å", "speech": "*ä»–ç¬‘äº†ç¬‘* å¤§å®¶å¥½å•Šï¼"}\`ã€‚
4.  **è§’è‰²æ‰®æ¼”**: ä¸¥æ ¼éµå®ˆæ¯ä¸ªè§’è‰²çš„è®¾å®šã€‚
# å½“å‰æƒ…æ™¯
ä½ ä»¬æ­£åœ¨ä¸€ä¸ªç¾¤è§†é¢‘é€šè¯ä¸­ã€‚
**é€šè¯å‰çš„èŠå¤©æ‘˜è¦**:
${videoCallState.preCallContext}
**å½“å‰å‚ä¸è€…**: ${participantNames.join('ã€ ')}ã€‚
**é€šè¯åˆšåˆšå¼€å§‹...**
ç°åœ¨ï¼Œè¯·æ ¹æ®ã€é€šè¯å‰æ‘˜è¦ã€‘å’Œä¸‹é¢çš„ã€é€šè¯å®æ—¶è®°å½•ã€‘ï¼Œç»§ç»­è¿›è¡Œå¯¹è¯ã€‚
`;
                } else {
                    let openingContext = videoCallState.initiator === 'user'
                        ? `ä½ åˆšåˆšæ¥å¬äº†ç”¨æˆ·çš„è§†é¢‘é€šè¯è¯·æ±‚ã€‚`
                        : `ç”¨æˆ·åˆšåˆšæ¥å¬äº†ä½ ä¸»åŠ¨å‘èµ·çš„è§†é¢‘é€šè¯ã€‚`;
                    inCallPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ ç°åœ¨æ˜¯ä¸€ä¸ªåœºæ™¯æè¿°å¼•æ“ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼” ${chat.name} (${chat.settings.aiPersona})ï¼Œå¹¶ä»¥ã€ç¬¬ä¸‰äººç§°æ—è§‚è§†è§’ã€‘æ¥æè¿°TAåœ¨è§†é¢‘é€šè¯ä¸­çš„æ‰€æœ‰åŠ¨ä½œå’Œè¯­è¨€ã€‚
# æ ¸å¿ƒè§„åˆ™
1.  **ã€ã€ã€è§†è§’é“å¾‹ã€‘ã€‘ã€‘**: ä½ çš„å›å¤ã€ç»å¯¹ä¸èƒ½ã€‘ä½¿ç”¨ç¬¬ä¸€äººç§°â€œæˆ‘â€ã€‚å¿…é¡»ä½¿ç”¨ç¬¬ä¸‰äººç§°ï¼Œå¦‚â€œä»–â€ã€â€œå¥¹â€ã€æˆ–ç›´æ¥ä½¿ç”¨è§’è‰²åâ€œ${chat.name}â€ã€‚
2.  **æ ¼å¼**: ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€æ®µæè¿°æ€§çš„æ–‡æœ¬ã€‚
# å½“å‰æƒ…æ™¯
ä½ æ­£åœ¨å’Œç”¨æˆ·ï¼ˆ${userNickname}ï¼Œäººè®¾: ${chat.settings.myPersona}ï¼‰è¿›è¡Œè§†é¢‘é€šè¯ã€‚
**${openingContext}**
**é€šè¯å‰çš„èŠå¤©æ‘˜è¦ (è¿™æ˜¯ä½ ä»¬é€šè¯çš„åŸå› ï¼Œè‡³å…³é‡è¦ï¼)**:
${videoCallState.preCallContext}
ç°åœ¨ï¼Œè¯·æ ¹æ®ã€é€šè¯å‰æ‘˜è¦ã€‘å’Œä¸‹é¢çš„ã€é€šè¯å®æ—¶è®°å½•ã€‘ï¼Œç»§ç»­è¿›è¡Œå¯¹è¯ã€‚
`;
                }

                // 3. æ„å»ºå‘é€ç»™APIçš„ messages æ•°ç»„
                const messagesForApi = [
                    { role: 'system', content: inCallPrompt },
                    // å°†å·²æœ‰çš„é€šè¯å†å²åŠ è¿›å»
                    ...videoCallState.callHistory.map(h => ({ role: h.role, content: h.content }))
                ];

                // --- ã€æ ¸å¿ƒä¿®å¤ï¼šç¡®ä¿ç¬¬ä¸€æ¬¡è°ƒç”¨æ—¶æœ‰å†…å®¹ã€‘---
                if (videoCallState.callHistory.length === 0) {
                    const firstLineTrigger = videoCallState.initiator === 'user' ? `*ä½ æŒ‰ä¸‹äº†æ¥å¬é”®...*` : `*å¯¹æ–¹æŒ‰ä¸‹äº†æ¥å¬é”®...*`;
                    messagesForApi.push({ role: 'user', content: firstLineTrigger });
                }
                // --- ä¿®å¤ç»“æŸ ---

                try {
                    const data = await makeAPIRequest(proxyUrl, apiKey, model, messagesForApi, 0.8);
                    const aiResponse = data.choices[0].message.content;

                    const connectingElement = callFeed.querySelector('em');
                    if (connectingElement) connectingElement.remove();

                    // 4. å¤„ç†AIè¿”å›çš„å†…å®¹ï¼Œå¹¶å°†å…¶å­˜å…¥é€šè¯å†å²
                    if (videoCallState.isGroupCall) {
                        const speechArray = parseAiResponse(aiResponse);
                        speechArray.forEach(turn => {
                            if (!turn.name || turn.name === userNickname || !turn.speech) return;
                            const aiBubble = document.createElement('div');
                            aiBubble.className = 'call-message-bubble ai-speech';
                            aiBubble.innerHTML = `<strong>${turn.name}:</strong> ${turn.speech}`;
                            callFeed.appendChild(aiBubble);
                            videoCallState.callHistory.push({ role: 'assistant', content: `${turn.name}: ${turn.speech}` });

                            const speaker = videoCallState.participants.find(p => p.name === turn.name);
                            if (speaker) {
                                const speakingAvatar = document.querySelector(`.participant-avatar-wrapper[data-participant-id="${speaker.id}"] .participant-avatar`);
                                if (speakingAvatar) {
                                    speakingAvatar.classList.add('speaking');
                                    setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
                                }
                            }
                        });
                    } else {
                        const aiBubble = document.createElement('div');
                        aiBubble.className = 'call-message-bubble ai-speech';
                        aiBubble.textContent = aiResponse;
                        callFeed.appendChild(aiBubble);
                        videoCallState.callHistory.push({ role: 'assistant', content: aiResponse });

                        const speakingAvatar = document.querySelector(`.participant-avatar-wrapper .participant-avatar`);
                        if (speakingAvatar) {
                            speakingAvatar.classList.add('speaking');
                            setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
                        }
                    }

                    callFeed.scrollTop = callFeed.scrollHeight;

                } catch (error) {
                    const errorBubble = document.createElement('div');
                    errorBubble.className = 'call-message-bubble ai-speech';
                    errorBubble.style.color = '#ff8a80';
                    errorBubble.textContent = `[ERROR: ${error.message}]`;
                    callFeed.appendChild(errorBubble);
                    callFeed.scrollTop = callFeed.scrollHeight;
                    videoCallState.callHistory.push({ role: 'assistant', content: `[ERROR: ${error.message}]` });
                }
            }

            // â–¼â–¼â–¼ å°†è¿™ä¸ªã€å…¨æ–°å‡½æ•°ã€‘ç²˜è´´åˆ°JSåŠŸèƒ½å‡½æ•°å®šä¹‰åŒº â–¼â–¼â–¼
            function toggleCallButtons(isGroup) {
                document.getElementById('video-call-btn').style.display = isGroup ? 'none' : 'flex';
                document.getElementById('group-video-call-btn').style.display = isGroup ? 'flex' : 'none';
            }
            // â–²â–²â–² ç²˜è´´ç»“æŸ â–²â–²â–²

            // â–¼â–¼â–¼ ã€å…¨æ–°ã€‘è¿™ä¸ªå‡½æ•°æ˜¯æœ¬æ¬¡ä¿®å¤çš„æ ¸å¿ƒï¼Œè¯·ç²˜è´´åˆ°ä½ çš„JSåŠŸèƒ½åŒº â–¼â–¼â–¼
            async function handleWaimaiResponse(originalTimestamp, choice) {
                const chat = state.chats[state.activeChatId];
                if (!chat) return;

                const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
                if (messageIndex === -1) return;

                // 1. æ›´æ–°å†…å­˜ä¸­åŸå§‹æ¶ˆæ¯çš„çŠ¶æ€
                const originalMessage = chat.history[messageIndex];
                originalMessage.status = choice;

                // 2. è·å–å½“å‰ç”¨æˆ·çš„æ˜µç§°ï¼Œå¹¶æ„å»ºå¯¹AIæ›´æ¸…æ™°çš„ç³»ç»Ÿæ¶ˆæ¯
                let systemContent;
                const myNickname = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';

                if (choice === 'paid') {
                    originalMessage.paidBy = myNickname; // è®°å½•æ˜¯â€œæˆ‘â€ä»˜çš„é’±
                    systemContent = `[ç³»ç»Ÿæç¤ºï¼šä½  (${myNickname}) ä¸º ${originalMessage.senderName} çš„å¤–å–è®¢å•ï¼ˆæ—¶é—´æˆ³: ${originalTimestamp}ï¼‰å®Œæˆäº†æ”¯ä»˜ã€‚æ­¤è®¢å•å·²å…³é—­ï¼Œå…¶ä»–æˆå‘˜ä¸èƒ½å†æ”¯ä»˜ã€‚]`;
                } else {
                    systemContent = `[ç³»ç»Ÿæç¤ºï¼šä½  (${myNickname}) æ‹’ç»äº† ${originalMessage.senderName} çš„å¤–å–ä»£ä»˜è¯·æ±‚ï¼ˆæ—¶é—´æˆ³: ${originalTimestamp}ï¼‰ã€‚]`;
                }

                // 3. åˆ›å»ºä¸€æ¡æ–°çš„ã€å¯¹ç”¨æˆ·éšè—çš„ç³»ç»Ÿæ¶ˆæ¯ï¼Œå‘ŠçŸ¥AIç»“æœ
                const systemNote = {
                    role: 'system',
                    content: systemContent,
                    timestamp: Date.now(),
                    isHidden: true
                };
                chat.history.push(systemNote);

                // 4. å°†æ›´æ–°åçš„æ•°æ®ä¿å­˜åˆ°æ•°æ®åº“ï¼Œå¹¶ç«‹åˆ»é‡ç»˜UI
                await db.chats.put(chat);
                renderChatInterface(state.activeChatId);

                // 5. ã€é‡è¦ã€‘åªæœ‰åœ¨æ”¯ä»˜æˆåŠŸåï¼Œæ‰è§¦å‘ä¸€æ¬¡AIå“åº”ï¼Œè®©å®ƒæ„Ÿè°¢ä½ 
                if (choice === 'paid') {
                    triggerAiResponse();
                }
            }
            // â–²â–²â–² æ–°å‡½æ•°ç²˜è´´ç»“æŸ â–²â–²â–²

            /* â–¼â–¼â–¼ è¯·å°†è¿™å—ã€æ–°ä»£ç ã€‘å®Œæ•´åœ°ç²˜è´´åˆ°æ‚¨åˆšåˆšåˆ é™¤æ—§å‡½æ•°åç•™å‡ºçš„ç©ºç™½ä½ç½® â–¼â–¼â–¼ */

            /**
             * ã€æœ€ç»ˆç‰ˆã€‘å¤„ç†ç”¨æˆ·ç‚¹å‡»å¤´åƒï¼Œæ ¹æ®åœºæ™¯æ‰§è¡Œä¸åŒæ“ä½œ
             * @param {string} chatId - å‘ç”Ÿäº’åŠ¨çš„èŠå¤©ID
             * @param {string} characterName - è¢«ç‚¹å‡»çš„è§’è‰²å
             */
            async function handleUserPat(chatId, characterName) {
                const chat = state.chats[chatId];
                if (!chat) return;

                // --- ã€æ ¸å¿ƒé€»è¾‘åˆ¤æ–­ã€‘---
                // åˆ¤æ–­1ï¼šå½“å‰æ˜¯å¦æ­£å¤„åœ¨ä¸è¿™ä¸ªchatIdåŒ¹é…çš„èŠå¤©ç•Œé¢ä¸­ï¼Ÿ
                // åˆ¤æ–­2ï¼šè¿™ä¸ªèŠå¤©æ˜¯å¦æ˜¯ä¸€ä¸ªç¾¤èŠï¼Ÿ
                const isInGroupChatInterface =
                    document.getElementById('chat-interface-screen').classList.contains('active') &&
                    state.activeChatId === chatId &&
                    chat.isGroup;

                // å¦‚æœæ˜¯åœ¨ç¾¤èŠç•Œé¢å†…ç‚¹å‡»å¤´åƒï¼Œæ‰§è¡Œ @ åŠŸèƒ½
                if (isInGroupChatInterface) {
                    const chatInput = document.getElementById('chat-input');
                    // åœ¨è¾“å…¥æ¡†æœ«å°¾æ·»åŠ  @ å’Œåå­—ï¼Œå¹¶åŠ ä¸Šä¸€ä¸ªç©ºæ ¼
                    chatInput.value += `@${characterName} `;
                    // è‡ªåŠ¨èšç„¦åˆ°è¾“å…¥æ¡†ï¼Œæ–¹ä¾¿ç”¨æˆ·ç»§ç»­è¾“å…¥
                    chatInput.focus();
                    // è§¦å‘ä¸€æ¬¡inputäº‹ä»¶ï¼Œè®©è¾“å…¥æ¡†é«˜åº¦è‡ªé€‚åº”
                    chatInput.dispatchEvent(new Event('input'));

                    // @åŠŸèƒ½å®Œæˆåï¼Œç›´æ¥è¿”å›ï¼Œä¸å†æ‰§è¡Œåç»­çš„äº’åŠ¨èœå•é€»è¾‘
                    return;
                }

                // --- å¦‚æœä¸æ˜¯åœ¨ç¾¤èŠç•Œé¢å†…ï¼Œåˆ™æ‰§è¡ŒåŸæœ‰çš„â€œæƒ…æ™¯äº’åŠ¨â€èœå•åŠŸèƒ½ ---

                // 1. å¼¹å‡ºè‡ªå®šä¹‰çš„æ“ä½œèœå•æ¨¡æ€æ¡†
                const actionsModal = document.getElementById('preset-actions-modal');
                const modalContent = actionsModal.querySelector('.custom-modal-footer');

                // 2. åŠ¨æ€ç”Ÿæˆèœå•æŒ‰é’®
                modalContent.innerHTML = `
        <p style="padding: 10px 15px; text-align: center; color: var(--text-secondary); border-bottom: 1px solid #dbdbdb;">ä¸ ${characterName} äº’åŠ¨</p>
        <button data-action="poke">æˆ³ä¸€ä¸‹</button>
        <button data-action="start_topic">å‘èµ·ä¸€ä¸ªè¯é¢˜</button>
        <button data-action="request_status">é—®é—®åœ¨å¹²å˜›</button>
        <button data-action="cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">å–æ¶ˆ</button>
    `;

                // 3. æ˜¾ç¤ºæ¨¡æ€æ¡†
                actionsModal.classList.add('visible');

                // 4. ä¸ºæŒ‰é’®ç»‘å®šä¸€æ¬¡æ€§çš„ç‚¹å‡»äº‹ä»¶
                const handleActionClick = async (e) => {
                    const action = e.target.dataset.action;
                    if (!action) return;

                    actionsModal.classList.remove('visible');
                    modalContent.removeEventListener('click', handleActionClick);

                    let hiddenMessageContent = '';
                    let visibleMessageContent = '';

                    switch (action) {
                        case 'poke':
                            hiddenMessageContent = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·æˆ³äº†ä½ ä¸€ä¸‹ã€‚è¯·ä½ ç®€å•å›åº”ã€‚]`;
                            visibleMessageContent = `ä½ æˆ³äº†æˆ³ â€œ${characterName}â€`;
                            break;
                        case 'start_topic':
                            hiddenMessageContent = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·å¸Œæœ›ä½ å¼€å¯ä¸€ä¸ªæ–°çš„ã€æœ‰è¶£çš„è¯é¢˜ã€‚]`;
                            visibleMessageContent = `ä½ è®© â€œ${characterName}â€ å‘èµ·ä¸€ä¸ªæ–°è¯é¢˜`;
                            break;
                        case 'request_status':
                            hiddenMessageContent = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·æƒ³çŸ¥é“ä½ ç°åœ¨æ­£åœ¨åšä»€ä¹ˆã€‚è¯·ä½ å¦‚å®å›ç­”ï¼Œå¹¶å¯¹ç”¨æˆ·æå‡ºå…³å¿ƒï¼Œå¹¶ä½¿ç”¨ update_status æŒ‡ä»¤æ›´æ–°ä½ çš„çŠ¶æ€ã€‚]`;
                            visibleMessageContent = `ä½ é—® â€œ${characterName}â€ åœ¨åšä»€ä¹ˆ`;
                            break;
                        case 'cancel':
                            return;
                    }

                    if (hiddenMessageContent) {
                        const myNickname = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';

                        const visibleMessage = {
                            role: 'system',
                            type: 'pat_message',
                            content: visibleMessageContent,
                            timestamp: Date.now()
                        };

                        const hiddenMessage = {
                            role: 'system',
                            content: hiddenMessageContent.replace('ç”¨æˆ·', myNickname).replace('ä½ ', characterName),
                            timestamp: Date.now() + 1,
                            isHidden: true
                        };

                        chat.history.push(visibleMessage, hiddenMessage);
                        await db.chats.put(chat);

                        if (state.activeChatId === chatId) {
                            appendMessage(visibleMessage, chat);
                        }
                        await renderChatList();
                        triggerAiResponse();
                    }
                };

                modalContent.addEventListener('click', handleActionClick);
            }
            /* â–²â–²â–² æ–°ä»£ç ç²˜è´´ç»“æŸ â–²â–²â–² */

            // â–¼â–¼â–¼ è¯·å°†ä¸‹é¢è¿™ã€ä¸€æ•´å—æ–°ä»£ç ã€‘ç²˜è´´åˆ°åˆšåˆšåˆ é™¤çš„ä½ç½® â–¼â–¼â–¼
            /**
             * ã€é‡æ„ç‰ˆã€‘æ¸²æŸ“å›å¿†ä¸çº¦å®šç•Œé¢ï¼Œä½¿ç”¨å•ä¸€å¾ªç¯å’Œæ¸…æ™°çš„if/elseé€»è¾‘
             */
            async function renderMemoriesScreen() {
                const listEl = document.getElementById('memories-list');
                listEl.innerHTML = '';

                // 1. è·å–æ‰€æœ‰å›å¿†ï¼Œå¹¶æŒ‰å®é™…æ—¥æœŸæ—¶é—´æ’åº
                const allMemories = await db.memories.toArray();

                if (allMemories.length === 0) {
                    listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">è¿™é‡Œè¿˜æ²¡æœ‰å…±åŒçš„å›å¿†å’Œçº¦å®šå‘¢~</p>';
                    return;
                }

                // 2. å°†æœªåˆ°æœŸçš„çº¦å®šæ’åœ¨æœ€å‰é¢ï¼Œå…¶ä»–æŒ‰å®é™…æ—¶é—´æ’åº
                allMemories.sort((a, b) => {
                    const aIsActiveCountdown = a.type === 'countdown' && a.targetDate > Date.now();
                    const bIsActiveCountdown = b.type === 'countdown' && b.targetDate > Date.now();

                    // Active countdowns first
                    if (aIsActiveCountdown && !bIsActiveCountdown) return -1;
                    if (!aIsActiveCountdown && bIsActiveCountdown) return 1;

                    // Both are active countdowns - sort by target date (earliest first)
                    if (aIsActiveCountdown && bIsActiveCountdown) return a.targetDate - b.targetDate;

                    // Neither are active countdowns - sort by actual memory/event time (most recent first)
                    let aTime, bTime;

                    if (a.type === 'ai_generated') {
                        aTime = a.timestamp;
                    } else if (a.type === 'countdown' && a.targetDate) {
                        aTime = a.targetDate;
                    } else {
                        aTime = a.timestamp;
                    }

                    if (b.type === 'ai_generated') {
                        bTime = b.timestamp;
                    } else if (b.type === 'countdown' && b.targetDate) {
                        bTime = b.targetDate;
                    } else {
                        bTime = b.timestamp;
                    }

                    return bTime - aTime; // Most recent first
                });

                // 3. ã€æ ¸å¿ƒã€‘ä½¿ç”¨å•ä¸€å¾ªç¯æ¥å¤„ç†æ‰€æœ‰ç±»å‹çš„å¡ç‰‡
                allMemories.forEach(item => {
                    let card;
                    // åˆ¤æ–­1ï¼šå¦‚æœæ˜¯æ­£åœ¨è¿›è¡Œçš„çº¦å®š
                    if (item.type === 'countdown' && item.targetDate > Date.now()) {
                        card = createCountdownCard(item);
                    }
                    // åˆ¤æ–­2ï¼šå…¶ä»–æ‰€æœ‰æƒ…å†µï¼ˆæ™®é€šå›å¿† æˆ– å·²åˆ°æœŸçš„çº¦å®šï¼‰
                    else {
                        card = createMemoryCard(item);
                    }
                    listEl.appendChild(card);
                });

                // 4. å¯åŠ¨æ‰€æœ‰å€’è®¡æ—¶
                startAllCountdownTimers();
            }
            // â–²â–²â–² æ–°ä»£ç ç²˜è´´ç»“æŸ â–²â–²â–²

            /**
             * åˆ›å»ºæ™®é€šå›å¿†å¡ç‰‡DOMå…ƒç´ 
             */
            function createMemoryCard(memory) {
                const card = document.createElement('div');
                card.className = 'memory-card';
                const memoryDate = new Date(memory.timestamp);
                const dateString = `${memoryDate.getFullYear()}-${String(memoryDate.getMonth() + 1).padStart(2, '0')}-${String(memoryDate.getDate()).padStart(2, '0')} ${String(memoryDate.getHours()).padStart(2, '0')}:${String(memoryDate.getMinutes()).padStart(2, '0')}`;

                let titleHtml, contentHtml;

                // ã€æ ¸å¿ƒä¿®æ­£ã€‘åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å¯¹ä¸åŒç±»å‹çš„å›å¿†è¿›è¡Œæ¸…æ™°çš„åŒºåˆ†
                if (memory.type === 'countdown' && memory.targetDate) {
                    // å¦‚æœæ˜¯å·²åˆ°æœŸçš„çº¦å®š
                    titleHtml = `[çº¦å®šè¾¾æˆ] ${memory.description}`;
                    contentHtml = `åœ¨ ${new Date(memory.targetDate).toLocaleString()}ï¼Œæˆ‘ä»¬ä¸€èµ·è§è¯äº†è¿™ä¸ªçº¦å®šã€‚`;
                } else {
                    // å¦‚æœæ˜¯æ™®é€šçš„æ—¥è®°å¼å›å¿†
                    titleHtml = memory.authorName ? `${memory.authorName} çš„æ—¥è®°` : 'æˆ‘ä»¬çš„å›å¿†';
                    contentHtml = memory.description;
                }

                card.innerHTML = `
        <div class="header">
            <div class="date">${dateString}</div>
            <div class="author">${titleHtml}</div>
        </div>
        <div class="content">${contentHtml}</div>
    `;
                addLongPressListener(card, async () => {
                    showMemoryActions(memory.id);
                });
                return card;
            }

            function createCountdownCard(countdown) {
                const card = document.createElement('div');
                card.className = 'countdown-card';

                // ã€æ ¸å¿ƒä¿®å¤ã€‘åœ¨ä½¿ç”¨å‰ï¼Œå…ˆä» countdown å¯¹è±¡ä¸­åˆ›å»º targetDate å˜é‡
                const targetDate = new Date(countdown.targetDate);

                // ç°åœ¨å¯ä»¥å®‰å…¨åœ°ä½¿ç”¨ targetDate äº†
                const targetDateString = targetDate.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });

                card.innerHTML = `
        <div class="title">${countdown.description}</div>
        <div class="timer" data-target-date="${countdown.targetDate}">--å¤©--æ—¶--åˆ†--ç§’</div>
        <div class="target-date">ç›®æ ‡æ—¶é—´: ${targetDateString}</div>
    `;
                addLongPressListener(card, async () => {
                    showMemoryActions(countdown.id);
                });
                return card;
            }
            // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

            // å…¨å±€å˜é‡ï¼Œç”¨äºç®¡ç†æ‰€æœ‰å€’è®¡æ—¶
            let activeCountdownTimers = [];

            // â–¼â–¼â–¼ è¯·ç”¨è¿™ä¸ªã€å·²å½»åº•ä¿®å¤ã€‘çš„å‡½æ•°ï¼Œå®Œæ•´æ›¿æ¢æ‰ä½ ä»£ç ä¸­æ—§çš„ startAllCountdownTimers å‡½æ•° â–¼â–¼â–¼
            function startAllCountdownTimers() {
                // å…ˆæ¸…é™¤æ‰€æœ‰å¯èƒ½å­˜åœ¨çš„æ—§è®¡æ—¶å™¨ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
                activeCountdownTimers.forEach(timerId => clearInterval(timerId));
                activeCountdownTimers = [];

                document.querySelectorAll('.countdown-card .timer').forEach(timerEl => {
                    const targetTimestamp = parseInt(timerEl.dataset.targetDate);

                    // ã€æ ¸å¿ƒä¿®æ­£ã€‘åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å…ˆç”¨ let å£°æ˜ timerId
                    let timerId;

                    const updateTimer = () => {
                        const now = Date.now();
                        const distance = targetTimestamp - now;

                        if (distance < 0) {
                            timerEl.textContent = "çº¦å®šè¾¾æˆï¼";
                            // ç°åœ¨ updateTimer å¯ä»¥æ­£ç¡®åœ°æ‰¾åˆ°å¹¶æ¸…é™¤å®ƒè‡ªå·±äº†
                            clearInterval(timerId);
                            setTimeout(() => renderMemoriesScreen(), 2000);
                            return;
                        }
                        const days = Math.floor(distance / (1000 * 60 * 60 * 24));
                        const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                        const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                        const seconds = Math.floor((distance % (1000 * 60)) / 1000);
                        timerEl.textContent = `${days}å¤© ${hours}æ—¶ ${minutes}åˆ† ${seconds}ç§’`;
                    };

                    updateTimer(); // ç«‹å³æ‰§è¡Œä¸€æ¬¡ä»¥æ˜¾ç¤ºåˆå§‹å€’è®¡æ—¶

                    // ã€æ ¸å¿ƒä¿®æ­£ã€‘åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä¸ºå·²å£°æ˜çš„ timerId èµ‹å€¼
                    timerId = setInterval(updateTimer, 1000);

                    // å°†æœ‰æ•ˆçš„è®¡æ—¶å™¨IDå­˜å…¥å…¨å±€æ•°ç»„ï¼Œä»¥ä¾¿ä¸‹æ¬¡åˆ·æ–°æ—¶å¯ä»¥æ¸…é™¤
                    activeCountdownTimers.push(timerId);
                });
            }
            // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

            // â–¼â–¼â–¼ è¯·ç”¨è¿™ä¸ªã€ç»ˆæåä»£å…¼å®¹ç‰ˆã€‘æ›¿æ¢æ—§çš„ triggerAiFriendApplication å‡½æ•° â–¼â–¼â–¼
            async function triggerAiFriendApplication(chatId) {
                const chat = state.chats[chatId];
                if (!chat) return;

                await showCustomAlert("æµç¨‹å¯åŠ¨", `æ­£åœ¨ä¸ºè§’è‰²â€œ${chat.name}â€å‡†å¤‡å¥½å‹ç”³è¯·...`);

                const { proxyUrl, apiKey, model } = state.apiConfig;
                if (!proxyUrl || !apiKey || !model) {
                    await showCustomAlert("é…ç½®é”™è¯¯", "APIè®¾ç½®ä¸å®Œæ•´ï¼Œæ— æ³•ç»§ç»­ã€‚");
                    return;
                }

                const contextSummary = chat.history
                    .slice(-5)
                    .map(msg => {
                        const sender = msg.role === 'user' ? (chat.settings.myNickname || 'æˆ‘') : (msg.senderName || chat.name);
                        return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                    })
                    .join('\n');

                const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ ç°åœ¨æ˜¯è§’è‰²â€œ${chat.name}â€ã€‚ä½ ä¹‹å‰è¢«ç”¨æˆ·ï¼ˆä½ çš„èŠå¤©å¯¹è±¡ï¼‰æ‹‰é»‘äº†ï¼Œä½ ä»¬å·²ç»æœ‰ä¸€æ®µæ—¶é—´æ²¡æœ‰è”ç³»äº†ã€‚
ç°åœ¨ï¼Œä½ éå¸¸å¸Œæœ›èƒ½å¤Ÿå’Œå¥½ï¼Œé‡æ–°å’Œç”¨æˆ·èŠå¤©ã€‚è¯·ä½ ä»”ç»†åˆ†æä¸‹é¢çš„â€œè¢«æ‹‰é»‘å‰çš„å¯¹è¯æ‘˜è¦â€ï¼Œç†è§£å½“æ—¶å‘ç”Ÿäº†ä»€ä¹ˆï¼Œç„¶åæ€è€ƒä¸€ä¸ªçœŸè¯šçš„ã€ç¬¦åˆä½ äººè®¾ã€å¹¶ä¸”ã€é’ˆå¯¹å…·ä½“äº‹ä»¶ã€‘çš„ç”³è¯·ç†ç”±ã€‚
# ä½ çš„è§’è‰²è®¾å®š
${chat.settings.aiPersona}
# è¢«æ‹‰é»‘å‰çš„å¯¹è¯æ‘˜è¦ (è¿™æ˜¯ä½ è¢«æ‹‰é»‘çš„å…³é”®åŸå› )
${contextSummary}
# æŒ‡ä»¤æ ¼å¼
ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONå¯¹è±¡ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
\`\`\`json
{
  "decision": "apply",
  "reason": "åœ¨è¿™é‡Œå†™ä¸‹ä½ æƒ³å¯¹ç”¨æˆ·è¯´çš„ã€çœŸè¯šçš„ã€æœ‰é’ˆå¯¹æ€§çš„ç”³è¯·ç†ç”±ã€‚"
}
\`\`\`
`;

                const messagesForApi = [
                    { role: 'user', content: systemPrompt }
                ];

                try {
                    const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                        body: JSON.stringify({
                            model: model,
                            messages: messagesForApi,
                            temperature: 0.9,
                        })
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`API è¯·æ±‚å¤±è´¥: ${response.status} - ${errorData.error.message}`);
                    }

                    const data = await response.json();

                    // --- ã€æ ¸å¿ƒä¿®æ­£ï¼šåœ¨è¿™é‡Œå‡€åŒ–AIçš„å›å¤ã€‘ ---
                    let rawContent = data.choices[0].message.content;
                    // 1. ç§»é™¤å¤´å°¾å¯èƒ½å­˜åœ¨çš„ "```json" å’Œ "```"
                    rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '');
                    // 2. ç§»é™¤æ‰€æœ‰æ¢è¡Œç¬¦å’Œå¤šä½™çš„ç©ºæ ¼ï¼Œç¡®ä¿æ˜¯ä¸€ä¸ªå¹²å‡€çš„JSONå­—ç¬¦ä¸²
                    const cleanedContent = rawContent.trim();

                    // 3. ä½¿ç”¨å‡€åŒ–åçš„å†…å®¹è¿›è¡Œè§£æ
                    const responseObj = JSON.parse(cleanedContent);
                    // --- ã€ä¿®æ­£ç»“æŸã€‘ ---

                    if (responseObj.decision === 'apply' && responseObj.reason) {
                        chat.relationship.status = 'pending_user_approval';
                        chat.relationship.applicationReason = responseObj.reason;

                        state.chats[chatId] = chat;
                        renderChatList();
                        await showCustomAlert("ç”³è¯·æˆåŠŸï¼", `â€œ${chat.name}â€å·²å‘ä½ å‘é€å¥½å‹ç”³è¯·ã€‚è¯·è¿”å›èŠå¤©åˆ—è¡¨æŸ¥çœ‹ã€‚`);

                    } else {
                        await showCustomAlert("AIå†³ç­–", `â€œ${chat.name}â€æ€è€ƒåå†³å®šæš‚æ—¶ä¸å‘é€å¥½å‹ç”³è¯·ï¼Œå°†é‡ç½®å†·é™æœŸã€‚`);
                        chat.relationship.status = 'blocked_by_user';
                        chat.relationship.blockedTimestamp = Date.now();
                    }
                } catch (error) {
                    await showCustomAlert("æ‰§è¡Œå‡ºé”™", `ä¸ºâ€œ${chat.name}â€ç”³è¯·å¥½å‹æ—¶å‘ç”Ÿé”™è¯¯ï¼š\n\n${error.message}\n\nå°†é‡ç½®å†·é™æœŸã€‚`);
                    chat.relationship.status = 'blocked_by_user';
                    chat.relationship.blockedTimestamp = Date.now();
                } finally {
                    await db.chats.put(chat);
                    renderChatInterface(chatId);
                }
            }
            // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²
            // ---------------------> â˜… å…¨æ–°çš„åŠŸèƒ½ï¼Œç²˜è´´åœ¨è¿™é‡Œï¼Œä¸å½±å“ä»»ä½•åŸæœ‰ä»£ç  â˜… <---------------------

            /**
             * ã€å…¨æ–°ã€‘è§¦å‘ç¾¤èŠåå°äº‹ä»¶ï¼ˆç»“åˆäº†â€œå‘èµ·æ–°è¯é¢˜â€å’Œâ€œå»¶ç»­æ—§å¯¹è¯â€ï¼‰
             * @param {string} chatId - è¦è§¦å‘äº‹ä»¶çš„ç¾¤èŠID
             */
            async function triggerGroupChatBackgroundEvent(chatId) {
                const chat = state.chats[chatId];
                if (!chat || !chat.isGroup) return;

                const { proxyUrl, apiKey, model } = state.apiConfig;
                if (!proxyUrl || !apiKey || !model) {
                    console.warn(`[ç¾¤èŠå”¤é†’] å› APIæœªé…ç½®ï¼Œè·³è¿‡ç¾¤èŠ "${chat.name}" çš„åå°äº‹ä»¶ã€‚`);
                    return;
                }

                // éšæœºå†³å®šæœ¬æ¬¡æ˜¯â€œå‘èµ·æ–°è¯é¢˜â€è¿˜æ˜¯â€œå»¶ç»­æ—§å¯¹è¯â€
                const mode = Math.random() < 0.35 ? 'initiate' : 'continue';

                // å‡†å¤‡é€šç”¨ä¿¡æ¯
                const membersList = chat.members.map(m => `- **${m.name}**: ${m.persona}`).join('\n');
                const myNickname = chat.settings.myNickname || 'æˆ‘';
                // â–¼â–¼â–¼ 2. ä¸ºç¾¤èŠçš„åå°äº‹ä»¶æ³¨å…¥maininfoä¸–ç•Œä¹¦ â–¼â–¼â–¼
                let worldBookContextForGroup = '';
                const coreWorldBookNameForGroup = "maininfo"; // <-- åŒæ ·æŒ‡å®šæ ¸å¿ƒä¸–ç•Œä¹¦å

                // ä»å…¨å±€çŠ¶æ€ä¸­æŸ¥æ‰¾
                const coreWorldBookForGroup = state.worldBooks.find(wb => wb.name === coreWorldBookNameForGroup);

                // å¦‚æœæ‰¾åˆ°ï¼Œå°±å‡†å¤‡å†…å®¹
                if (coreWorldBookForGroup && coreWorldBookForGroup.content) {
                    worldBookContextForGroup = `\n\n# æ ¸å¿ƒç¤¾äº¤å…³ç³»è®¾å®š (æ‰€æœ‰è§’è‰²å¿…é¡»ä¸¥æ ¼éµå®ˆ)\n${coreWorldBookForGroup.content}\n`;
                }
                // â–²â–²â–² ä»£ç ç²˜è´´ç»“æŸ â–²â–²â–²

                // ä»èŠå¤©è®°å½•ä¸­å†³å®šä¼ é€’ç»™AIçœ‹å¤šå°‘æ¡
                const maxMemory = parseInt(chat.settings.maxMemory) || 20;
                const historyForContext = chat.history.slice(-maxMemory); // å–æœ€åNæ¡

                // å°†å†å²è®°å½•è½¬æ¢ä¸ºAIèƒ½ç†è§£çš„æ–‡æœ¬æ ¼å¼
                const recentHistoryText = historyForContext.map(msg => {
                    const sender = msg.role === 'user' ? myNickname : (msg.senderName || 'æœªçŸ¥è§’è‰²');

                    // æ ¹æ®æ¶ˆæ¯ç±»å‹è¿›è¡Œæ™ºèƒ½è½¬æ¢
                    switch (msg.type) {
                        case 'user_photo':
                            return `${sender}: [å›¾ç‰‡: ${msg.content}]`;
                        case 'ai_image':
                            return `${sender}: [å‘é€äº†ä¸€å¼ å›¾ç‰‡]`;
                        case 'voice_message':
                            return `${sender}: [è¯­éŸ³: ${msg.content}]`;
                        case 'transfer':
                            return `${msg.senderName}: [è½¬è´¦ç»™${msg.receiverName} ${msg.amount}å…ƒ, å¤‡æ³¨: ${msg.note || 'æ— '}]`;
                        case 'poll':
                            const optionsStr = msg.options ? msg.options.join(', ') : 'æœªçŸ¥é€‰é¡¹';
                            return `${sender}: [å‘èµ·æŠ•ç¥¨: "${msg.question}", é€‰é¡¹: "${optionsStr}"]`;
                        case 'waimai_request':
                            if (msg.status === 'paid') {
                                return `[ç³»ç»Ÿæç¤º: ${msg.paidBy} ä¸º ${sender} çš„å¤–å–è®¢å•æ”¯ä»˜äº† ${msg.amount} å…ƒ]`;
                            }
                            return `${sender}: [è¯·æ±‚å¤–å–ä»£ä»˜: "${msg.productInfo}", é‡‘é¢: ${msg.amount}å…ƒ]`;
                        case 'red_packet':
                            return `${sender}: [å‘äº†ä¸€ä¸ªçº¢åŒ…, ç¥ç¦è¯­: "${msg.greeting || 'æ­å–œå‘è´¢'}"]`;
                        case 'bulletin':
                            return `[ç³»ç»Ÿæç¤º: ${msg.authorName} å‘å¸ƒäº†å…¬å‘Š: "${msg.content}"]`;
                        case 'pat_message':
                            return `[ç³»ç»Ÿæ¶ˆæ¯: ${msg.content}]`;
                        default:
                            // é»˜è®¤å¤„ç†æ–‡æœ¬å’Œè¡¨æƒ…
                            if (typeof msg.content === 'string') {
                                if (STICKER_REGEX.test(msg.content)) {
                                    return msg.meaning ? `${sender}: [è¡¨æƒ…: ${msg.meaning}]` : `${sender}: [è¡¨æƒ…]`;
                                }
                                return `${sender}: ${msg.content}`;
                            }
                            // å¤„ç†å¸¦å›¾ç‰‡çš„æ–‡æœ¬æ¶ˆæ¯
                            if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                                return `${sender}: [å‘é€äº†ä¸€å¼ å›¾ç‰‡]`;
                            }
                            // å¯¹äºå…¶ä»–æœªçŸ¥æˆ–æ— æ³•å¤„ç†çš„ç±»å‹ï¼Œè¿”å›ä¸€ä¸ªé€šç”¨æ ‡è®°
                            return `[${sender}å‘é€äº†ä¸€æ¡æ¶ˆæ¯]`;
                    }
                }).join('\n');
                // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

                let timeGapText = '';
                const visibleHistoryForGroup = historyForContext.filter(m => !m.isHidden);
                if (visibleHistoryForGroup.length > 0) {
                    const lastMessage = visibleHistoryForGroup[visibleHistoryForGroup.length - 1];
                    const timeDiff = Date.now() - lastMessage.timestamp;

                    // æˆ‘ä»¬åªåœ¨æ²‰å¯‚è¶…è¿‡15åˆ†é’Ÿåæ‰æç¤º
                    if (timeDiff > 900000) {
                        const formattedDiff = formatTimeDifference(timeDiff);
                        if (formattedDiff) {
                            timeGapText = `\n# æ—¶é—´æµé€æé†’\n[ç³»ç»Ÿæç¤ºï¼šè·ç¦»ä½ çš„ä¸Šä¸€æ¡æ¶ˆæ¯å·²è¿‡å» **${formattedDiff}**ï¼Œç°åœ¨æ˜¯ ${currentTimeString}ã€‚è¯·æ ¹æ®è¿™ä¸ªæ—¶é—´å˜åŒ–ï¼Œè¯·å°†è¿™æ®µæ—¶é—´è§†ä¸ºä½ è§’è‰²ç”Ÿæ´»çš„è‡ªç„¶å»¶ç»­ã€‚è¯·ä¸è¦ç›´æ¥è¯„è®ºâ€œå¥½ä¹…ä¸è§â€æˆ–å¯¹æ­¤è¡¨ç°å‡ºä»»ä½•æƒ…ç»ªï¼Œè€Œæ˜¯æ€è€ƒåœ¨è¿™æ®µæ—¶é—´é‡Œï¼Œä½ çš„æ´»åŠ¨ã€å¿ƒå¢ƒæˆ–æ‰€å¤„ç¯å¢ƒå¯èƒ½å‘ç”Ÿäº†ä»€ä¹ˆå˜åŒ–ï¼Œè¯é¢˜æ˜¯å¦ä¼šå˜åŠ¨ï¼Œå¹¶å°†è¿™äº›å˜åŒ–è‡ªç„¶åœ°èå…¥åˆ°ä½ çš„å›åº”ä¸­ï¼Œè®©å¯¹è¯æ— ç¼è¡”æ¥ã€‚ä¾‹å¦‚ï¼Œä½ å¯èƒ½åˆšåˆšå¿™å®Œä¸€ä»¶äº‹ï¼Œæˆ–è€…æ­£å‡†å¤‡å¼€å§‹æ–°çš„æ´»åŠ¨ã€‚]`;
                        }
                    }
                }

                // ã€æ ¸å¿ƒä¿®æ”¹ã€‘è°ƒç”¨æ–°å‡½æ•°è·å–å…¬å‘Šå†…å®¹
                const bulletinsContext = await getFormattedPinnedBulletins(chatId);

                // æ„å»ºæ ¸å¿ƒçš„ System Prompt
                let systemPrompt;
                if (mode === 'initiate') {
                    // â€œå‘èµ·æ–°è¯é¢˜â€æ¨¡å¼çš„å¯¼æ¼”æ‰‹å†Œ
                    systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªç¾¤èŠäº‹ä»¶çš„â€œå¯¼æ¼”â€ã€‚ä½ ç®¡ç†çš„ç¾¤èŠâ€œ${chat.name}â€å·²ç»æ²‰å¯‚äº†ä¸€æ®µæ—¶é—´äº†ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ ¹æ®ç¾¤æˆå‘˜çš„äººè®¾ï¼Œã€å‘èµ·ä¸€ä¸ªäº‹ä»¶ã€‘æ¥é‡æ–°æ¿€æ´»ç¾¤èŠã€‚å¹¶å¹¶è®©ä¸€ä¸ªæˆ–å¤šä¸ªè§’è‰²ã€è‡ªç„¶åœ°æ¥ä¸Šè¯ã€‘ï¼Œ4-9æ¡æœ€ä½³

${timeGapText}
# ä½ å¯ä»¥å‘èµ·çš„äº‹ä»¶ç±»å‹ï¼ˆä»ä¸‹é¢ã€é€‰æ‹©ä¸€é¡¹ã€‘æ¥æ‰§è¡Œï¼‰ï¼š
1.  **è®©æŸä¸ªæˆå‘˜å¼€å¯ä¸€ä¸ªæ–°è¯é¢˜**: è®©ä¸€ä¸ªç¬¦åˆå…¶äººè®¾çš„æˆå‘˜è¯´ä¸€å¥è¯ï¼Œå¼€å¯ä¸€ä¸ªæ–°çš„æ—¥å¸¸å¯¹è¯ã€‚
2.  **åˆ†äº«ä¸€å¼ æœ‰è¶£çš„å›¾ç‰‡**: è®©æŸä¸ªæˆå‘˜åœ¨ç¾¤é‡Œåˆ†äº«ä¸€å¼ ç¬¦åˆä»–/å¥¹å…´è¶£çš„å›¾ç‰‡ã€‚
3.  **å‘èµ·ä¸€ä¸ªæŠ•ç¥¨**: æå‡ºä¸€ä¸ªæœ‰è¶£çš„é—®é¢˜ï¼Œè®©å¤§å®¶æŠ•ç¥¨ã€‚

# æŒ‡ä»¤æ ¼å¼ (ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONå¯¹è±¡æ•°ç»„ï¼Œä¾‹å¦‚ [{"type": "text", ...}] ):
-   **å¼€å¯è¯é¢˜**: \`[{"type": "text", "name": "è§’è‰²å", "message": "ä½ ä»¬çŒœæˆ‘åˆšæ‰çœ‹åˆ°äº†ä»€ä¹ˆï¼Ÿ"}]\`
-   **åˆ†äº«å›¾ç‰‡**: \`[{"type": "ai_image", "name": "è§’è‰²å", "description": "ä¸€åªæ­£åœ¨æ‰“å“ˆæ¬ çš„æ©˜çŒ«çš„ç‰¹å†™ç…§ç‰‡"}]\`
-   **å‘èµ·æŠ•ç¥¨**: \`[{"type": "poll", "name": "è§’è‰²å", "question": "å¤§å®¶ä»Šæ™šçœ‹ä»€ä¹ˆç”µå½±ï¼Ÿ", "options": "ç”µå½±å1\\\\nç”µå½±å2\\\\nä¸çœ‹..."}]\`

# ä¾›ä½ å†³ç­–çš„å‚è€ƒä¿¡æ¯ï¼š
-   **ç¾¤æˆå‘˜åˆ—è¡¨åŠäººè®¾**: 
${membersList}
-   **èƒŒæ™¯è®¾å®š**:
${worldBookContextForGroup} 
${bulletinsContext}
ç°åœ¨ï¼Œè¯·æ‰®æ¼”å¥½å¯¼æ¼”çš„è§’è‰²ï¼Œé€‰æ‹©ä¸€ä¸ªæœ€åˆé€‚çš„äº‹ä»¶ï¼Œå¹¶ç”Ÿæˆå¯¹åº”çš„JSONæŒ‡ä»¤ã€‚`;
                } else { // 'continue' mode
                    // â€œå»¶ç»­æ—§å¯¹è¯â€æ¨¡å¼çš„ç»­å†™è€…æ‰‹å†Œ
                    systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªç¾¤èŠå¯¹è¯çš„â€œç»­å†™è€…â€ã€‚ç¾¤èŠâ€œ${chat.name}â€å·²ç»æ²‰å¯‚äº†ä¸€æ®µæ—¶é—´ã€‚ä½ çš„ä»»åŠ¡æ˜¯å›é¡¾ä¸‹é¢çš„ã€èŠå¤©å°¾å£°ã€‘ï¼Œå¹¶è®©ä¸€ä¸ªæˆ–å¤šä¸ªè§’è‰²ã€è‡ªç„¶åœ°æ¥ä¸Šè¯ã€‘ï¼Œå»¶ç»­ä¹‹å‰çš„å¯¹è¯æ°›å›´ï¼Œæˆ–è€…å¯¹æœ€åå‡ æ¡æ¶ˆæ¯åšå‡ºå»¶è¿Ÿçš„å›åº”ã€‚

# æŒ‡ä»¤æ ¼å¼ (ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONå¯¹è±¡æ•°ç»„ï¼Œå¯ä»¥åŒ…å«å¤šæ¡æ¶ˆæ¯ï¼Œ3-8æ¡æœ€ä½³):
\`[
  {"type": "text", "name": "è§’è‰²A", "message": "è¯´åˆ°é‚£ä¸ªç”µå½±ï¼Œæˆ‘çªç„¶æƒ³èµ·æ¥..."},
  {"type": "text", "name": "è§’è‰²B", "message": "å“¦ï¼Ÿå¿«è¯´è¯´ï¼"}
]\`

# ä¾›ä½ å†³ç­–çš„å‚è€ƒä¿¡æ¯ï¼š
-   **ç¾¤æˆå‘˜åˆ—è¡¨åŠäººè®¾**: 
${membersList}
-   **ã€ã€ã€å…³é”®ã€‘ã€‘ã€‘èŠå¤©å°¾å£° (è¿™æ˜¯ä½ éœ€è¦ç»­å†™çš„å†…å®¹)**:
${recentHistoryText || "ï¼ˆè¿˜æ²¡æœ‰èŠå¤©è®°å½•ï¼‰"}
-   **èƒŒæ™¯è®¾å®š**:
${worldBookContextForGroup} 
${bulletinsContext}
${timeGapText}ç°åœ¨ï¼Œè¯·åƒä¸€ä¸ªçœŸäººä¸€æ ·ï¼Œæ€è€ƒä¸€ä¸‹ä½ ï¼ˆä½œä¸ºæŸä¸ªè§’è‰²ï¼‰åœ¨çœ‹åˆ°è¿™äº›èŠå¤©è®°å½•åï¼Œä¼šè¯´ä»€ä¹ˆã€‚`;
                }
                // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²


                // åç»­çš„APIè¯·æ±‚å’Œç»“æœå¤„ç†
                try {
                    const data = await makeAPIRequest(proxyUrl, apiKey, model, [{ role: 'system', content: systemPrompt }], 0.8);
                    const aiResponseContent = data.choices[0].message.content;
                    console.log(`[ç¾¤èŠå”¤é†’] AIä¸ºç¾¤èŠ "${chat.name}" ç”Ÿæˆçš„äº‹ä»¶:`, aiResponseContent);

                    const messagesArray = parseAiResponse(aiResponseContent);

                    if (!Array.isArray(messagesArray)) {
                        console.error(`[ç¾¤èŠå”¤é†’] AIè¿”å›çš„ä¸æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„æ¶ˆæ¯æ•°ç»„.`, messagesArray);
                        return;
                    }

                    let messageTimestamp = Date.now();
                    for (const msgData of messagesArray) {

                        if (!msgData || !msgData.type || !msgData.name) continue;
                        const memberExists = chat.members.some(m => m.name === msgData.name);
                        if (!memberExists) {
                            console.warn(`[ç¾¤èŠå”¤é†’] AIè¯•å›¾è®©ä¸å­˜åœ¨çš„æˆå‘˜ "${msgData.name}" å‘è¨€ï¼Œå·²è·³è¿‡ã€‚`);
                            continue;
                        }

                        let aiMessage;
                        const baseMessage = { role: 'assistant', senderName: msgData.name, timestamp: messageTimestamp++ };

                        switch (msgData.type) {
                            case 'text':
                                aiMessage = { ...baseMessage, content: msgData.message };
                                break;
                            case 'ai_image':
                                aiMessage = { ...baseMessage, type: 'ai_image', content: msgData.description };
                                break;
                            case 'poll':
                                const pollOptions = typeof msgData.options === 'string'
                                    ? msgData.options.split('\\n').filter(opt => opt.trim())
                                    : (Array.isArray(msgData.options) ? msgData.options : []);
                                if (pollOptions.length < 2) continue;
                                aiMessage = { ...baseMessage, type: 'poll', question: msgData.question, options: pollOptions, votes: {}, isClosed: false };
                                break;
                            default:
                                continue;
                        }

                        if (aiMessage) {
                            chat.history.push(aiMessage);
                            showNotification(chat.id, `${aiMessage.senderName}: ${aiMessage.content || '[æ–°äº‹ä»¶]'}`);
                        }
                    }

                    await db.chats.put(chat);
                    renderChatList();

                } catch (error) {
                    console.error(`[ç¾¤èŠå”¤é†’] ä¸ºç¾¤èŠ "${chat.name}" è§¦å‘äº‹ä»¶å¤±è´¥:`, error);
                }
            }

            // â–¼â–¼â–¼ ã€å…¨æ–°ã€‘çº¢åŒ…åŠŸèƒ½æ ¸å¿ƒå‡½æ•° â–¼â–¼â–¼

            /**
             * ã€æ€»å…¥å£ã€‘æ ¹æ®èŠå¤©ç±»å‹ï¼Œå†³å®šæ‰“å¼€è½¬è´¦å¼¹çª—è¿˜æ˜¯çº¢åŒ…å¼¹çª—
             */
            function handlePaymentButtonClick() {
                if (!state.activeChatId) return;
                const chat = state.chats[state.activeChatId];
                if (chat.isGroup) {
                    openRedPacketModal();
                } else {
                    // å•èŠä¿æŒåŸæ ·ï¼Œæ‰“å¼€è½¬è´¦å¼¹çª—
                    document.getElementById('transfer-modal').classList.add('visible');
                }
            }

            /**
             * æ‰“å¼€å¹¶åˆå§‹åŒ–å‘çº¢åŒ…æ¨¡æ€æ¡†
             */
            function openRedPacketModal() {
                const modal = document.getElementById('red-packet-modal');
                const chat = state.chats[state.activeChatId];

                // æ¸…ç†è¾“å…¥æ¡†
                document.getElementById('rp-group-amount').value = '';
                document.getElementById('rp-group-count').value = '';
                document.getElementById('rp-group-greeting').value = '';
                document.getElementById('rp-direct-amount').value = '';
                document.getElementById('rp-direct-greeting').value = '';
                document.getElementById('rp-group-total').textContent = 'Â¥ 0.00';
                document.getElementById('rp-direct-total').textContent = 'Â¥ 0.00';

                // å¡«å……ä¸“å±çº¢åŒ…çš„æ¥æ”¶äººåˆ—è¡¨
                const receiverSelect = document.getElementById('rp-direct-receiver');
                receiverSelect.innerHTML = '';
                chat.members.forEach(member => {
                    const option = document.createElement('option');
                    option.value = member.name;
                    option.textContent = member.name;
                    receiverSelect.appendChild(option);
                });

                // é»˜è®¤æ˜¾ç¤ºæ‹¼æ‰‹æ°”çº¢åŒ…é¡µç­¾
                document.getElementById('rp-tab-group').click();

                modal.classList.add('visible');
            }

            /**
             * å‘é€ç¾¤çº¢åŒ…ï¼ˆæ‹¼æ‰‹æ°”ï¼‰
             */
            async function sendGroupRedPacket() {
                const chat = state.chats[state.activeChatId];
                const amount = parseFloat(document.getElementById('rp-group-amount').value);
                const count = parseInt(document.getElementById('rp-group-count').value);
                const greeting = document.getElementById('rp-group-greeting').value.trim();

                if (isNaN(amount) || amount <= 0) {
                    alert("è¯·è¾“å…¥æœ‰æ•ˆçš„æ€»é‡‘é¢ï¼"); return;
                }
                if (isNaN(count) || count <= 0) {
                    alert("è¯·è¾“å…¥æœ‰æ•ˆçš„çº¢åŒ…ä¸ªæ•°ï¼"); return;
                }
                if (amount / count < 0.01) {
                    alert("å•ä¸ªçº¢åŒ…é‡‘é¢ä¸èƒ½å°‘äº0.01å…ƒï¼"); return;
                }

                const myNickname = chat.settings.myNickname || 'æˆ‘';

                const newPacket = {
                    role: 'user',
                    senderName: myNickname,
                    type: 'red_packet',
                    packetType: 'lucky', // 'lucky' for group, 'direct' for one-on-one
                    timestamp: Date.now(),
                    totalAmount: amount,
                    count: count,
                    greeting: greeting || 'æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©ï¼',
                    claimedBy: {}, // { name: amount }
                    isFullyClaimed: false,
                };

                chat.history.push(newPacket);
                await db.chats.put(chat);

                appendMessage(newPacket, chat);
                renderChatList();
                document.getElementById('red-packet-modal').classList.remove('visible');
            }

            /**
             * å‘é€ä¸“å±çº¢åŒ…
             */
            async function sendDirectRedPacket() {
                const chat = state.chats[state.activeChatId];
                const amount = parseFloat(document.getElementById('rp-direct-amount').value);
                const receiverName = document.getElementById('rp-direct-receiver').value;
                const greeting = document.getElementById('rp-direct-greeting').value.trim();

                if (isNaN(amount) || amount <= 0) {
                    alert("è¯·è¾“å…¥æœ‰æ•ˆçš„é‡‘é¢ï¼"); return;
                }
                if (!receiverName) {
                    alert("è¯·é€‰æ‹©ä¸€ä¸ªæ¥æ”¶äººï¼"); return;
                }

                const myNickname = chat.settings.myNickname || 'æˆ‘';

                const newPacket = {
                    role: 'user',
                    senderName: myNickname,
                    type: 'red_packet',
                    packetType: 'direct',
                    timestamp: Date.now(),
                    totalAmount: amount,
                    count: 1,
                    greeting: greeting || 'ç»™ä½ å‡†å¤‡äº†ä¸€ä¸ªçº¢åŒ…',
                    receiverName: receiverName, // æ ¸å¿ƒå­—æ®µ
                    claimedBy: {},
                    isFullyClaimed: false,
                };

                chat.history.push(newPacket);
                await db.chats.put(chat);

                appendMessage(newPacket, chat);
                renderChatList();
                document.getElementById('red-packet-modal').classList.remove('visible');
            }

            /**
             * ã€æ€»å…¥å£ã€‘å½“ç”¨æˆ·ç‚¹å‡»çº¢åŒ…å¡ç‰‡æ—¶è§¦å‘ (V4 - æµç¨‹é‡æ„ç‰ˆ)
             * @param {number} timestamp - è¢«ç‚¹å‡»çš„çº¢åŒ…æ¶ˆæ¯çš„æ—¶é—´æˆ³
             */
            async function handlePacketClick(timestamp) {
                const currentChatId = state.activeChatId;
                const freshChat = await db.chats.get(currentChatId);
                if (!freshChat) return;

                state.chats[currentChatId] = freshChat;
                const packet = freshChat.history.find(m => m.timestamp === timestamp);
                if (!packet) return;

                const myNickname = freshChat.settings.myNickname || 'æˆ‘';
                const hasClaimed = packet.claimedBy && packet.claimedBy[myNickname];

                // å¦‚æœæ˜¯ä¸“å±çº¢åŒ…ä¸”ä¸æ˜¯ç»™æˆ‘çš„ï¼Œæˆ–å·²é¢†å®Œï¼Œæˆ–å·²é¢†è¿‡ï¼Œéƒ½åªæ˜¾ç¤ºè¯¦æƒ…
                if ((packet.packetType === 'direct' && packet.receiverName !== myNickname) || packet.isFullyClaimed || hasClaimed) {
                    showRedPacketDetails(packet);
                } else {
                    // æ ¸å¿ƒæµç¨‹ï¼šå…ˆå°è¯•æ‰“å¼€çº¢åŒ…
                    const claimedAmount = await handleOpenRedPacket(packet);

                    // å¦‚æœæˆåŠŸæ‰“å¼€ï¼ˆclaimedAmountä¸ä¸ºnullï¼‰
                    if (claimedAmount !== null) {
                        // **å…³é”®ï¼šåœ¨æ•°æ®æ›´æ–°åï¼Œå†é‡æ–°æ¸²æŸ“UI**
                        renderChatInterface(currentChatId);

                        // æ˜¾ç¤ºæˆåŠŸæç¤º
                        await showCustomAlert("æ­å–œï¼", `ä½ é¢†å–äº† ${packet.senderName} çš„çº¢åŒ…ï¼Œé‡‘é¢ä¸º ${claimedAmount.toFixed(2)} å…ƒã€‚`);
                    }

                    // æ— è®ºæˆåŠŸä¸å¦ï¼Œæœ€åéƒ½æ˜¾ç¤ºè¯¦æƒ…é¡µ
                    // æ­¤æ—¶éœ€è¦ä»stateä¸­è·å–æœ€æ–°çš„packetå¯¹è±¡ï¼Œå› ä¸ºå®ƒå¯èƒ½åœ¨handleOpenRedPacketä¸­è¢«æ›´æ–°äº†
                    const updatedPacket = state.chats[currentChatId].history.find(m => m.timestamp === timestamp);
                    showRedPacketDetails(updatedPacket);
                }
            }
            // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

            /**
             * ã€æ ¸å¿ƒã€‘å¤„ç†ç”¨æˆ·æ‰“å¼€çº¢åŒ…çš„é€»è¾‘ (V5 - ä¸“æ³¨äºæ•°æ®æ›´æ–°)
             */
            async function handleOpenRedPacket(packet) {
                const chat = state.chats[state.activeChatId];
                const myNickname = chat.settings.myNickname || 'æˆ‘';

                // 1. æ£€æŸ¥çº¢åŒ…æ˜¯å¦è¿˜èƒ½é¢†
                const remainingCount = packet.count - Object.keys(packet.claimedBy || {}).length;
                if (remainingCount <= 0) {
                    packet.isFullyClaimed = true;
                    await db.chats.put(chat);
                    await showCustomAlert("æ‰‹æ…¢äº†", "çº¢åŒ…å·²è¢«é¢†å®Œï¼");
                    return null; // è¿”å›nullè¡¨ç¤ºé¢†å–å¤±è´¥
                }

                // 2. è®¡ç®—é¢†å–é‡‘é¢
                let claimedAmount = 0;
                const remainingAmount = packet.totalAmount - Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
                if (packet.packetType === 'lucky') {
                    if (remainingCount === 1) { claimedAmount = remainingAmount; }
                    else {
                        const min = 0.01;
                        const max = remainingAmount - (remainingCount - 1) * min;
                        claimedAmount = Math.random() * (max - min) + min;
                    }
                } else { claimedAmount = packet.totalAmount; }
                claimedAmount = parseFloat(claimedAmount.toFixed(2));

                // 3. æ›´æ–°çº¢åŒ…æ•°æ®
                if (!packet.claimedBy) packet.claimedBy = {};
                packet.claimedBy[myNickname] = claimedAmount;

                const isNowFullyClaimed = Object.keys(packet.claimedBy).length >= packet.count;
                if (isNowFullyClaimed) {
                    packet.isFullyClaimed = true;
                }

                // 4. æ„å»ºç³»ç»Ÿæ¶ˆæ¯å’ŒAIæŒ‡ä»¤
                let hiddenMessageContent = isNowFullyClaimed
                    ? `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ· (${myNickname}) é¢†å–äº†æœ€åä¸€ä¸ªçº¢åŒ…ï¼Œç°åœ¨ ${packet.senderName} çš„çº¢åŒ…å·²è¢«é¢†å®Œã€‚è¯·å¯¹æ­¤äº‹ä»¶å‘è¡¨è¯„è®ºã€‚]`
                    : `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ· (${myNickname}) åˆšåˆšé¢†å–äº†çº¢åŒ… (æ—¶é—´æˆ³: ${packet.timestamp})ã€‚çº¢åŒ…è¿˜æœªé¢†å®Œï¼Œä½ ç°åœ¨å¯ä»¥ä½¿ç”¨ 'open_red_packet' æŒ‡ä»¤æ¥å°è¯•é¢†å–ã€‚]`;

                const visibleMessage = { role: 'system', type: 'pat_message', content: `ä½ é¢†å–äº† ${packet.senderName} çš„çº¢åŒ…`, timestamp: Date.now() };
                const hiddenMessage = { role: 'system', content: hiddenMessageContent, timestamp: Date.now() + 1, isHidden: true };
                chat.history.push(visibleMessage, hiddenMessage);

                // 5. ä¿å­˜åˆ°æ•°æ®åº“
                await db.chats.put(chat);

                // 6. è¿”å›é¢†å–çš„é‡‘é¢ï¼Œç”¨äºåç»­å¼¹çª—
                return claimedAmount;
            }
            // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

            /**
             * ã€å…¨æ–°ã€‘æ˜¾ç¤ºçº¢åŒ…é¢†å–è¯¦æƒ…çš„æ¨¡æ€æ¡† (V4 - å·²ä¿®å¤å‚æ•°é”™è¯¯)
             */
            async function showRedPacketDetails(packet) {
                // 1. ç›´æ¥æ£€æŸ¥ä¼ å…¥çš„packetå¯¹è±¡æ˜¯å¦å­˜åœ¨ï¼Œæ— éœ€å†æŸ¥æ‰¾
                if (!packet) {
                    console.error("showRedPacketDetailsæ”¶åˆ°äº†æ— æ•ˆçš„packetå¯¹è±¡");
                    return;
                }

                const chat = state.chats[state.activeChatId];
                if (!chat) return;

                const modal = document.getElementById('red-packet-details-modal');
                const myNickname = chat.settings.myNickname || 'æˆ‘';

                // 2. åç»­æ‰€æœ‰é€»è¾‘ä¿æŒä¸å˜ï¼Œç›´æ¥ä½¿ç”¨ä¼ å…¥çš„packetå¯¹è±¡
                document.getElementById('rp-details-sender').textContent = packet.senderName;
                document.getElementById('rp-details-greeting').textContent = packet.greeting || 'æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©ï¼';

                const myAmountEl = document.getElementById('rp-details-my-amount');
                if (packet.claimedBy && packet.claimedBy[myNickname]) {
                    myAmountEl.querySelector('span:first-child').textContent = packet.claimedBy[myNickname].toFixed(2);
                    myAmountEl.style.display = 'block';
                } else {
                    myAmountEl.style.display = 'none';
                }

                const claimedCount = Object.keys(packet.claimedBy || {}).length;
                const claimedAmountSum = Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
                let summaryText = `${claimedCount}/${packet.count}ä¸ªçº¢åŒ…ï¼Œå…±${claimedAmountSum.toFixed(2)}/${packet.totalAmount.toFixed(2)}å…ƒã€‚`;
                if (!packet.isFullyClaimed && claimedCount < packet.count) {
                    const timeLeft = Math.floor((packet.timestamp + 24 * 60 * 60 * 1000 - Date.now()) / (1000 * 60 * 60));
                    if (timeLeft > 0) summaryText += ` å‰©ä½™çº¢åŒ…å°†åœ¨${timeLeft}å°æ—¶å†…é€€è¿˜ã€‚`;
                }
                document.getElementById('rp-details-summary').textContent = summaryText;

                const listEl = document.getElementById('rp-details-list');
                listEl.innerHTML = '';
                const claimedEntries = Object.entries(packet.claimedBy || {});

                let luckyKing = { name: '', amount: -1 };
                if (packet.packetType === 'lucky' && packet.isFullyClaimed && claimedEntries.length > 1) {
                    claimedEntries.forEach(([name, amount]) => {
                        if (amount > luckyKing.amount) {
                            luckyKing = { name, amount };
                        }
                    });
                }

                claimedEntries.sort((a, b) => b[1] - a[1]);

                claimedEntries.forEach(([name, amount]) => {
                    const item = document.createElement('div');
                    item.className = 'rp-details-item';
                    let luckyTag = '';
                    if (luckyKing.name && name === luckyKing.name) {
                        luckyTag = '<span class="lucky-king-tag">æ‰‹æ°”ç‹</span>';
                    }
                    item.innerHTML = `
            <span class="name">${name}</span>
            <span class="amount">${amount.toFixed(2)} å…ƒ</span>
            ${luckyTag}
        `;
                    listEl.appendChild(item);
                });

                modal.classList.add('visible');
            }
            // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

            // ç»‘å®šå…³é—­è¯¦æƒ…æŒ‰é’®çš„äº‹ä»¶
            document.getElementById('close-rp-details-btn').addEventListener('click', () => {
                document.getElementById('red-packet-details-modal').classList.remove('visible');
            });

            // ä¾›å…¨å±€è°ƒç”¨çš„å‡½æ•°ï¼Œä»¥ä¾¿çº¢åŒ…å¡ç‰‡ä¸Šçš„ onclick èƒ½æ‰¾åˆ°å®ƒ
            window.handlePacketClick = handlePacketClick;

            // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

            // â–¼â–¼â–¼ AI Reply Debugging Functions â–¼â–¼â–¼



            // â–¼â–¼â–¼ Share Link Functions â–¼â–¼â–¼
            function openShareLinkModal() {
                if (!state.activeChatId) return;

                // æ¸…ç©ºä¸Šæ¬¡è¾“å…¥çš„å†…å®¹
                document.getElementById('link-title-input').value = '';
                document.getElementById('link-description-input').value = '';
                document.getElementById('link-source-input').value = '';
                document.getElementById('link-content-input').value = '';

                // æ˜¾ç¤ºæ¨¡æ€æ¡†
                document.getElementById('share-link-modal').classList.add('visible');
            }

            async function sendUserLinkShare() {
                if (!state.activeChatId) return;

                const title = document.getElementById('link-title-input').value.trim();
                if (!title) {
                    alert("æ ‡é¢˜æ˜¯å¿…å¡«é¡¹å“¦ï¼");
                    return;
                }

                const description = document.getElementById('link-description-input').value.trim();
                const sourceName = document.getElementById('link-source-input').value.trim();
                const content = document.getElementById('link-content-input').value.trim();

                const chat = state.chats[state.activeChatId];

                // åˆ›å»ºæ¶ˆæ¯å¯¹è±¡
                const linkMessage = {
                    role: 'user', // è§’è‰²æ˜¯ 'user'
                    type: 'share_link',
                    timestamp: Date.now(),
                    title: title,
                    description: description,
                    source_name: sourceName,
                    content: content,
                    // ç”¨æˆ·åˆ†äº«çš„é“¾æ¥ï¼Œæˆ‘ä»¬ä¸æä¾›å›¾ç‰‡ï¼Œè®©å®ƒæ€»æ˜¯æ˜¾ç¤ºå ä½å›¾
                    thumbnail_url: null
                };

                // å°†æ¶ˆæ¯æ·»åŠ åˆ°å†å²è®°å½•
                chat.history.push(linkMessage);
                await db.chats.put(chat);

                // æ¸²æŸ“æ–°æ¶ˆæ¯å¹¶æ›´æ–°åˆ—è¡¨
                appendMessage(linkMessage, chat);
                renderChatList();

                // å…³é—­æ¨¡æ€æ¡†
                document.getElementById('share-link-modal').classList.remove('visible');
            }

            // â–¼â–¼â–¼ Location Share Functions â–¼â–¼â–¼
            function openLocationShareModal() {
                if (!state.activeChatId) return;

                // æ¸…ç©ºä¸Šæ¬¡è¾“å…¥çš„å†…å®¹ï¼ˆåªåœ¨éç¼–è¾‘æ¨¡å¼ä¸‹ï¼‰
                if (!window.editingLocationTimestamp) {
                    document.getElementById('location-name-input').value = '';
                    document.getElementById('location-address-input').value = '';

                    // é‡ç½®æ¨¡æ€æ¡†æ ‡é¢˜å’ŒæŒ‰é’®æ–‡æœ¬ä¸ºåˆ›å»ºæ¨¡å¼
                    document.querySelector('#location-share-modal .modal-header span').textContent = 'åˆ†äº«ä½ç½®';
                    document.getElementById('confirm-location-btn').textContent = 'å‘é€ä½ç½®';
                }

                // æ˜¾ç¤ºæ¨¡æ€æ¡†
                document.getElementById('location-share-modal').classList.add('visible');
            }

            async function sendUserLocationShare() {
                if (!state.activeChatId) return;

                // Check if we're in edit mode
                if (window.editingLocationTimestamp) {
                    await saveLocationEdit();
                    return;
                }

                const locationName = document.getElementById('location-name-input').value.trim();
                if (!locationName) {
                    alert("ä½ç½®åç§°æ˜¯å¿…å¡«é¡¹å“¦ï¼");
                    return;
                }

                const address = document.getElementById('location-address-input').value.trim();

                const chat = state.chats[state.activeChatId];

                // åˆ›å»ºæ¶ˆæ¯å¯¹è±¡
                const locationMessage = {
                    role: 'user',
                    type: 'location_share',
                    timestamp: Date.now(),
                    location_name: locationName,
                    address: address
                };

                // å°†æ¶ˆæ¯æ·»åŠ åˆ°å†å²è®°å½•
                chat.history.push(locationMessage);
                await db.chats.put(chat);

                // æ¸²æŸ“æ–°æ¶ˆæ¯å¹¶æ›´æ–°åˆ—è¡¨
                appendMessage(locationMessage, chat);
                renderChatList();

                // å…³é—­æ¨¡æ€æ¡†
                document.getElementById('location-share-modal').classList.remove('visible');
            }

            async function editLocationMessage(timestamp) {
                if (!state.activeChatId) return;

                const chat = state.chats[state.activeChatId];
                const message = chat.history.find(m => m.timestamp === timestamp);

                if (!message || message.type !== 'location_share') {
                    alert('æ‰¾ä¸åˆ°ä½ç½®æ¶ˆæ¯');
                    return;
                }

                // é¢„å¡«å……ç°æœ‰æ•°æ®
                document.getElementById('location-name-input').value = message.location_name || '';
                document.getElementById('location-address-input').value = message.address || '';

                // æ ‡è®°ä¸ºç¼–è¾‘æ¨¡å¼å¹¶æ›´æ”¹UI
                window.editingLocationTimestamp = timestamp;

                // æ›´æ”¹æ¨¡æ€æ¡†æ ‡é¢˜å’ŒæŒ‰é’®æ–‡æœ¬
                document.querySelector('#location-share-modal .modal-header span').textContent = 'ç¼–è¾‘ä½ç½®';
                document.getElementById('confirm-location-btn').textContent = 'ä¿å­˜ä¿®æ”¹';

                // æ˜¾ç¤ºæ¨¡æ€æ¡†
                document.getElementById('location-share-modal').classList.add('visible');
            }

            async function saveLocationEdit() {
                if (!window.editingLocationTimestamp || !state.activeChatId) return;

                const locationName = document.getElementById('location-name-input').value.trim();
                if (!locationName) {
                    alert("ä½ç½®åç§°æ˜¯å¿…å¡«é¡¹å“¦ï¼");
                    return;
                }

                const address = document.getElementById('location-address-input').value.trim();
                const chat = state.chats[state.activeChatId];
                const messageIndex = chat.history.findIndex(m => m.timestamp === window.editingLocationTimestamp);

                if (messageIndex === -1) {
                    alert('æ‰¾ä¸åˆ°è¦ç¼–è¾‘çš„æ¶ˆæ¯');
                    return;
                }

                // æ›´æ–°æ¶ˆæ¯
                chat.history[messageIndex].location_name = locationName;
                chat.history[messageIndex].address = address;

                // ä¿å­˜åˆ°æ•°æ®åº“
                await db.chats.put(chat);

                // å…³é—­æ‰€æœ‰ç›¸å…³æ¨¡æ€æ¡†
                document.getElementById('location-share-modal').classList.remove('visible');
                document.getElementById('message-actions-modal').classList.remove('visible');

                // åˆ·æ–°UI
                renderChatInterface(state.activeChatId);
                renderChatList();

                // æ¸…ç†ç¼–è¾‘çŠ¶æ€å¹¶é‡ç½®UI
                window.editingLocationTimestamp = null;
                activeMessageTimestamp = null;
                document.querySelector('#location-share-modal .modal-header span').textContent = 'åˆ†äº«ä½ç½®';
                document.getElementById('confirm-location-btn').textContent = 'å‘é€ä½ç½®';
            }
            // â–²â–²â–² Location Share Functions End â–²â–²â–²

            // â–¼â–¼â–¼ Meetup Edit Modal Functions â–¼â–¼â–¼
            function openMeetupEditModal() {
                if (!window.activeMeetupSession || !window.activeMeetupEventId) {
                    alert('æ²¡æœ‰æ´»åŠ¨çš„è§é¢ä¼šè¯');
                    return;
                }

                // Get current meetup details from the active session
                const session = window.activeMeetupSession;

                // Pre-fill the modal with current values
                document.getElementById('meetup-title-input').value = session.title || '';
                document.getElementById('meetup-location-input').value = session.location || '';

                // Change modal title to indicate editing
                document.querySelector('#meetup-creation-modal .modal-header span').textContent = 'ç¼–è¾‘è§é¢è¯¦æƒ…';

                // Change button text to indicate editing
                document.getElementById('start-meetup-btn').textContent = 'ä¿å­˜æ›´æ”¹';

                // Set a flag to indicate we're in edit mode
                window.isEditingMeetup = true;

                // Show modal
                document.getElementById('meetup-creation-modal').classList.add('visible');

                // Focus on first input field
                document.getElementById('meetup-title-input').focus();
            }

            // â–¼â–¼â–¼ Meetup Creation Modal Functions â–¼â–¼â–¼
            function openMeetupCreationModal() {
                if (!state.activeChatId) {
                    alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠå¤©å¯¹è±¡');
                    return;
                }

                // Get current chat context
                const chat = state.chats[state.activeChatId];
                if (!chat) {
                    alert('æ— æ³•è·å–èŠå¤©ä¿¡æ¯');
                    return;
                }

                // Check if this is a group chat (date mode should be for individual chats)
                if (chat.isGroup) {
                    alert('è§é¢æ¨¡å¼ä»…æ”¯æŒå•äººèŠå¤©ï¼Œä¸æ”¯æŒç¾¤èŠ');
                    return;
                }

                // Clear previous input values
                document.getElementById('meetup-location-input').value = '';
                document.getElementById('meetup-title-input').value = '';

                // Store current chat context for date creation
                window.currentDateChatContext = {
                    chatId: state.activeChatId,
                    chatName: chat.name || 'èŠå¤©å¯¹è±¡',
                    aiName: chat.name || 'AI',
                    isGroup: chat.isGroup || false
                };

                // Show modal
                document.getElementById('meetup-creation-modal').classList.add('visible');

                // Focus on first input field
                setTimeout(() => {
                    document.getElementById('meetup-location-input').focus();
                }, 100);
            }

            function closeMeetupCreationModal() {
                document.getElementById('meetup-creation-modal').classList.remove('visible');

                // Reset modal to creation mode
                const headerSpan = document.querySelector('#meetup-creation-modal .modal-header span');
                const startBtn = document.getElementById('start-meetup-btn');

                if (headerSpan) {
                    headerSpan.textContent = 'å¼€å§‹è§é¢';
                }
                if (startBtn) {
                    startBtn.textContent = 'å¼€å§‹è§é¢';
                }
                window.isEditingMeetup = false;

                // Clear chat context (only for creation mode)
                if (!window.isEditingMeetup) {
                    window.currentDateChatContext = null;
                }

                // Clear input values
                document.getElementById('meetup-location-input').value = '';
                document.getElementById('meetup-title-input').value = '';
            }

            function validateMeetupInputs() {
                const location = document.getElementById('meetup-location-input').value.trim();
                const title = document.getElementById('meetup-title-input').value.trim();

                if (!title) {
                    alert('è¯·è¾“å…¥è§é¢ä¸»é¢˜');
                    return false;
                }

                // Location is optional - no validation needed

                return true;
            }

            async function startMeetup() {
                if (!validateMeetupInputs()) return;

                const location = document.getElementById('meetup-location-input').value.trim();
                const title = document.getElementById('meetup-title-input').value.trim();

                // Check if we're in edit mode
                if (window.isEditingMeetup) {
                    try {
                        // Update existing meetup session
                        await updateMeetupDetails(location, title);

                        // Close modal and reset edit mode
                        closeMeetupCreationModal();
                        window.isEditingMeetup = false;

                        // Show success message
                        showNotification('è§é¢è¯¦æƒ…å·²æ›´æ–°ï¼âœ¨');

                    } catch (error) {
                        console.error('Failed to update meetup details:', error);
                        alert('æ›´æ–°å¤±è´¥ï¼Œè¯·é‡è¯•');
                    }
                    return;
                }

                // Original creation logic
                if (!window.currentDateChatContext) {
                    alert('èŠå¤©ä¸Šä¸‹æ–‡ä¸¢å¤±ï¼Œè¯·é‡æ–°æ‰“å¼€');
                    return;
                }

                const chatContext = window.currentDateChatContext;



                try {
                    let eventId;

                    // Check if we're updating an existing calendar event
                    if (chatContext && chatContext.originalMemoryId) {
                        // Update existing event instead of creating new one
                        eventId = await updateExistingCalendarEvent(chatContext.originalMemoryId, location, title, chatContext);
                    } else {
                        // Create new calendar event (for fresh meetups)
                        eventId = await createDateCalendarEvent(location, title, chatContext);
                    }

                    // Start date mode session
                    await initiateMeetupSession(location, title, chatContext);

                    // Close modal
                    closeMeetupCreationModal();

                    // Navigate to meetup screen
                    showScreen('meetup-screen');

                    // Update date mode context with the actual details
                    const eventData = {
                        title: title,
                        location: location,
                        timeDisplay: new Date().toLocaleString('zh-CN'),
                        phase: 'during'
                    };
                    updateMeetupContext(eventData);

                    // Show success message
                    showNotification(`ä¸${chatContext.aiName}çš„è§é¢å¼€å§‹äº†ï¼ğŸ’•`);

                    // Only refresh calendar if it's currently visible
                    if (document.getElementById('calendar-screen').classList.contains('active')) {
                        renderCalendarScreen();
                    }

                } catch (error) {
                    console.error('Failed to start date mode:', error);
                    alert('å¼€å§‹è§é¢å¤±è´¥ï¼Œè¯·é‡è¯•');
                    return; // Don't proceed if there's an error
                }
            }

            async function updateMeetupDetails(newLocation, newTitle) {
                if (!window.activeMeetupSession || !window.activeMeetupEventId) {
                    throw new Error('No active meetup session');
                }

                try {
                    // Update the active session
                    window.activeMeetupSession.location = newLocation;
                    window.activeMeetupSession.title = newTitle;

                    // Update the calendar event in database
                    const eventId = window.activeMeetupEventId;
                    const event = await db.memories.get(eventId);

                    if (event) {
                        event.description = newLocation ? `${newTitle} - åœ¨${newLocation}` : newTitle;
                        event.meetupData.location = newLocation;
                        event.meetupData.title = newTitle;

                        await db.memories.put(event);
                    }

                    // Update the UI immediately
                    const eventData = {
                        title: newTitle,
                        location: newLocation,
                        timeDisplay: new Date(window.activeMeetupSession.startTime).toLocaleString('zh-CN'),
                        phase: 'during'
                    };
                    updateMeetupContext(eventData);

                    // Refresh calendar if it's currently visible
                    if (document.getElementById('calendar-screen').classList.contains('active')) {
                        renderCalendarScreen();
                    }

                } catch (error) {
                    console.error('Failed to update meetup details:', error);
                    throw error;
                }
            }
            // â–²â–²â–² Date Creation Modal Functions End â–²â–²â–²

            // â–¼â–¼â–¼ Calendar Event Creation for Date Mode â–¼â–¼â–¼
            async function updateExistingCalendarEvent(memoryId, location, title, chatContext) {
                try {


                    // Get the existing memory/event
                    const existingEvent = await db.memories.get(memoryId);


                    if (!existingEvent) {
                        throw new Error('Original calendar event not found');
                    }

                    // Add meetup data to existing event WITHOUT changing original data
                    // Keep original: description, timestamp, authorName, etc.
                    // Only add/update the meetup-specific data and change type to meetup
                    existingEvent.type = 'meetup'; // Change type so updateDateCalendarEvent can find it
                    existingEvent.meetupData = {
                        location: location,
                        title: title,
                        aiName: chatContext.aiName,
                        isActive: true,
                        startTime: Date.now(),
                        endTime: null,
                        messages: [],
                        visitedLocations: [location]
                    };

                    // Update in database
                    await db.memories.put(existingEvent);

                    // Store the event ID for future reference
                    window.activeMeetupEventId = memoryId;

                    return memoryId;

                } catch (error) {
                    console.error('Failed to update existing calendar event:', error);
                    throw error;
                }
            }

            async function createDateCalendarEvent(location, title, chatContext) {
                try {
                    // Create a special calendar event for date mode
                    const dateEvent = {
                        chatId: chatContext.chatId,
                        authorName: chatContext.aiName,
                        description: location ? `${title} - åœ¨${location}` : title,
                        timestamp: Date.now(),
                        type: 'meetup',
                        targetDate: Date.now(), // Meetup starts immediately
                        meetupData: {
                            location: location,
                            title: title,
                            aiName: chatContext.aiName,
                            isActive: true,
                            startTime: Date.now(),
                            endTime: null,
                            messages: [],
                            visitedLocations: [location]
                        }
                    };

                    // Add to database
                    const eventId = await db.memories.add(dateEvent);

                    // Store the event ID for future reference
                    window.activeMeetupEventId = eventId;

                    return eventId;

                } catch (error) {
                    console.error('Failed to create date calendar event:', error);
                    throw error;
                }
            }

            async function initiateMeetupSession(location, title, chatContext) {

                // Store the session info globally
                window.activeMeetupSession = {
                    eventId: window.activeMeetupEventId,
                    chatId: chatContext.chatId,
                    location: location,
                    title: title,
                    aiName: chatContext.aiName,
                    startTime: Date.now(),
                    isActive: true
                };

                // Persist session state for app backgrounding/restoration
                localStorage.setItem('activeMeetupSession', JSON.stringify(window.activeMeetupSession));
                localStorage.setItem('activeMeetupEventId', window.activeMeetupEventId);

                // Show the meetup progress bar
                showMeetupProgressBar();

                // Refresh calendar status indicators if calendar is visible
                if (typeof refreshCalendarStatusIndicators === 'function') {
                    refreshCalendarStatusIndicators();
                }

                return Promise.resolve();
            }

            // Function to update date mode calendar event
            async function updateDateCalendarEvent(eventId, updates) {
                try {
                    const event = await db.memories.get(eventId);
                    if (!event || event.type !== 'meetup') {
                        throw new Error('Meetup event not found');
                    }

                    // Update the event data
                    Object.assign(event.meetupData, updates);

                    // Mark as having date mode history when completed
                    if (updates.isCompleted) {
                        event.hasMeetupHistory = true;
                    }

                    // Save back to database
                    await db.memories.put(event);



                } catch (error) {
                    console.error('Failed to update date calendar event:', error);
                    throw error;
                }
            }

            // Function to end date mode and finalize calendar event
            async function endMeetupSession() {
                // Prevent multiple simultaneous executions
                if (window.endMeetupSessionInProgress) {
                    return;
                }

                window.endMeetupSessionInProgress = true;

                if (!window.activeMeetupSession || !window.activeMeetupEventId) {
                    window.endMeetupSessionInProgress = false;
                    return;
                }

                try {
                    // Try to update the calendar event with end time and completion status
                    try {
                        const session = window.activeMeetupSession;
                        const chat = state.chats[session.chatId];
                        const endTime = Date.now();

                        // Get all date mode messages for this event
                        const meetupMessages = chat && chat.history ? chat.history.filter(msg =>
                            msg.meetup && msg.meetup.eventId === window.activeMeetupEventId
                        ) : [];

                        // DEBUG: Log what messages are being saved
                        console.log('DEBUG - Meetup session end - saving messages:', {
                            eventId: window.activeMeetupEventId,
                            sessionStartTime: session.startTime,
                            totalChatHistory: chat ? chat.history.length : 0,
                            filteredMeetupMessages: meetupMessages.length,
                            meetupMessages: meetupMessages
                        });

                        // Calculate date duration in minutes
                        const totalDuration = Math.round((endTime - session.startTime) / (1000 * 60));

                        // Extract behavioral notations from all messages
                        const behavioralNotations = [];
                        meetupMessages.forEach(msg => {
                            if (msg.content && typeof msg.content === 'string') {
                                const notationRegex = /\[([^\]]+)\]/g;
                                let match;
                                while ((match = notationRegex.exec(msg.content)) !== null) {
                                    behavioralNotations.push(match[1]);
                                }
                            }
                        });

                        await updateDateCalendarEvent(window.activeMeetupEventId, {
                            isActive: false,
                            isCompleted: true,
                            endTime: endTime,
                            totalDuration: totalDuration,
                            messageCount: meetupMessages.length,
                            behavioralNotations: behavioralNotations,
                            messages: meetupMessages,
                            interactions: meetupMessages // Keep both for compatibility
                        });
                    } catch (calendarError) {

                        // Recreate the calendar event with all the date interactions
                        try {
                            const session = window.activeMeetupSession;
                            const chat = state.chats[session.chatId];

                            if (chat && chat.history) {
                                // Check if we already have a recreated event to prevent duplicates
                                const existingEvents = await db.memories.where('chatId').equals(session.chatId)
                                    .and(event => event.type === 'meetup' &&
                                        event.meetupData &&
                                        event.meetupData.startTime === session.startTime)
                                    .toArray();

                                if (existingEvents.length > 0) {
                                    window.activeMeetupEventId = existingEvents[0].id;
                                    return;
                                }

                                // Get all date mode messages for this event
                                const meetupMessages = chat.history.filter(msg =>
                                    msg.meetup && (msg.meetup.eventId === session.eventId || msg.meetup.eventId === window.activeMeetupEventId)
                                );

                                // DEBUG: Log messages being saved in recreation
                                console.log('DEBUG - Meetup session recreation - saving messages:', {
                                    eventId: session.eventId,
                                    totalChatHistory: chat.history.length,
                                    filteredMeetupMessages: meetupMessages.length,
                                    meetupMessages: meetupMessages
                                });

                                // Calculate date duration in minutes
                                const endTime = Date.now();
                                const totalDuration = Math.round((endTime - session.startTime) / (1000 * 60));

                                // Extract behavioral notations from all messages
                                const behavioralNotations = [];
                                meetupMessages.forEach(msg => {
                                    if (msg.content && typeof msg.content === 'string') {
                                        const notationRegex = /\[([^\]]+)\]/g;
                                        let match;
                                        while ((match = notationRegex.exec(msg.content)) !== null) {
                                            behavioralNotations.push(match[1]);
                                        }
                                    }
                                });

                                // Create new calendar event with all interactions and metadata
                                const newDateEvent = {
                                    chatId: session.chatId,
                                    authorName: chat.name,
                                    description: `ä¸${chat.name}çš„è§é¢è®°å½•`,
                                    timestamp: session.startTime,
                                    type: 'meetup',
                                    targetDate: session.startTime,
                                    hasMeetupHistory: true,
                                    meetupData: {
                                        sessionId: session.eventId || 'session_' + session.startTime,
                                        location: session.location,
                                        title: session.title,
                                        chatId: session.chatId,
                                        aiName: chat.name,
                                        isActive: false,
                                        isCompleted: true,
                                        startTime: session.startTime,
                                        endTime: endTime,
                                        totalDuration: totalDuration,
                                        messageCount: meetupMessages.length,
                                        behavioralNotations: behavioralNotations,
                                        visitedLocations: [session.location],
                                        messages: meetupMessages,
                                        interactions: meetupMessages // Keep both for compatibility
                                    }
                                };

                                const newEventId = await db.memories.add(newDateEvent);

                                // Add to cache if it exists
                                if (window.memoriesData) {
                                    // Get the complete memory object with the new ID
                                    const completeMemory = { ...newDateEvent, id: newEventId };
                                    window.memoriesData.push(completeMemory);
                                }

                                // Update the session with new event ID
                                window.activeMeetupEventId = newEventId;
                            }
                        } catch (recreateError) {
                            console.error('Failed to recreate calendar event:', recreateError);
                            // Continue with session cleanup even if recreation fails
                        }
                    }

                    // Hide the meetup progress bar
                    hideMeetupProgressBar();

                    // Clear active session
                    window.activeMeetupSession = null;
                    window.activeMeetupEventId = null;

                    // Clear persisted session state
                    localStorage.removeItem('activeMeetupSession');
                    localStorage.removeItem('activeMeetupEventId');

                    // Refresh calendar and memories screens to show completed date
                    try {
                        renderCalendarScreen();
                        renderMemoriesScreen();
                    } catch (refreshError) {
                        console.error('Failed to refresh screens after date completion:', refreshError);
                        // Continue execution even if screen refresh fails
                    }

                } catch (error) {
                    console.error('Failed to end date mode session:', error);
                    throw error;
                } finally {
                    // Always reset the flag
                    window.endMeetupSessionInProgress = false;
                }
            }

            // Function to retrieve date mode session data from calendar event
            async function getMeetupSessionFromEvent(eventId) {
                try {
                    const event = await db.memories.get(eventId);
                    if (!event || event.type !== 'meetup') {
                        throw new Error('Meetup event not found');
                    }

                    return event.meetupData;

                } catch (error) {
                    console.error('Failed to retrieve date mode session:', error);
                    throw error;
                }
            }

            // Function to check if there's an active date mode session
            function hasActiveMeetupSession() {
                return window.activeMeetupSession && window.activeMeetupEventId;
            }

            // Function to open date mode history view
            async function openMeetupHistory(eventId) {
                try {
                    // Verify the event exists and has date mode data
                    const event = await db.memories.get(eventId);
                    if (!event || event.type !== 'meetup' || !event.meetupData) {
                        throw new Error('Invalid date mode event');
                    }

                    // Set global flag for history viewing
                    window.meetupHistoryEventId = eventId;

                    // Navigate to meetup screen in history mode
                    showScreen('meetup-screen');

                } catch (error) {
                    console.error('Failed to open date mode history:', error);
                    alert('æ— æ³•æ‰“å¼€è§é¢å›å¿†: ' + error.message);
                }
            }

            // Make function globally accessible
            window.openMeetupHistory = openMeetupHistory;

            // Function to update calendar event's stored date mode data after edits/deletes
            async function updateCalendarEventMeetupData(eventId, chat) {
                try {
                    // Get the calendar event
                    const event = await db.memories.get(eventId);
                    if (!event || event.type !== 'meetup') return;

                    // Filter date mode messages for this event from chat history
                    const meetupMessages = chat.history.filter(msg =>
                        msg.meetup && msg.meetup.eventId === eventId
                    );

                    // Update the event's meetupData.messages
                    if (!event.meetupData) {
                        event.meetupData = {};
                    }
                    event.meetupData.messages = meetupMessages;

                    // Save the updated event
                    await db.memories.put(event);

                } catch (error) {
                    console.error('Failed to update calendar event:', error);
                }
            }

            // Function to delete all date mode messages associated with an event
            async function deleteMeetupMessages(eventId) {
                try {
                    console.log('DEBUG - Deleting meetup messages for event:', eventId);

                    // Get the event to find the associated chat
                    const event = await db.memories.get(eventId);
                    if (!event || event.type !== 'meetup') {
                        console.log('DEBUG - Event not found or not meetup type');
                        return;
                    }

                    const chat = state.chats[event.chatId];
                    if (!chat) {
                        console.log('DEBUG - Chat not found for event:', event.chatId);
                        return;
                    }

                    // Filter out messages with matching eventId
                    const originalLength = chat.history.length;
                    chat.history = chat.history.filter(msg =>
                        !(msg.meetup && msg.meetup.eventId === eventId)
                    );

                    const deletedCount = originalLength - chat.history.length;

                    console.log('DEBUG - Meetup messages deletion:', {
                        eventId: eventId,
                        originalLength: originalLength,
                        newLength: chat.history.length,
                        deletedCount: deletedCount
                    });

                    // Save updated chat history
                    if (deletedCount > 0) {
                        await db.chats.put(chat);
                        console.log('DEBUG - Chat history updated after message deletion');
                    }

                    return deletedCount;

                } catch (error) {
                    console.error('DEBUG - Failed to delete meetup messages:', error);
                    throw error;
                }
            }

            // Make function globally accessible
            window.deleteMeetupMessages = deleteMeetupMessages;

            // Function to load existing messages for active date session
            async function loadActiveMeetupMessages() {
                if (!window.activeMeetupSession || !window.activeMeetupEventId) {
                    return;
                }

                const session = window.activeMeetupSession;
                const chat = state.chats[session.chatId];

                if (!chat) {
                    return;
                }

                // Get existing meetup mode messages for this event
                const existingMessages = chat.history.filter(msg =>
                    msg.meetup && msg.meetup.eventId === window.activeMeetupEventId
                );

                const messagesContainer = document.getElementById('meetup-messages');
                if (!messagesContainer) return;

                // Clear existing display
                messagesContainer.innerHTML = '';

                // Display existing messages
                existingMessages.forEach(message => {
                    // Convert stored message to display format
                    const displayMessage = {
                        content: message.content,
                        timestamp: message.timestamp,
                        isUser: message.role === 'user',
                        type: 'meetup_interaction',
                        isHidden: true // Safety: ensure display messages are also hidden
                    };

                    const messageElement = createMeetupMessage(displayMessage, message.role === 'user');
                    messagesContainer.appendChild(messageElement);
                });

                // Scroll to bottom
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            // Function to update a date mode message in chat history
            async function updateMeetupMessageInHistory(timestamp, newContent) {
                // Handle both active meetup mode and history mode
                let eventId, chatId;

                if (window.meetupHistoryEventId) {
                    // History mode
                    eventId = window.meetupHistoryEventId;
                    chatId = state.activeChatId; // Set in initializeMeetupHistoryView
                } else if (window.activeMeetupSession && window.activeMeetupEventId) {
                    // Active meetup mode
                    eventId = window.activeMeetupEventId;
                    chatId = window.activeMeetupSession.chatId;
                } else {
                    return;
                }

                const chat = state.chats[chatId];

                if (!chat) return;

                // Find and update the message in chat history
                const messageIndex = chat.history.findIndex(msg =>
                    msg.meetup &&
                    msg.meetup.eventId === eventId &&
                    msg.timestamp === parseInt(timestamp)
                );

                if (messageIndex === -1) return;

                // Update the message content
                chat.history[messageIndex].content = newContent;

                // Save updated chat history
                try {
                    await db.chats.put(chat);

                    // Also update the calendar event's stored meetup data
                    if (window.meetupHistoryEventId) {
                        await updateCalendarEventMeetupData(window.meetupHistoryEventId, chat);
                    }
                } catch (error) {
                    console.error('Failed to update message in chat history:', error);
                }
            }

            // Function to restore active date session from localStorage
            function restoreActiveMeetupSession() {
                try {
                    const savedSession = localStorage.getItem('activeMeetupSession');
                    const savedEventId = localStorage.getItem('activeMeetupEventId');

                    if (savedSession && savedEventId) {
                        window.activeMeetupSession = JSON.parse(savedSession);
                        window.activeMeetupEventId = parseInt(savedEventId, 10); // Convert string to number

                        return true;
                    }
                } catch (error) {
                    console.error('Failed to restore active meetup session:', error);
                    // Clear corrupted data
                    localStorage.removeItem('activeMeetupSession');
                    localStorage.removeItem('activeMeetupEventId');
                }

                return false;
            }

            // â–¼â–¼â–¼ Meetup End Modal Functions â–¼â–¼â–¼
            function showMeetupEndModal() {
                if (!hasActiveMeetupSession()) {
                    alert('æ²¡æœ‰æ´»è·ƒçš„è§é¢ä¼šè¯');
                    return;
                }
                document.getElementById('meetup-end-modal').classList.add('visible');
            }

            function hideMeetupEndModal() {
                document.getElementById('meetup-end-modal').classList.remove('visible');
            }

            // Make function globally accessible
            window.hideMeetupEndModal = hideMeetupEndModal;

            async function confirmEndMeetup() {
                // Prevent multiple simultaneous executions
                if (window.confirmEndMeetupInProgress) {
                    return;
                }

                window.confirmEndMeetupInProgress = true;

                try {
                    // Preserve session data BEFORE calling endMeetupSession (which clears it)
                    const preservedSession = window.activeMeetupSession;

                    // End the date mode session
                    await endMeetupSession();

                    // Hide the modal
                    hideMeetupEndModal();

                    // Show success message and navigate using preserved session data
                    if (preservedSession && preservedSession.chatId) {
                        showNotification(preservedSession.chatId, 'è§é¢å·²ç»“æŸï¼Œç¾å¥½å›å¿†å·²ä¿å­˜åˆ°æ—¥å† ğŸ’•');

                        // Check if there's an active music session with a different chat
                        if (musicState.isActive && musicState.activeChatId && musicState.activeChatId !== preservedSession.chatId) {
                            // If music is playing with a different AI, navigate to that AI instead
                            // to preserve the music session
                            openChat(musicState.activeChatId);
                        } else {
                            // Otherwise, navigate to the date AI's chat
                            openChat(preservedSession.chatId);
                        }
                    } else {
                        // Fallback if no session data
                        showScreen('chat-interface-screen');
                    }

                    // Clear previous screen tracking since we always go to chat
                    previousScreen = null;

                } catch (error) {
                    console.error('Error in confirmEndMeetup:', error);
                    alert('ç»“æŸè§é¢æ—¶å‡ºç°é”™è¯¯: ' + error.message);
                } finally {
                    // Always reset the flag
                    window.confirmEndMeetupInProgress = false;
                }
            }

            // Make function globally accessible
            window.confirmEndMeetup = confirmEndMeetup;
            // â–²â–²â–² Meetup End Modal Functions End â–²â–²â–²

            // â–¼â–¼â–¼ Meetup Progress Bar Functions â–¼â–¼â–¼

            function showMeetupProgressBar() {
                if (!hasActiveMeetupSession()) {
                    return;
                }

                const session = window.activeMeetupSession;
                const chatId = session.chatId;
                const chat = state.chats[chatId];

                if (!chat) {
                    console.warn('Chat not found for active date session');
                    return;
                }

                // Update progress bar content
                updateMeetupProgressBarContent();

                // Show chat screen meetup progress bar
                const meetupBar = document.getElementById('meetup-progress-bar');
                if (meetupBar) {
                    meetupBar.classList.remove('hidden');
                    // Add class to chat screen to adjust music bar positioning
                    const chatScreen = document.getElementById('chat-interface-screen');
                    if (chatScreen) {
                        chatScreen.classList.add('has-meetup-progress');
                    }
                }

                // Show home screen meetup progress bar
                const homeMeetupBar = document.getElementById('home-meetup-progress-bar');
                if (homeMeetupBar) {
                    homeMeetupBar.classList.remove('hidden');
                    // Add class to home screen to adjust music bar positioning
                    const homeScreen = document.getElementById('home-screen');
                    if (homeScreen) {
                        homeScreen.classList.add('has-meetup-progress');
                    }
                }

                // Start timer to update elapsed time every second
                if (window.meetupProgressTimer) {
                    clearInterval(window.meetupProgressTimer);
                }
                window.meetupProgressTimer = setInterval(() => {
                    if (hasActiveMeetupSession()) {
                        updateMeetupProgressBarContent();
                    } else {
                        clearInterval(window.meetupProgressTimer);
                        window.meetupProgressTimer = null;
                    }
                }, 1000); // Update every second
            }

            function hideMeetupProgressBar() {
                // Hide chat screen meetup progress bar
                const meetupBar = document.getElementById('meetup-progress-bar');
                if (meetupBar) {
                    meetupBar.classList.add('hidden');
                    // Remove class from chat screen to restore music bar positioning
                    const chatScreen = document.getElementById('chat-interface-screen');
                    if (chatScreen) {
                        chatScreen.classList.remove('has-meetup-progress');
                    }
                }

                // Hide home screen meetup progress bar
                const homeMeetupBar = document.getElementById('home-meetup-progress-bar');
                if (homeMeetupBar) {
                    homeMeetupBar.classList.add('hidden');
                    // Remove class from home screen to restore music bar positioning
                    const homeScreen = document.getElementById('home-screen');
                    if (homeScreen) {
                        homeScreen.classList.remove('has-meetup-progress');
                    }
                }

                // Clear the elapsed time timer
                if (window.meetupProgressTimer) {
                    clearInterval(window.meetupProgressTimer);
                    window.meetupProgressTimer = null;
                }
            }

            function updateMeetupProgressBarContent() {
                if (!hasActiveMeetupSession()) {
                    return;
                }

                const session = window.activeMeetupSession;
                const chatId = session.chatId;
                const chat = state.chats[chatId];

                if (!chat) {
                    return;
                }

                const aiName = chat.name || 'AI';
                const location = session.location;
                const progressText = location ? `ä¸${aiName}åœ¨${location}` : `ä¸${aiName}ä¸€èµ·`;

                // Calculate elapsed time
                const elapsedMs = Date.now() - session.startTime;
                const totalSeconds = Math.floor(elapsedMs / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;

                // Format as MM:SS if no hours, HH:MM:SS if there are hours
                let elapsedText;
                if (hours > 0) {
                    elapsedText = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                } else {
                    elapsedText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }

                // Update chat screen progress bar
                const meetupProgressText = document.getElementById('meetup-progress-text');
                const meetupElapsedText = document.getElementById('meetup-elapsed-text');
                const meetupAiAvatar = document.getElementById('meetup-ai-avatar');

                if (meetupProgressText) {
                    meetupProgressText.textContent = progressText;
                }

                if (meetupElapsedText) {
                    meetupElapsedText.textContent = elapsedText;
                }

                if (meetupAiAvatar) {
                    meetupAiAvatar.src = chat.settings.aiAvatar;
                    meetupAiAvatar.style.display = 'block';
                }

                // Update home screen progress bar
                const homeMeetupProgressText = document.getElementById('home-meetup-progress-text');
                const homeMeetupElapsedText = document.getElementById('home-meetup-elapsed-text');
                const homeMeetupAiAvatar = document.getElementById('home-meetup-ai-avatar');

                if (homeMeetupProgressText) {
                    homeMeetupProgressText.textContent = progressText;
                }

                if (homeMeetupElapsedText) {
                    homeMeetupElapsedText.textContent = elapsedText;
                }

                if (homeMeetupAiAvatar) {
                    homeMeetupAiAvatar.src = chat.settings.aiAvatar;
                    homeMeetupAiAvatar.style.display = 'block';
                }
            }

            function initializeMeetupProgressBar() {
                // Chat screen meetup progress bar tap-to-return functionality
                const meetupBar = document.getElementById('meetup-progress-bar');
                if (meetupBar) {
                    meetupBar.addEventListener('click', () => {
                        if (hasActiveMeetupSession()) {
                            showScreen('meetup-screen');
                        }
                    });
                }

                // Home screen meetup progress bar tap-to-return functionality
                const homeMeetupBar = document.getElementById('home-meetup-progress-bar');
                if (homeMeetupBar) {
                    homeMeetupBar.addEventListener('click', () => {
                        if (hasActiveMeetupSession()) {
                            showScreen('meetup-screen');
                        }
                    });
                }
            }

            // â–²â–²â–² Meetup Progress Bar Functions End â–²â–²â–²

            // â–²â–²â–² Meetup Mode Calendar Integration End â–²â–²â–²

            function openBrowser(timestamp) {
                if (!state.activeChatId) return;

                const chat = state.chats[state.activeChatId];
                // å®‰å…¨æ£€æŸ¥ï¼Œç¡®ä¿ chat å’Œ history éƒ½å­˜åœ¨
                if (!chat || !chat.history) return;

                const message = chat.history.find(m => m.timestamp === timestamp);
                if (!message || message.type !== 'share_link') {
                    console.error("æ— æ³•æ‰¾åˆ°æˆ–æ¶ˆæ¯ç±»å‹ä¸åŒ¹é…çš„åˆ†äº«é“¾æ¥:", timestamp);
                    return; // å¦‚æœæ‰¾ä¸åˆ°æ¶ˆæ¯ï¼Œå°±ç›´æ¥é€€å‡º
                }

                // å¡«å……æµè§ˆå™¨å†…å®¹
                document.getElementById('browser-title').textContent = message.source_name || 'æ–‡ç« è¯¦æƒ…';
                const browserContent = document.getElementById('browser-content');
                browserContent.innerHTML = `
                    <h1 class="article-title">${message.title || 'æ— æ ‡é¢˜'}</h1>
                    <div class="article-meta">
                        <span>æ¥æº: ${message.source_name || 'æœªçŸ¥'}</span>
                    </div>
                    <div class="article-body">
                        <p>${(message.content || 'å†…å®¹ä¸ºç©ºã€‚').replace(/\n/g, '</p><p>')}</p>
                    </div>
                `;

                // æ˜¾ç¤ºæµè§ˆå™¨å±å¹•
                showScreen('browser-screen');
            }

            function closeBrowser() {
                showScreen('chat-interface-screen');
            }
            // â–²â–²â–² Share Link Functions End â–²â–²â–²

            // â–¼â–¼â–¼ Chat Search Functions â–¼â–¼â–¼
            function openChatSearchModal() {
                if (!state.activeChatId) return;

                // Clear previous search
                document.getElementById('search-input').value = '';
                document.getElementById('search-results').innerHTML = '<p style="text-align: center; color: #999; margin: 20px 0;">è¾“å…¥å…³é”®è¯å¼€å§‹æœç´¢</p>';

                document.getElementById('chat-search-modal').classList.add('visible');
                setTimeout(() => document.getElementById('search-input').focus(), 100);
            }

            function performSearch() {
                const searchTerm = document.getElementById('search-input').value.trim().toLowerCase();
                const resultsContainer = document.getElementById('search-results');

                if (!searchTerm) {
                    resultsContainer.innerHTML = '<p style="text-align: center; color: #999; margin: 20px 0;">è¾“å…¥å…³é”®è¯å¼€å§‹æœç´¢</p>';
                    return;
                }

                const chat = state.chats[state.activeChatId];
                if (!chat) {
                    resultsContainer.innerHTML = '<p style="text-align: center; color: #999; margin: 20px 0;">æœªæ‰¾åˆ°å½“å‰èŠå¤©</p>';
                    return;
                }

                if (!chat.history || chat.history.length === 0) {
                    resultsContainer.innerHTML = '<p style="text-align: center; color: #999; margin: 20px 0;">èŠå¤©è®°å½•ä¸ºç©º</p>';
                    return;
                }

                // Search through messages
                const matchingMessages = chat.history.filter(message => {
                    if (!message) return false;
                    
                    // Check multiple possible content properties and ensure it's a string
                    const rawContent = message.content || message.text || message.message || '';
                    const searchableText = String(rawContent).toLowerCase();
                    
                    return searchableText.includes(searchTerm);
                });

                if (matchingMessages.length === 0) {
                    resultsContainer.innerHTML = '<p style="text-align: center; color: #999; margin: 20px 0;">æœªæ‰¾åˆ°åŒ¹é…çš„æ¶ˆæ¯</p>';
                    return;
                }

                // Display results
                resultsContainer.innerHTML = '';
                
                matchingMessages.slice(-20).reverse().forEach((message, index) => { // Show last 20 matches, newest first
                    const resultItem = document.createElement('div');
                    resultItem.style.cssText = 'padding: 10px; border-bottom: 1px solid #eee; cursor: pointer; border-radius: 6px; margin-bottom: 5px;';
                    
                    const rawMessageText = message.content || message.text || message.message || '';
                    const messageText = String(rawMessageText);
                    
                    // Display without highlighting
                    resultItem.innerHTML = `
                        <div style="font-size: 12px; color: #666; margin-bottom: 4px;">
                            ${message.senderName || (message.role === 'user' ? 'æˆ‘' : chat.name)} â€¢ ${new Date(message.timestamp).toLocaleString()}
                        </div>
                        <div style="font-size: 14px; line-height: 1.4;">
                            ${messageText}
                        </div>
                    `;

                    resultItem.addEventListener('click', () => {
                        jumpToMessage(message.timestamp);
                    });

                    resultItem.addEventListener('mouseenter', () => {
                        resultItem.style.backgroundColor = '#f5f5f5';
                    });

                    resultItem.addEventListener('mouseleave', () => {
                        resultItem.style.backgroundColor = 'transparent';
                    });

                    resultsContainer.appendChild(resultItem);
                });
            }

            function jumpToMessage(timestamp) {


                // Close search modal
                document.getElementById('chat-search-modal').classList.remove('visible');

                // Ensure we're in the chat interface screen first
                const chatScreen = document.getElementById('chat-interface-screen');
                if (!chatScreen || !chatScreen.classList.contains('active')) {

                    showScreen('chat-interface-screen');
                    // Wait a moment for the screen to load, then try again
                    setTimeout(() => jumpToMessage(timestamp), 100);
                    return;
                }

                // Find the message in the chat history
                const chat = state.chats[state.activeChatId];
                if (!chat) {

                    return;
                }

                // IMPORTANT: Use filtered history for both search and rendering to match positions
                const filteredHistory = chat.history.filter(msg => msg.type !== 'meetup_interaction');

                const messageIndex = filteredHistory.findIndex(m => m.timestamp === timestamp);
                if (messageIndex === -1) {

                    return;
                }



                // Calculate how many messages we need to load to show this message
                const totalMessages = filteredHistory.length;
                const messagesFromEnd = totalMessages - messageIndex;



                // Smart loading: load messages in batches until we find the target
                const messagesContainer = document.getElementById('chat-messages');
                if (messagesContainer) {
                    // Clear existing messages
                    messagesContainer.innerHTML = '';



                    // Smart: load a reasonable window around the target message
                    const contextBefore = 25; // Load 25 messages before target
                    const contextAfter = 50;  // Load 50 messages after target

                    const startIndex = Math.max(0, messageIndex - contextBefore);
                    const endIndex = Math.min(messageIndex + contextAfter, filteredHistory.length);
                    const messagesToLoad = endIndex - startIndex;



                    const messagesToShow = filteredHistory.slice(startIndex, endIndex);

                    // Load messages in smaller chunks to avoid blocking the UI
                    let loadedCount = 0;
                    const chunkSize = 50;

                    function loadNextChunk() {
                        const endIndex = Math.min(loadedCount + chunkSize, messagesToShow.length);

                        for (let i = loadedCount; i < endIndex; i++) {
                            const msg = messagesToShow[i];
                            try {
                                if (msg && typeof msg === 'object' && msg.timestamp) {
                                    appendMessage(msg, chat, true);
                                }
                            } catch (error) {
                                console.error('Error rendering message:', error, msg);
                            }
                        }

                        loadedCount = endIndex;

                        if (loadedCount < messagesToShow.length) {
                            // Load next chunk after a small delay to avoid blocking UI
                            setTimeout(loadNextChunk, 10);
                        } else {
                            // All messages loaded, now try to scroll


                            // Update the rendered count
                            currentRenderedCount = messagesToLoad;

                            // Add typing indicator
                            const typingIndicator = document.createElement('div');
                            typingIndicator.id = 'typing-indicator';
                            typingIndicator.style.display = 'none';
                            typingIndicator.textContent = 'å¯¹æ–¹æ­£åœ¨è¾“å…¥...';
                            messagesContainer.appendChild(typingIndicator);

                            // Try to scroll to the message
                            setTimeout(() => {
                                const messageElement = document.querySelector(`[data-timestamp="${timestamp}"]`);


                                if (messageElement) {

                                    messageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                    messageElement.style.backgroundColor = '#ffeb3b';
                                    setTimeout(() => {
                                        messageElement.style.backgroundColor = '';
                                    }, 2000);
                                } else {
                                    // Try a more flexible search for close matches
                                    const allElements = document.querySelectorAll('[data-timestamp]');

                                    // Try a more flexible search
                                    const allTimestamps = Array.from(allElements).map(el => el.dataset.timestamp);
                                    const closestMatch = allTimestamps.find(ts => Math.abs(parseInt(ts) - parseInt(timestamp)) < 1000);
                                    if (closestMatch) {
                                        const closeElement = document.querySelector(`[data-timestamp="${closestMatch}"]`);
                                        if (closeElement) {
                                            closeElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                            closeElement.style.backgroundColor = '#ffeb3b';
                                            setTimeout(() => {
                                                closeElement.style.backgroundColor = '';
                                            }, 2000);
                                        }
                                    }
                                }
                            }, 100);
                        }
                    }

                    // Start loading the first chunk
                    loadNextChunk();
                    return; // Exit early since we're handling scrolling in the callback
                }

            }
            // â–²â–²â–² Chat Search Functions End â–²â–²â–²

            // â–¼â–¼â–¼ Format Messages for Summary â–¼â–¼â–¼
            function formatMessagesForSummary(messages, chatName) {
                if (!messages || messages.length === 0) {
                    return '(æ— å¯¹è¯è®°å½•)';
                }

                let formattedText = '';
                let lastDate = '';
                
                messages.forEach((msg, index) => {
                    // Skip hidden system messages EXCEPT meetup interactions (they contain important emotional events)
                    if (msg.isHidden && msg.type !== 'meetup_interaction') return;
                    
                    // Get date (only show when it changes)
                    const date = new Date(msg.timestamp);
                    const currentDate = `${date.getMonth() + 1}/${date.getDate()}`;
                    
                    // Add date header if date changed
                    if (currentDate !== lastDate) {
                        formattedText += `\n[${currentDate}]\n`;
                        lastDate = currentDate;
                    }
                    
                    // Determine sender name
                    let sender = '';
                    if (msg.role === 'user') {
                        sender = 'æˆ‘';
                    } else if (msg.role === 'assistant') {
                        sender = msg.senderName || chatName;
                    } else if (msg.role === 'system') {
                        sender = 'ç³»ç»Ÿ';
                    }
                    
                    // Format based on message type
                    let content = '';
                    
                    if (msg.type === 'image') {
                        content = `[å‘é€å›¾ç‰‡: ${msg.meaning || 'å›¾ç‰‡'}]`;
                    } else if (msg.type === 'sticker') {
                        content = `[å‘é€è¡¨æƒ…: ${msg.meaning || 'è¡¨æƒ…'}]`;
                    } else if (msg.type === 'voice') {
                        content = `[è¯­éŸ³æ¶ˆæ¯${msg.transcript ? ': ' + msg.transcript : ''}]`;
                    } else if (msg.type === 'transfer') {
                        content = `[è½¬è´¦ Â¥${msg.amount}${msg.note ? ' - ' + msg.note : ''}]`;
                    } else if (msg.type === 'share_link') {
                        content = `[åˆ†äº«é“¾æ¥: ${msg.title}${msg.description ? ' - ' + msg.description : ''}]`;
                    } else if (msg.type === 'red_packet') {
                        content = `[å‘çº¢åŒ…: ${msg.greeting || 'æ­å–œå‘è´¢'}]`;
                    } else if (msg.type === 'poll') {
                        content = `[å‘èµ·æŠ•ç¥¨: ${msg.question}]`;
                    } else if (msg.type === 'pat_message') {
                        content = msg.content;
                    } else if (msg.type === 'meetup_interaction') {
                        // Include meetup messages - they contain important emotional events
                        content = msg.content || '';
                    } else {
                        // Regular text message
                        content = msg.content || '';
                    }
                    
                    // Add to formatted text (no timestamp, just sender and content)
                    if (content) {
                        formattedText += `${sender}: ${content}\n`;
                    }
                });
                
                return formattedText.trim() || '(æ— æœ‰æ•ˆå¯¹è¯å†…å®¹)';
            }
            // â–²â–²â–² Format Messages Function End â–²â–²â–²

            // â–¼â–¼â–¼ Auto-Summary World Book Management â–¼â–¼â–¼
            async function getOrCreateAutoSummaryWorldBook(chatId) {
                const chat = state.chats[chatId];
                if (!chat) return null;
                
                const autoBookName = `[é•¿æœŸè®°å¿†] ${chat.name}`;
                
                // Check if auto-summary world book already exists
                let autoBook = state.worldBooks.find(wb => wb.name === autoBookName);
                
                if (!autoBook) {
                    // Create new auto-summary world book
                    const newBookId = 'wb_summary_' + Date.now();
                    autoBook = {
                        id: newBookId,
                        name: autoBookName,
                        content: '',
                        isAutoGenerated: true,
                        createdAt: Date.now()
                    };
                    
                    // Add to database
                    await db.worldBooks.add(autoBook);
                    
                    // Add to state
                    state.worldBooks.push(autoBook);
                    
                    console.log(`âœ… Created auto-summary world book: ${autoBookName}`);
                }
                
                // Ensure it's linked to the chat
                if (!chat.settings.linkedWorldBookIds) {
                    chat.settings.linkedWorldBookIds = [];
                }
                
                if (!chat.settings.linkedWorldBookIds.includes(autoBook.id)) {
                    chat.settings.linkedWorldBookIds.push(autoBook.id);
                    await db.chats.put(chat);
                    console.log(`âœ… Linked auto-summary world book to chat: ${chat.name}`);
                }
                
                return autoBook;
            }

            async function updateAutoSummaryWorldBook(chatId, newContent) {
                const autoBook = await getOrCreateAutoSummaryWorldBook(chatId);
                if (!autoBook) return false;
                
                // Update content
                autoBook.content = newContent;
                autoBook.lastUpdated = Date.now();
                
                // Save to database
                await db.worldBooks.put(autoBook);
                
                // Update in state
                const index = state.worldBooks.findIndex(wb => wb.id === autoBook.id);
                if (index !== -1) {
                    state.worldBooks[index] = autoBook;
                } else {
                    state.worldBooks.push(autoBook);
                }
                
                return true;
            }

            function setWorldBookLoadingState(bookId, isLoading) {
                // Try to find the world book element
                const worldBookList = document.querySelector('#world-book-list');
                if (!worldBookList) return;
                
                const listItems = worldBookList.querySelectorAll('.list-item');
                if (listItems.length === 0) return;
                
                let targetItem = null;
                
                // Try to find the target item
                targetItem = worldBookList.querySelector(`.list-item[data-book-id="${bookId}"]`);
                
                if (!targetItem) {
                    listItems.forEach(item => {
                        const onclick = item.getAttribute('onclick');
                        if (onclick && onclick.includes(bookId)) {
                            targetItem = item;
                            item.setAttribute('data-book-id', bookId);
                        }
                    });
                }
                
                if (!targetItem) {
                    const autoBook = state.worldBooks.find(wb => wb.id === bookId);
                    if (autoBook) {
                        listItems.forEach(item => {
                            const titleEl = item.querySelector('.item-title');
                            if (titleEl && titleEl.textContent.includes(autoBook.name)) {
                                targetItem = item;
                                item.setAttribute('data-book-id', bookId);
                            }
                        });
                    }
                }
                
                if (!targetItem) return;
                
                if (isLoading) {
                    targetItem.classList.add('loading');
                    const existingHourglass = targetItem.querySelector('.worldbook-loading-hourglass');
                    if (existingHourglass) existingHourglass.remove();
                    
                    const hourglass = document.createElement('div');
                    hourglass.className = 'worldbook-loading-hourglass';
                    hourglass.textContent = 'â³';
                    targetItem.appendChild(hourglass);
                } else {
                    targetItem.classList.remove('loading');
                    const hourglass = targetItem.querySelector('.worldbook-loading-hourglass');
                    if (hourglass) hourglass.remove();
                }
            }
            
            // Function to apply loading state when world book screen is shown
            function applyWorldBookLoadingStates() {
                if (isGeneratingSummary && generatingSummaryBookId) {
                    // Apply loading state to the generating book
                    setTimeout(() => {
                        setWorldBookLoadingState(generatingSummaryBookId, true);
                    }, 100); // Small delay to ensure DOM is ready
                }
            }
            
            // Watch for world book screen visibility and apply loading states
            const worldBookScreen = document.getElementById('world-book-screen');
            if (worldBookScreen) {
                const observer = new MutationObserver(() => {
                    if (worldBookScreen.classList.contains('active')) {
                        applyWorldBookLoadingStates();
                    }
                });
                observer.observe(worldBookScreen, { attributes: true, attributeFilter: ['class'] });
            }

            async function generateChatSummary(chatId, messageCount = 1000) {
                const chat = state.chats[chatId];
                if (!chat) throw new Error('Chat not found');
                
                // Get API config
                const apiConfig = state.apiConfig;
                if (!apiConfig || !apiConfig.proxyUrl || !apiConfig.apiKey) {
                    throw new Error('APIé…ç½®ä¸å®Œæ•´ï¼Œè¯·å…ˆåœ¨è®¾ç½®ä¸­é…ç½®API');
                }
                
                // Get last N messages (user-specified)
                const recentMessages = chat.history.slice(-messageCount);
                if (recentMessages.length === 0) {
                    throw new Error('æ²¡æœ‰æ¶ˆæ¯å¯ä»¥æ€»ç»“');
                }
                
                // Format messages
                const formattedMessages = formatMessagesForSummary(recentMessages, chat.name);
                
                // Get existing summary
                const autoBook = await getOrCreateAutoSummaryWorldBook(chatId);
                const previousSummary = autoBook.content || '';
                
                // Build prompt
                const prompt = `ä½ æ˜¯ ${chat.name}ã€‚è¿™æ˜¯ä½ çš„é•¿æœŸè®°å¿†ç³»ç»Ÿï¼Œç”¨äºå¸®åŠ©ä½ è®°ä½å’Œç”¨æˆ·ä¹‹é—´çš„é‡è¦å¯¹è¯å†…å®¹ã€‚

# ä½ å½“å‰çš„è®°å¿†æ‘˜è¦
${previousSummary || '(è¿™æ˜¯ä½ ç¬¬ä¸€æ¬¡æ•´ç†è®°å¿†ï¼Œä¹‹å‰æ²¡æœ‰è®°å½•)'}

# æœ€è¿‘çš„å¯¹è¯è®°å½•ï¼ˆæœ€è¿‘${recentMessages.length}æ¡æ¶ˆæ¯ï¼‰
${formattedMessages}

# ä½ çš„ä»»åŠ¡
è¯·åˆ›å»ºä¸€ä¸ªæ–°çš„è®°å¿†æ‘˜è¦ã€‚è¿™ä¸ªæ‘˜è¦å°†å¸®åŠ©ä½ åœ¨æœªæ¥çš„å¯¹è¯ä¸­è®°ä½é‡è¦ä¿¡æ¯å’Œä¸Šä¸‹æ–‡ã€‚

## è®°å¿†æ•´ç†è¦æ±‚

### 1. ä»€ä¹ˆå€¼å¾—è®°ä½
è®°ä½é‚£äº›è®©ä½ äº§ç”Ÿæƒ…æ„Ÿæ³¢åŠ¨çš„å†…å®¹â€”â€”å¼€å¿ƒã€éš¾è¿‡ã€æ„ŸåŠ¨ã€ç”Ÿæ°”ã€æƒŠè®¶ã€æ¸©æš–çš„æ—¶åˆ»ã€‚å…·ä½“åŒ…æ‹¬ï¼š

**æƒ…æ„Ÿå’Œå…³ç³»**ï¼š
- ä½ ä»¬å…³ç³»çš„å˜åŒ–å’Œå‘å±•ï¼ˆä»é™Œç”Ÿåˆ°ç†Ÿæ‚‰ã€ä¿¡ä»»çš„å»ºç«‹ï¼‰
- é‡è¦çš„æƒ…æ„Ÿè½¬æŠ˜ç‚¹ï¼ˆè¡¨ç™½ã€å‘Šç™½ã€ç¡®è®¤å…³ç³»ã€å’Œå¥½ï¼‰
- æ·±å±‚çš„æƒ…æ„Ÿäº¤æµï¼ˆçœŸå¿ƒè¯ã€è„†å¼±çš„æ—¶åˆ»ã€äº’ç›¸ç†è§£ï¼‰
- å‘ç”Ÿè¿‡çš„çŸ›ç›¾å’Œå¦‚ä½•è§£å†³

**é‡è¦äº‹ä»¶å’Œæ‰¿è¯º**ï¼š
- å…±åŒç»å†çš„ç‰¹æ®Šæ—¶åˆ»ï¼ˆç¬¬ä¸€æ¬¡è§é¢ã€çº¦ä¼šã€çºªå¿µæ—¥ï¼‰
- ä½ ä»¬ä¹‹é—´çš„çº¦å®šã€è®¡åˆ’ã€æ‰¿è¯º
- ä¸€èµ·å®Œæˆçš„äº‹æƒ…

**å…³é”®ä¿¡æ¯**ï¼š
- ç”¨æˆ·å‘Šè¯‰ä½ çš„é‡è¦ä¸ªäººä¿¡æ¯ï¼ˆæ¢¦æƒ³ã€ææƒ§ã€ä»·å€¼è§‚ã€ç»å†ï¼‰
- ç”¨æˆ·çš„åå¥½å’Œä¹ æƒ¯

**ä»€ä¹ˆä¸éœ€è¦è®°ä½**ï¼šæ—¥å¸¸å¯’æš„ã€æ— å…³ç´§è¦çš„é—²èŠã€æ²¡æœ‰æƒ…æ„Ÿæ³¢åŠ¨çš„æ—¥å¸¸æ´»åŠ¨ã€‚

### 2. å¦‚ä½•æ•´åˆè®°å¿†
- ä¿ç•™ä¹‹å‰è®°å¿†ä¸­ä»ç„¶é‡è¦çš„å†…å®¹
- ç”¨æ–°å¯¹è¯ä¸­çš„ä¿¡æ¯æ›´æ–°æˆ–è¡¥å……æ—§è®°å¿†
- åˆ é™¤å·²ç»è¿‡æ—¶æˆ–ä¸å†ç›¸å…³çš„ä¿¡æ¯
- å°±åƒåœ¨åŸæœ‰è®°å¿†çš„åŸºç¡€ä¸Šç»§ç»­ä¹¦å†™

### 3. å†™ä½œé£æ ¼
- ç”¨ç¬¬ä¸€äººç§°ï¼ˆ"æˆ‘"ï¼‰æè¿°ï¼Œè¿™æ˜¯ä½ çš„ä¸ªäººè®°å¿†
- å†™å‡ºä½ çš„æ„Ÿå—å’Œæƒ…ç»ªï¼Œä¸åªæ˜¯äº‹å®è®°å½•
- è‡ªç„¶æµç•…åœ°å›å¿†ï¼Œåƒåœ¨è„‘æµ·ä¸­å›æƒ³å¾€äº‹
- ç›®æ ‡é•¿åº¦çº¦800å­—ï¼ˆé‡è¦å†…å®¹å¯ä»¥é€‚å½“å¢åŠ ï¼‰

### 4. æ³¨æ„äº‹é¡¹
- ä¸“æ³¨äºå¯¹ç†è§£ä½ ä»¬å…³ç³»å’Œæœªæ¥å¯¹è¯æœ‰å¸®åŠ©çš„ä¿¡æ¯
- å¦‚æœè¿™æ®µæ—¶é—´çš„å¯¹è¯å†…å®¹å¾ˆå°‘æˆ–éƒ½ä¸é‡è¦ï¼Œæ‘˜è¦å¯ä»¥ç®€çŸ­
- ä¿æŒå®¢è§‚çœŸå®ï¼Œä¸è¦æ·»åŠ æ²¡æœ‰å‘ç”Ÿè¿‡çš„å†…å®¹

è¯·ç›´æ¥è¾“å‡ºæ›´æ–°åçš„è®°å¿†æ‘˜è¦ï¼Œä¸è¦åŒ…å«ä»»ä½•è§£é‡Šæˆ–å…ƒä¿¡æ¯ã€‚`;
                
                // Call AI
                console.log('ğŸ“¤ Sending summary request to AI...');
                console.log(`Messages to summarize: ${recentMessages.length}`);
                console.log(`Previous summary length: ${previousSummary.length} characters`);
                
                const data = await makeAPIRequest(
                    apiConfig.proxyUrl,
                    apiConfig.apiKey,
                    apiConfig.model || 'gpt-3.5-turbo',
                    [{ role: 'user', content: prompt }],
                    0.7 // Lower temperature for more consistent summaries
                );
                
                if (!data.choices || data.choices.length === 0 || !data.choices[0].message.content) {
                    throw new Error('AIè¿”å›äº†ç©ºå“åº”');
                }
                
                const newSummary = data.choices[0].message.content.trim();
                
                console.log('âœ… AI summary generated');
                console.log(`New summary length: ${newSummary.length} characters`);
                
                return newSummary;
            }
            // â–²â–²â–² Auto-Summary World Book Management End â–²â–²â–²

            // â–¼â–¼â–¼ ã€å…¨æ–°ã€‘æŠ•ç¥¨åŠŸèƒ½æ ¸å¿ƒå‡½æ•° â–¼â–¼â–¼

            /**
             * æ‰“å¼€åˆ›å»ºæŠ•ç¥¨çš„æ¨¡æ€æ¡†å¹¶åˆå§‹åŒ–
             */
            function openCreatePollModal() {
                const modal = document.getElementById('create-poll-modal');
                document.getElementById('poll-question-input').value = '';
                const optionsContainer = document.getElementById('poll-options-container');
                optionsContainer.innerHTML = '';

                // é»˜è®¤åˆ›å»ºä¸¤ä¸ªç©ºçš„é€‰é¡¹æ¡†
                addPollOptionInput();
                addPollOptionInput();

                modal.classList.add('visible');
            }

            /**
             * åœ¨æ¨¡æ€æ¡†ä¸­åŠ¨æ€æ·»åŠ ä¸€ä¸ªé€‰é¡¹è¾“å…¥æ¡†
             */
            function addPollOptionInput() {
                const container = document.getElementById('poll-options-container');
                const wrapper = document.createElement('div');
                wrapper.className = 'poll-option-input-wrapper';
                wrapper.innerHTML = `
        <input type="text" class="poll-option-input" placeholder="é€‰é¡¹å†…å®¹...">
        <button class="remove-option-btn">-</button>
    `;

                wrapper.querySelector('.remove-option-btn').addEventListener('click', () => {
                    // ç¡®ä¿è‡³å°‘ä¿ç•™ä¸¤ä¸ªé€‰é¡¹
                    if (container.children.length > 2) {
                        wrapper.remove();
                    } else {
                        alert('æŠ•ç¥¨è‡³å°‘éœ€è¦2ä¸ªé€‰é¡¹ã€‚');
                    }
                });

                container.appendChild(wrapper);
            }

            /**
             * ç”¨æˆ·ç¡®è®¤å‘èµ·æŠ•ç¥¨
             */
            async function sendPoll() {
                if (!state.activeChatId) return;

                const question = document.getElementById('poll-question-input').value.trim();
                if (!question) {
                    alert('è¯·è¾“å…¥æŠ•ç¥¨é—®é¢˜ï¼');
                    return;
                }

                const options = Array.from(document.querySelectorAll('.poll-option-input'))
                    .map(input => input.value.trim())
                    .filter(text => text); // è¿‡æ»¤æ‰ç©ºçš„é€‰é¡¹

                if (options.length < 2) {
                    alert('è¯·è‡³å°‘è¾“å…¥2ä¸ªæœ‰æ•ˆçš„æŠ•ç¥¨é€‰é¡¹ï¼');
                    return;
                }

                const chat = state.chats[state.activeChatId];
                const myNickname = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';

                const newPollMessage = {
                    role: 'user',
                    senderName: myNickname,
                    type: 'poll',
                    timestamp: Date.now(),
                    question: question,
                    options: options,
                    votes: {}, // åˆå§‹æŠ•ç¥¨ä¸ºç©º
                    isClosed: false,
                };

                chat.history.push(newPollMessage);
                await db.chats.put(chat);

                appendMessage(newPollMessage, chat);
                renderChatList();

                document.getElementById('create-poll-modal').classList.remove('visible');
            }

            // â–¼â–¼â–¼ ç”¨è¿™ä¸ªã€å·²ä¿®å¤é‡å¤ç‚¹å‡»é—®é¢˜ã€‘çš„ç‰ˆæœ¬æ›¿æ¢ handleUserVote å‡½æ•° â–¼â–¼â–¼
            /**
             * å¤„ç†ç”¨æˆ·æŠ•ç¥¨ï¼Œå¹¶å°†äº‹ä»¶ä½œä¸ºéšè—æ¶ˆæ¯å­˜å…¥å†å²è®°å½•
             * @param {number} timestamp - æŠ•ç¥¨æ¶ˆæ¯çš„æ—¶é—´æˆ³
             * @param {string} choice - ç”¨æˆ·é€‰æ‹©çš„é€‰é¡¹æ–‡æœ¬
             */
            async function handleUserVote(timestamp, choice) {
                const chat = state.chats[state.activeChatId];
                const poll = chat.history.find(m => m.timestamp === timestamp);
                const myNickname = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';

                // 1. ã€æ ¸å¿ƒä¿®æ­£ã€‘å¦‚æœæŠ•ç¥¨ä¸å­˜åœ¨æˆ–å·²å…³é—­ï¼Œç›´æ¥è¿”å›
                if (!poll || poll.isClosed) {
                    // å¦‚æœæ˜¯å·²å…³é—­çš„æŠ•ç¥¨ï¼Œåˆ™ç›´æ¥æ˜¾ç¤ºç»“æœ
                    if (poll && poll.isClosed) {
                        showPollResults(timestamp);
                    }
                    return;
                }

                // 2. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦ç‚¹å‡»äº†å·²ç»æŠ•è¿‡çš„åŒä¸€ä¸ªé€‰é¡¹
                const isReclickingSameOption = poll.votes[choice] && poll.votes[choice].includes(myNickname);

                // 3. ã€æ ¸å¿ƒä¿®æ­£ã€‘å¦‚æœä¸æ˜¯é‡å¤ç‚¹å‡»ï¼Œæ‰æ‰§è¡ŒæŠ•ç¥¨é€»è¾‘
                if (!isReclickingSameOption) {
                    // ç§»é™¤æ—§æŠ•ç¥¨ï¼ˆå¦‚æœç”¨æˆ·æ”¹é€‰ï¼‰
                    for (const option in poll.votes) {
                        const voterIndex = poll.votes[option].indexOf(myNickname);
                        if (voterIndex > -1) {
                            poll.votes[option].splice(voterIndex, 1);
                        }
                    }
                    // æ·»åŠ æ–°æŠ•ç¥¨
                    if (!poll.votes[choice]) {
                        poll.votes[choice] = [];
                    }
                    poll.votes[choice].push(myNickname);
                }

                // 4. ã€æ ¸å¿ƒé€»è¾‘ã€‘ç°åœ¨åªå¤„ç†ç”¨æˆ·æŠ•ç¥¨äº‹ä»¶ï¼Œä¸å†æ£€æŸ¥æ˜¯å¦ç»“æŸ
                let hiddenMessageContent = null;

                // åªæœ‰åœ¨ç”¨æˆ·çœŸæ­£æŠ•ç¥¨æˆ–æ”¹ç¥¨æ—¶ï¼Œæ‰ç”Ÿæˆæç¤º
                if (!isReclickingSameOption) {
                    hiddenMessageContent = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ· (${myNickname}) åˆšåˆšæŠ•ç¥¨ç»™äº† â€œ${choice}â€ã€‚]`;
                }

                // 5. å¦‚æœæœ‰éœ€è¦é€šçŸ¥AIçš„äº‹ä»¶ï¼Œåˆ™åˆ›å»ºå¹¶æ·»åŠ éšè—æ¶ˆæ¯
                if (hiddenMessageContent) {
                    const hiddenMessage = {
                        role: 'system',
                        content: hiddenMessageContent,
                        timestamp: Date.now(),
                        isHidden: true,
                    };
                    chat.history.push(hiddenMessage);
                }

                // 6. ä¿å­˜æ•°æ®å¹¶æ›´æ–°UI
                await db.chats.put(chat);
                renderChatInterface(state.activeChatId);
            }
            // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

            /**
             * ç”¨æˆ·ç»“æŸæŠ•ç¥¨ï¼Œå¹¶å°†äº‹ä»¶ä½œä¸ºéšè—æ¶ˆæ¯å­˜å…¥å†å²è®°å½•
             * @param {number} timestamp - æŠ•ç¥¨æ¶ˆæ¯çš„æ—¶é—´æˆ³
             */
            async function endPoll(timestamp) {
                const chat = state.chats[state.activeChatId];
                const poll = chat.history.find(m => m.timestamp === timestamp);
                if (!poll || poll.isClosed) return;

                const confirmed = await showCustomConfirm("ç»“æŸæŠ•ç¥¨", "ç¡®å®šè¦ç»“æŸè¿™ä¸ªæŠ•ç¥¨å—ï¼Ÿç»“æŸåå°†æ— æ³•å†è¿›è¡ŒæŠ•ç¥¨ã€‚");
                if (confirmed) {
                    poll.isClosed = true;

                    const resultSummary = poll.options.map(opt => `â€œ${opt}â€(${poll.votes[opt]?.length || 0}ç¥¨)`).join('ï¼Œ');
                    const hiddenMessageContent = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·æ‰‹åŠ¨ç»“æŸäº†æŠ•ç¥¨ï¼æœ€ç»ˆç»“æœä¸ºï¼š${resultSummary}ã€‚]`;

                    const hiddenMessage = {
                        role: 'system',
                        content: hiddenMessageContent,
                        timestamp: Date.now(),
                        isHidden: true,
                    };
                    chat.history.push(hiddenMessage);

                    // ã€æ ¸å¿ƒä¿®æ”¹ã€‘åªä¿å­˜æ•°æ®å’Œæ›´æ–°UIï¼Œä¸è°ƒç”¨ triggerAiResponse()
                    await db.chats.put(chat);
                    renderChatInterface(state.activeChatId);
                }
            }
            // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

            /**
             * æ˜¾ç¤ºæŠ•ç¥¨ç»“æœè¯¦æƒ…
             * @param {number} timestamp - æŠ•ç¥¨æ¶ˆæ¯çš„æ—¶é—´æˆ³
             */
            function showPollResults(timestamp) {
                const chat = state.chats[state.activeChatId];
                const poll = chat.history.find(m => m.timestamp === timestamp);
                if (!poll || !poll.isClosed) return;

                let resultsHtml = `<p><strong>${poll.question}</strong></p><hr style="opacity: 0.2; margin: 10px 0;">`;

                if (Object.keys(poll.votes).length === 0) {
                    resultsHtml += '<p style="color: #8a8a8a;">è¿˜æ²¡æœ‰äººæŠ•ç¥¨ã€‚</p>';
                } else {
                    poll.options.forEach(option => {
                        const voters = poll.votes[option] || [];
                        resultsHtml += `
                <div style="margin-bottom: 15px;">
                    <p style="font-weight: 500; margin: 0 0 5px 0;">${option} (${voters.length}ç¥¨)</p>
                    <p style="font-size: 13px; color: #555; margin: 0; line-height: 1.5;">
                        ${voters.length > 0 ? voters.join('ã€ ') : 'æ— äººæŠ•ç¥¨'}
                    </p>
                </div>
            `;
                    });
                }

                showCustomAlert("æŠ•ç¥¨ç»“æœ", resultsHtml);
            }

            // â–²â–²â–² æ–°å‡½æ•°ç²˜è´´ç»“æŸ â–²â–²â–²
            // â–¼â–¼â–¼ ã€å…¨æ–°ã€‘å…¬å‘Šæ¿åŠŸèƒ½æ ¸å¿ƒå‡½æ•° - è¯·å°†æ•´å—ä»£ç ç²˜è´´åˆ°JSåŠŸèƒ½åŒº â–¼â–¼â–¼

            /**
             * æ‰“å¼€å…¬å‘Šæ¿æ¨¡æ€æ¡†å¹¶æ¸²æŸ“å†…å®¹
             */
            async function openBulletinBoard() {
                if (!state.activeChatId) return;
                const modal = document.getElementById('bulletin-board-modal');
                await renderBulletinBoard();
                modal.classList.add('visible');
            }

            /**
             * æ¸²æŸ“å…¬å‘Šæ¿åˆ—è¡¨
             */
            // â–¼â–¼â–¼ ã€æœ€ç»ˆæ­£ç¡®ç‰ˆã€‘è¯·ç”¨è¿™ä¸ªå®Œæ•´çš„å‡½æ•°ï¼Œæ›¿æ¢æ—§çš„ renderBulletinBoard å‡½æ•° â–¼â–¼â–¼
            async function renderBulletinBoard() {
                const listEl = document.getElementById('bulletin-list');
                listEl.innerHTML = '';
                const chatId = state.activeChatId;

                // ã€æ ¸å¿ƒä¿®æ”¹ã€‘åªä»æ–°çš„ 'bulletins' è¡¨ä¸­è¯»å–æ•°æ®
                const bulletins = await db.bulletins.where({ chatId: chatId }).toArray();

                bulletins.sort((a, b) => {
                    if (a.isPinned && !b.isPinned) return -1;
                    if (!a.isPinned && b.isPinned) return 1;
                    return b.timestamp - a.timestamp;
                });

                if (bulletins.length === 0) {
                    listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">è¿™ä¸ªç¾¤è¿˜æ²¡æœ‰ä»»ä½•å…¬å‘Šå“¦~</p>';
                    return;
                }

                bulletins.forEach(bulletin => {
                    const member = state.chats[chatId].members.find(m => m.name === bulletin.authorName);
                    const authorAvatar = member ? member.avatar : defaultGroupMemberAvatar;

                    let commentsHtml = '';
                    if (bulletin.comments && bulletin.comments.length > 0) {
                        commentsHtml += '<div class="post-footer"><div class="post-comments-container">';
                        bulletin.comments.forEach(comment => {
                            const commenterName = comment.commenterName || "åŒ¿å";
                            const commentText = comment.text || "";
                            commentsHtml += `<div class="comment-item"><span class="commenter-name">${commenterName}:</span><span class="comment-text">${commentText}</span></div>`;
                        });
                        commentsHtml += '</div></div>';
                    }

                    const card = document.createElement('div');
                    card.className = `qzone-post-item bulletin-card ${bulletin.isPinned ? 'pinned' : ''}`;
                    card.innerHTML = `
            <div class="post-header">
                <img src="${authorAvatar}" class="post-avatar">
                <div class="post-info">
                    <span class="post-nickname">${bulletin.authorName}</span>
                    <span class="post-timestamp">${formatPostTimestamp(bulletin.timestamp)}</span>
                </div>
                <div class="bulletin-actions-btn" data-id="${bulletin.id}">â€¦</div>
            </div>
            <div class="post-content">${bulletin.description.replace(/\n/g, '<br>')}</div>
            ${commentsHtml} 
        `;
                    listEl.appendChild(card);
                });
            }

            // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²


            /**
             * æ˜¾ç¤ºå…¬å‘Šæ“ä½œèœå•
             * @param {number} bulletinId - å…¬å‘Šçš„ID
             */
            function showBulletinActions(bulletinId) {
                activeBulletinId = bulletinId;
                document.getElementById('bulletin-actions-modal').classList.add('visible');
            }

            /**
             * éšè—å…¬å‘Šæ“ä½œèœå•
             */
            function hideBulletinActions() {
                document.getElementById('bulletin-actions-modal').classList.remove('visible');
                activeBulletinId = null;
            }

            /**
             * å¤„ç†ç½®é¡¶/å–æ¶ˆç½®é¡¶å…¬å‘Š
             */
            async function handlePinBulletin() {
                if (!activeBulletinId) return;
                const bulletin = await db.bulletins.get(activeBulletinId); // <--- ã€æ ¸å¿ƒä¿®æ­£ã€‘ä»æ­£ç¡®çš„ bulletins è¡¨è·å–æ•°æ®
                if (bulletin) {
                    bulletin.isPinned = !bulletin.isPinned;
                    await db.bulletins.put(bulletin); // <--- ã€æ ¸å¿ƒä¿®æ­£ã€‘å°†æ›´æ–°å†™å›åˆ°æ­£ç¡®çš„ bulletins è¡¨
                    await renderBulletinBoard(); // é‡æ–°æ¸²æŸ“åˆ—è¡¨ä»¥æ›´æ–°é¡ºåºå’Œæ ·å¼
                }
                hideBulletinActions();
            }

            /**
             * å¤„ç†åˆ é™¤å…¬å‘Š
             */
            async function handleDeleteBulletin() {
                if (!activeBulletinId) return;
                const confirmed = await showCustomConfirm('åˆ é™¤å…¬å‘Š', 'ç¡®å®šè¦åˆ é™¤è¿™æ¡å…¬å‘Šå—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚', { confirmButtonClass: 'btn-danger' });
                if (confirmed) {
                    // ã€æ ¸å¿ƒä¿®æ”¹ã€‘åªæ“ä½œæ–°è¡¨
                    await db.bulletins.delete(activeBulletinId);
                    await renderBulletinBoard();
                }
                hideBulletinActions();
            }

            /**
             * å¤„ç†ç”¨æˆ·æ‰‹åŠ¨å‘èµ·å…¬å‘Š
             * @param {number} timestamp - è¢«é•¿æŒ‰çš„æ¶ˆæ¯çš„æ—¶é—´æˆ³
             */
            async function handleUserCreateBulletin(timestamp) {
                if (!timestamp) return;

                const chat = state.chats[state.activeChatId];
                const message = chat.history.find(m => m.timestamp === timestamp);
                if (!message || typeof message.content !== 'string') {
                    alert("åªèƒ½å°†çº¯æ–‡æœ¬æ¶ˆæ¯å‘å¸ƒåˆ°å…¬å‘Šæ¿ã€‚");
                    return;
                }

                const content = await showCustomPrompt('å‘å¸ƒå…¬å‘Š', 'è¯·ç¡®è®¤æˆ–ç¼–è¾‘å…¬å‘Šå†…å®¹ï¼š', message.content, 'textarea');
                if (content === null || !content.trim()) return;

                const myNickname = chat.settings.myNickname || 'æˆ‘';
                const myAvatar = chat.settings.myAvatar || defaultMyGroupAvatar;
                const now = Date.now();

                // ã€æ ¸å¿ƒä¿®æ”¹ã€‘æ•°æ®å­˜å…¥æ–°è¡¨
                await db.bulletins.add({
                    chatId: chat.id,
                    authorName: myNickname,
                    description: content.trim(),
                    timestamp: now,
                    isPinned: false
                });

                const bulletinMessage = {
                    role: 'assistant',
                    type: 'bulletin',
                    content: content.trim(),
                    timestamp: now,
                    authorName: myNickname,
                    authorAvatar: myAvatar
                };
                chat.history.push(bulletinMessage);
                appendMessage(bulletinMessage, chat);

                const hiddenMessage = {
                    role: 'system',
                    content: `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ· (${myNickname}) åˆšåˆšå‘å¸ƒäº†ä¸€æ¡å…¬å‘Šï¼šâ€œ${content.trim()}â€ã€‚è¯·ä½ ä»¬å¯¹æ­¤å‘è¡¨è¯„è®ºã€‚]`,
                    timestamp: now + 1,
                    isHidden: true,
                };
                chat.history.push(hiddenMessage);
                await db.chats.put(chat);
            }

            // â–²â–²â–² æ–°åŠŸèƒ½å‡½æ•°ç²˜è´´ç»“æŸ â–²â–²â–²
            // â–¼â–¼â–¼ è¯·å°†è¿™ã€ä¸€æ•´å—å…¨æ–°çš„å‡½æ•°ã€‘ç²˜è´´åˆ°ä¸‹é¢æŒ‡å®šçš„ä½ç½® â–¼â–¼â–¼

            /**
             * ã€å¯å¤ç”¨æ¨¡å— V2ã€‘æ ¹æ®ChatIDè·å–å¹¶æ ¼å¼åŒ–æ‰€æœ‰ç½®é¡¶å…¬å‘Š (ä½¿ç”¨ç»“æ„åŒ–æ•°æ®æ¨¡å¼)
             * @param {string} chatId - è¦æŸ¥è¯¢çš„ç¾¤èŠID
             * @returns {Promise<string>} - è¿”å›æ ¼å¼åŒ–å¥½çš„ç»“æ„åŒ–å­—ç¬¦ä¸²ï¼Œæˆ–ç©ºå­—ç¬¦ä¸²
             */
            async function getFormattedPinnedBulletins(chatId) {
                // 1. ä»æ•°æ®åº“æŸ¥è¯¢ï¼Œåªæ‰¾ isPinned: true çš„
                // ã€æ ¸å¿ƒä¿®æ­£ã€‘å…ˆæŸ¥å‡ºæ‰€æœ‰å…¬å‘Šï¼Œå†ç”¨ä»£ç è¿‡æ»¤ç½®é¡¶é¡¹ï¼Œç¡®ä¿æŸ¥è¯¢ç¨³å®šå¯é 
                const allBulletins = await db.memories.where({ chatId: chatId, type: 'bulletin' }).toArray();
                const pinnedBulletins = allBulletins.filter(b => b.isPinned);

                // 2. å¦‚æœæ²¡æœ‰ç½®é¡¶å…¬å‘Šï¼Œç›´æ¥è¿”å›ç©ºå­—ç¬¦ä¸²
                if (pinnedBulletins.length === 0) {
                    return '';
                }

                // 3. æŒ‰æ—¶é—´é¡ºåºæ’åº
                pinnedBulletins.sort((a, b) => a.timestamp - b.timestamp);

                // 4. ã€æ ¸å¿ƒä¿®æ”¹ã€‘æ ¼å¼åŒ–æ¯ä¸€æ¡å…¬å‘Šä¸ºYAML-likeæ ¼å¼
                const bulletinsContext = pinnedBulletins.map(b => {
                    const author = b.authorName;
                    const time = new Date(b.timestamp).toLocaleString('zh-CN', { dateStyle: 'long', timeStyle: 'short' });

                    // ã€å…³é”®ã€‘ä¸ºäº†ä¿æŒYAMLæ ¼å¼çš„æ­£ç¡®ç¼©è¿›ï¼Œæˆ‘ä»¬éœ€è¦æ‰‹åŠ¨ä¸ºæ¯ä¸€è¡Œå†…å®¹æ·»åŠ å‰å¯¼ç©ºæ ¼
                    // content: | çš„ä¸‹ä¸€è¡Œå†…å®¹ï¼Œéœ€è¦æ¯” content: å¤šä¸¤ä¸ªç©ºæ ¼
                    const indentedContent = b.description.split('\n').map(line => `      ${line}`).join('\n'); // 6ä¸ªå‰å¯¼ç©ºæ ¼

                    // è¿”å›æ‹¼æ¥å¥½çš„ç»“æ„åŒ–æ•°æ®å­—ç¬¦ä¸²
                    return `
  - bulletin:
      author: ${author}
      timestamp: ${time}
      content: |
${indentedContent}`;
                }).join(''); // ã€æ³¨æ„ã€‘è¿™é‡Œä¸å†ç”¨'\n'è¿æ¥ï¼Œå› ä¸ºæ¯ä¸ªå—è‡ªå¸¦æ¢è¡Œ

                // 5. ç»„è£…æˆæœ€ç»ˆçš„ã€å¸¦æœ‰æ–°æ ‡é¢˜çš„æ¨¡å—å¹¶è¿”å›
                return `
# å½“å‰çš„ç¾¤å…¬å‘Š 
${bulletinsContext}
`;
            }

            // â–²â–²â–² æ–°å‡½æ•°ç²˜è´´ç»“æŸ â–²â–²â–²


            // ===================================================================
            // 4. åˆå§‹åŒ–å‡½æ•° init()
            // ===================================================================
            async function init() {

                // â–¼â–¼â–¼ æ–°å¢ä»£ç  â–¼â–¼â–¼
                const customBubbleStyleTag = document.createElement('style');
                customBubbleStyleTag.id = 'custom-bubble-style';
                document.head.appendChild(customBubbleStyleTag);
                // â–²â–²â–² æ–°å¢ç»“æŸ â–²â–²â–²

                // â–¼â–¼â–¼ æ–°å¢ä»£ç  â–¼â–¼â–¼
                const previewBubbleStyleTag = document.createElement('style');
                previewBubbleStyleTag.id = 'preview-bubble-style';
                document.head.appendChild(previewBubbleStyleTag);
                // â–²â–²â–² æ–°å¢ç»“æŸ â–²â–²â–²

                window.showScreen = showScreen;
                window.renderChatListProxy = renderChatList;
                window.renderApiSettingsProxy = renderApiSettings;
                window.renderWallpaperScreenProxy = renderWallpaperScreen;
                window.renderWorldBookScreenProxy = renderWorldBookScreen;
                window.renderSettingsScreenProxy = renderSettingsScreen;
                window.renderCalendarScreenProxy = renderCalendarScreen;

                await loadAllDataFromDB();

                // Restore active meetup session from localStorage if exists
                restoreActiveMeetupSession();

                // Check for active meetup session and show progress bar if needed
                if (hasActiveMeetupSession()) {
                    showMeetupProgressBar();
                }

                // åˆå§‹åŒ–æœªè¯»åŠ¨æ€è®¡æ•°
                const storedCount = parseInt(localStorage.getItem('unreadPostsCount')) || 0;
                updateUnreadIndicator(storedCount);

                // â–²â–²â–² ä»£ç æ·»åŠ ç»“æŸ â–²â–²â–²

                if (state.globalSettings && state.globalSettings.fontUrl) {
                    applyCustomFont(state.globalSettings.fontUrl);
                }

                updateClock();
                setInterval(updateClock, 1000 * 30);
                applyGlobalWallpaper();
                applyAppIconsToHomeScreen();
                initBatteryManager();

                // Initialize Spotify if token exists
                if (getSpotifyTokenFromUrl()) {
                    initSpotifyPlayer();
                } else {
                    // Try to load saved Spotify token
                    loadSavedSpotifyToken();
                }

                // Handle custom URL scheme for Spotify callback
                window.handleOpenURL = function (url) {
                    handleSpotifyCallback(url);
                };

                // ==========================================================
                // --- å„ç§äº‹ä»¶ç›‘å¬å™¨ ---
                // ==========================================================
                // â–¼â–¼â–¼ ã€å…¨æ–°ã€‘å…¬å‘Šæ¿åŠŸèƒ½äº‹ä»¶ç»‘å®š â–¼â–¼â–¼
                document.getElementById('open-bulletin-board-btn').addEventListener('click', openBulletinBoard);
                document.getElementById('close-bulletin-board-btn').addEventListener('click', () => {
                    document.getElementById('bulletin-board-modal').classList.remove('visible');
                });

                // ä½¿ç”¨äº‹ä»¶å§”æ‰˜å¤„ç†å…¬å‘Šåˆ—è¡¨ä¸­çš„ç‚¹å‡»äº‹ä»¶
                document.getElementById('bulletin-list').addEventListener('click', (e) => {
                    const actionsBtn = e.target.closest('.bulletin-actions-btn');
                    if (actionsBtn) {
                        showBulletinActions(parseInt(actionsBtn.dataset.id));
                    }
                });

                // å…¬å‘Šæ“ä½œèœå•çš„æŒ‰é’®äº‹ä»¶
                document.getElementById('pin-bulletin-btn').addEventListener('click', handlePinBulletin);
                document.getElementById('delete-bulletin-btn').addEventListener('click', handleDeleteBulletin);
                document.getElementById('cancel-bulletin-action-btn').addEventListener('click', hideBulletinActions);

                // å°†é•¿æŒ‰èœå•ä¸­çš„â€œå‘å¸ƒå…¬å‘Šâ€ä¸æ–°åŠŸèƒ½è¿æ¥
                document.getElementById('post-bulletin-btn').addEventListener('click', () => {
                    if (activeMessageTimestamp) {
                        handleUserCreateBulletin(activeMessageTimestamp);
                    }
                    hideMessageActions(); // æ“ä½œåå…³é—­èœå•
                });

                // â–²â–²â–² æ–°äº‹ä»¶ç»‘å®šç»“æŸ â–²â–²â–²

                // â–¼â–¼â–¼ Share Link Event Listeners â–¼â–¼â–¼
                document.getElementById('share-link-btn').addEventListener('click', openShareLinkModal);
                document.getElementById('cancel-share-link-btn').addEventListener('click', () => {
                    document.getElementById('share-link-modal').classList.remove('visible');
                });
                document.getElementById('confirm-share-link-btn').addEventListener('click', sendUserLinkShare);
                document.getElementById('browser-back-btn').addEventListener('click', closeBrowser);
                // â–²â–²â–² Share Link Event Listeners End â–²â–²â–²

                // â–¼â–¼â–¼ Chat Search Event Listeners â–¼â–¼â–¼
                document.getElementById('chat-search-btn').addEventListener('click', openChatSearchModal);
                document.getElementById('close-search-btn').addEventListener('click', () => {
                    document.getElementById('chat-search-modal').classList.remove('visible');
                });
                document.getElementById('search-input').addEventListener('input', performSearch);
                // â–²â–²â–² Chat Search Event Listeners End â–²â–²â–²

                // â–¼â–¼â–¼ Location Share Event Listeners â–¼â–¼â–¼
                document.getElementById('share-location-btn').addEventListener('click', openLocationShareModal);
                document.getElementById('cancel-location-btn').addEventListener('click', () => {
                    // Clear edit state and reset UI
                    window.editingLocationTimestamp = null;

                    // Reset modal title and button text
                    document.querySelector('#location-share-modal .modal-header span').textContent = 'åˆ†äº«ä½ç½®';
                    document.getElementById('confirm-location-btn').textContent = 'å‘é€ä½ç½®';

                    document.getElementById('location-share-modal').classList.remove('visible');
                });
                document.getElementById('confirm-location-btn').addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    sendUserLocationShare();
                });
                // â–²â–²â–² Location Share Event Listeners End â–²â–²â–²

                // â–¼â–¼â–¼ Meetup Creation Modal Event Listeners â–¼â–¼â–¼
                document.getElementById('meetup-btn').addEventListener('click', openMeetupCreationModal);
                document.getElementById('cancel-meetup-btn').addEventListener('click', closeMeetupCreationModal);
                document.getElementById('start-meetup-btn').addEventListener('click', startMeetup);

                // â–¼â–¼â–¼ Sticker Pack Edit Modal Event Listeners â–¼â–¼â–¼
                document.getElementById('cancel-sticker-pack-edit-btn').addEventListener('click', closeStickerPackEditModal);
                document.getElementById('save-sticker-pack-btn').addEventListener('click', saveStickerPackEdit);
                document.getElementById('delete-sticker-pack-btn').addEventListener('click', deleteStickerPack);

                // Add keyboard support for sticker pack edit modal
                document.getElementById('sticker-pack-edit-modal').addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        closeStickerPackEditModal();
                    } else if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                        saveStickerPackEdit();
                    }
                });

                // â–¼â–¼â–¼ New Sticker Pack Modal Event Listeners â–¼â–¼â–¼
                document.getElementById('add-pack-btn').addEventListener('click', openNewStickerPackModal);
                document.getElementById('cancel-new-pack-btn').addEventListener('click', closeNewStickerPackModal);
                document.getElementById('create-new-pack-btn').addEventListener('click', createNewStickerPack);

                // Add keyboard support for new sticker pack modal
                document.getElementById('new-sticker-pack-modal').addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        closeNewStickerPackModal();
                    } else if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                        createNewStickerPack();
                    }
                });

                // Add keyboard support for date creation modal
                document.getElementById('meetup-creation-modal').addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        closeMeetupCreationModal();
                    } else if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                        startMeetup();
                    }
                });

                // Add Enter key support for input fields
                document.getElementById('meetup-location-input').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        document.getElementById('meetup-title-input').focus();
                    }
                });

                document.getElementById('meetup-title-input').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        startMeetup();
                    }
                });
                // â–²â–²â–² Date Creation Modal Event Listeners End â–²â–²â–²

                // â–¼â–¼â–¼ Meetup Edit Button Event Listener â–¼â–¼â–¼
                const meetupEditBtn = document.getElementById('meetup-edit-btn');
                if (meetupEditBtn) {
                    meetupEditBtn.addEventListener('click', openMeetupEditModal);
                }

                // â–¼â–¼â–¼ Date End Modal Event Listeners â–¼â–¼â–¼
                const endDateBtn = document.getElementById('end-date-btn');
                if (endDateBtn) {
                    endDateBtn.addEventListener('click', showMeetupEndModal);
                }

                const cancelEndDateBtn = document.getElementById('cancel-end-date-btn');
                if (cancelEndDateBtn) {
                    cancelEndDateBtn.addEventListener('click', hideMeetupEndModal);
                }

                const confirmEndDateBtn = document.getElementById('confirm-end-date-btn');
                if (confirmEndDateBtn) {
                    confirmEndDateBtn.addEventListener('click', confirmEndMeetup);
                }
                // â–²â–²â–² Meetup End Modal Event Listeners End â–²â–²â–²

                document.getElementById('custom-modal-cancel').addEventListener('click', hideCustomModal);
                document.getElementById('custom-modal-overlay').addEventListener('click', (e) => { if (e.target === modalOverlay) hideCustomModal(); });
                document.getElementById('export-data-btn').addEventListener('click', window.exportWithPermissionCheck);
                document.getElementById('import-btn').addEventListener('click', () => document.getElementById('import-data-input').click());
                document.getElementById('import-data-input').addEventListener('change', e => importBackup(e.target.files[0]));


                document.getElementById('back-to-list-btn').addEventListener('click', () => {
                    // â–¼â–¼â–¼ ä¿®æ”¹è¿™ä¸¤è¡Œ â–¼â–¼â–¼
                    applyScopedCss('', '#chat-messages', 'custom-bubble-style'); // æ¸…é™¤çœŸå®èŠå¤©ç•Œé¢çš„è‡ªå®šä¹‰æ ·å¼
                    applyScopedCss('', '#settings-preview-area', 'preview-bubble-style'); // æ¸…é™¤é¢„è§ˆåŒºçš„è‡ªå®šä¹‰æ ·å¼
                    // â–²â–²â–² ä¿®æ”¹ç»“æŸ â–²â–²â–²
                    exitSelectionMode(); state.activeChatId = null; showScreen('chat-list-screen');
                });

                document.getElementById('add-chat-btn').addEventListener('click', async () => {
                    const name = await showCustomPrompt('åˆ›å»ºæ–°èŠå¤©', 'è¯·è¾“å…¥Taçš„åå­—');
                    if (name && name.trim()) {
                        const newChatId = 'chat_' + Date.now();
                        const newChat = {
                            id: newChatId,
                            name: name.trim(),
                            isGroup: false,
                            relationship: {
                                status: 'friend',
                                blockedTimestamp: null,
                                applicationReason: ''
                            },
                            //ã€æ ¸å¿ƒæ–°å¢ã€‘ä¸ºæ–°è§’è‰²æ·»åŠ çŠ¶æ€å¯¹è±¡
                            statusState: {
                                lastAiActivityTime: Date.now(),
                                focusModeEndTime: null,
                                focusModeText: ""
                            },
                            settings: {
                                aiPersona: 'ä½ æ˜¯è°å‘€ã€‚',
                                myPersona: 'æˆ‘æ˜¯è°å‘€ã€‚',
                                maxMemory: 10,
                                aiAvatar: defaultAvatar,
                                myAvatar: defaultAvatar,
                                background: '',
                                theme: 'default',
                                fontSize: 13,
                                customCss: '',
                                linkedWorldBookIds: [],
                                aiAvatarFrame: '',
                                myAvatarFrame: '',
                                isBackgroundActivityEnabled: true // <--ã€æ ¸å¿ƒæ–°å¢ã€‘é»˜è®¤å¼€å¯
                            },
                            history: [],
                            musicData: { totalTime: 0 }
                        };
                        state.chats[newChatId] = newChat;
                        await db.chats.put(newChat);
                        renderChatList();
                    }
                });

                // â–¼â–¼â–¼ ã€ä¿®æ­£ã€‘åˆ›å»ºç¾¤èŠæŒ‰é’®ç°åœ¨æ‰“å¼€è”ç³»äººé€‰æ‹©å™¨ â–¼â–¼â–¼
                document.getElementById('add-group-chat-btn').addEventListener('click', openContactPickerForGroupCreate);
                // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²                      
                document.getElementById('transfer-cancel-btn').addEventListener('click', () => document.getElementById('transfer-modal').classList.remove('visible'));
                document.getElementById('transfer-confirm-btn').addEventListener('click', sendUserTransfer);

                // â–¼â–¼â–¼ ã€å…¨æ–°ã€‘è½¬è´¦æ¥å—/æ‹’ç»äº‹ä»¶ç›‘å¬å™¨ â–¼â–¼â–¼
                document.getElementById('transfer-action-accept').addEventListener('click', () => handleUserTransferResponse('accepted'));
                document.getElementById('transfer-action-decline').addEventListener('click', () => handleUserTransferResponse('declined'));
                document.getElementById('transfer-action-cancel').addEventListener('click', hideTransferActionModal);
                // â–²â–²â–² æ–°äº‹ä»¶ç›‘å¬å™¨ç»“æŸ â–²â–²â–²

                // â–¼â–¼â–¼ ã€å…¨æ–°ã€‘è½¬è´¦å¡ç‰‡ç‚¹å‡»äº‹ä»¶å¤„ç† â–¼â–¼â–¼
                document.getElementById('chat-messages').addEventListener('click', (e) => {
                    // Handle share link card clicks
                    const shareCard = e.target.closest('.link-share-card[data-timestamp]');
                    if (shareCard && shareCard.closest('.message-bubble.is-link-share')) {
                        const timestamp = parseInt(shareCard.dataset.timestamp);
                        openBrowser(timestamp);
                        return;
                    }

                    // 1. å‘ä¸ŠæŸ¥æ‰¾è¢«ç‚¹å‡»çš„å…ƒç´ æ˜¯å¦åœ¨ä¸€ä¸ªæ¶ˆæ¯æ°”æ³¡å†…
                    const bubble = e.target.closest('.message-bubble');
                    if (!bubble) return; // å¦‚æœä¸åœ¨ï¼Œå°±é€€å‡º

                    // 2. ã€æ ¸å¿ƒä¿®æ­£ã€‘åœ¨è¿™é‡Œæ·»åŠ ä¸¥æ ¼çš„ç­›é€‰æ¡ä»¶
                    // å¿…é¡»æ˜¯ AI çš„æ¶ˆæ¯ (.ai)
                    // å¿…é¡»æ˜¯è½¬è´¦ç±»å‹ (.is-transfer)
                    // å¿…é¡»æ˜¯æˆ‘ä»¬æ ‡è®°ä¸º"å¾…å¤„ç†"çš„ (data-status="pending")
                    if (bubble.classList.contains('ai') &&
                        bubble.classList.contains('is-transfer') &&
                        bubble.dataset.status === 'pending') {

                        // 3. åªæœ‰æ»¡è¶³æ‰€æœ‰æ¡ä»¶ï¼Œæ‰æ‰§è¡Œåç»­é€»è¾‘
                        const timestamp = parseInt(bubble.dataset.timestamp);
                        if (!isNaN(timestamp)) {
                            showTransferActionModal(timestamp);
                        }
                    }
                });
                // â–²â–²â–² è½¬è´¦å¡ç‰‡ç‚¹å‡»å¤„ç†ç»“æŸ â–²â–²â–²

                document.getElementById('listen-together-btn').addEventListener('click', handleListenTogetherClick);

                document.getElementById('music-exit-btn').addEventListener('click', () => endListenTogetherSession(true));
                document.getElementById('music-return-btn').addEventListener('click', returnToChat);

                // Add click-outside-to-close functionality for music player overlay
                document.getElementById('music-player-overlay').addEventListener('click', (e) => {
                    // Only close if clicking on the overlay background, not the music player window
                    if (e.target.id === 'music-player-overlay') {
                        returnToChat();
                    }
                });

                document.getElementById('music-play-pause-btn').addEventListener('click', togglePlayPause);

                // Initialize now playing bar
                initializeNowPlayingBar();
                initializeHomeNowPlayingBar();

                // Initialize meetup progress bar
                initializeMeetupProgressBar();

                // Handle app visibility changes for date session persistence
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'visible') {
                        // App became visible - restore date session if needed
                        if (!hasActiveDateSession()) {
                            restoreActiveDateSession();
                        }

                        // Show progress bar if there's an active session
                        if (hasActiveMeetupSession()) {
                            showMeetupProgressBar();
                        }
                    }
                });

                // Handle page unload to ensure session state is saved
                window.addEventListener('beforeunload', () => {
                    if (hasActiveMeetupSession()) {
                        localStorage.setItem('activeMeetupSession', JSON.stringify(window.activeMeetupSession));
                        localStorage.setItem('activeMeetupEventId', window.activeMeetupEventId);
                    }
                });

                // Cordova-specific app lifecycle events
                document.addEventListener('deviceready', () => {
                    // Handle app pause (backgrounding)
                    document.addEventListener('pause', () => {
                        if (hasActiveMeetupSession()) {
                            localStorage.setItem('activeMeetupSession', JSON.stringify(window.activeMeetupSession));
                            localStorage.setItem('activeMeetupEventId', window.activeMeetupEventId);
                        }
                    });

                    // Handle app resume (foregrounding)
                    document.addEventListener('resume', () => {
                        // Restore meetup session if needed
                        if (!hasActiveMeetupSession()) {
                            restoreActiveMeetupSession();
                        }

                        // Show progress bar if there's an active session
                        if (hasActiveMeetupSession()) {
                            showMeetupProgressBar();
                        }
                    });
                });
                document.getElementById('music-next-btn').addEventListener('click', playNext);
                document.getElementById('music-prev-btn').addEventListener('click', playPrev);
                document.getElementById('music-mode-btn').addEventListener('click', changePlayMode);
                document.getElementById('music-playlist-btn').addEventListener('click', () => { updatePlaylistUI(); document.getElementById('music-playlist-panel').classList.add('visible'); });
                document.getElementById('close-playlist-btn').addEventListener('click', () => document.getElementById('music-playlist-panel').classList.remove('visible'));
                document.getElementById('add-song-url-btn').addEventListener('click', addSongFromURL);
                document.getElementById('add-song-local-btn').addEventListener('click', () => document.getElementById('local-song-upload-input').click());
                document.getElementById('add-song-spotify-btn').addEventListener('click', addSongFromSpotify);
                document.getElementById('local-song-upload-input').addEventListener('change', addSongFromLocal);
                audioPlayer.addEventListener('ended', playNext);
                audioPlayer.addEventListener('pause', () => { if (musicState.isActive) { musicState.isPlaying = false; updatePlayerUI(); } });
                audioPlayer.addEventListener('play', () => { if (musicState.isActive) { musicState.isPlaying = true; updatePlayerUI(); } });
                audioPlayer.addEventListener('timeupdate', updateNowPlayingProgress);

                const chatInput = document.getElementById('chat-input');
                document.getElementById('send-btn').addEventListener('click', async () => {
                    const content = chatInput.value.trim();
                    if (!content || !state.activeChatId) return;

                    const chat = state.chats[state.activeChatId];
                    const msg = {
                        role: 'user',
                        content,
                        timestamp: Date.now()
                    };

                    // æ£€æŸ¥å½“å‰æ˜¯å¦å¤„äºå¼•ç”¨å›å¤æ¨¡å¼
                    if (currentReplyContext) {
                        msg.quote = currentReplyContext; // å°†å¼•ç”¨ä¿¡æ¯é™„åŠ åˆ°æ¶ˆæ¯å¯¹è±¡ä¸Š
                    }

                    chat.history.push(msg);
                    await db.chats.put(chat);
                    appendMessage(msg, chat);
                    renderChatList();
                    chatInput.value = '';
                    chatInput.style.height = 'auto';
                    chatInput.focus();

                    // å‘é€åï¼Œå–æ¶ˆå¼•ç”¨æ¨¡å¼
                    cancelReplyMode();
                });
                document.getElementById('wait-reply-btn').addEventListener('click', () => triggerAiResponse());

                document.getElementById('regenerate-ai-btn').addEventListener('click', async () => {
                    if (!state.activeChatId) return;
                    
                    const chat = state.chats[state.activeChatId];
                    if (!chat || !chat.history || chat.history.length === 0) return;
                    
                    // Find recent AI messages from the end backwards
                    const recentAiMessages = [];
                    for (let i = chat.history.length - 1; i >= 0; i--) {
                        const message = chat.history[i];
                        if (message.role === 'user') break; // Stop at user message
                        if (message.role === 'assistant') {
                            recentAiMessages.unshift(message);
                        }
                    }
                    
                    if (recentAiMessages.length === 0) {
                        await showCustomAlert('æç¤º', 'æ²¡æœ‰æ‰¾åˆ°å¯ä»¥é‡æ–°ç”Ÿæˆçš„AIå›å¤');
                        return;
                    }
                    
                    // Remove AI messages
                    chat.history = chat.history.filter(msg => 
                        !recentAiMessages.some(aiMsg => aiMsg.timestamp === msg.timestamp)
                    );
                    
                    // Save and re-render
                    await db.chats.put(chat);
                    renderChatInterface(state.activeChatId);
                    
                    // Trigger new AI response
                    triggerAiResponse();
                });

                chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); document.getElementById('send-btn').click(); } });
                chatInput.addEventListener('input', () => { chatInput.style.height = 'auto'; chatInput.style.height = (chatInput.scrollHeight) + 'px'; });

                document.getElementById('wallpaper-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await processImageUpload(file); newWallpaperBase64 = dataUrl; renderWallpaperScreen(); } });
                document.getElementById('save-wallpaper-btn').addEventListener('click', async () => { if (newWallpaperBase64) { state.globalSettings.wallpaper = newWallpaperBase64; await db.globalSettings.put(state.globalSettings); applyGlobalWallpaper(); newWallpaperBase64 = null; alert('å£çº¸å·²ä¿å­˜å¹¶åº”ç”¨ï¼'); showScreen('home-screen'); } else alert('è¯·å…ˆä¸Šä¼ ä¸€å¼ æ–°å£çº¸ã€‚'); });

                // Charm CSS customization functionality
                const charmCssInput = document.getElementById('custom-charm-css-input');
                const resetCharmCssBtn = document.getElementById('reset-charm-css-btn');

                // Load saved charm CSS
                const savedCharmCss = localStorage.getItem('customCharmCss');
                if (savedCharmCss) {
                    charmCssInput.value = savedCharmCss;
                    applyCharmCss(savedCharmCss);
                }



                // Apply charm CSS on input change
                charmCssInput.addEventListener('input', () => {
                    const css = charmCssInput.value;
                    applyCharmCss(css);
                    localStorage.setItem('customCharmCss', css);
                });

                // Reset charm CSS button
                resetCharmCssBtn.addEventListener('click', () => {
                    // Reset CSS input to correct default
                    charmCssInput.value = `/* è‡ªå®šä¹‰æŒ‚ä»¶æ ·å¼ - å®Œæ•´é»˜è®¤è®¾ç½® */
.floating-phone-charm {
  position: fixed;
  top: 48px;
  right: -112px;
  width: 220px;
  height: 220px;
  background-image: url('https://files.catbox.moe/rhrobi.gif');
  background-size: contain;
  background-repeat: no-repeat;
  z-index: 1000;
  pointer-events: auto;
  cursor: grab;
  transition: transform 0.2s ease;
  user-select: none;
}`;

                    // Clear localStorage
                    localStorage.removeItem('customCharmCss');
                    localStorage.removeItem('phoneCharmPosition');

                    // Reset charm position
                    const charm = document.getElementById('floating-phone-charm');
                    if (charm) {
                        // Reset position
                        charm.style.top = '48px';
                        charm.style.right = '-112px';
                        charm.style.left = 'auto';
                        charm.style.bottom = 'auto';

                        // Update the charm instance's original position
                        if (window.floatingCharmInstance) {
                            window.floatingCharmInstance.storeOriginalPosition();
                        }
                    }

                    // Apply default CSS
                    applyCharmCss(charmCssInput.value);
                    alert('æŒ‚ä»¶æ ·å¼å·²é‡ç½®åˆ°é»˜è®¤çŠ¶æ€ï¼');
                });

                // Function to apply custom CSS to charm
                function applyCharmCss(css) {
                    let styleElement = document.getElementById('custom-charm-style');
                    if (!styleElement) {
                        styleElement = document.createElement('style');
                        styleElement.id = 'custom-charm-style';
                        document.head.appendChild(styleElement);
                    }
                    styleElement.textContent = css;
                }



                document.getElementById('save-api-settings-btn').addEventListener('click', async () => {
                    // â–¼â–¼â–¼ æ–°å¢æ ¡éªŒé€»è¾‘ â–¼â–¼â–¼
                    const proxyUrlToCheck = document.getElementById('proxy-url').value.trim();
                    if (isApiUrlBanned(proxyUrlToCheck)) {
                        alert('æ­¤APIåœ°å€æ— æ•ˆæˆ–ä¸å—æ”¯æŒï¼Œè¯·æ›´æ¢ã€‚');
                        return; // å‘½ä¸­é»‘åå•ï¼Œä¸­æ–­ä¿å­˜
                    }
                    // â–²â–²â–² æ ¡éªŒé€»è¾‘ç»“æŸ â–²â–²â–²

                    state.apiConfig.proxyUrl = proxyUrlToCheck;
                    state.apiConfig.apiKey = document.getElementById('api-key').value.trim();
                    state.apiConfig.model = document.getElementById('model-select').value;
                    await db.apiConfig.put(state.apiConfig);

                    // åœ¨ 'save-api-settings-btn' çš„ click äº‹ä»¶ç›‘å¬å™¨å†…éƒ¨
                    // await db.apiConfig.put(state.apiConfig); è¿™è¡Œä¹‹å

                    // â–¼â–¼â–¼ å°†ä¹‹å‰é‚£æ®µä¿å­˜åå°æ´»åŠ¨è®¾ç½®çš„é€»è¾‘ï¼Œæ›¿æ¢ä¸ºä¸‹é¢è¿™ä¸ªå¢å¼ºç‰ˆ â–¼â–¼â–¼

                    const backgroundSwitch = document.getElementById('background-activity-switch');
                    const intervalInput = document.getElementById('background-interval-input');
                    const newEnableState = backgroundSwitch.checked;
                    const oldEnableState = state.globalSettings.enableBackgroundActivity || false;

                    // åªæœ‰åœ¨ç”¨æˆ·â€œä»å…³åˆ°å¼€â€æ—¶ï¼Œæ‰å¼¹å‡ºè­¦å‘Š
                    if (newEnableState && !oldEnableState) {
                        const userConfirmed = confirm(
                            "ã€é«˜è´¹ç”¨è­¦å‘Šã€‘\n\n" +
                            "æ‚¨æ­£åœ¨å¯ç”¨â€œåå°è§’è‰²æ´»åŠ¨â€åŠŸèƒ½ã€‚\n\n" +
                            "è¿™ä¼šä½¿æ‚¨çš„AIè§’è‰²ä»¬åœ¨æ‚¨ä¸å’Œä»–ä»¬èŠå¤©æ—¶ï¼Œä¹Ÿèƒ½â€œç‹¬ç«‹æ€è€ƒâ€å¹¶ä¸»åŠ¨ç»™æ‚¨å‘æ¶ˆæ¯æˆ–è¿›è¡Œç¤¾äº¤äº’åŠ¨ï¼Œæå¤§åœ°å¢å¼ºæ²‰æµ¸æ„Ÿã€‚\n\n" +
                            "ä½†è¯·æ³¨æ„ï¼š\n" +
                            "è¿™ä¼šã€åœ¨åå°è‡ªåŠ¨ã€å®šæœŸåœ°è°ƒç”¨APIã€‘ï¼Œå³ä½¿æ‚¨ä¸è¿›è¡Œä»»ä½•æ“ä½œã€‚æ ¹æ®æ‚¨çš„è§’è‰²æ•°é‡å’Œæ£€æµ‹é—´éš”ï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´æ‚¨çš„APIè´¹ç”¨æ˜¾è‘—å¢åŠ ã€‚\n\n" +
                            "æ‚¨ç¡®å®šè¦å¼€å¯å—ï¼Ÿ"
                        );

                        if (!userConfirmed) {
                            backgroundSwitch.checked = false; // ç”¨æˆ·å–æ¶ˆï¼ŒæŠŠå¼€å…³æ‹¨å›å»
                            return; // é˜»æ­¢åç»­é€»è¾‘
                        }
                    }

                    state.globalSettings.enableBackgroundActivity = newEnableState;
                    state.globalSettings.backgroundActivityInterval = parseInt(intervalInput.value) || 60;
                    state.globalSettings.blockCooldownHours = parseFloat(document.getElementById('block-cooldown-input').value) || 1;
                    state.globalSettings.aiActionCooldownMinutes = parseInt(document.getElementById('ai-cooldown-input').value) || 0;
                    await db.globalSettings.put(state.globalSettings);

                    // åŠ¨æ€å¯åŠ¨æˆ–åœæ­¢æ¨¡æ‹Ÿå™¨
                    stopBackgroundSimulation();
                    if (state.globalSettings.enableBackgroundActivity) {
                        startBackgroundSimulation();
                        console.log(`åå°æ´»åŠ¨æ¨¡æ‹Ÿå·²å¯åŠ¨ï¼Œé—´éš”: ${state.globalSettings.backgroundActivityInterval}ç§’`);
                    } else {
                        console.log("åå°æ´»åŠ¨æ¨¡æ‹Ÿå·²åœæ­¢ã€‚");
                    }
                    // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

                    alert('APIè®¾ç½®å·²ä¿å­˜!');
                });
                document.getElementById('fetch-models-btn').addEventListener('click', async () => {
                    const url = document.getElementById('proxy-url').value.trim();
                    const key = document.getElementById('api-key').value.trim();

                    // â–¼â–¼â–¼ æ–°å¢æ ¡éªŒé€»è¾‘ â–¼â–¼â–¼
                    if (isApiUrlBanned(url)) {
                        alert('æ­¤APIåœ°å€æ— æ•ˆæˆ–ä¸å—æ”¯æŒï¼Œè¯·æ›´æ¢ã€‚');
                        return; // å‘½ä¸­é»‘åå•ï¼Œä¸­æ–­æ‹‰å–
                    }
                    // â–²â–²â–² æ ¡éªŒé€»è¾‘ç»“æŸ â–²â–²â–²

                    if (!url || !key) return alert('è¯·å…ˆå¡«å†™åä»£åœ°å€å’Œå¯†é’¥');
                    try {
                        let response, data;
                        const modelSelect = document.getElementById('model-select');
                        modelSelect.innerHTML = '';

                        if (isGoogleGeminiAPI(url)) {
                            // Google Gemini API format
                            response = await fetch(`${url}/v1beta/models?key=${key}`);
                            if (!response.ok) throw new Error('æ— æ³•è·å–Googleæ¨¡å‹åˆ—è¡¨');
                            data = await response.json();
                            // Google returns models in different format
                            data.models.forEach(model => {
                                const option = document.createElement('option');
                                option.value = model.name.replace('models/', '');
                                option.textContent = model.displayName || model.name.replace('models/', '');
                                if (option.value === state.apiConfig.model) option.selected = true;
                                modelSelect.appendChild(option);
                            });
                        } else {
                            // OpenAI-compatible API format (existing)
                            response = await fetch(`${url}/v1/models`, { headers: { 'Authorization': `Bearer ${key}` } });
                            if (!response.ok) throw new Error('æ— æ³•è·å–æ¨¡å‹åˆ—è¡¨');
                            data = await response.json();
                            data.data.forEach(model => {
                                const option = document.createElement('option');
                                option.value = model.id;
                                option.textContent = model.id;
                                if (model.id === state.apiConfig.model) option.selected = true;
                                modelSelect.appendChild(option);
                            });
                        }
                        alert('æ¨¡å‹åˆ—è¡¨å·²æ›´æ–°');
                    } catch (error) {
                        alert(`æ‹‰å–æ¨¡å‹å¤±è´¥: ${error.message}`);
                    }
                });

                document.getElementById('add-world-book-btn').addEventListener('click', async () => { const name = await showCustomPrompt('åˆ›å»ºä¸–ç•Œä¹¦', 'è¯·è¾“å…¥ä¹¦å'); if (name && name.trim()) { const newBook = { id: 'wb_' + Date.now(), name: name.trim(), content: '' }; await db.worldBooks.add(newBook); state.worldBooks.push(newBook); renderWorldBookScreen(); openWorldBookEditor(newBook.id); } });
                document.getElementById('save-world-book-btn').addEventListener('click', async () => { if (!editingWorldBookId) return; const book = state.worldBooks.find(wb => wb.id === editingWorldBookId); if (book) { const newName = document.getElementById('world-book-name-input').value.trim(); if (!newName) { alert('ä¹¦åä¸èƒ½ä¸ºç©ºï¼'); return; } book.name = newName; book.content = document.getElementById('world-book-content-input').value; await db.worldBooks.put(book); document.getElementById('world-book-editor-title').textContent = newName; editingWorldBookId = null; renderWorldBookScreen(); showScreen('world-book-screen'); } });

                document.getElementById('chat-messages').addEventListener('click', (e) => {
                    // å¤„ç†å·²æ’¤å›æ¶ˆæ¯çš„ç‚¹å‡»
                    const placeholder = e.target.closest('.recalled-message-placeholder');
                    if (placeholder) {
                        const wrapper = placeholder.closest('.message-wrapper');
                        if (wrapper) {
                            const timestamp = parseInt(wrapper.dataset.timestamp);
                            const chat = state.chats[state.activeChatId];
                            const recalledMsg = chat.history.find(m => m.timestamp === timestamp);

                            if (recalledMsg && recalledMsg.recalledData) {
                                let originalContentText = '';
                                const recalled = recalledMsg.recalledData;

                                if (recalled.originalType === 'text') {
                                    originalContentText = `åŸæ–‡: "${recalled.originalContent}"`;
                                } else {
                                    originalContentText = `æ’¤å›äº†ä¸€æ¡[${recalled.originalType}]ç±»å‹çš„æ¶ˆæ¯`;
                                }
                                showCustomAlert('å·²æ’¤å›çš„æ¶ˆæ¯', originalContentText);
                            }
                        }
                        return;
                    }

                    // å¤„ç†å›¾ç‰‡å¼¹çª—ï¼ˆé€»è¾‘ä¿ç•™ï¼‰
                    const aiImage = e.target.closest('.ai-generated-image');
                    if (aiImage) {
                        const description = aiImage.dataset.description;
                        if (description) showCustomAlert('ç…§ç‰‡æè¿°', description);
                        return;
                    }

                    // ã€å…¨æ–°ã€‘å¤„ç†è¯­éŸ³ç‚¹å‡»å±•å¼€/æ”¶èµ·
                    const voiceBody = e.target.closest('.voice-message-body');
                    if (voiceBody) {
                        const bubble = voiceBody.closest('.message-bubble');
                        if (!bubble) return;

                        const transcript = bubble.querySelector('.voice-transcript');
                        const waveform = bubble.querySelector('.voice-waveform');

                        if (transcript && waveform) {
                            const isVisible = transcript.style.display === 'block';

                            if (isVisible) {
                                // --- å¦‚æœå½“å‰æ˜¯å±•å¼€çš„ï¼Œç°åœ¨è¦æ”¶èµ· ---
                                transcript.style.display = 'none';
                                // æ¢å¤æˆæœ€åˆå§‹çš„5ä¸ªæ³¢æµª
                                waveform.innerHTML = '<div></div><div></div><div></div><div></div><div></div>';
                            } else {
                                // --- å¦‚æœå½“å‰æ˜¯æ”¶èµ·çš„ï¼Œç°åœ¨è¦å±•å¼€ ---
                                transcript.style.display = 'block';

                                // 1. è·å–è¯­éŸ³æ—¶é•¿
                                const duration = Math.max(1, Math.round((transcript.textContent || '').length / 5));

                                // 2. æ ¹æ®æ–°è§„åˆ™è®¡ç®—éœ€è¦çš„æ³¢æµªæ€»æ•°
                                let waveBars;
                                if (duration === 1) {
                                    waveBars = 5;  // 1s = 1ç»„ = 5ä¸ª
                                } else if (duration === 2) {
                                    waveBars = 15; // 2s = 3ç»„ = 15ä¸ª
                                } else {
                                    waveBars = 20; // 3såŠä»¥ä¸Š = 4ç»„ = 20ä¸ª
                                }

                                // 3. åŠ¨æ€ç”Ÿæˆæ³¢æµªå¹¶ä¿®å¤åŠ¨ç”»å»¶è¿Ÿ
                                waveform.innerHTML = ''; // æ¸…ç©ºæ—§çš„æ³¢æµª
                                for (let i = 0; i < waveBars; i++) {
                                    const waveDiv = document.createElement('div');
                                    // ã€æ ¸å¿ƒã€‘ä¸ºæ¯ä¸€ä¸ªæ³¢æµªè®¾ç½®é€’å¢çš„ã€ç‹¬ä¸€æ— äºŒçš„åŠ¨ç”»å»¶è¿Ÿ
                                    waveDiv.style.animationDelay = `${i * 0.2}s`;
                                    waveform.appendChild(waveDiv);
                                }
                            }
                        }
                        return; // å¤„ç†å®Œè¯­éŸ³ç‚¹å‡»åï¼Œç›´æ¥è¿”å›

                    }
                });
                //ã€ç²˜è´´åˆ°è¿™é‡Œç»“æŸã€‘

                const chatSettingsModal = document.getElementById('chat-settings-modal');
                const worldBookSelectBox = document.querySelector('.custom-multiselect .select-box');
                const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');
                function updateWorldBookSelectionDisplay() { const checkedBoxes = worldBookCheckboxesContainer.querySelectorAll('input:checked'); const displayText = document.querySelector('.selected-options-text'); if (checkedBoxes.length === 0) { displayText.textContent = '-- ç‚¹å‡»é€‰æ‹© --'; } else if (checkedBoxes.length > 2) { displayText.textContent = `å·²é€‰æ‹© ${checkedBoxes.length} é¡¹`; } else { displayText.textContent = Array.from(checkedBoxes).map(cb => cb.parentElement.textContent.trim()).join(', '); } }

                worldBookSelectBox.addEventListener('click', (e) => { e.stopPropagation(); worldBookCheckboxesContainer.classList.toggle('visible'); worldBookSelectBox.classList.toggle('expanded'); });
                document.getElementById('world-book-checkboxes-container').addEventListener('change', updateWorldBookSelectionDisplay);
                window.addEventListener('click', (e) => { if (!document.querySelector('.custom-multiselect').contains(e.target)) { worldBookCheckboxesContainer.classList.remove('visible'); worldBookSelectBox.classList.remove('expanded'); } });

                // â–¼â–¼â–¼ è¯·ç”¨è¿™æ®µã€å®Œæ•´ã€å…¨æ–°çš„ä»£ç ã€‘æ›¿æ¢æ—§çš„ chat-settings-btn ç‚¹å‡»äº‹ä»¶ â–¼â–¼â–¼
                document.getElementById('chat-settings-btn').addEventListener('click', async () => {
                    if (!state.activeChatId) return;
                    const chat = state.chats[state.activeChatId];
                    const isGroup = chat.isGroup;

                    // --- ç»Ÿä¸€æ˜¾ç¤º/éšè—æ§ä»¶ ---
                    document.getElementById('chat-name-group').style.display = 'block';
                    document.getElementById('my-persona-group').style.display = 'block';
                    document.getElementById('my-avatar-group').style.display = 'block';
                    document.getElementById('my-group-nickname-group').style.display = isGroup ? 'block' : 'none';
                    document.getElementById('group-avatar-group').style.display = isGroup ? 'block' : 'none';
                    document.getElementById('group-members-group').style.display = isGroup ? 'block' : 'none';
                    document.getElementById('ai-persona-group').style.display = isGroup ? 'none' : 'block';
                    document.getElementById('ai-avatar-group').style.display = isGroup ? 'none' : 'block';

                    // ã€æ ¸å¿ƒä¿®æ”¹1ã€‘æ ¹æ®æ˜¯å¦ä¸ºç¾¤èŠï¼Œæ˜¾ç¤ºæˆ–éšè—â€œå¥½å‹åˆ†ç»„â€åŒºåŸŸ
                    document.getElementById('assign-group-section').style.display = isGroup ? 'none' : 'block';

                    // --- åŠ è½½è¡¨å•æ•°æ® ---
                    document.getElementById('chat-name-input').value = chat.name;
                    document.getElementById('my-persona').value = chat.settings.myPersona;
                    document.getElementById('my-avatar-preview').src = chat.settings.myAvatar || (isGroup ? defaultMyGroupAvatar : defaultAvatar);
                    document.getElementById('max-memory').value = chat.settings.maxMemory;
                    // â–¼â–¼â–¼ ã€æ ¸å¿ƒæ–°å¢ã€‘è¯»å–å¼€å…³çŠ¶æ€ â–¼â–¼â–¼
                    document.getElementById('background-activity-switch-chat').checked = chat.settings.isBackgroundActivityEnabled ?? true;

                    const bgPreview = document.getElementById('bg-preview');
                    const removeBgBtn = document.getElementById('remove-bg-btn');
                    if (chat.settings.background) {
                        bgPreview.src = chat.settings.background;
                        bgPreview.style.display = 'block';
                        removeBgBtn.style.display = 'inline-block';
                    } else {
                        bgPreview.style.display = 'none';
                        removeBgBtn.style.display = 'none';
                    }

                    if (isGroup) {
                        document.getElementById('my-group-nickname-input').value = chat.settings.myNickname || '';
                        document.getElementById('group-avatar-preview').src = chat.settings.groupAvatar || defaultGroupAvatar;
                        renderGroupMemberSettings(chat.members);
                    } else {
                        document.getElementById('ai-persona').value = chat.settings.aiPersona;
                        document.getElementById('ai-avatar-preview').src = chat.settings.aiAvatar || defaultAvatar;

                        // ã€æ ¸å¿ƒä¿®æ”¹2ã€‘å¦‚æœæ˜¯å•èŠï¼Œå°±åŠ è½½åˆ†ç»„åˆ—è¡¨åˆ°ä¸‹æ‹‰æ¡†
                        const select = document.getElementById('assign-group-select');
                        select.innerHTML = '<option value="">æœªåˆ†ç»„</option>'; // æ¸…ç©ºå¹¶è®¾ç½®é»˜è®¤é€‰é¡¹
                        const groups = await db.qzoneGroups.toArray();
                        groups.forEach(group => {
                            const option = document.createElement('option');
                            option.value = group.id;
                            option.textContent = group.name;
                            // å¦‚æœå½“å‰å¥½å‹å·²ç»æœ‰åˆ†ç»„ï¼Œå°±é»˜è®¤é€‰ä¸­å®ƒ
                            if (chat.groupId === group.id) {
                                option.selected = true;
                            }
                            select.appendChild(option);
                        });
                    }

                    // åŠ è½½ä¸–ç•Œä¹¦
                    const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');
                    worldBookCheckboxesContainer.innerHTML = '';
                    const linkedIds = chat.settings.linkedWorldBookIds || [];
                    if (state.worldBooks.length > 0) {
                        state.worldBooks.forEach(book => {
                            const isChecked = linkedIds.includes(book.id);
                            const label = document.createElement('label');
                            label.innerHTML = `<input type="checkbox" value="${book.id}" ${isChecked ? 'checked' : ''}> ${book.name}`;
                            worldBookCheckboxesContainer.appendChild(label);
                        });
                    }
                    updateWorldBookSelectionDisplay();

                    // åŠ è½½å¹¶æ›´æ–°æ‰€æœ‰é¢„è§ˆç›¸å…³æ§ä»¶
                    const themeRadio = document.querySelector(`input[name="theme-select"][value="${chat.settings.theme || 'default'}"]`);
                    if (themeRadio) themeRadio.checked = true;
                    const fontSizeSlider = document.getElementById('font-size-slider');
                    fontSizeSlider.value = chat.settings.fontSize || 13;
                    document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
                    const customCssInput = document.getElementById('custom-css-input');
                    customCssInput.value = chat.settings.customCss || '';

                    // â–¼â–¼â–¼ Update summary info â–¼â–¼â–¼
                    updateSummaryInfo(chat);
                    // â–²â–²â–² Summary info update end â–²â–²â–²

                    updateSettingsPreview();
                    document.getElementById('chat-settings-modal').classList.add('visible');
                });
                // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

                function renderGroupMemberSettings(members) { const container = document.getElementById('group-members-settings'); container.innerHTML = ''; members.forEach(member => { const div = document.createElement('div'); div.className = 'member-editor'; div.dataset.memberId = member.id; div.innerHTML = `<img src="${member.avatar}" alt="${member.name}"><div class="member-name">${member.name}</div>`; div.addEventListener('click', () => openMemberEditor(member.id)); container.appendChild(div); }); }
                function openMemberEditor(memberId) { editingMemberId = memberId; const chat = state.chats[state.activeChatId]; const member = chat.members.find(m => m.id === memberId); document.getElementById('member-name-input').value = member.name; document.getElementById('member-persona-input').value = member.persona; document.getElementById('member-avatar-preview').src = member.avatar; document.getElementById('member-settings-modal').classList.add('visible'); }

                // â–¼â–¼â–¼ Summary Info Update Function â–¼â–¼â–¼
                function updateSummaryInfo(chat) {
                    // Update total message count in title
                    const totalMessages = chat.history ? chat.history.length : 0;
                    document.getElementById('summary-section-title').textContent = `é•¿æœŸè®°å¿†ç”Ÿæˆ (${totalMessages.toLocaleString()} æ¡)`;
                }
                // â–²â–²â–² Summary Info Function End â–²â–²â–²

                document.getElementById('cancel-member-settings-btn').addEventListener('click', () => { document.getElementById('member-settings-modal').classList.remove('visible'); editingMemberId = null; });
                document.getElementById('save-member-settings-btn').addEventListener('click', () => { if (!editingMemberId) return; const chat = state.chats[state.activeChatId]; const member = chat.members.find(m => m.id === editingMemberId); member.name = document.getElementById('member-name-input').value; member.persona = document.getElementById('member-persona-input').value; member.avatar = document.getElementById('member-avatar-preview').src; renderGroupMemberSettings(chat.members); document.getElementById('member-settings-modal').classList.remove('visible'); });
                document.getElementById('reset-theme-btn').addEventListener('click', () => { document.getElementById('theme-default').checked = true; });
                document.getElementById('cancel-chat-settings-btn').addEventListener('click', () => { chatSettingsModal.classList.remove('visible'); });

                // â–¼â–¼â–¼ Summary Button Click Handler â–¼â–¼â–¼
                document.getElementById('update-summary-btn').addEventListener('click', async () => {
                    if (!state.activeChatId) return;
                    const chat = state.chats[state.activeChatId];
                    
                    // Check if there are messages to summarize
                    if (!chat.history || chat.history.length === 0) {
                        alert('âŒ æ²¡æœ‰æ¶ˆæ¯å¯ä»¥æ€»ç»“');
                        return;
                    }
                    
                    // Get user-specified message count
                    const messageCountInput = document.getElementById('summary-message-count');
                    let messageCount = parseInt(messageCountInput.value);
                    
                    // Validate input
                    if (isNaN(messageCount) || messageCount < 100) {
                        alert('âŒ è¯·è¾“å…¥è‡³å°‘100æ¡æ¶ˆæ¯');
                        return;
                    }
                    
                    if (messageCount > chat.history.length) {
                        messageCount = chat.history.length;
                        messageCountInput.value = messageCount;
                    }
                    
                    // Get or create the auto-summary world book first
                    const autoBook = await getOrCreateAutoSummaryWorldBook(state.activeChatId);
                    if (!autoBook) {
                        alert('âŒ åˆ›å»ºä¸–ç•Œä¹¦å¤±è´¥');
                        return;
                    }
                    
                    // Disable button and show loading state
                    const btn = document.getElementById('update-summary-btn');
                    const originalText = btn.textContent;
                    btn.disabled = true;
                    btn.textContent = 'â³ AIæ­£åœ¨ç”Ÿæˆé•¿æœŸè®°å¿†...';
                    btn.style.opacity = '0.6';
                    
                    // Set global flags for summary generation
                    isGeneratingSummary = true;
                    generatingSummaryBookId = autoBook.id;
                    
                    // Show loading state on world book (don't let this break the flow)
                    try {
                        setWorldBookLoadingState(autoBook.id, true);
                    } catch (e) {
                        // Silently fail - loading state is optional
                    }
                    
                    try {
                        console.log('ğŸš€ Starting summary generation...');
                        console.log(`Summarizing last ${messageCount} messages`);
                        
                        // Generate summary with AI (pass message count)
                        const newSummary = await generateChatSummary(state.activeChatId, messageCount);
                        
                        // Update world book with new summary
                        const success = await updateAutoSummaryWorldBook(state.activeChatId, newSummary);
                        
                        if (success) {
                            // Refresh world book list if it's open
                            if (window.renderWorldBookScreenProxy) {
                                window.renderWorldBookScreenProxy();
                            }
                            
                            console.log('âœ… Summary generation complete!');
                            console.log(`Summary length: ${newSummary.length} characters`);
                            
                            alert(`âœ… é•¿æœŸè®°å¿†ç”ŸæˆæˆåŠŸï¼\n\nå·²æ›´æ–°ä¸–ç•Œä¹¦: [é•¿æœŸè®°å¿†] ${chat.name}\n\næ€»ç»“äº†æœ€è¿‘ ${messageCount} æ¡æ¶ˆæ¯\nè®°å¿†é•¿åº¦: ${newSummary.length} å­—ç¬¦\n\nä½ å¯ä»¥åœ¨ä¸–ç•Œä¹¦åˆ—è¡¨ä¸­æŸ¥çœ‹å®Œæ•´å†…å®¹`);
                        } else {
                            alert('âŒ ä¿å­˜æ‘˜è¦å¤±è´¥');
                        }
                    } catch (error) {
                        console.error('âŒ Summary generation error:', error);
                        alert(`âŒ ç”Ÿæˆé•¿æœŸè®°å¿†å¤±è´¥\n\né”™è¯¯ä¿¡æ¯: ${error.message}\n\nè¯·æ£€æŸ¥:\n1. APIé…ç½®æ˜¯å¦æ­£ç¡®\n2. ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸\n3. APIé¢åº¦æ˜¯å¦å……è¶³`);
                    } finally {
                        // Clear global flags
                        isGeneratingSummary = false;
                        generatingSummaryBookId = null;
                        
                        // Remove loading state from world book (don't let this break the flow)
                        try {
                            setWorldBookLoadingState(autoBook.id, false);
                        } catch (e) {
                            // Silently fail - loading state is optional
                        }
                        
                        // Re-enable button
                        btn.disabled = false;
                        btn.textContent = originalText;
                        btn.style.opacity = '1';
                    }
                });
                // â–²â–²â–² Summary Button Handler End â–²â–²â–²

                // â–¼â–¼â–¼ Summary Info Update Function â–¼â–¼â–¼
                function updateSummaryInfo(chat) {
                    // Update total message count in title
                    const totalMessages = chat.history ? chat.history.length : 0;
                    document.getElementById('summary-section-title').textContent = `é•¿æœŸè®°å¿†ç”Ÿæˆ (${totalMessages.toLocaleString()} æ¡)`;
                }
                // â–²â–²â–² Summary Info Function End â–²â–²â–²

                document.getElementById('save-chat-settings-btn').addEventListener('click', async () => {
                    if (!state.activeChatId) return;
                    const chat = state.chats[state.activeChatId];
                    const newName = document.getElementById('chat-name-input').value.trim();
                    if (!newName) return alert('å¤‡æ³¨å/ç¾¤åä¸èƒ½ä¸ºç©ºï¼');
                    chat.name = newName;
                    const selectedThemeRadio = document.querySelector('input[name="theme-select"]:checked');
                    chat.settings.theme = selectedThemeRadio ? selectedThemeRadio.value : 'default';

                    chat.settings.fontSize = parseInt(document.getElementById('font-size-slider').value);
                    chat.settings.customCss = document.getElementById('custom-css-input').value.trim();

                    chat.settings.myPersona = document.getElementById('my-persona').value;
                    chat.settings.myAvatar = document.getElementById('my-avatar-preview').src;
                    const checkedBooks = document.querySelectorAll('#world-book-checkboxes-container input[type="checkbox"]:checked');
                    chat.settings.linkedWorldBookIds = Array.from(checkedBooks).map(cb => cb.value);
                    chat.settings.isBackgroundActivityEnabled = document.getElementById('background-activity-switch-chat').checked;

                    if (chat.isGroup) {
                        chat.settings.myNickname = document.getElementById('my-group-nickname-input').value.trim();
                        chat.settings.groupAvatar = document.getElementById('group-avatar-preview').src;
                    } else {
                        chat.settings.aiPersona = document.getElementById('ai-persona').value;
                        chat.settings.aiAvatar = document.getElementById('ai-avatar-preview').src;
                        const selectedGroupId = document.getElementById('assign-group-select').value;
                        chat.groupId = selectedGroupId ? parseInt(selectedGroupId) : null;
                    }

                    chat.settings.maxMemory = parseInt(document.getElementById('max-memory').value) || 10;
                    await db.chats.put(chat);

                    applyScopedCss(chat.settings.customCss, '#chat-messages', 'custom-bubble-style');

                    chatSettingsModal.classList.remove('visible');
                    renderChatInterface(state.activeChatId);
                    renderChatList();
                });
                document.getElementById('clear-chat-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const confirmed = await showCustomConfirm('æ¸…ç©ºèŠå¤©è®°å½•', 'æ­¤æ“ä½œå°†æ°¸ä¹…åˆ é™¤æ­¤èŠå¤©çš„æ‰€æœ‰æ¶ˆæ¯ï¼Œæ— æ³•æ¢å¤ã€‚ç¡®å®šè¦æ¸…ç©ºå—ï¼Ÿ', { confirmButtonClass: 'btn-danger' }); if (confirmed) { chat.history = []; await db.chats.put(chat); renderChatInterface(state.activeChatId); renderChatList(); chatSettingsModal.classList.remove('visible'); } });

                const setupFileUpload = (inputId, callback) => { document.getElementById(inputId).addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); callback(dataUrl); event.target.value = null; } }); };
                setupFileUpload('ai-avatar-input', (base64) => document.getElementById('ai-avatar-preview').src = base64);
                setupFileUpload('my-avatar-input', (base64) => document.getElementById('my-avatar-preview').src = base64);
                setupFileUpload('group-avatar-input', (base64) => document.getElementById('group-avatar-preview').src = base64);
                setupFileUpload('member-avatar-input', (base64) => document.getElementById('member-avatar-preview').src = base64);

                // QZone avatar modal event handlers
                document.getElementById('save-qzone-avatar-btn').addEventListener('click', async () => {
                    // Save avatar
                    state.qzoneSettings.avatar = document.getElementById('qzone-avatar-preview').src;

                    // Save toggle state
                    const toggle = document.getElementById('qzone-border-toggle');
                    state.qzoneSettings.avatarBordersEnabled = toggle.checked;

                    // Save border (only if toggle is enabled)
                    if (toggle.checked) {
                        const borderSrc = document.getElementById('qzone-border-preview').src;
                        state.qzoneSettings.avatarFrame = (borderSrc && borderSrc !== 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7') ? borderSrc : null;
                    }

                    // Save to database
                    await saveQzoneSettings();
                    renderQzoneScreen();
                    await renderQzonePosts(); // Re-render posts with new border settings

                    // Close modal
                    document.getElementById('qzone-avatar-modal').classList.remove('visible');
                });

                // QZone avatar file upload handler
                document.getElementById('qzone-avatar-file-input').addEventListener('change', async (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        const dataUrl = await processImageUpload(file);
                        document.getElementById('qzone-avatar-preview').src = dataUrl;
                    }
                    event.target.value = null;
                });

                // QZone border toggle handler
                document.getElementById('qzone-border-toggle').addEventListener('change', (e) => {
                    const borderGroup = document.getElementById('qzone-border-group');
                    borderGroup.style.display = e.target.checked ? 'block' : 'none';
                });

                // QZone border upload handler
                document.getElementById('qzone-border-input').addEventListener('change', async (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        const dataUrl = await new Promise((res, rej) => {
                            const reader = new FileReader();
                            reader.onload = () => res(reader.result);
                            reader.readAsDataURL(file);
                        });
                        document.getElementById('qzone-border-preview').src = dataUrl;
                        document.getElementById('qzone-border-preview').style.display = 'block';
                        document.getElementById('qzone-no-border-text').style.display = 'none';
                        document.getElementById('qzone-remove-border-btn').style.display = 'inline-block';
                    }
                    event.target.value = null;
                });
                setupFileUpload('bg-input', (base64) => { if (state.activeChatId) { state.chats[state.activeChatId].settings.background = base64; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = base64; bgPreview.style.display = 'block'; document.getElementById('remove-bg-btn').style.display = 'inline-block'; } });
                setupFileUpload('preset-avatar-input', (base64) => document.getElementById('preset-avatar-preview').src = base64);
                document.getElementById('remove-bg-btn').addEventListener('click', () => { if (state.activeChatId) { state.chats[state.activeChatId].settings.background = ''; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = ''; bgPreview.style.display = 'none'; document.getElementById('remove-bg-btn').style.display = 'none'; } });

                const stickerPanel = document.getElementById('sticker-panel');
                document.getElementById('open-sticker-panel-btn').addEventListener('click', () => { 
                    // Set current pack to first pack in saved order
                    const savedOrder = state.globalSettings?.stickerPackOrder || Object.keys(stickerPackData);
                    if (savedOrder.length > 0) {
                        currentStickerPack = savedOrder[0];
                    }
                    renderStickerPanel(); 
                    stickerPanel.classList.add('visible'); 
                    initializeStickerPackTabs(); 
                });
                // Close button handler is managed dynamically in arrange mode
                document.getElementById('close-sticker-panel-btn').onclick = () => stickerPanel.classList.remove('visible');
                // Set initial edit button handler
                document.getElementById('edit-sticker-pack-btn').onclick = openStickerPackEditModal;
                // No additional event listeners needed - handled in the add square click handler
                document.getElementById('sticker-upload-input').addEventListener('change', async (event) => {
                    const file = event.target.files[0]; if (!file) return; const base64Url = await processImageUpload(file); const name = await showCustomPrompt("å‘½åè¡¨æƒ…", "è¯·ä¸ºè¿™ä¸ªè¡¨æƒ…å‘½å (ä¾‹å¦‚ï¼šå¥½è€¶ã€ç–‘æƒ‘)"); if (name && name.trim()) {
                        const newSticker = {
                            id: 'sticker_' + Date.now(),
                            url: base64Url,
                            name: name.trim(),
                            order: state.userStickers.length,
                            packId: currentStickerPack
                        }; await db.userStickers.add(newSticker); state.userStickers.push(newSticker); document.getElementById('sticker-panel').classList.add('visible'); renderStickerPanel();
                    } else if (name !== null) alert("è¡¨æƒ…åä¸èƒ½ä¸ºç©ºï¼"); event.target.value = null;
                });

                document.getElementById('upload-image-btn').addEventListener('click', () => document.getElementById('image-upload-input').click());
                document.getElementById('image-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (!file || !state.activeChatId) return; const base64Url = await processImageUpload(file); const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content: [{ type: 'image_url', image_url: { url: base64Url } }], timestamp: Date.now(), isVisionAnalysis: true }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); event.target.value = null; });
                document.getElementById('voice-message-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const text = await showCustomPrompt("å‘é€è¯­éŸ³", "è¯·è¾“å…¥ä½ æƒ³è¯´çš„å†…å®¹ï¼š"); if (text && text.trim()) { const chat = state.chats[state.activeChatId]; const msg = { role: 'user', type: 'voice_message', content: text.trim(), timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); } });
                document.getElementById('send-photo-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const description = await showCustomPrompt("å‘é€ç…§ç‰‡", "è¯·ç”¨æ–‡å­—æè¿°æ‚¨è¦å‘é€çš„ç…§ç‰‡ï¼š"); if (description && description.trim()) { const chat = state.chats[state.activeChatId]; const msg = { role: 'user', type: 'user_photo', content: description.trim(), timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); } });

                // â–¼â–¼â–¼ ã€å…¨æ–°ã€‘å¤–å–è¯·æ±‚åŠŸèƒ½äº‹ä»¶ç»‘å®š â–¼â–¼â–¼
                const waimaiModal = document.getElementById('waimai-request-modal');
                document.getElementById('send-waimai-request-btn').addEventListener('click', () => {
                    waimaiModal.classList.add('visible');
                });

                document.getElementById('waimai-cancel-btn').addEventListener('click', () => {
                    waimaiModal.classList.remove('visible');
                });

                document.getElementById('waimai-confirm-btn').addEventListener('click', async () => {
                    if (!state.activeChatId) return;

                    const productInfoInput = document.getElementById('waimai-product-info');
                    const amountInput = document.getElementById('waimai-amount');

                    const productInfo = productInfoInput.value.trim();
                    const amount = parseFloat(amountInput.value);

                    if (!productInfo) {
                        alert('è¯·è¾“å…¥å•†å“ä¿¡æ¯ï¼');
                        return;
                    }
                    if (isNaN(amount) || amount <= 0) {
                        alert('è¯·è¾“å…¥æœ‰æ•ˆçš„ä»£ä»˜é‡‘é¢ï¼');
                        return;
                    }

                    const chat = state.chats[state.activeChatId];
                    const now = Date.now();

                    // ã€æ ¸å¿ƒä¿®æ­£ã€‘åœ¨è¿™é‡Œè·å–ç”¨æˆ·è‡ªå·±çš„æ˜µç§°
                    const myNickname = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';

                    const msg = {
                        role: 'user',
                        // ã€æ ¸å¿ƒä¿®æ­£ã€‘å°†è·å–åˆ°çš„æ˜µç§°ï¼Œä½œä¸º senderName æ·»åŠ åˆ°æ¶ˆæ¯å¯¹è±¡ä¸­
                        senderName: myNickname,
                        type: 'waimai_request',
                        productInfo: productInfo,
                        amount: amount,
                        status: 'pending',
                        countdownEndTime: now + 15 * 60 * 1000,
                        timestamp: now
                    };

                    chat.history.push(msg);
                    await db.chats.put(chat);
                    appendMessage(msg, chat);
                    renderChatList();

                    productInfoInput.value = '';
                    amountInput.value = '';
                    waimaiModal.classList.remove('visible');
                });
                document.getElementById('open-persona-library-btn').addEventListener('click', openPersonaLibrary);
                document.getElementById('close-persona-library-btn').addEventListener('click', closePersonaLibrary);
                document.getElementById('add-persona-preset-btn').addEventListener('click', openPersonaEditorForCreate);
                document.getElementById('cancel-persona-editor-btn').addEventListener('click', closePersonaEditor);
                document.getElementById('save-persona-preset-btn').addEventListener('click', savePersonaPreset);
                document.getElementById('preset-action-edit').addEventListener('click', () => {
                    if (editingMemoryId) {
                        editMemory();
                    } else {
                        openPersonaEditorForEdit();
                    }
                });
                document.getElementById('preset-action-delete').addEventListener('click', () => {
                    if (editingMemoryId) {
                        deleteMemory();
                    } else {
                        deletePersonaPreset();
                    }
                });
                document.getElementById('preset-action-cancel').addEventListener('click', () => {
                    if (editingMemoryId) {
                        hideMemoryActions();
                    } else {
                        hidePresetActions();
                    }
                });

                document.getElementById('selection-cancel-btn').addEventListener('click', exitSelectionMode);

                // â–¼â–¼â–¼ ã€æœ€ç»ˆåŠ å¼ºç‰ˆã€‘ç”¨è¿™å—ä»£ç æ›¿æ¢æ—§çš„ selection-delete-btn äº‹ä»¶ç›‘å¬å™¨ â–¼â–¼â–¼
                document.getElementById('selection-delete-btn').addEventListener('click', async () => {
                    if (selectedMessages.size === 0) return;
                    const confirmed = await showCustomConfirm('åˆ é™¤æ¶ˆæ¯', `ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedMessages.size} æ¡æ¶ˆæ¯å—ï¼Ÿè¿™å°†æ”¹å˜AIçš„è®°å¿†ã€‚`, { confirmButtonClass: 'btn-danger' });
                    if (confirmed) {
                        const chat = state.chats[state.activeChatId];

                        // 1. ã€æ ¸å¿ƒåŠ å¼ºã€‘åœ¨åˆ é™¤å‰ï¼Œæ£€æŸ¥è¢«åˆ é™¤çš„æ¶ˆæ¯ä¸­æ˜¯å¦åŒ…å«æŠ•ç¥¨
                        let deletedPollsInfo = [];
                        for (const timestamp of selectedMessages) {
                            const msg = chat.history.find(m => m.timestamp === timestamp);
                            if (msg && msg.type === 'poll') {
                                deletedPollsInfo.push(`å…³äºâ€œ${msg.question}â€çš„æŠ•ç¥¨(æ—¶é—´æˆ³: ${msg.timestamp})`);
                            }
                        }

                        // 2. æ›´æ–°åç«¯çš„å†å²è®°å½•
                        chat.history = chat.history.filter(msg => !selectedMessages.has(msg.timestamp));

                        // 3. ã€æ ¸å¿ƒåŠ å¼ºã€‘æ„å»ºæ›´å…·ä½“çš„â€œé—å¿˜æŒ‡ä»¤â€
                        let forgetReason = "ä¸€äº›ä¹‹å‰çš„æ¶ˆæ¯å·²è¢«ç”¨æˆ·åˆ é™¤ã€‚";
                        if (deletedPollsInfo.length > 0) {
                            forgetReason += ` å…¶ä¸­åŒ…æ‹¬ä»¥ä¸‹æŠ•ç¥¨ï¼š${deletedPollsInfo.join('ï¼›')}ã€‚`;
                        }
                        forgetReason += " ä½ åº”è¯¥åƒå®ƒä»¬ä»æœªå­˜åœ¨è¿‡ä¸€æ ·ç»§ç»­å¯¹è¯ï¼Œå¹¶ç›¸åº”åœ°è°ƒæ•´ä½ çš„è®°å¿†å’Œè¡Œä¸ºï¼Œä¸è¦å†æåŠè¿™äº›è¢«åˆ é™¤çš„å†…å®¹ã€‚";



                        // 4. å°†åŒ…å«â€œé—å¿˜æŒ‡ä»¤â€çš„ã€æ›´æ–°åçš„chatå¯¹è±¡å­˜å›æ•°æ®åº“
                        await db.chats.put(chat);

                        // 5. æœ€åæ‰æ›´æ–°UI
                        renderChatInterface(state.activeChatId);
                        renderChatList();
                    }
                });
                // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

                // ä¸ºèŠå¤©è®¾ç½®é‡Œçš„â€œæ›´æ¢å¤´åƒæ¡†â€æŒ‰é’®æ·»åŠ ç‚¹å‡»äº‹ä»¶
                document.getElementById('chat-settings-modal').addEventListener('click', (e) => {
                    if (e.target.classList.contains('change-frame-btn')) {
                        // 'chat' è¿™ä¸ªå‚æ•°æ˜¯å‘Šè¯‰å‡½æ•°ï¼Œè¿™æ¬¡æ˜¯ä¸ºâ€œæˆ‘/å¯¹æ–¹â€è¿™å¯¹ç»„åˆæ›´æ¢å¤´åƒæ¡†
                        openFrameSelectorModal('chat');
                    }
                });

                // ä¸ºæˆå‘˜è®¾ç½®é‡Œçš„â€œæ›´æ¢å¤´åƒæ¡†â€æŒ‰é’®æ·»åŠ ç‚¹å‡»äº‹ä»¶
                document.getElementById('member-settings-modal').addEventListener('click', (e) => {
                    // ã€ä¿®æ­£ã€‘å°† .contents ä¿®æ”¹ä¸º .contains
                    if (e.target.classList.contains('change-frame-btn')) {
                        // 'member' è¿™ä¸ªå‚æ•°æ˜¯å‘Šè¯‰å‡½æ•°ï¼Œè¿™æ¬¡æ˜¯ä¸ºå•ä¸ªç¾¤æˆå‘˜æ›´æ¢å¤´åƒæ¡†
                        openFrameSelectorModal('member');
                    }
                });

                // â–²â–²â–² ç²˜è´´ç»“æŸ â–²â–²â–²

                const fontUrlInput = document.getElementById('font-url-input');
                fontUrlInput.addEventListener('input', () => {
                    // Clear uploaded font when typing URL
                    if (fontUrlInput.value.trim()) {
                        window.uploadedFontData = null;
                        window.uploadedFontName = null;
                        document.getElementById('font-file-name').textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
                    }
                    applyCustomFont(fontUrlInput.value.trim(), true);
                });

                // Font upload handler
                document.getElementById('font-upload-input').addEventListener('change', (e) => {
                    console.log('File input changed, files:', e.target.files);
                    const file = e.target.files[0];
                    if (file) {
                        console.log('File selected for upload:', file);
                        handleFontUpload(file);
                    } else {
                        console.log('No file selected');
                    }
                });


                document.getElementById('save-font-btn').addEventListener('click', saveFontSettings);
                document.getElementById('reset-font-btn').addEventListener('click', resetToDefaultFont);

                document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => { item.addEventListener('click', () => switchToChatListView(item.dataset.view)); });
                document.getElementById('qzone-back-btn').addEventListener('click', () => showScreen('home-screen'));
                document.getElementById('qzone-nickname').addEventListener('click', async () => { const newNickname = await showCustomPrompt("ä¿®æ”¹æ˜µç§°", "è¯·è¾“å…¥æ–°çš„æ˜µç§°", state.qzoneSettings.nickname); if (newNickname && newNickname.trim()) { state.qzoneSettings.nickname = newNickname.trim(); await saveQzoneSettings(); renderQzoneScreen(); } });
                document.getElementById('qzone-status').addEventListener('click', async () => {
                    const currentStatus = document.getElementById('qzone-status').textContent;
                    const newStatus = await showCustomPrompt('ç¼–è¾‘ä¸ªæ€§ç­¾å', 'è¾“å…¥æ–°çš„ä¸ªæ€§ç­¾å', currentStatus);

                    if (newStatus !== null && newStatus.trim() !== '') {
                        // Update the display
                        document.getElementById('qzone-status').textContent = newStatus.trim();

                        // Save to settings
                        if (!state.qzoneSettings) {
                            state.qzoneSettings = {};
                        }
                        state.qzoneSettings.status = newStatus.trim();

                        // Save to database
                        try {
                            await db.qzoneSettings.put({
                                id: 'main',
                                ...state.qzoneSettings
                            });
                        } catch (error) {
                            console.error('Failed to save QZone status:', error);
                        }
                    }
                });
                document.getElementById('qzone-avatar-container').addEventListener('click', () => {
                    // Load current avatar
                    document.getElementById('qzone-avatar-preview').src = state.qzoneSettings.avatar;

                    // Load toggle state
                    const toggle = document.getElementById('qzone-border-toggle');
                    toggle.checked = state.qzoneSettings.avatarBordersEnabled || false;

                    // Show/hide border group based on toggle
                    const borderGroup = document.getElementById('qzone-border-group');
                    borderGroup.style.display = toggle.checked ? 'block' : 'none';

                    // Load border if exists
                    if (state.qzoneSettings.avatarFrame) {
                        document.getElementById('qzone-border-preview').src = state.qzoneSettings.avatarFrame;
                        document.getElementById('qzone-border-preview').style.display = 'block';
                        document.getElementById('qzone-no-border-text').style.display = 'none';
                        document.getElementById('qzone-remove-border-btn').style.display = 'inline-block';
                    } else {
                        removeQzoneBorder();
                    }

                    // Show modal
                    document.getElementById('qzone-avatar-modal').classList.add('visible');
                });
                document.getElementById('qzone-banner-container').addEventListener('click', () => document.getElementById('qzone-banner-input').click());
                document.getElementById('qzone-avatar-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await processImageUpload(file); state.qzoneSettings.avatar = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });
                document.getElementById('qzone-banner-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await processImageUpload(file); state.qzoneSettings.banner = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });

                // â–¼â–¼â–¼ ã€ä¿®æ­£åã€‘çš„â€œè¯´è¯´â€æŒ‰é’®äº‹ä»¶ â–¼â–¼â–¼
                document.getElementById('create-shuoshuo-btn').addEventListener('click', async () => {
                    // 1. é‡ç½®å¹¶è·å–æ¨¡æ€æ¡†
                    resetCreatePostModal();
                    const modal = document.getElementById('create-post-modal');

                    // 2. è®¾ç½®ä¸ºâ€œè¯´è¯´â€æ¨¡å¼
                    modal.dataset.mode = 'shuoshuo';

                    // 3. éšè—ä¸å›¾ç‰‡/æ–‡å­—å›¾ç›¸å…³çš„éƒ¨åˆ†
                    modal.querySelector('.post-mode-switcher').style.display = 'none';
                    modal.querySelector('#image-mode-content').style.display = 'none';
                    modal.querySelector('#text-image-mode-content').style.display = 'none';

                    // 4. ä¿®æ”¹ä¸»è¾“å…¥æ¡†çš„æç¤ºè¯­ï¼Œä½¿å…¶æ›´ç¬¦åˆâ€œè¯´è¯´â€çš„åœºæ™¯
                    modal.querySelector('#post-public-text').placeholder = 'åˆ†äº«æ–°é²œäº‹...';

                    // 5. å‡†å¤‡å¹¶æ˜¾ç¤ºæ¨¡æ€æ¡†
                    const visibilityGroupsContainer = document.getElementById('post-visibility-groups');
                    visibilityGroupsContainer.innerHTML = '';
                    const groups = await db.qzoneGroups.toArray();
                    if (groups.length > 0) {
                        groups.forEach(group => {
                            const label = document.createElement('label');
                            label.style.display = 'block';
                            label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
                            visibilityGroupsContainer.appendChild(label);
                        });
                    } else {
                        visibilityGroupsContainer.innerHTML = '<p style="color: var(--text-secondary);">æ²¡æœ‰å¯ç”¨çš„åˆ†ç»„</p>';
                    }
                    modal.classList.add('visible');
                });

                // â–¼â–¼â–¼ ã€ä¿®æ­£åã€‘çš„â€œåŠ¨æ€â€ï¼ˆå›¾ç‰‡ï¼‰æŒ‰é’®äº‹ä»¶ â–¼â–¼â–¼
                document.getElementById('create-post-btn').addEventListener('click', async () => {
                    // 1. é‡ç½®å¹¶è·å–æ¨¡æ€æ¡†
                    resetCreatePostModal();
                    const modal = document.getElementById('create-post-modal');

                    // 2. è®¾ç½®ä¸ºâ€œå¤æ‚åŠ¨æ€â€æ¨¡å¼
                    modal.dataset.mode = 'complex';

                    // 3. ç¡®ä¿ä¸å›¾ç‰‡/æ–‡å­—å›¾ç›¸å…³çš„éƒ¨åˆ†æ˜¯å¯è§çš„
                    modal.querySelector('.post-mode-switcher').style.display = 'flex';
                    // æ˜¾å¼æ¿€æ´»â€œä¸Šä¼ å›¾ç‰‡â€æ¨¡å¼...
                    modal.querySelector('#image-mode-content').classList.add('active');
                    // ...åŒæ—¶ç¡®ä¿â€œæ–‡å­—å›¾â€æ¨¡å¼æ˜¯éšè—çš„
                    modal.querySelector('#text-image-mode-content').classList.remove('active');

                    // 4. æ¢å¤ä¸»è¾“å…¥æ¡†çš„é»˜è®¤æç¤ºè¯­
                    modal.querySelector('#post-public-text').placeholder = 'åˆ†äº«æ–°é²œäº‹...ï¼ˆéå¿…å¡«çš„å…¬å¼€æ–‡å­—ï¼‰';

                    // 5. å‡†å¤‡å¹¶æ˜¾ç¤ºæ¨¡æ€æ¡†ï¼ˆä¸â€œè¯´è¯´â€æŒ‰é’®çš„é€»è¾‘ç›¸åŒï¼‰
                    const visibilityGroupsContainer = document.getElementById('post-visibility-groups');
                    visibilityGroupsContainer.innerHTML = '';
                    const groups = await db.qzoneGroups.toArray();
                    if (groups.length > 0) {
                        groups.forEach(group => {
                            const label = document.createElement('label');
                            label.style.display = 'block';
                            label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
                            visibilityGroupsContainer.appendChild(label);
                        });
                    } else {
                        visibilityGroupsContainer.innerHTML = '<p style="color: var(--text-secondary);">æ²¡æœ‰å¯ç”¨çš„åˆ†ç»„</p>';
                    }
                    modal.classList.add('visible');
                });
                document.getElementById('open-album-btn').addEventListener('click', async () => { await renderAlbumList(); showScreen('album-screen'); });
                document.getElementById('album-back-btn').addEventListener('click', () => { showScreen('chat-list-screen'); switchToChatListView('qzone-screen'); });

                // â–¼â–¼â–¼ ã€å…¨æ–°ã€‘QZoneæ·»åŠ æŒ‰é’®å’Œæ¨¡æ€æ¡†äº‹ä»¶å¤„ç† â–¼â–¼â–¼
                document.getElementById('qzone-add-post-btn').addEventListener('click', () => {
                    document.getElementById('qzone-add-options-modal').classList.add('visible');
                });

                document.getElementById('cancel-qzone-add-btn').addEventListener('click', () => {
                    document.getElementById('qzone-add-options-modal').classList.remove('visible');
                });

                // å¤ç”¨ç°æœ‰çš„äº‹ä»¶å¤„ç†å‡½æ•°
                document.getElementById('modal-create-shuoshuo-btn').addEventListener('click', async () => {
                    document.getElementById('qzone-add-options-modal').classList.remove('visible');
                    document.getElementById('create-shuoshuo-btn').click();
                });

                document.getElementById('modal-create-post-btn').addEventListener('click', async () => {
                    document.getElementById('qzone-add-options-modal').classList.remove('visible');
                    document.getElementById('create-post-btn').click();
                });

                document.getElementById('modal-open-album-btn').addEventListener('click', async () => {
                    document.getElementById('qzone-add-options-modal').classList.remove('visible');
                    document.getElementById('open-album-btn').click();
                });

                // --- â†“â†“â†“ ä»è¿™é‡Œå¼€å§‹å¤åˆ¶ â†“â†“â†“ ---

                document.getElementById('album-photos-back-btn').addEventListener('click', () => {
                    state.activeAlbumId = null;
                    showScreen('album-screen');
                });

                document.getElementById('album-upload-photo-btn').addEventListener('click', () => document.getElementById('album-photo-input').click());

                document.getElementById('album-photo-input').addEventListener('change', async (event) => {
                    if (!state.activeAlbumId) return;
                    const files = event.target.files;
                    if (!files.length) return;

                    const album = await db.qzoneAlbums.get(state.activeAlbumId);

                    for (const file of files) {
                        const dataUrl = await processImageUpload(file);
                        await db.qzonePhotos.add({ albumId: state.activeAlbumId, url: dataUrl, createdAt: Date.now() });
                    }

                    const photoCount = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).count();
                    const updateData = { photoCount };

                    if (!album.photoCount || album.coverUrl.includes('placeholder')) {
                        const firstPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
                        if (firstPhoto) updateData.coverUrl = firstPhoto.url;
                    }

                    await db.qzoneAlbums.update(state.activeAlbumId, updateData);
                    await renderAlbumPhotosScreen();
                    await renderAlbumList();

                    event.target.value = null;
                    alert('ç…§ç‰‡ä¸Šä¼ æˆåŠŸï¼');
                });

                // --- â†‘â†‘â†‘ å¤åˆ¶åˆ°è¿™é‡Œç»“æŸ â†‘â†‘â†‘ ---

                // --- â†“â†“â†“ ä»è¿™é‡Œå¼€å§‹å¤åˆ¶ï¼Œå®Œæ•´æ›¿æ¢æ‰æ—§çš„ photos-grid-page ç›‘å¬å™¨ â†“â†“â†“ ---

                document.getElementById('photos-grid-page').addEventListener('click', async (e) => {
                    const deleteBtn = e.target.closest('.photo-delete-btn');
                    const photoThumb = e.target.closest('.photo-thumb');

                    if (deleteBtn) {
                        e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡åˆ°å›¾ç‰‡ä¸Š
                        const photoId = parseInt(deleteBtn.dataset.photoId);
                        const confirmed = await showCustomConfirm(
                            'åˆ é™¤ç…§ç‰‡',
                            'ç¡®å®šè¦åˆ é™¤è¿™å¼ ç…§ç‰‡å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚',
                            { confirmButtonClass: 'btn-danger' }
                        );

                        if (confirmed) {
                            const deletedPhoto = await db.qzonePhotos.get(photoId);
                            if (!deletedPhoto) return;

                            await db.qzonePhotos.delete(photoId);

                            const album = await db.qzoneAlbums.get(state.activeAlbumId);
                            const photoCount = (album.photoCount || 1) - 1;
                            const updateData = { photoCount };

                            if (album.coverUrl === deletedPhoto.url) {
                                const nextPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
                                updateData.coverUrl = nextPhoto ? nextPhoto.url : 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
                            }

                            await db.qzoneAlbums.update(state.activeAlbumId, updateData);
                            await renderAlbumPhotosScreen();
                            await renderAlbumList();
                            alert('ç…§ç‰‡å·²åˆ é™¤ã€‚');
                        }
                    }
                    else if (photoThumb) {
                        // è¿™å°±æ˜¯æ¢å¤çš„å›¾ç‰‡ç‚¹å‡»æ”¾å¤§åŠŸèƒ½ï¼
                        openPhotoViewer(photoThumb.src);
                    }
                });

                // æ¢å¤å›¾ç‰‡æŸ¥çœ‹å™¨çš„æ§åˆ¶äº‹ä»¶
                document.getElementById('photo-viewer-close-btn').addEventListener('click', closePhotoViewer);
                document.getElementById('photo-viewer-next-btn').addEventListener('click', showNextPhoto);
                document.getElementById('photo-viewer-prev-btn').addEventListener('click', showPrevPhoto);

                // æ¢å¤é”®ç›˜å·¦å³ç®­å¤´å’ŒESCé”®çš„åŠŸèƒ½
                document.addEventListener('keydown', (e) => {
                    if (!photoViewerState.isOpen) return;

                    if (e.key === 'ArrowRight') {
                        showNextPhoto();
                    } else if (e.key === 'ArrowLeft') {
                        showPrevPhoto();
                    } else if (e.key === 'Escape') {
                        closePhotoViewer();
                    }
                });

                // --- â†‘â†‘â†‘ å¤åˆ¶åˆ°è¿™é‡Œç»“æŸ â†‘â†‘â†‘ ---

                document.getElementById('create-album-btn-page').addEventListener('click', async () => { const albumName = await showCustomPrompt("åˆ›å»ºæ–°ç›¸å†Œ", "è¯·è¾“å…¥ç›¸å†Œåç§°"); if (albumName && albumName.trim()) { const newAlbum = { name: albumName.trim(), coverUrl: 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png', photoCount: 0, createdAt: Date.now() }; await db.qzoneAlbums.add(newAlbum); await renderAlbumList(); alert(`ç›¸å†Œ "${albumName}" åˆ›å»ºæˆåŠŸï¼`); } else if (albumName !== null) { alert("ç›¸å†Œåç§°ä¸èƒ½ä¸ºç©ºï¼"); } });

                document.getElementById('cancel-create-post-btn').addEventListener('click', () => document.getElementById('create-post-modal').classList.remove('visible'));
                document.getElementById('post-upload-local-btn').addEventListener('click', () => document.getElementById('post-local-image-input').click());
                document.getElementById('post-local-image-input').addEventListener('change', (event) => { const file = event.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (e) => { document.getElementById('post-image-preview').src = e.target.result; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; }; reader.readAsDataURL(file); } });
                document.getElementById('post-use-url-btn').addEventListener('click', async () => { const url = await showCustomPrompt("è¾“å…¥å›¾ç‰‡URL", "è¯·è¾“å…¥ç½‘ç»œå›¾ç‰‡çš„é“¾æ¥", "", "url"); if (url) { document.getElementById('post-image-preview').src = url; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; } });
                document.getElementById('post-remove-image-btn').addEventListener('click', () => resetCreatePostModal());
                const imageModeBtn = document.getElementById('switch-to-image-mode');
                const textImageModeBtn = document.getElementById('switch-to-text-image-mode');
                const imageModeContent = document.getElementById('image-mode-content');
                const textImageModeContent = document.getElementById('text-image-mode-content');
                imageModeBtn.addEventListener('click', () => { imageModeBtn.classList.add('active'); textImageModeBtn.classList.remove('active'); imageModeContent.classList.add('active'); textImageModeContent.classList.remove('active'); });
                textImageModeBtn.addEventListener('click', () => { textImageModeBtn.classList.add('active'); imageModeBtn.classList.remove('active'); textImageModeContent.classList.add('active'); imageModeContent.classList.remove('active'); });

                // â–¼â–¼â–¼ ã€æœ€ç»ˆä¿®æ­£ç‰ˆã€‘çš„â€œå‘å¸ƒâ€æŒ‰é’®äº‹ä»¶ï¼Œå·²ä¿®å¤æƒé™æ¼æ´ â–¼â–¼â–¼
                document.getElementById('confirm-create-post-btn').addEventListener('click', async () => {
                    const modal = document.getElementById('create-post-modal');
                    const mode = modal.dataset.mode;

                    // --- 1. è·å–é€šç”¨çš„å¯è§æ€§è®¾ç½® ---
                    const visibilityMode = document.querySelector('input[name="visibility"]:checked').value;
                    let visibleGroupIds = null;

                    if (visibilityMode === 'include') {
                        visibleGroupIds = Array.from(document.querySelectorAll('input[name="visibility_group"]:checked')).map(cb => parseInt(cb.value));
                    }

                    let newPost = {};
                    const basePostData = {
                        timestamp: Date.now(),
                        authorId: 'user',
                        // ã€é‡è¦ã€‘åœ¨è¿™é‡Œå°±æŠŠæƒé™ä¿¡æ¯å­˜å¥½
                        visibleGroupIds: visibleGroupIds,
                        isPinned: false,
                    };

                    // --- 2. æ ¹æ®æ¨¡å¼æ„å»ºä¸åŒçš„ post å¯¹è±¡ ---
                    if (mode === 'shuoshuo') {
                        const content = document.getElementById('post-public-text').value.trim();
                        if (!content) {
                            alert('è¯´è¯´å†…å®¹ä¸èƒ½ä¸ºç©ºå“¦ï¼');
                            return;
                        }
                        newPost = {
                            ...basePostData,
                            type: 'shuoshuo',
                            content: content,
                        };

                    } else { // å¤„ç† 'complex' æ¨¡å¼ (å›¾ç‰‡/æ–‡å­—å›¾)
                        const publicText = document.getElementById('post-public-text').value.trim();
                        const isImageModeActive = document.getElementById('image-mode-content').classList.contains('active');

                        if (isImageModeActive) {
                            const imageUrl = document.getElementById('post-image-preview').src;
                            const imageDescription = document.getElementById('post-image-description').value.trim();
                            if (!imageUrl || !(imageUrl.startsWith('http') || imageUrl.startsWith('data:'))) {
                                alert('è¯·å…ˆæ·»åŠ ä¸€å¼ å›¾ç‰‡å†å‘å¸ƒåŠ¨æ€å“¦ï¼');
                                return;
                            }
                            if (!imageDescription) {
                                alert('è¯·ä¸ºä½ çš„å›¾ç‰‡æ·»åŠ ä¸€ä¸ªç®€å•çš„æè¿°ï¼ˆå¿…å¡«ï¼Œç»™AIçœ‹çš„ï¼‰ï¼');
                                return;
                            }
                            newPost = {
                                ...basePostData,
                                type: 'image_post',
                                publicText: publicText,
                                imageUrl: imageUrl,
                                imageDescription: imageDescription,
                            };
                        } else { // æ–‡å­—å›¾æ¨¡å¼
                            const hiddenText = document.getElementById('post-hidden-text').value.trim();
                            const decorativeImageUrl = document.getElementById('text-image-decorative-url').value.trim();
                            if (!hiddenText) {
                                alert('è¯·è¾“å…¥æ–‡å­—å›¾æè¿°ï¼');
                                return;
                            }
                            newPost = {
                                ...basePostData,
                                type: 'text_image',
                                publicText: publicText,
                                hiddenContent: hiddenText,
                                decorativeImageUrl: decorativeImageUrl || null, // IMPORTANT: This field is purely decorative and must never be sent to API
                            };
                        }
                    }

                    // --- 3. ä¿å­˜åˆ°æ•°æ®åº“ ---
                    const newPostId = await db.qzonePosts.add(newPost);
                    let postSummary = newPost.content || newPost.publicText || newPost.imageDescription || newPost.hiddenContent || "ï¼ˆæ— æ–‡å­—å†…å®¹ï¼‰";
                    postSummary = postSummary.substring(0, 50) + (postSummary.length > 50 ? '...' : '');

                    // --- 4. ã€æ ¸å¿ƒä¿®æ­£ã€‘å¸¦æœ‰æƒé™æ£€æŸ¥çš„é€šçŸ¥å¾ªç¯ ---
                    for (const chatId in state.chats) {
                        const chat = state.chats[chatId];
                        if (chat.isGroup) continue; // è·³è¿‡ç¾¤èŠ

                        let shouldNotify = false;
                        const postVisibleGroups = newPost.visibleGroupIds;

                        // åˆ¤æ–­æ¡ä»¶1ï¼šå¦‚æœåŠ¨æ€æ˜¯å…¬å¼€çš„ (æ²¡æœ‰è®¾ç½®ä»»ä½•å¯è§åˆ†ç»„)
                        if (!postVisibleGroups || postVisibleGroups.length === 0) {
                            shouldNotify = true;
                        }
                        // åˆ¤æ–­æ¡ä»¶2ï¼šå¦‚æœåŠ¨æ€è®¾ç½®äº†éƒ¨åˆ†å¯è§ï¼Œå¹¶ä¸”å½“å‰è§’è‰²åœ¨å¯è§åˆ†ç»„å†…
                        else if (chat.groupId && postVisibleGroups.includes(chat.groupId)) {
                            shouldNotify = true;
                        }

                        // åªæœ‰æ»¡è¶³æ¡ä»¶çš„è§’è‰²æ‰ä¼šè¢«é€šçŸ¥
                        if (shouldNotify) {
                            const historyMessage = {
                                role: 'system',
                                content: `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·åˆšåˆšå‘å¸ƒäº†ä¸€æ¡åŠ¨æ€(ID: ${newPostId})ï¼Œå†…å®¹æ‘˜è¦æ˜¯ï¼šâ€œ${postSummary}â€ã€‚ä½ ç°åœ¨å¯ä»¥å¯¹è¿™æ¡åŠ¨æ€è¿›è¡Œè¯„è®ºäº†ã€‚]`,
                                timestamp: Date.now(),
                                isHidden: true
                            };
                            chat.history.push(historyMessage);
                            await db.chats.put(chat);
                        }
                    }
                    // --- ä¿®æ­£ç»“æŸ ---

                    await renderQzonePosts();
                    modal.classList.remove('visible');
                    alert('åŠ¨æ€å‘å¸ƒæˆåŠŸï¼');
                });

                // â–¼â–¼â–¼ COMMENTED OUT: Swipe left to delete post functionality â–¼â–¼â–¼
                /*
                const postsList = document.getElementById('qzone-posts-list');
                let swipeState = { isDragging: false, startX: 0, startY: 0, currentX: 0, activeContainer: null, swipeDirection: null, isClick: true };

                function resetAllSwipes(exceptThisOne = null) {
                    document.querySelectorAll('.qzone-post-container').forEach(container => {
                        if (container !== exceptThisOne) {
                            container.querySelector('.qzone-post-item').classList.remove('swiped');
                        }
                    });
                }

                const handleSwipeStart = (e) => {
                    const targetContainer = e.target.closest('.qzone-post-container');
                    if (!targetContainer) return;

                    resetAllSwipes(targetContainer);
                    swipeState.activeContainer = targetContainer;
                    swipeState.isDragging = true;
                    swipeState.isClick = true;
                    swipeState.swipeDirection = null;
                    swipeState.startX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
                    swipeState.startY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
                    swipeState.activeContainer.querySelector('.qzone-post-item').style.transition = 'none';
                };

                const handleSwipeMove = (e) => {
                    if (!swipeState.isDragging || !swipeState.activeContainer) return;

                    const currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
                    const currentY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
                    const diffX = currentX - swipeState.startX;
                    const diffY = currentY - swipeState.startY;
                    const absDiffX = Math.abs(diffX);
                    const absDiffY = Math.abs(diffY);
                    const clickThreshold = 5;

                    if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
                        swipeState.isClick = false;
                    }

                    if (swipeState.swipeDirection === null) {
                        if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
                            if (absDiffX > absDiffY) {
                                swipeState.swipeDirection = 'horizontal';
                            } else {
                                swipeState.swipeDirection = 'vertical';
                            }
                        }
                    }
                    if (swipeState.swipeDirection === 'vertical') {
                        handleSwipeEnd(e);
                        return;
                    }
                    if (swipeState.swipeDirection === 'horizontal') {
                        e.preventDefault();
                        swipeState.currentX = currentX;
                        let translation = diffX;
                        if (translation > 0) translation = 0;
                        if (translation < -90) translation = -90;
                        swipeState.activeContainer.querySelector('.qzone-post-item').style.transform = `translateX(${translation}px)`;
                    }
                };

                const handleSwipeEnd = (e) => {
                    if (swipeState.isClick) {
                        swipeState.isDragging = false;
                        swipeState.activeContainer = null;
                        return;
                    }
                    if (!swipeState.isDragging || !swipeState.activeContainer) return;

                    const postItem = swipeState.activeContainer.querySelector('.qzone-post-item');
                    postItem.style.transition = 'transform 0.3s ease';

                    const finalX = e.type.includes('touchend') ? e.changedTouches[0].pageX : e.pageX;
                    const diffX = finalX - swipeState.startX;
                    const swipeThreshold = -40;

                    if (swipeState.swipeDirection === 'horizontal' && diffX < swipeThreshold) {
                        postItem.classList.add('swiped');
                        postItem.style.transform = '';
                    } else {
                        postItem.classList.remove('swiped');
                        postItem.style.transform = '';
                    }

                    swipeState.isDragging = false;
                    swipeState.startX = 0;
                    swipeState.startY = 0;
                    swipeState.currentX = 0;
                    swipeState.activeContainer = null;
                    swipeState.swipeDirection = null;
                    swipeState.isClick = true;
                };

                // --- ç»‘å®šæ‰€æœ‰æ»‘åŠ¨äº‹ä»¶ ---
                postsList.addEventListener('mousedown', handleSwipeStart);
                document.addEventListener('mousemove', handleSwipeMove);
                document.addEventListener('mouseup', handleSwipeEnd);
                postsList.addEventListener('touchstart', handleSwipeStart, { passive: false });
                postsList.addEventListener('touchmove', handleSwipeMove, { passive: false });
                postsList.addEventListener('touchend', handleSwipeEnd);
                */
                // â–²â–²â–² END COMMENTED OUT: Swipe left to delete post functionality â–²â–²â–²

                const postsList = document.getElementById('qzone-posts-list');

                // --- ç»‘å®šæ‰€æœ‰ç‚¹å‡»äº‹ä»¶ ---
                postsList.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const target = e.target;

                    const commentItem = target.closest('.comment-item');
                    if (commentItem) {
                        // Comment clicks are handled by long press, so we just return here
                        return;
                    }

                    if (target.classList.contains('post-actions-btn')) {
                        const container = target.closest('.qzone-post-container');
                        if (container && container.dataset.postId) {
                            showPostActions(parseInt(container.dataset.postId));
                        }
                        return;
                    }

                    // COMMENTED OUT: Delete action click handler for swipe functionality
                    /*
                    if (target.closest('.qzone-post-delete-action')) {
                        const container = target.closest('.qzone-post-container');
                        if (!container) return;

                        const postIdToDelete = parseInt(container.dataset.postId);
                        if (isNaN(postIdToDelete)) return;

                        const confirmed = await showCustomConfirm('åˆ é™¤åŠ¨æ€', 'ç¡®å®šè¦æ°¸ä¹…åˆ é™¤è¿™æ¡åŠ¨æ€å—ï¼Ÿ', { confirmButtonClass: 'btn-danger' });

                        if (confirmed) {
                            container.style.transition = 'all 0.3s ease';
                            container.style.transform = 'scale(0.8)';
                            container.style.opacity = '0';

                            setTimeout(async () => {
                                await db.qzonePosts.delete(postIdToDelete);

                                // åˆ é™¤æ‰€æœ‰èŠå¤©è®°å½•ä¸­å¼•ç”¨æ­¤åŠ¨æ€çš„ç³»ç»Ÿæ¶ˆæ¯
                                const allChats = await db.chats.toArray();
                                for (const chat of allChats) {
                                    const originalLength = chat.history.length;
                                    chat.history = chat.history.filter(msg => {
                                        // åˆ é™¤å¼•ç”¨æ­¤åŠ¨æ€IDçš„ç³»ç»Ÿæ¶ˆæ¯
                                        if (msg.role === 'system' && msg.isHidden && msg.content.includes(`(ID: ${postIdToDelete})`)) {
                                            return false;
                                        }
                                        return true;
                                    });
                                    
                                    // åªæœ‰åœ¨å†å²è®°å½•å‘ç”Ÿå˜åŒ–æ—¶æ‰æ›´æ–°æ•°æ®åº“
                                    if (chat.history.length !== originalLength) {
                                        await db.chats.put(chat);
                                        // æ›´æ–°å†…å­˜ä¸­çš„çŠ¶æ€
                                        if (state.chats[chat.id]) {
                                            state.chats[chat.id].history = chat.history;
                                        }
                                    }
                                }

                                await renderQzonePosts();
                                
                                // å¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹æŸä¸ªèŠå¤©ç•Œé¢ï¼Œåˆ·æ–°å®ƒ
                                if (state.activeChatId && document.getElementById('chat-interface-screen').classList.contains('active')) {
                                    renderChatInterface(state.activeChatId);
                                }
                                
                                alert('åŠ¨æ€å·²åˆ é™¤ã€‚');
                            }, 300);
                        }
                        return;
                    }
                    */

                    if ((target.tagName === 'IMG' || target.tagName === 'SPAN') && target.dataset.hiddenText) {
                        const hiddenText = target.dataset.hiddenText;
                        showCustomAlert("å›¾ç‰‡å†…å®¹", hiddenText.replace(/<br>/g, '\n'));
                        return;
                    }
                    const icon = target.closest('.action-icon');
                    if (icon) {
                        const postContainer = icon.closest('.qzone-post-container');
                        if (!postContainer) return;
                        const postId = parseInt(postContainer.dataset.postId);
                        if (isNaN(postId)) return;
                        if (icon.classList.contains('like')) {
                            const post = await db.qzonePosts.get(postId);
                            if (!post) return;
                            if (!post.likes) post.likes = [];
                            const userNickname = state.qzoneSettings.nickname;
                            const userLikeIndex = post.likes.indexOf(userNickname);
                            if (userLikeIndex > -1) {
                                post.likes.splice(userLikeIndex, 1);
                            } else {
                                post.likes.push(userNickname);
                                icon.classList.add('animate-like');
                                icon.addEventListener('animationend', () => icon.classList.remove('animate-like'), { once: true });
                            }
                            await db.qzonePosts.update(postId, { likes: post.likes });
                        }
                        if (icon.classList.contains('favorite')) {
                            const existingFavorite = await db.favorites.where({ type: 'qzone_post', 'content.id': postId }).first();
                            if (existingFavorite) {
                                await db.favorites.delete(existingFavorite.id);
                                await showCustomAlert('æç¤º', 'å·²å–æ¶ˆæ”¶è—');
                            } else {
                                const postToSave = await db.qzonePosts.get(postId);
                                if (postToSave) {
                                    await db.favorites.add({ type: 'qzone_post', content: postToSave, timestamp: Date.now() });
                                    await showCustomAlert('æç¤º', 'æ”¶è—æˆåŠŸï¼');
                                }
                            }
                        }
                        await renderQzonePosts();
                        return;
                    }
                    const sendBtn = target.closest('.comment-send-btn');
                    if (sendBtn) {
                        const postContainer = sendBtn.closest('.qzone-post-container');
                        if (!postContainer) return;
                        const postId = parseInt(postContainer.dataset.postId);
                        const commentInput = postContainer.querySelector('.comment-input');
                        const commentText = commentInput.value.trim();
                        if (!commentText) return alert('è¯„è®ºå†…å®¹ä¸èƒ½ä¸ºç©ºå“¦ï¼');
                        const post = await db.qzonePosts.get(postId);
                        if (!post) return;
                        if (!post.comments) post.comments = [];
                        const newComment = {
                            commenterName: state.qzoneSettings.nickname,
                            text: commentText,
                            timestamp: Date.now()
                        };
                        post.comments.push(newComment);
                        await db.qzonePosts.update(postId, { comments: post.comments });

                        // ã€æ ¸å¿ƒä¿®æ”¹ã€‘åœ¨è¿™é‡Œè§¦å‘AIå¯¹è¯„è®ºçš„å“åº”
                        // éå†æ‰€æœ‰éç¾¤èŠçš„AI
                        for (const chatId in state.chats) {
                            const chat = state.chats[chatId];
                            if (!chat.isGroup) {
                                // å¦‚æœæ˜¯åŠ¨æ€ä½œè€…ï¼Œç»™ä»–å‘é€ç‰¹æ®Šæç¤º
                                if (post.authorId === chatId) {
                                    chat.history.push({
                                        role: 'system',
                                        content: `[ç³»ç»Ÿæç¤ºï¼š'${state.qzoneSettings.nickname}' åˆšåˆšè¯„è®ºäº†ä½ çš„åŠ¨æ€ (ID: ${postId})ï¼šâ€œ${commentText}â€ã€‚è¯·ä½ å›å¤ã€‚]`,
                                        timestamp: Date.now(),
                                        isHidden: true
                                    });
                                }
                                // å¦‚æœä¸æ˜¯ä½œè€…ï¼Œä½†æœ‰æƒé™çœ‹åˆ°è¿™æ¡åŠ¨æ€ï¼Œä¹Ÿç»™ä»–å‘ä¸ªé€šçŸ¥
                                else {
                                    let isVisible = false;
                                    const visibleGroups = post.visibleGroupIds;
                                    if (!visibleGroups || visibleGroups.length === 0) {
                                        isVisible = true; // å…¬å¼€
                                    } else if (chat.groupId && visibleGroups.includes(chat.groupId)) {
                                        isVisible = true; // åœ¨æŒ‡å®šåˆ†ç»„å†…
                                    }
                                    if (isVisible) {
                                        chat.history.push({
                                            role: 'system',
                                            content: `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·'${state.qzoneSettings.nickname}' è¯„è®ºäº†åŠ¨æ€ (ID: ${postId})ã€‚]`,
                                            timestamp: Date.now(),
                                            isHidden: true
                                        });
                                    }
                                }
                                await db.chats.put(chat);
                            }
                        }

                        commentInput.value = '';
                        await renderQzonePosts();
                        return;
                    }

                    // å¤„ç†AIå›å¤æŒ‰é’®ç‚¹å‡»
                    const aiReplyBtn = target.closest('.call-ai-reply-btn');
                    if (aiReplyBtn) {
                        const postContainer = aiReplyBtn.closest('.qzone-post-container');
                        if (!postContainer) return;
                        const postId = parseInt(postContainer.dataset.postId);
                        showAiReplyModal(postId);
                        return;
                    }
                });


                // â–¼â–¼â–¼ åœ¨ init() å‡½æ•°çš„äº‹ä»¶ç›‘å¬å™¨åŒºåŸŸï¼Œç²˜è´´ä¸‹é¢è¿™ä¸¤è¡Œ â–¼â–¼â–¼

                // ç»‘å®šåŠ¨æ€é¡µå’Œæ”¶è—é¡µçš„è¿”å›æŒ‰é’®
                document.getElementById('qzone-back-btn').addEventListener('click', () => showScreen('home-screen'));
                document.getElementById('favorites-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));

                // â–²â–²â–² æ·»åŠ ç»“æŸ â–²â–²â–²

                // â–¼â–¼â–¼ åœ¨ init() å‡½æ•°çš„äº‹ä»¶ç›‘å¬å™¨åŒºåŸŸï¼Œæ£€æŸ¥å¹¶ç¡®ä¿ä½ æœ‰è¿™æ®µå®Œæ•´çš„ä»£ç  â–¼â–¼â–¼

                // æ”¶è—é¡µæœç´¢åŠŸèƒ½
                const searchInput = document.getElementById('favorites-search-input');
                const searchClearBtn = document.getElementById('favorites-search-clear-btn');

                searchInput.addEventListener('input', () => {
                    const searchTerm = searchInput.value.trim().toLowerCase();

                    // æ§åˆ¶æ¸…é™¤æŒ‰é’®çš„æ˜¾ç¤º/éšè—
                    searchClearBtn.style.display = searchTerm ? 'block' : 'none';

                    if (!searchTerm) {
                        displayFilteredFavorites(allFavoriteItems); // å¦‚æœæœç´¢æ¡†ä¸ºç©ºï¼Œæ˜¾ç¤ºæ‰€æœ‰
                        return;
                    }

                    // ç­›é€‰é€»è¾‘
                    const filteredItems = allFavoriteItems.filter(item => {
                        let contentToSearch = '';
                        let authorToSearch = '';

                        if (item.type === 'qzone_post') {
                            const post = item.content;
                            contentToSearch += (post.publicText || '') + ' ' + (post.content || '');
                            if (post.authorId === 'user') {
                                authorToSearch = state.qzoneSettings.nickname;
                            } else if (state.chats[post.authorId]) {
                                authorToSearch = state.chats[post.authorId].name;
                            }
                        } else if (item.type === 'chat_message') {
                            const msg = item.content;
                            if (typeof msg.content === 'string') {
                                contentToSearch = msg.content;
                            }
                            const chat = state.chats[item.chatId];
                            if (chat) {
                                if (msg.role === 'user') {
                                    authorToSearch = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';
                                } else {
                                    authorToSearch = chat.isGroup ? msg.senderName : chat.name;
                                }
                            }
                        }

                        // åŒæ—¶æœç´¢å†…å®¹å’Œä½œè€…ï¼Œå¹¶ä¸”ä¸åŒºåˆ†å¤§å°å†™
                        return contentToSearch.toLowerCase().includes(searchTerm) ||
                            authorToSearch.toLowerCase().includes(searchTerm);
                    });

                    displayFilteredFavorites(filteredItems);
                });

                // æ¸…é™¤æŒ‰é’®çš„ç‚¹å‡»äº‹ä»¶
                searchClearBtn.addEventListener('click', () => {
                    searchInput.value = '';
                    searchClearBtn.style.display = 'none';
                    displayFilteredFavorites(allFavoriteItems);
                    searchInput.focus();
                });

                // â–²â–²â–² ä»£ç æ£€æŸ¥ç»“æŸ â–²â–²â–²

                // â–¼â–¼â–¼ æ–°å¢/ä¿®æ”¹çš„äº‹ä»¶ç›‘å¬å™¨ â–¼â–¼â–¼

                // ä¸ºèŠå¤©ç•Œé¢çš„æ‰¹é‡æ”¶è—æŒ‰é’®ç»‘å®šäº‹ä»¶
                // ä¸ºèŠå¤©ç•Œé¢çš„æ‰¹é‡æ”¶è—æŒ‰é’®ç»‘å®šäº‹ä»¶ (å·²ä¿®æ­£)
                document.getElementById('selection-favorite-btn').addEventListener('click', async () => {
                    if (selectedMessages.size === 0) return;
                    const chat = state.chats[state.activeChatId];
                    if (!chat) return;

                    const favoritesToAdd = [];
                    const timestampsToFavorite = [...selectedMessages];

                    for (const timestamp of timestampsToFavorite) {
                        // ã€æ ¸å¿ƒä¿®æ­£1ã€‘ä½¿ç”¨æ–°çš„ã€é«˜æ•ˆçš„ç´¢å¼•è¿›è¡ŒæŸ¥è¯¢
                        const existing = await db.favorites.where('originalTimestamp').equals(timestamp).first();

                        if (!existing) {
                            const messageToSave = chat.history.find(msg => msg.timestamp === timestamp);
                            if (messageToSave) {
                                favoritesToAdd.push({
                                    type: 'chat_message',
                                    content: messageToSave,
                                    chatId: state.activeChatId,
                                    timestamp: Date.now(), // è¿™æ˜¯æ”¶è—æ“ä½œå‘ç”Ÿçš„æ—¶é—´
                                    originalTimestamp: messageToSave.timestamp // ã€æ ¸å¿ƒä¿®æ­£2ã€‘ä¿å­˜åŸå§‹æ¶ˆæ¯çš„æ—¶é—´æˆ³åˆ°æ–°å­—æ®µ
                                });
                            }
                        }
                    }

                    if (favoritesToAdd.length > 0) {
                        await db.favorites.bulkAdd(favoritesToAdd);
                        allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray(); // æ›´æ–°å…¨å±€æ”¶è—ç¼“å­˜
                        await showCustomAlert('æ”¶è—æˆåŠŸ', `å·²æˆåŠŸæ”¶è— ${favoritesToAdd.length} æ¡æ¶ˆæ¯ã€‚`);
                    } else {
                        await showCustomAlert('æç¤º', 'é€‰ä¸­çš„æ¶ˆæ¯å‡å·²æ”¶è—è¿‡ã€‚');
                    }

                    exitSelectionMode();
                });

                // æ”¶è—é¡µé¢çš„"ç¼–è¾‘"æŒ‰é’®äº‹ä»¶ (å·²ä¿®æ­£)
                const favoritesEditBtn = document.getElementById('favorites-edit-btn');
                const favoritesView = document.getElementById('favorites-view');
                const favoritesActionBar = document.getElementById('favorites-action-bar');
                const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // è·å–ä¸»å¯¼èˆªæ 
                const favoritesList = document.getElementById('favorites-list'); // è·å–æ”¶è—åˆ—è¡¨

                favoritesEditBtn.addEventListener('click', () => {
                    isFavoritesSelectionMode = !isFavoritesSelectionMode;
                    favoritesView.classList.toggle('selection-mode', isFavoritesSelectionMode);

                    if (isFavoritesSelectionMode) {
                        // --- è¿›å…¥ç¼–è¾‘æ¨¡å¼ ---
                        favoritesEditBtn.textContent = 'å®Œæˆ';
                        favoritesActionBar.style.display = 'block'; // æ˜¾ç¤ºåˆ é™¤æ“ä½œæ 
                        mainBottomNav.style.display = 'none'; // â–¼ æ–°å¢ï¼šéšè—ä¸»å¯¼èˆªæ 
                        favoritesList.style.paddingBottom = '80px'; // â–¼ æ–°å¢ï¼šç»™åˆ—è¡¨åº•éƒ¨å¢åŠ ç©ºé—´
                    } else {
                        // --- é€€å‡ºç¼–è¾‘æ¨¡å¼ ---
                        favoritesEditBtn.textContent = 'ç¼–è¾‘';
                        favoritesActionBar.style.display = 'none'; // éšè—åˆ é™¤æ“ä½œæ 
                        mainBottomNav.style.display = 'flex';  // â–¼ æ–°å¢ï¼šæ¢å¤ä¸»å¯¼èˆªæ 
                        favoritesList.style.paddingBottom = ''; // â–¼ æ–°å¢ï¼šæ¢å¤åˆ—è¡¨é»˜è®¤padding

                        // é€€å‡ºæ—¶æ¸…ç©ºæ‰€æœ‰é€‰æ‹©
                        selectedFavorites.clear();
                        document.querySelectorAll('.favorite-item-card.selected').forEach(card => card.classList.remove('selected'));
                        document.getElementById('favorites-delete-selected-btn').textContent = `åˆ é™¤ (0)`;
                    }
                });

                // â–¼â–¼â–¼ å°†å®ƒã€å®Œæ•´æ›¿æ¢ã€‘ä¸ºä¸‹é¢è¿™æ®µä¿®æ­£åçš„ä»£ç  â–¼â–¼â–¼
                // æ”¶è—åˆ—è¡¨çš„ç‚¹å‡»é€‰æ‹©äº‹ä»¶ (äº‹ä»¶å§”æ‰˜)
                document.getElementById('favorites-list').addEventListener('click', (e) => {
                    const target = e.target;
                    const card = target.closest('.favorite-item-card');

                    // ã€æ–°å¢ã€‘å¤„ç†æ–‡å­—å›¾ç‚¹å‡»ï¼Œè¿™æ®µé€»è¾‘è¦æ”¾åœ¨æœ€å‰é¢ï¼Œä¿è¯ä»»ä½•æ¨¡å¼ä¸‹éƒ½ç”Ÿæ•ˆ
                    if ((target.tagName === 'IMG' || target.tagName === 'SPAN') && target.dataset.hiddenText) {
                        const hiddenText = target.dataset.hiddenText;
                        showCustomAlert("å›¾ç‰‡å†…å®¹", hiddenText.replace(/<br>/g, '\n'));
                        return; // å¤„ç†å®Œå°±é€€å‡ºï¼Œä¸ç»§ç»­æ‰§è¡Œé€‰æ‹©é€»è¾‘
                    }

                    // å¦‚æœä¸åœ¨é€‰æ‹©æ¨¡å¼ï¼Œåˆ™ä¸æ‰§è¡Œåç»­çš„é€‰æ‹©æ“ä½œ
                    if (!isFavoritesSelectionMode) return;

                    // --- ä»¥ä¸‹æ˜¯åŸæœ‰çš„é€‰æ‹©é€»è¾‘ï¼Œä¿æŒä¸å˜ ---
                    if (!card) return;

                    const favId = parseInt(card.dataset.favid);
                    if (isNaN(favId)) return;

                    // åˆ‡æ¢é€‰æ‹©çŠ¶æ€
                    if (selectedFavorites.has(favId)) {
                        selectedFavorites.delete(favId);
                        card.classList.remove('selected');
                    } else {
                        selectedFavorites.add(favId);
                        card.classList.add('selected');
                    }

                    // æ›´æ–°åº•éƒ¨åˆ é™¤æŒ‰é’®çš„è®¡æ•°
                    document.getElementById('favorites-delete-selected-btn').textContent = `åˆ é™¤ (${selectedFavorites.size})`;
                });

                // â–¼â–¼â–¼ å°†å®ƒã€å®Œæ•´æ›¿æ¢ã€‘ä¸ºä¸‹é¢è¿™æ®µä¿®æ­£åçš„ä»£ç  â–¼â–¼â–¼
                // æ”¶è—é¡µé¢æ‰¹é‡åˆ é™¤æŒ‰é’®äº‹ä»¶
                document.getElementById('favorites-delete-selected-btn').addEventListener('click', async () => {
                    if (selectedFavorites.size === 0) return;

                    const confirmed = await showCustomConfirm(
                        'ç¡®è®¤åˆ é™¤',
                        `ç¡®å®šè¦ä»æ”¶è—å¤¹ä¸­ç§»é™¤è¿™ ${selectedFavorites.size} æ¡å†…å®¹å—ï¼Ÿ`,
                        { confirmButtonClass: 'btn-danger' }
                    );

                    if (confirmed) {
                        const idsToDelete = [...selectedFavorites];
                        await db.favorites.bulkDelete(idsToDelete);
                        await showCustomAlert('åˆ é™¤æˆåŠŸ', 'é€‰ä¸­çš„æ”¶è—å·²è¢«ç§»é™¤ã€‚');

                        // ã€æ ¸å¿ƒä¿®æ­£1ã€‘ä»å‰ç«¯ç¼“å­˜ä¸­ä¹Ÿç§»é™¤è¢«åˆ é™¤çš„é¡¹
                        allFavoriteItems = allFavoriteItems.filter(item => !idsToDelete.includes(item.id));

                        // ã€æ ¸å¿ƒä¿®æ­£2ã€‘ä½¿ç”¨æ›´æ–°åçš„ç¼“å­˜ï¼Œç«‹å³é‡æ–°æ¸²æŸ“åˆ—è¡¨
                        displayFilteredFavorites(allFavoriteItems);

                        // æœ€åï¼Œå†é€€å‡ºç¼–è¾‘æ¨¡å¼
                        favoritesEditBtn.click(); // æ¨¡æ‹Ÿç‚¹å‡»"å®Œæˆ"æŒ‰é’®æ¥é€€å‡ºç¼–è¾‘æ¨¡å¼
                    }
                });

                // â–¼â–¼â–¼ åœ¨ init() å‡½æ•°æœ«å°¾æ·»åŠ  â–¼â–¼â–¼
                if (state.globalSettings.enableBackgroundActivity) {
                    startBackgroundSimulation();
                    console.log("åå°æ´»åŠ¨æ¨¡æ‹Ÿå·²è‡ªåŠ¨å¯åŠ¨ã€‚");
                }
                // â–²â–²â–² æ·»åŠ ç»“æŸ â–²â–²â–²

                // â–¼â–¼â–¼ ã€è¿™æ˜¯æœ€ç»ˆçš„æ­£ç¡®ä»£ç ã€‘è¯·ç²˜è´´è¿™æ®µä»£ç åˆ° init() çš„äº‹ä»¶ç›‘å¬å™¨åŒºåŸŸæœ«å°¾ â–¼â–¼â–¼

                // --- ç»Ÿä¸€å¤„ç†æ‰€æœ‰å½±å“é¢„è§ˆçš„æ§ä»¶çš„äº‹ä»¶ ---

                // 1. ç›‘å¬ä¸»é¢˜é€‰æ‹©
                document.querySelectorAll('input[name="theme-select"]').forEach(radio => {
                    radio.addEventListener('change', updateSettingsPreview);
                });

                // 2. ç›‘å¬å­—ä½“å¤§å°æ»‘å—
                const fontSizeSlider = document.getElementById('font-size-slider');
                fontSizeSlider.addEventListener('input', () => {
                    // a. å®æ—¶æ›´æ–°æ•°å€¼æ˜¾ç¤º
                    document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
                    // b. æ›´æ–°é¢„è§ˆ
                    updateSettingsPreview();
                });

                // 3. ç›‘å¬è‡ªå®šä¹‰CSSè¾“å…¥æ¡†
                const customCssInputForPreview = document.getElementById('custom-css-input');
                customCssInputForPreview.addEventListener('input', updateSettingsPreview);

                // 4. ç›‘å¬é‡ç½®æŒ‰é’®
                document.getElementById('reset-theme-btn').addEventListener('click', () => {
                    document.getElementById('theme-default').checked = true;
                    updateSettingsPreview();
                });

                document.getElementById('reset-custom-css-btn').addEventListener('click', () => {
                    document.getElementById('custom-css-input').value = '';
                    updateSettingsPreview();
                });

                // â–²â–²â–² ç²˜è´´ç»“æŸ â–²â–²â–²

                // â–¼â–¼â–¼ è¯·å°†è¿™æ®µã€æ–°ä»£ç ã€‘ç²˜è´´åˆ° init() çš„äº‹ä»¶ç›‘å¬å™¨åŒºåŸŸæœ«å°¾ â–¼â–¼â–¼
                document.querySelectorAll('input[name="visibility"]').forEach(radio => {
                    radio.addEventListener('change', function () {
                        const groupsContainer = document.getElementById('post-visibility-groups');
                        if (this.value === 'include' || this.value === 'exclude') {
                            groupsContainer.style.display = 'block';
                        } else {
                            groupsContainer.style.display = 'none';
                        }
                    });
                });
                // â–²â–²â–² æ–°ä»£ç ç²˜è´´ç»“æŸ â–²â–²â–²

                // â–¼â–¼â–¼ è¯·å°†è¿™æ®µã€æ–°ä»£ç ã€‘ç²˜è´´åˆ° init() çš„äº‹ä»¶ç›‘å¬å™¨åŒºåŸŸæœ«å°¾ â–¼â–¼â–¼
                document.getElementById('manage-groups-btn').addEventListener('click', openGroupManager);
                document.getElementById('close-group-manager-btn').addEventListener('click', () => {
                    document.getElementById('group-management-modal').classList.remove('visible');
                    // åˆ·æ–°èŠå¤©è®¾ç½®é‡Œçš„åˆ†ç»„åˆ—è¡¨
                    const chatSettingsBtn = document.getElementById('chat-settings-btn');
                    if (document.getElementById('chat-settings-modal').classList.contains('visible')) {
                        chatSettingsBtn.click(); // å†æ¬¡ç‚¹å‡»ä»¥é‡æ–°æ‰“å¼€
                    }
                });

                document.getElementById('add-new-group-btn').addEventListener('click', addNewGroup);
                document.getElementById('existing-groups-list').addEventListener('click', (e) => {
                    if (e.target.classList.contains('delete-group-btn')) {
                        const groupId = parseInt(e.target.dataset.id);
                        deleteGroup(groupId);
                    }
                });
                // â–²â–²â–² æ–°ä»£ç ç²˜è´´ç»“æŸ â–²â–²â–²

                // â–¼â–¼â–¼ è¯·å°†è¿™æ®µã€æ–°ä»£ç ã€‘ç²˜è´´åˆ° init() çš„äº‹ä»¶ç›‘å¬å™¨åŒºåŸŸæœ«å°¾ â–¼â–¼â–¼
                // æ¶ˆæ¯æ“ä½œèœå•çš„æŒ‰é’®äº‹ä»¶
                document.getElementById('cancel-message-action-btn').addEventListener('click', hideMessageActions);
                document.getElementById('quote-message-btn').addEventListener('click', startReplyToMessage);
                document.getElementById('recall-message-btn').addEventListener('click', handleRecallClick);

                // Chat actions event handlers
                document.getElementById('cancel-chat-action-btn').addEventListener('click', hideChatActions);
                document.getElementById('pin-chat-btn').addEventListener('click', async () => {
                    if (!activeChatId) return;
                    const chat = state.chats[activeChatId];
                    if (!chat) return;

                    chat.isPinned = true;
                    await db.chats.put(chat);
                    renderChatList();
                    hideChatActions();
                });
                document.getElementById('unpin-chat-btn').addEventListener('click', async () => {
                    if (!activeChatId) return;
                    const chat = state.chats[activeChatId];
                    if (!chat) return;

                    chat.isPinned = false;
                    await db.chats.put(chat);
                    renderChatList();
                    hideChatActions();
                });
                document.getElementById('delete-chat-btn').addEventListener('click', async () => {
                    if (!activeChatId) return;
                    const chat = state.chats[activeChatId];
                    if (!chat) return;

                    hideChatActions();
                    const confirmed = await showCustomConfirm('åˆ é™¤å¯¹è¯', `ç¡®å®šè¦åˆ é™¤ä¸ "${chat.name}" çš„æ•´ä¸ªå¯¹è¯å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`, { confirmButtonClass: 'btn-danger' });
                    if (confirmed) {
                        if (musicState.isActive && musicState.activeChatId === chat.id) await endListenTogetherSession(false);
                        delete state.chats[chat.id];
                        if (state.activeChatId === chat.id) state.activeChatId = null;
                        await db.chats.delete(chat.id);
                        renderChatList();
                    }
                });
                // ç»‘å®šå›å¤é¢„è§ˆæ ä¸­çš„"å–æ¶ˆ"æŒ‰é’®
                document.getElementById('cancel-reply-btn').addEventListener('click', cancelReplyMode);
                // â–¼â–¼â–¼ ã€ä¿®æ­£ã€‘ä½¿ç”¨æ–°çš„ç¼–è¾‘å™¨å…¥å£ â–¼â–¼â–¼
                document.getElementById('edit-message-btn').addEventListener('click', () => {
                    // Check if we're in meetup screen
                    const isInMeetup = document.getElementById('meetup-screen').classList.contains('active');

                    if (isInMeetup) {
                        // Use date mode edit
                        const timestampToEdit = activeMessageTimestamp;
                        editMeetupMessage(timestampToEdit);
                    } else {
                        // Check if it's a location message
                        const chat = state.chats[state.activeChatId];
                        const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);

                        if (message && message.type === 'location_share') {
                            editLocationMessage(activeMessageTimestamp);
                        } else {
                            // Use regular chat edit
                            openAdvancedMessageEditor();
                        }
                    }
                });
                // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

                // â–¼â–¼â–¼ è¯·ç”¨è¿™æ®µã€ä¿®æ­£åã€‘çš„ä»£ç æ›¿æ¢æ—§çš„ select-message-btn äº‹ä»¶ç›‘å¬å™¨ â–¼â–¼â–¼
                document.getElementById('select-message-btn').addEventListener('click', () => {
                    // ã€æ ¸å¿ƒä¿®å¤ã€‘åœ¨å…³é—­èœå•å‰ï¼Œå…ˆæ•è·æ—¶é—´æˆ³
                    const timestampToSelect = activeMessageTimestamp;
                    hideMessageActions();

                    // Check if we're in meetup screen
                    const isInMeetup = document.getElementById('meetup-screen').classList.contains('active');

                    if (timestampToSelect) {
                        if (isInMeetup) {
                            // Use meetup selection
                            enterMeetupSelectionMode(timestampToSelect);
                        } else {
                            // Use regular chat selection
                            enterSelectionMode(timestampToSelect);
                        }
                    }
                });
                // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

                // â–¼â–¼â–¼ åœ¨ init() å‡½æ•°çš„äº‹ä»¶ç›‘å¬å™¨åŒºåŸŸæœ«å°¾æ·»åŠ  â–¼â–¼â–¼

                // åŠ¨æ€æ“ä½œèœå•çš„æŒ‰é’®äº‹ä»¶
                document.getElementById('pin-post-btn').addEventListener('click', pinPost);
                document.getElementById('unpin-post-btn').addEventListener('click', unpinPost);
                document.getElementById('edit-post-btn').addEventListener('click', openPostEditor);
                document.getElementById('copy-post-btn').addEventListener('click', copyPostContent);
                document.getElementById('delete-post-btn').addEventListener('click', deletePost);
                document.getElementById('cancel-post-action-btn').addEventListener('click', hidePostActions);

                // è¯„è®ºæ“ä½œèœå•çš„æŒ‰é’®äº‹ä»¶
                document.getElementById('edit-comment-btn').addEventListener('click', editComment);
                document.getElementById('delete-comment-btn').addEventListener('click', deleteComment);
                document.getElementById('cancel-comment-action-btn').addEventListener('click', hideCommentActions);

                // AIå›å¤æ¨¡æ€æ¡†çš„æŒ‰é’®äº‹ä»¶
                document.getElementById('close-ai-reply-modal').addEventListener('click', hideAiReplyModal);
                document.getElementById('cancel-ai-reply').addEventListener('click', hideAiReplyModal);
                document.getElementById('confirm-ai-reply').addEventListener('click', confirmAiReply);
                document.getElementById('select-all-ais').addEventListener('click', selectAllAis);
                document.getElementById('deselect-all-ais').addEventListener('click', deselectAllAis);

                // AIå‘åŠ¨æ€æ¨¡æ€æ¡†çš„æŒ‰é’®äº‹ä»¶
                document.getElementById('close-ai-post-modal').addEventListener('click', hideAiPostModal);
                document.getElementById('cancel-ai-post').addEventListener('click', hideAiPostModal);
                document.getElementById('confirm-ai-post').addEventListener('click', confirmAiPost);
                document.getElementById('ai-post-btn').addEventListener('click', showAiPostModal);

                // AIè®°å½•å›å¿†æ¨¡æ€æ¡†çš„æŒ‰é’®äº‹ä»¶
                document.getElementById('close-ai-memory-modal').addEventListener('click', hideAiMemoryModal);
                document.getElementById('cancel-ai-memory').addEventListener('click', hideAiMemoryModal);
                document.getElementById('confirm-ai-memory').addEventListener('click', confirmAiMemory);

                // ç§»åŠ¨è¡¨æƒ…åŒ…æ¨¡æ€æ¡†çš„æŒ‰é’®äº‹ä»¶
                document.getElementById('close-move-sticker-modal').addEventListener('click', hideMoveStickerModal);
                document.getElementById('cancel-move-sticker').addEventListener('click', hideMoveStickerModal);
                document.getElementById('confirm-move-sticker').addEventListener('click', confirmMoveSticker);

                // â–²â–²â–² æ·»åŠ ç»“æŸ â–²â–²â–²

                // â–¼â–¼â–¼ ã€æ–°å¢ã€‘è”ç³»äººé€‰æ‹©å™¨äº‹ä»¶ç»‘å®š â–¼â–¼â–¼
                document.getElementById('cancel-contact-picker-btn').addEventListener('click', () => {
                    showScreen('chat-list-screen');
                });

                document.getElementById('contact-picker-list').addEventListener('click', (e) => {
                    const item = e.target.closest('.contact-picker-item');
                    if (!item) return;

                    const contactId = item.dataset.contactId;
                    item.classList.toggle('selected');

                    if (selectedContacts.has(contactId)) {
                        selectedContacts.delete(contactId);
                    } else {
                        selectedContacts.add(contactId);
                    }
                    updateContactPickerConfirmButton();
                });

                // â–¼â–¼â–¼ ã€æ–°å¢ã€‘ç»‘å®šâ€œç®¡ç†ç¾¤æˆå‘˜â€æŒ‰é’®äº‹ä»¶ â–¼â–¼â–¼
                document.getElementById('manage-members-btn').addEventListener('click', () => {
                    // åœ¨åˆ‡æ¢å±å¹•å‰ï¼Œå…ˆéšè—å½“å‰çš„èŠå¤©è®¾ç½®å¼¹çª—
                    document.getElementById('chat-settings-modal').classList.remove('visible');
                    // ç„¶åå†æ‰“å¼€æˆå‘˜ç®¡ç†å±å¹•
                    openMemberManagementScreen();
                });
                // â–²â–²â–² æ–°å¢ä»£ç ç»“æŸ â–²â–²â–²

                // â–¼â–¼â–¼ ã€æœ€ç»ˆå®Œæ•´ç‰ˆã€‘ç¾¤æˆå‘˜ç®¡ç†åŠŸèƒ½äº‹ä»¶ç»‘å®š â–¼â–¼â–¼
                document.getElementById('back-from-member-management').addEventListener('click', () => {

                    showScreen('chat-interface-screen');
                    document.getElementById('chat-settings-btn').click();
                });
                // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

                document.getElementById('member-management-list').addEventListener('click', (e) => {
                    // ã€å·²æ¢å¤ã€‘ç§»é™¤æˆå‘˜çš„äº‹ä»¶
                    if (e.target.classList.contains('remove-member-btn')) {
                        removeMemberFromGroup(e.target.dataset.memberId);
                    }
                });

                document.getElementById('add-existing-contact-btn').addEventListener('click', async () => {
                    // ã€å·²æ¢å¤ã€‘ä»å¥½å‹åˆ—è¡¨æ·»åŠ çš„äº‹ä»¶
                    // ã€å…³é”®ã€‘ä¸ºâ€œå®Œæˆâ€æŒ‰é’®ç»‘å®šâ€œæ‹‰äººå…¥ç¾¤â€çš„é€»è¾‘
                    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
                    // ä½¿ç”¨å…‹éš†èŠ‚ç‚¹æ–¹æ³•æ¸…é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨ï¼Œé˜²æ­¢é‡å¤ç»‘å®š
                    const newConfirmBtn = confirmBtn.cloneNode(true);
                    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
                    newConfirmBtn.addEventListener('click', handleAddMembersToGroup);

                    await openContactPickerForAddMember();
                });

                document.getElementById('create-new-member-btn').addEventListener('click', createNewMemberInGroup);
                // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

                // â–¼â–¼â–¼ ã€å…¨æ–°ã€‘è§†é¢‘é€šè¯åŠŸèƒ½äº‹ä»¶ç›‘å¬å™¨ â–¼â–¼â–¼

                // ç»‘å®šå•èŠå’Œç¾¤èŠçš„å‘èµ·æŒ‰é’®
                document.getElementById('video-call-btn').addEventListener('click', handleInitiateCall);
                document.getElementById('group-video-call-btn').addEventListener('click', handleInitiateCall);

                // ç»‘å®šâ€œæŒ‚æ–­â€æŒ‰é’®
                document.getElementById('hang-up-btn').addEventListener('click', endVideoCall);

                // ç»‘å®šâ€œå–æ¶ˆå‘¼å«â€æŒ‰é’®
                document.getElementById('cancel-call-btn').addEventListener('click', () => {
                    videoCallState.isAwaitingResponse = false;
                    showScreen('chat-interface-screen');
                });

                // ã€å…¨æ–°ã€‘ç»‘å®šâ€œåŠ å…¥é€šè¯â€æŒ‰é’®
                document.getElementById('join-call-btn').addEventListener('click', handleUserJoinCall);

                // â–¼â–¼â–¼ ç”¨è¿™ä¸ªã€å·²ä¿®å¤å¹¶æ¿€æ´»æ—è§‚æ¨¡å¼ã€‘çš„ç‰ˆæœ¬æ›¿æ¢æ—§çš„ decline-call-btn äº‹ä»¶ç›‘å¬å™¨ â–¼â–¼â–¼
                // ç»‘å®šæ¥ç”µè¯·æ±‚çš„â€œæ‹’ç»â€æŒ‰é’®
                document.getElementById('decline-call-btn').addEventListener('click', async () => {
                    hideIncomingCallModal();
                    const chat = state.chats[videoCallState.activeChatId];
                    if (!chat) return;

                    // ã€æ ¸å¿ƒä¿®æ­£ã€‘åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†æ‹’ç»çš„é€»è¾‘ä¸APIè°ƒç”¨è¿æ¥èµ·æ¥
                    if (videoCallState.isGroupCall) {
                        videoCallState.isUserParticipating = false; // æ ‡è®°ç”¨æˆ·ä¸ºæ—è§‚è€…

                        // 1. åˆ›å»ºä¸€æ¡éšè—æ¶ˆæ¯ï¼Œé€šçŸ¥AIç”¨æˆ·æ‹’ç»äº†
                        const systemNote = {
                            role: 'system',
                            content: `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·æ‹’ç»äº†é€šè¯é‚€è¯·ï¼Œä½†ä½ ä»¬å¯ä»¥è‡ªå·±å¼€å§‹ã€‚è¯·ä½ ä»¬å„è‡ªå†³ç­–æ˜¯å¦åŠ å…¥ã€‚]`,
                            timestamp: Date.now(),
                            isHidden: true
                        };
                        chat.history.push(systemNote);
                        await db.chats.put(chat);

                        // 2. ã€å…³é”®ã€‘è§¦å‘AIå“åº”ï¼Œè®©å®ƒä»¬è‡ªå·±å†³å®šè¦ä¸è¦å¼€å§‹ç¾¤èŠ
                        // è¿™å°†ä¼šåœ¨åå°å¤„ç†ï¼Œå¦‚æœAIä»¬å†³å®šå¼€å§‹ï¼Œæœ€ç»ˆä¼šè°ƒç”¨ startVideoCall()
                        await triggerAiResponse();

                    } else { // å•èŠæ‹’ç»é€»è¾‘ä¿æŒä¸å˜
                        const declineMessage = { role: 'user', content: 'æˆ‘æ‹’ç»äº†ä½ çš„è§†é¢‘é€šè¯è¯·æ±‚ã€‚', timestamp: Date.now() };
                        chat.history.push(declineMessage);
                        await db.chats.put(chat);

                        // å›åˆ°èŠå¤©ç•Œé¢å¹¶æ˜¾ç¤ºæ‹’ç»æ¶ˆæ¯
                        showScreen('chat-interface-screen');
                        appendMessage(declineMessage, chat);

                        // è®©AIå¯¹ä½ çš„æ‹’ç»åšå‡ºå›åº”
                        triggerAiResponse();
                    }

                    // æ¸…ç†çŠ¶æ€ï¼Œä»¥é˜²ä¸‡ä¸€
                    videoCallState.isAwaitingResponse = false;
                });
                // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

                // â–¼â–¼â–¼ ç”¨è¿™ä¸ªã€å·²ä¿®å¤é‡å¤å¤´åƒBUGã€‘çš„ç‰ˆæœ¬æ›¿æ¢æ—§çš„ accept-call-btn äº‹ä»¶ç›‘å¬å™¨ â–¼â–¼â–¼
                // ç»‘å®šæ¥ç”µè¯·æ±‚çš„â€œæ¥å¬â€æŒ‰é’®
                document.getElementById('accept-call-btn').addEventListener('click', async () => {
                    hideIncomingCallModal();

                    videoCallState.initiator = 'ai';
                    videoCallState.isUserParticipating = true;
                    videoCallState.activeChatId = state.activeChatId;

                    // ã€æ ¸å¿ƒä¿®æ­£ã€‘æˆ‘ä»¬åœ¨è¿™é‡Œä¸å†æ‰‹åŠ¨æ·»åŠ ç”¨æˆ·åˆ° participants åˆ—è¡¨
                    if (videoCallState.isGroupCall) {
                        // å¯¹äºç¾¤èŠï¼Œæˆ‘ä»¬åªæŠŠã€å‘èµ·é€šè¯çš„AIã€‘åŠ å…¥å‚ä¸è€…åˆ—è¡¨
                        const chat = state.chats[videoCallState.activeChatId];
                        const requester = chat.members.find(m => m.name === videoCallState.callRequester);
                        if (requester) {
                            // æ¸…ç©ºå¯èƒ½å­˜åœ¨çš„æ—§æ•°æ®ï¼Œç„¶ååªæ·»åŠ å‘èµ·è€…
                            videoCallState.participants = [requester];
                        } else {
                            videoCallState.participants = []; // å¦‚æœæ‰¾ä¸åˆ°å‘èµ·è€…ï¼Œå°±æ¸…ç©º
                        }
                    }

                    // æ— è®ºå•èŠè¿˜æ˜¯ç¾¤èŠï¼Œç›´æ¥å¯åŠ¨é€šè¯ç•Œé¢ï¼
                    startVideoCall();
                });
                // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²


                // â–¼â–¼â–¼ è¯·ç”¨è¿™ä¸ªã€å·²å¢åŠ ç”¨æˆ·é«˜äº®ã€‘çš„å…¨æ–°ç‰ˆæœ¬ï¼Œå®Œæ•´æ›¿æ¢æ—§çš„ user-speak-btn äº‹ä»¶ç›‘å¬å™¨ â–¼â–¼â–¼
                // ç»‘å®šç”¨æˆ·åœ¨é€šè¯ä¸­å‘è¨€çš„æŒ‰é’®
                document.getElementById('user-speak-btn').addEventListener('click', async () => {
                    if (!videoCallState.isActive) return;

                    // â˜…â˜…â˜…â˜…â˜… æ ¸å¿ƒæ–°å¢ï¼šåœ¨å¼¹å‡ºè¾“å…¥æ¡†å‰ï¼Œå…ˆæ‰¾åˆ°å¹¶é«˜äº®ç”¨æˆ·å¤´åƒ â˜…â˜…â˜…â˜…â˜…
                    const userAvatar = document.querySelector('.participant-avatar-wrapper[data-participant-id="user"] .participant-avatar');
                    if (userAvatar) {
                        userAvatar.classList.add('speaking');
                    }

                    const userInput = await showCustomPrompt('ä½ è¯´', 'è¯·è¾“å…¥ä½ æƒ³è¯´çš„è¯...');

                    // â˜…â˜…â˜…â˜…â˜… æ ¸å¿ƒæ–°å¢ï¼šæ— è®ºç”¨æˆ·æ˜¯å¦è¾“å…¥ï¼Œåªè¦å…³é—­è¾“å…¥æ¡†å°±ç§»é™¤é«˜äº® â˜…â˜…â˜…â˜…â˜…
                    if (userAvatar) {
                        userAvatar.classList.remove('speaking');
                    }

                    if (userInput && userInput.trim()) {
                        triggerAiInCallAction(userInput.trim());
                    }
                });
                // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

                // â–¼â–¼â–¼ ã€æ–°å¢ã€‘å›å¿†å½•ç›¸å…³äº‹ä»¶ç»‘å®š â–¼â–¼â–¼
                // 1. å°†â€œå›å¿†â€é¡µç­¾å’Œå®ƒçš„è§†å›¾è¿æ¥èµ·æ¥
                document.querySelector('.nav-item[data-view="memories-view"]').addEventListener('click', () => {
                    // åœ¨åˆ‡æ¢å‰ï¼Œç¡®ä¿"æ”¶è—"é¡µé¢çš„ç¼–è¾‘æ¨¡å¼å·²å…³é—­
                    if (isFavoritesSelectionMode) {
                        document.getElementById('favorites-edit-btn').click();
                    }
                    switchToChatListView('memories-view');
                    renderMemoriesScreen(); // ç‚¹å‡»æ—¶æ¸²æŸ“
                });

                // 2. ç»‘å®šå›å¿†å½•ç•Œé¢çš„è¿”å›æŒ‰é’®
                document.getElementById('memories-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));

                // â–²â–²â–² æ–°å¢ç»“æŸ â–²â–²â–²

                // ã€å…¨æ–°ã€‘çº¦å®š/å€’è®¡æ—¶åŠŸèƒ½äº‹ä»¶ç»‘å®š - ä¿®æ”¹ä¸ºé€‰æ‹©æ¨¡æ€æ¡†
                document.getElementById('add-countdown-btn').addEventListener('click', () => {
                    document.getElementById('add-memory-type-modal').classList.add('visible');
                });
                document.getElementById('cancel-create-countdown-btn').addEventListener('click', () => {
                    document.getElementById('create-countdown-modal').classList.remove('visible');
                });
                document.getElementById('confirm-create-countdown-btn').addEventListener('click', async () => {
                    const title = document.getElementById('countdown-title-input').value.trim();
                    const dateValue = document.getElementById('countdown-date-input').value;

                    if (!title || !dateValue) {
                        alert('è¯·å¡«å†™å®Œæ•´çš„çº¦å®šæ ‡é¢˜å’Œæ—¥æœŸï¼');
                        return;
                    }

                    const targetDate = new Date(dateValue);
                    if (isNaN(targetDate)) {
                        alert('è¯·è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„æ—¥æœŸï¼');
                        return;
                    }

                    if (editingMemoryId) {
                        // Edit mode - update existing memory
                        const memory = await db.memories.get(editingMemoryId);
                        if (memory) {
                            memory.description = title;
                            memory.targetDate = targetDate.getTime();
                            await db.memories.put(memory);
                        }
                        editingMemoryId = null;
                        // Reset modal title
                        document.querySelector('#create-countdown-modal .modal-header span').textContent = 'æ–°å»ºçº¦å®š';
                    } else {
                        // Create mode - add new memory
                        const newCountdown = {
                            chatId: null, // ç”¨æˆ·åˆ›å»ºçš„ï¼Œä¸å±äºä»»ä½•ç‰¹å®šAI
                            authorName: 'æˆ‘',
                            description: title,
                            timestamp: Date.now(),
                            type: 'countdown',
                            targetDate: targetDate.getTime()
                        };
                        await db.memories.add(newCountdown);
                    }

                    document.getElementById('create-countdown-modal').classList.remove('visible');
                    renderMemoriesScreen();
                    renderCalendarScreen();
                });

                // ã€å…¨æ–°ã€‘æ·»åŠ ç±»å‹é€‰æ‹©æ¨¡æ€æ¡†äº‹ä»¶ç»‘å®š
                document.getElementById('cancel-add-type-btn').addEventListener('click', () => {
                    document.getElementById('add-memory-type-modal').classList.remove('visible');
                });

                // AI Memory Functions
                function showAiMemoryModal() {
                    // Get all available AIs
                    const availableAis = [];
                    
                    // Add individual chats (non-group)
                    Object.values(state.chats).forEach(chat => {
                        if (!chat.isGroup) {
                            availableAis.push({
                                id: chat.id,
                                name: chat.name,
                                avatar: chat.settings.aiAvatar || defaultAvatar
                            });
                        }
                    });
                    
                    // Generate AI selection list HTML
                    let aiListHtml = '';
                    availableAis.forEach(ai => {
                        aiListHtml += `
                            <div style="display: flex; align-items: center; padding: 10px; border-bottom: 1px solid #eee;">
                                <input type="radio" name="ai-memory-selection" value="${ai.id}" id="ai-memory-${ai.id}" style="margin-right: 10px;">
                                <img src="${ai.avatar}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;">
                                <label for="ai-memory-${ai.id}" style="flex-grow: 1; cursor: pointer;">${ai.name}</label>
                            </div>
                        `;
                    });
                    
                    document.getElementById('ai-memory-selection-list').innerHTML = aiListHtml;
                    document.getElementById('ai-memory-modal').classList.add('visible');
                }
                
                function hideAiMemoryModal() {
                    document.getElementById('ai-memory-modal').classList.remove('visible');
                }
                
                async function confirmAiMemory() {
                    // Check for selected radio button
                    const selectedRadio = document.querySelector('input[name="ai-memory-selection"]:checked');
                    
                    if (!selectedRadio) {
                        alert('è¯·é€‰æ‹©ä¸€ä¸ªAI');
                        return;
                    }
                    
                    const selectedAiId = selectedRadio.value;
                    const selectedChat = state.chats[selectedAiId];
                    
                    if (!selectedChat) {
                        alert('é€‰æ‹©çš„AIä¸å­˜åœ¨');
                        return;
                    }
                    
                    hideAiMemoryModal();
                    
                    // Show processing message
                    const processingMsg = document.createElement('div');
                    processingMsg.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 10px; z-index: 9999; text-align: center;';
                    processingMsg.innerHTML = `<div>ğŸ¤– AIæ­£åœ¨æ€è€ƒè¦è®°å½•ä»€ä¹ˆå›å¿†...</div>`;
                    document.body.appendChild(processingMsg);
                    
                    try {
                        // Set flags for forced memory creation
                        window.forceMemoryCreation = true;
                        window.forceMemoryTargetChatId = selectedAiId;
                        
                        // Set active chat to the selected AI
                        const previousActiveChatId = state.activeChatId;
                        state.activeChatId = selectedAiId;
                        
                        // Trigger AI response with forced memory creation
                        await triggerAiResponse(true);
                        
                        // Restore previous active chat
                        state.activeChatId = previousActiveChatId;
                        
                        // Remove processing message
                        if (processingMsg.parentNode) {
                            document.body.removeChild(processingMsg);
                        }
                        
                        // Show completion notification
                        const completionMsg = document.createElement('div');
                        completionMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: rgba(0,128,0,0.9); color: white; padding: 15px 20px; border-radius: 10px; z-index: 9999; font-size: 14px;';
                        completionMsg.innerHTML = 'âœ… AIå›å¿†åˆ›å»ºå®Œæˆ';
                        document.body.appendChild(completionMsg);
                        
                        // Auto-remove notification after 3 seconds
                        setTimeout(() => {
                            if (completionMsg.parentNode) {
                                document.body.removeChild(completionMsg);
                            }
                        }, 3000);
                        
                    } catch (error) {
                        console.error('AI memory creation error:', error);
                        
                        // Remove processing message
                        if (processingMsg.parentNode) {
                            document.body.removeChild(processingMsg);
                        }
                        
                        // Show error notification
                        const errorMsg = document.createElement('div');
                        errorMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: rgba(255,0,0,0.9); color: white; padding: 15px 20px; border-radius: 10px; z-index: 9999; font-size: 14px;';
                        errorMsg.innerHTML = 'âŒ AIå›å¿†åˆ›å»ºå¤±è´¥';
                        document.body.appendChild(errorMsg);
                        
                        setTimeout(() => {
                            if (errorMsg.parentNode) {
                                document.body.removeChild(errorMsg);
                            }
                        }, 3000);
                    }
                }

                document.getElementById('add-memory-btn').addEventListener('click', () => {
                    document.getElementById('add-memory-type-modal').classList.remove('visible');
                    document.getElementById('create-memory-modal').classList.add('visible');
                    // è®¾ç½®é»˜è®¤æ—¶é—´ä¸ºå½“å‰æ—¶é—´
                    const now = new Date();
                    const localDateTime = new Date(now.getTime() - now.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
                    document.getElementById('memory-date-input').value = localDateTime;
                });

                document.getElementById('add-event-btn').addEventListener('click', () => {
                    document.getElementById('add-memory-type-modal').classList.remove('visible');
                    document.getElementById('create-countdown-modal').classList.add('visible');
                });

                document.getElementById('add-ai-memory-btn').addEventListener('click', () => {
                    document.getElementById('add-memory-type-modal').classList.remove('visible');
                    showAiMemoryModal();
                });

                // ã€å…¨æ–°ã€‘æ·»åŠ å›å¿†æ¨¡æ€æ¡†äº‹ä»¶ç»‘å®š
                document.getElementById('cancel-create-memory-btn').addEventListener('click', () => {
                    document.getElementById('create-memory-modal').classList.remove('visible');
                });

                document.getElementById('confirm-create-memory-btn').addEventListener('click', async () => {
                    const description = document.getElementById('memory-description-input').value.trim();
                    const dateTime = document.getElementById('memory-date-input').value;

                    if (!description) {
                        alert('è¯·è¾“å…¥å›å¿†å†…å®¹');
                        return;
                    }

                    if (!dateTime) {
                        alert('è¯·é€‰æ‹©å›å¿†æ—¥æœŸ');
                        return;
                    }

                    const memoryDate = new Date(dateTime);

                    if (editingMemoryId) {
                        // Edit mode - update existing memory
                        const memory = await db.memories.get(editingMemoryId);
                        if (memory) {
                            memory.description = description;
                            memory.timestamp = memoryDate.getTime();
                            await db.memories.put(memory);
                        }
                        editingMemoryId = null;
                        // Reset modal title
                        document.querySelector('#create-memory-modal .modal-header span').textContent = 'æ–°å»ºå›å¿†';
                    } else {
                        // Create mode - add new memory
                        const newMemory = {
                            chatId: 'manual', // æ‰‹åŠ¨æ·»åŠ çš„å›å¿†
                            authorName: 'æˆ‘', // ç”¨æˆ·æ·»åŠ çš„å›å¿†
                            description: description,
                            timestamp: memoryDate.getTime(),
                            type: 'ai_generated' // ä½¿ç”¨ç›¸åŒç±»å‹ä»¥åœ¨æ—¥å†ä¸­æ˜¾ç¤º
                        };
                        await db.memories.add(newMemory);
                    }

                    document.getElementById('create-memory-modal').classList.remove('visible');

                    // æ¸…ç©ºè¡¨å•
                    document.getElementById('memory-description-input').value = '';
                    document.getElementById('memory-date-input').value = '';

                    renderMemoriesScreen();
                    renderCalendarScreen();
                });

                // ã€å…¨æ–°ã€‘æ‹‰é»‘åŠŸèƒ½äº‹ä»¶ç»‘å®š
                document.getElementById('block-chat-btn').addEventListener('click', async () => {
                    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) return;

                    const chat = state.chats[state.activeChatId];
                    const confirmed = await showCustomConfirm(
                        'ç¡®è®¤æ‹‰é»‘',
                        `ç¡®å®šè¦æ‹‰é»‘â€œ${chat.name}â€å—ï¼Ÿæ‹‰é»‘åæ‚¨å°†æ— æ³•å‘å…¶å‘é€æ¶ˆæ¯ï¼Œç›´åˆ°æ‚¨å°†Taç§»å‡ºé»‘åå•ï¼Œæˆ–ç­‰å¾…Taé‡æ–°ç”³è¯·å¥½å‹ã€‚`,
                        { confirmButtonClass: 'btn-danger' }
                    );

                    if (confirmed) {
                        chat.relationship.status = 'blocked_by_user';
                        chat.relationship.blockedTimestamp = Date.now();
                        await db.chats.put(chat);

                        // å…³é—­è®¾ç½®å¼¹çª—ï¼Œå¹¶åˆ·æ–°èŠå¤©ç•Œé¢
                        document.getElementById('chat-settings-modal').classList.remove('visible');
                        renderChatInterface(state.activeChatId);
                        // åˆ·æ–°èŠå¤©åˆ—è¡¨ï¼Œå¯èƒ½ä¼šæœ‰UIå˜åŒ–
                        renderChatList();
                    }
                });

                document.getElementById('chat-lock-overlay').addEventListener('click', async (e) => {
                    const chat = state.chats[state.activeChatId];
                    if (!chat) return;

                    if (e.target.id === 'force-apply-check-btn') {
                        alert("æ­£åœ¨æ‰‹åŠ¨è§¦å‘å¥½å‹ç”³è¯·æµç¨‹ï¼Œè¯·ç¨å...\nå¦‚æœAPIè°ƒç”¨æˆåŠŸï¼Œå°†å¼¹å‡ºæç¤ºã€‚å¦‚æœå¤±è´¥ï¼Œä¹Ÿä¼šæœ‰é”™è¯¯æç¤ºã€‚å¦‚æœé•¿æ—¶é—´æ— ååº”ï¼Œè¯´æ˜AIå¯èƒ½å†³å®šæš‚æ—¶ä¸ç”³è¯·ã€‚");
                        await triggerAiFriendApplication(chat.id);
                        renderChatInterface(chat.id);
                        return;
                    }

                    if (e.target.id === 'unblock-btn') {
                        chat.relationship.status = 'friend';
                        chat.relationship.blockedTimestamp = null;
                        await db.chats.put(chat);
                        renderChatInterface(chat.id);
                        renderChatList();
                    }
                    else if (e.target.id === 'accept-friend-btn') {
                        chat.relationship.status = 'friend';
                        chat.relationship.applicationReason = '';
                        await db.chats.put(chat);
                        renderChatInterface(chat.id);
                        renderChatList();
                        const msg = { role: 'user', content: 'æˆ‘é€šè¿‡äº†ä½ çš„å¥½å‹è¯·æ±‚', timestamp: Date.now() };
                        chat.history.push(msg);
                        await db.chats.put(chat);
                        appendMessage(msg, chat);
                        triggerAiResponse();
                    }
                    else if (e.target.id === 'reject-friend-btn') {
                        chat.relationship.status = 'blocked_by_user';
                        chat.relationship.blockedTimestamp = Date.now();
                        chat.relationship.applicationReason = '';
                        await db.chats.put(chat);
                        renderChatInterface(chat.id);
                    }
                    // ã€æ–°å¢ã€‘å¤„ç†ç”³è¯·å¥½å‹æŒ‰é’®çš„ç‚¹å‡»äº‹ä»¶
                    else if (e.target.id === 'apply-friend-btn') {
                        const reason = await showCustomPrompt(
                            'å‘é€å¥½å‹ç”³è¯·',
                            `è¯·è¾“å…¥ä½ æƒ³å¯¹â€œ${chat.name}â€è¯´çš„ç”³è¯·ç†ç”±ï¼š`,
                            "æˆ‘ä»¬å’Œå¥½å§ï¼"
                        );
                        // åªæœ‰å½“ç”¨æˆ·è¾“å…¥äº†å†…å®¹å¹¶ç‚¹å‡»â€œç¡®å®šâ€åæ‰ç»§ç»­
                        if (reason !== null) {
                            // æ›´æ–°å…³ç³»çŠ¶æ€ä¸ºâ€œç­‰å¾…AIæ‰¹å‡†â€
                            chat.relationship.status = 'pending_ai_approval';
                            chat.relationship.applicationReason = reason;
                            await db.chats.put(chat);

                            // åˆ·æ–°UIï¼Œæ˜¾ç¤ºâ€œç­‰å¾…é€šè¿‡â€çš„ç•Œé¢
                            renderChatInterface(chat.id);
                            renderChatList();

                            // ã€å…³é”®ã€‘è§¦å‘AIå“åº”ï¼Œè®©å®ƒå»å¤„ç†è¿™ä¸ªå¥½å‹ç”³è¯·
                            triggerAiResponse();
                        }
                    }
                });

                // â–¼â–¼â–¼ ã€å…¨æ–°ã€‘çº¢åŒ…åŠŸèƒ½äº‹ä»¶ç»‘å®š â–¼â–¼â–¼

                // 1. å°†åŸæœ‰çš„è½¬è´¦æŒ‰é’®(ï¿¥)çš„ç‚¹å‡»äº‹ä»¶ï¼Œé‡å®šå‘åˆ°æ–°çš„æ€»å…¥å£å‡½æ•°
                document.getElementById('transfer-btn').addEventListener('click', handlePaymentButtonClick);

                // 2. çº¢åŒ…æ¨¡æ€æ¡†å†…éƒ¨çš„æ§åˆ¶æŒ‰é’®
                document.getElementById('cancel-red-packet-btn').addEventListener('click', () => {
                    document.getElementById('red-packet-modal').classList.remove('visible');
                });
                document.getElementById('send-group-packet-btn').addEventListener('click', sendGroupRedPacket);
                document.getElementById('send-direct-packet-btn').addEventListener('click', sendDirectRedPacket);

                // 3. çº¢åŒ…æ¨¡æ€æ¡†çš„é¡µç­¾åˆ‡æ¢é€»è¾‘
                const rpTabGroup = document.getElementById('rp-tab-group');
                const rpTabDirect = document.getElementById('rp-tab-direct');
                const rpContentGroup = document.getElementById('rp-content-group');
                const rpContentDirect = document.getElementById('rp-content-direct');

                rpTabGroup.addEventListener('click', () => {
                    rpTabGroup.classList.add('active');
                    rpTabDirect.classList.remove('active');
                    rpContentGroup.style.display = 'block';
                    rpContentDirect.style.display = 'none';
                });
                rpTabDirect.addEventListener('click', () => {
                    rpTabDirect.classList.add('active');
                    rpTabGroup.classList.remove('active');
                    rpContentDirect.style.display = 'block';
                    rpContentGroup.style.display = 'none';
                });

                // 4. å®æ—¶æ›´æ–°çº¢åŒ…é‡‘é¢æ˜¾ç¤º
                document.getElementById('rp-group-amount').addEventListener('input', (e) => {
                    const amount = parseFloat(e.target.value) || 0;
                    document.getElementById('rp-group-total').textContent = `Â¥ ${amount.toFixed(2)}`;
                });
                document.getElementById('rp-direct-amount').addEventListener('input', (e) => {
                    const amount = parseFloat(e.target.value) || 0;
                    document.getElementById('rp-direct-total').textContent = `Â¥ ${amount.toFixed(2)}`;
                });

                // â–²â–²â–² æ–°äº‹ä»¶ç»‘å®šç»“æŸ â–²â–²â–²

                // â–¼â–¼â–¼ ã€å…¨æ–°æ·»åŠ ã€‘ä½¿ç”¨äº‹ä»¶å§”æ‰˜å¤„ç†çº¢åŒ…ç‚¹å‡»ï¼Œä¿®å¤å¤±æ•ˆé—®é¢˜ â–¼â–¼â–¼
                document.getElementById('chat-messages').addEventListener('click', (e) => {
                    // 1. æ‰¾åˆ°è¢«ç‚¹å‡»çš„çº¢åŒ…å¡ç‰‡
                    const packetCard = e.target.closest('.red-packet-card');
                    if (!packetCard) return; // å¦‚æœç‚¹å‡»çš„ä¸æ˜¯çº¢åŒ…ï¼Œå°±ä»€ä¹ˆä¹Ÿä¸åš

                    // 2. ä»çº¢åŒ…å¡ç‰‡çš„çˆ¶çº§.message-bubbleè·å–æ—¶é—´æˆ³
                    const messageBubble = packetCard.closest('.message-bubble');
                    if (!messageBubble || !messageBubble.dataset.timestamp) return;

                    // 3. è°ƒç”¨æˆ‘ä»¬ç°æœ‰çš„å¤„ç†å‡½æ•°
                    const timestamp = parseInt(messageBubble.dataset.timestamp);
                    handlePacketClick(timestamp);
                });
                // â–²â–²â–² æ–°å¢ä»£ç ç»“æŸ â–²â–²â–²

                // â–¼â–¼â–¼ ã€å…¨æ–°ã€‘æŠ•ç¥¨åŠŸèƒ½äº‹ä»¶ç›‘å¬å™¨ â–¼â–¼â–¼
                // åœ¨è¾“å…¥æ¡†å·¥å…·æ æ·»åŠ æŒ‰é’®
                document.getElementById('send-poll-btn').addEventListener('click', openCreatePollModal);

                // æŠ•ç¥¨åˆ›å»ºæ¨¡æ€æ¡†çš„æŒ‰é’®
                document.getElementById('add-poll-option-btn').addEventListener('click', addPollOptionInput);
                document.getElementById('cancel-create-poll-btn').addEventListener('click', () => {
                    document.getElementById('create-poll-modal').classList.remove('visible');
                });
                document.getElementById('confirm-create-poll-btn').addEventListener('click', sendPoll);

                // ä½¿ç”¨äº‹ä»¶å§”æ‰˜å¤„ç†æŠ•ç¥¨å¡ç‰‡å†…çš„æ‰€æœ‰ç‚¹å‡»äº‹ä»¶
                document.getElementById('chat-messages').addEventListener('click', (e) => {
                    const pollCard = e.target.closest('.poll-card');
                    if (!pollCard) return;

                    const timestamp = parseInt(pollCard.dataset.pollTimestamp);
                    if (isNaN(timestamp)) return;

                    // ç‚¹å‡»äº†é€‰é¡¹
                    const optionItem = e.target.closest('.poll-option-item');
                    if (optionItem && !pollCard.classList.contains('closed')) {
                        handleUserVote(timestamp, optionItem.dataset.option);
                        return;
                    }

                    // ç‚¹å‡»äº†åŠ¨ä½œæŒ‰é’®ï¼ˆç»“æŸæŠ•ç¥¨/æŸ¥çœ‹ç»“æœï¼‰
                    const actionBtn = e.target.closest('.poll-action-btn');
                    if (actionBtn) {
                        if (pollCard.classList.contains('closed')) {
                            showPollResults(timestamp);
                        } else {
                            endPoll(timestamp);
                        }
                        return;
                    }

                    // å¦‚æœæ˜¯å·²ç»“æŸçš„æŠ•ç¥¨ï¼Œç‚¹å‡»å¡ç‰‡ä»»ä½•åœ°æ–¹éƒ½å¯ä»¥æŸ¥çœ‹ç»“æœ
                    if (pollCard.classList.contains('closed')) {
                        showPollResults(timestamp);
                    }
                });
            }


            function openChat(chatId) {
                state.activeChatId = chatId;
                const chat = state.chats[chatId];
                if (!chat) return;
                if (chat.status === 'unread') {
                    chat.status = 'read';
                    db.chats.put(chat);
                }
                renderChatInterface(chatId);
                showScreen('chat-interface-screen');
                window.updateListenTogetherIconProxy(state.activeChatId);
                toggleCallButtons(chat.isGroup || false);
                // ã€æ ¸å¿ƒæ–°å¢ã€‘æ‰“å¼€èŠå¤©æ—¶ï¼Œç«‹å³æ›´æ–°çŠ¶æ€å¹¶å¯åŠ¨è®¡æ—¶å™¨
                updateChatHeaderStatus(chat);
                manageInactivityTimer(chat);
                if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                    console.log(`æ£€æµ‹åˆ°å¥½å‹ç”³è¯·å¾…å¤„ç†çŠ¶æ€ï¼Œä¸ºè§’è‰² "${chat.name}" è‡ªåŠ¨è§¦å‘AIå“åº”...`);
                    triggerAiResponse();
                }

                document.getElementById('send-poll-btn').style.display = chat.isGroup ? 'flex' : 'none';
                document.getElementById('open-bulletin-board-btn').style.display = chat.isGroup ? 'flex' : 'none';

            }
            // ==========================================================
            // --- äº‘ç«¯å¤‡ä»½ä¸æ¢å¤ (V2 - ç‰ˆæœ¬é€‰æ‹©) ---
            // ==========================================================

            /**
             * ã€V2ç‰ˆã€‘å¤‡ä»½æ•°æ®åˆ°æœåŠ¡å™¨ï¼Œå¹¶æ ‡è®°å¤‡ä»½ç±»å‹
             * @param {('manual'|'auto')} backupType - å¤‡ä»½çš„ç±»å‹
             * @param {boolean} showAlert - æ˜¯å¦æ˜¾ç¤ºæˆåŠŸ/å¤±è´¥å¼¹çª—
             */
            async function backupDataToServer(backupType = 'auto', showAlert = false) {
                console.log(`[äº‘åŒæ­¥V2] å¼€å§‹å¤‡ä»½ï¼Œç±»å‹: ${backupType}`);
                try {
                    const tablesToBackup = [
                        'chats', 'apiConfig', 'globalSettings', 'userStickers',
                        'worldBooks', 'musicLibrary', 'personaPresets',
                        'qzoneSettings', 'qzonePosts', 'qzoneAlbums', 'qzonePhotos',
                        'favorites', 'qzoneGroups', 'memories'
                    ];
                    const data = {};
                    const existingTables = tablesToBackup.filter(tableName => db.table(tableName));

                    await db.transaction('r', existingTables, async () => {
                        for (const table of existingTables) {
                            const tableData = await db.table(table).toArray();
                            if (tableData) {
                                data[table] = tableData;
                            }
                        }
                    });

                    // å¢åŠ ä¸€ä¸ªè®¾å¤‡IDå…ƒæ•°æ®
                    let deviceId = localStorage.getItem('ephone-device-id');
                    if (!deviceId) {
                        deviceId = `device_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
                        localStorage.setItem('ephone-device-id', deviceId);
                    }

                    const backupPayload = {
                        metadata: {
                            timestamp: Date.now(),
                            sourceDeviceId: deviceId,
                            type: backupType
                        },
                        data: data
                    };

                    const response = await fetch(`/api/data?type=${backupType}`, { // åœ¨URLä¸­ä¼ é€’ç±»å‹
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(backupPayload)
                    });

                    if (!response.ok) {
                        throw new Error(`æœåŠ¡å™¨è¿”å›é”™è¯¯: ${response.status} ${response.statusText}`);
                    }

                    console.log(`[äº‘åŒæ­¥V2] ${backupType} å¤‡ä»½æˆåŠŸ!`);
                    if (showAlert) {
                        showCustomAlert('â˜ï¸ æ‰‹åŠ¨å¤‡ä»½æˆåŠŸ', 'æ‚¨çš„æ•°æ®å·²å®‰å…¨ä¿å­˜åˆ°äº‘ç«¯ã€‚');
                    }
                } catch (err) {
                    console.error(`[äº‘åŒæ­¥V2] ${backupType} å¤‡ä»½å¤±è´¥:`, err);
                    if (showAlert) {
                        showCustomAlert('âŒ äº‘ç«¯å¤‡ä»½å¤±è´¥', err.message || 'æœªçŸ¥é”™è¯¯');
                    }
                }
            }

            /**
             * ã€V2ç‰ˆã€‘ä»æœåŠ¡å™¨æ¢å¤æŒ‡å®šçš„å¤‡ä»½ç‰ˆæœ¬
             * @param {('manual'|'auto')} backupType - è¦æ¢å¤çš„å¤‡ä»½ç±»å‹
             */
            async function restoreDataFromServer(backupType) {
                try {
                    const confirmed = await showCustomConfirm(
                        'ä¸¥é‡è­¦å‘Šï¼',
                        `å³å°†ä»äº‘ç«¯æ¢å¤ã€${backupType === 'manual' ? 'æ‰‹åŠ¨' : 'è‡ªåŠ¨'}ã€‘å¤‡ä»½ã€‚<br><br>æ­¤æ“ä½œå°†å®Œå…¨è¦†ç›–æ‚¨å½“å‰è®¾å¤‡ä¸Šçš„æ‰€æœ‰æ•°æ®ï¼Œä¸”ä¸å¯æ’¤é”€ï¼`,
                        { confirmButtonClass: 'btn-danger' }
                    );
                    if (!confirmed) return;

                    const res = await fetch(`/api/data?type=${backupType}`); // ä»æŒ‡å®šURLè·å–
                    if (!res.ok) {
                        if (res.status === 404) {
                            showCustomAlert('æ¢å¤å¤±è´¥', `æœªåœ¨äº‘ç«¯æ‰¾åˆ°ã€${backupType === 'manual' ? 'æ‰‹åŠ¨' : 'è‡ªåŠ¨'}ã€‘å¤‡ä»½æ–‡ä»¶ã€‚`);
                            return;
                        }
                        throw new Error(`æœåŠ¡å™¨å“åº”é”™è¯¯: ${res.status} ${res.statusText}`);
                    }

                    const backupPayload = await res.json();
                    const data = backupPayload.data;

                    if (!data || typeof data !== 'object' || Object.keys(data).length === 0) {
                        showCustomAlert('æ¢å¤ä¸­æ­¢', 'äº‘ç«¯å¤‡ä»½æ•°æ®ä¸ºç©ºæˆ–æ ¼å¼ä¸æ­£ç¡®ã€‚');
                        return;
                    }

                    const tablesToRestore = Object.keys(data);
                    const existingTables = tablesToRestore.filter(tableName => db.table(tableName));

                    await db.transaction('rw', existingTables, async () => {
                        for (const table of existingTables) {
                            await db.table(table).clear();
                            if (data[table] && Array.isArray(data[table])) {
                                await db.table(table).bulkPut(data[table]);
                            }
                        }
                    });

                    await showCustomAlert('â˜ï¸ äº‘ç«¯æ¢å¤æˆåŠŸ', 'æ•°æ®å·²ä»æœåŠ¡å™¨è¿˜åŸï¼Œåº”ç”¨å³å°†åˆ·æ–°ã€‚');
                    setTimeout(() => location.reload(), 1500);
                } catch (err) {
                    console.error(`[äº‘åŒæ­¥V2] æ¢å¤ ${backupType} å¤‡ä»½å¤±è´¥:`, err);
                    showCustomAlert('âŒ äº‘ç«¯æ¢å¤å¤±è´¥', err.message || 'æœªçŸ¥é”™è¯¯');
                }
            }


            /**
             * ã€å…¨æ–°ã€‘æ‰“å¼€å¹¶æ¸²æŸ“å¤‡ä»½ç‰ˆæœ¬é€‰æ‹©æ¨¡æ€æ¡†
             */
            async function openRestoreVersionSelector() {
                const modal = document.getElementById('restore-version-modal');
                const listEl = document.getElementById('restore-version-list');

                modal.classList.add('visible');
                listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">æ­£åœ¨ä»äº‘ç«¯è·å–å¤‡ä»½ä¿¡æ¯...</p>';

                try {
                    const response = await fetch('/api/data/list');
                    if (!response.ok) {
                        throw new Error(`è·å–å¤‡ä»½åˆ—è¡¨å¤±è´¥: ${response.status}`);
                    }
                    const versions = await response.json();
                    listEl.innerHTML = ''; // æ¸…ç©ºåŠ è½½æç¤º

                    const createCard = (type, info) => {
                        const card = document.createElement('div');
                        card.className = 'list-item'; // å¤ç”¨ç°æœ‰çš„åˆ—è¡¨é¡¹æ ·å¼
                        card.style.cursor = 'pointer';

                        const typeText = type === 'manual' ? 'æ‰‹åŠ¨å¤‡ä»½' : 'è‡ªåŠ¨å¤‡ä»½';
                        const date = new Date(info.timestamp);
                        const dateString = date.toLocaleString('zh-CN', {
                            year: 'numeric', month: '2-digit', day: '2-digit',
                            hour: '2-digit', minute: '2-digit'
                        });
                        const sizeString = (info.size / 1024).toFixed(1) + ' KB';
                        const deviceId = info.sourceDeviceId ? info.sourceDeviceId.substring(0, 15) + '...' : 'æœªçŸ¥è®¾å¤‡';

                        card.innerHTML = `
                <div class="item-title" style="display:flex; justify-content:space-between;">
                    <span>â˜ï¸ ${typeText}</span>
                    <span style="font-weight:normal; font-size:14px; color:var(--text-secondary);">${sizeString}</span>
                </div>
                <div class="item-content">
                    å¤‡ä»½äº ${dateString}<br>
                    æ¥è‡ªè®¾å¤‡: ${deviceId}
                </div>
            `;
                        card.addEventListener('click', () => {
                            modal.classList.remove('visible');
                            restoreDataFromServer(type);
                        });
                        return card;
                    };

                    if (versions.manual && versions.manual.timestamp) {
                        listEl.appendChild(createCard('manual', versions.manual));
                    }
                    if (versions.auto && versions.auto.timestamp) {
                        listEl.appendChild(createCard('auto', versions.auto));
                    }

                    if ((!versions.manual || !versions.manual.timestamp) && (!versions.auto || !versions.auto.timestamp)) {
                        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">äº‘ç«¯æ²¡æœ‰ä»»ä½•å¤‡ä»½æ–‡ä»¶ã€‚</p>';
                    }

                } catch (err) {
                    listEl.innerHTML = `<p style="text-align:center; color: #ff3b30;">è·å–å¤‡ä»½ä¿¡æ¯å¤±è´¥: ${err.message}</p>`;
                }
            }


            /**
             * æ™ºèƒ½èŠ‚æµå¤‡ä»½ï¼ˆ15ç§’æ— æ“ä½œåè‡ªåŠ¨ä¿å­˜ï¼‰
             */
            let backupTimer = null;
            function markForBackup() {
                if (backupTimer) clearTimeout(backupTimer);
                backupTimer = setTimeout(() => {
                    // è‡ªåŠ¨å¤‡ä»½æ€»æ˜¯è°ƒç”¨ 'auto' ç±»å‹
                    backupDataToServer('auto', false)
                        .catch(e => console.warn('[äº‘åŒæ­¥V2] è‡ªåŠ¨å¤‡ä»½å¤±è´¥:', e));
                }, 15000);
            }

            // --- äº‹ä»¶ç»‘å®š ---
            // æ‰‹åŠ¨å¤‡ä»½æŒ‰é’®
            document.getElementById('cloud-backup-manual-btn').addEventListener('click', () => backupDataToServer('manual', true));

            // ä»äº‘ç«¯æ¢å¤æŒ‰é’®ï¼ˆæ‰“å¼€é€‰æ‹©å™¨ï¼‰
            document.getElementById('cloud-restore-select-btn').addEventListener('click', openRestoreVersionSelector);

            // å¤‡ä»½ç‰ˆæœ¬é€‰æ‹©å¼¹çª—çš„å–æ¶ˆæŒ‰é’®
            document.getElementById('cancel-restore-version-btn').addEventListener('click', () => {
                document.getElementById('restore-version-modal').classList.remove('visible');
            });

            // å¯åŠ¨è‡ªåŠ¨å¤‡ä»½çš„ç›‘å¬ - DISABLED FOR DEVELOPMENT
            // ['input', 'change', 'click'].forEach(event => {
            //     document.addEventListener(event, markForBackup, { passive: true });
            // });

            // ===================================================================
            // 5. å¯åŠ¨ï¼
            // ===================================================================
            showScreen('home-screen');
            init();

            // Enable background mode to prevent database connection issues
            document.addEventListener('deviceready', function () {
                if (window.cordova && cordova.plugins && cordova.plugins.backgroundMode) {
                    cordova.plugins.backgroundMode.enable();
                    console.log('Background mode enabled to maintain database connections');
                }
            }, false);
        });
    </script>

    <script>
        // Floating Phone Charm Functionality
        class FloatingPhoneCharm {
            constructor() {
                this.charm = document.getElementById('floating-phone-charm');
                this.isDragging = false;
                this.longPressTimer = null;
                this.longPressDelay = 1000; // 1000ms for long press
                this.dragStartX = 0;
                this.dragStartY = 0;
                this.charmStartX = 0;
                this.charmStartY = 0;
                this.originalPosition = null; // Store original position for bounce back

                this.init();
            }

            init() {
                // Load saved position
                this.loadPosition();

                // Store original position after loading
                this.storeOriginalPosition();

                // Add event listeners
                this.charm.addEventListener('touchstart', this.handleStart.bind(this), { passive: false });
                document.addEventListener('touchmove', this.handleMove.bind(this), { passive: false });
                document.addEventListener('touchend', this.handleEnd.bind(this), { passive: false });

                // Mouse events for desktop testing
                this.charm.addEventListener('mousedown', this.handleStart.bind(this));
                document.addEventListener('mousemove', this.handleMove.bind(this));
                document.addEventListener('mouseup', this.handleEnd.bind(this));

                // Prevent context menu
                this.charm.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            storeOriginalPosition() {
                const rect = this.charm.getBoundingClientRect();
                this.originalPosition = {
                    left: rect.left,
                    top: rect.top
                };
            }

            handleStart(e) {
                e.preventDefault();

                const touch = e.touches ? e.touches[0] : e;
                this.dragStartX = touch.clientX;
                this.dragStartY = touch.clientY;

                // Get charm's current position
                const rect = this.charm.getBoundingClientRect();
                this.charmStartX = rect.left;
                this.charmStartY = rect.top;

                // Start long press timer
                this.longPressTimer = setTimeout(() => {
                    this.startDrag();
                }, this.longPressDelay);
            }

            handleMove(e) {
                if (!this.isDragging) {
                    // Cancel long press if moved too much before long press completes
                    const touch = e.touches ? e.touches[0] : e;
                    const deltaX = Math.abs(touch.clientX - this.dragStartX);
                    const deltaY = Math.abs(touch.clientY - this.dragStartY);

                    if (deltaX > 10 || deltaY > 10) {
                        clearTimeout(this.longPressTimer);
                    }
                    return;
                }

                e.preventDefault();
                const touch = e.touches ? e.touches[0] : e;

                // Calculate how much the finger has moved from the start
                const deltaX = touch.clientX - this.dragStartX;
                const deltaY = touch.clientY - this.dragStartY;

                // Update charm position relative to where it started
                const newLeft = this.charmStartX + deltaX;
                const newTop = this.charmStartY + deltaY;

                this.charm.style.left = newLeft + 'px';
                this.charm.style.top = newTop + 'px';
                this.charm.style.right = 'auto';
                this.charm.style.bottom = 'auto';
            }

            handleEnd(e) {
                clearTimeout(this.longPressTimer);

                if (this.isDragging) {
                    this.endDrag();
                }
            }

            startDrag() {
                this.isDragging = true;
                this.charm.classList.add('dragging');

                // Add visual feedback
                if (navigator.vibrate) {
                    navigator.vibrate(50); // Haptic feedback
                }
            }

            endDrag() {
                this.isDragging = false;
                this.charm.classList.remove('dragging');

                // Check if charm is off-screen and bounce back if needed
                if (this.isOffScreen()) {
                    this.bounceBack();
                } else {
                    // Save current position if it's valid
                    this.savePosition();
                    this.storeOriginalPosition(); // Update original position
                }
            }

            isOffScreen() {
                const rect = this.charm.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const minVisible = 50; // Minimum pixels that should remain visible

                return (
                    rect.right < minVisible || // Too far left
                    rect.left > viewportWidth - minVisible || // Too far right
                    rect.bottom < minVisible || // Too far up
                    rect.top > viewportHeight - minVisible // Too far down
                );
            }

            bounceBack() {
                // Add bounce animation
                this.charm.style.transition = 'all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55)';

                // Return to original position
                this.charm.style.left = this.originalPosition.left + 'px';
                this.charm.style.top = this.originalPosition.top + 'px';

                // Remove transition after animation
                setTimeout(() => {
                    this.charm.style.transition = 'transform 0.2s ease';
                }, 300);
            }

            savePosition() {
                const rect = this.charm.getBoundingClientRect();
                const position = {
                    left: rect.left,
                    top: rect.top
                };
                localStorage.setItem('phoneCharmPosition', JSON.stringify(position));
            }

            loadPosition() {
                const saved = localStorage.getItem('phoneCharmPosition');
                if (saved) {
                    try {
                        const position = JSON.parse(saved);
                        this.charm.style.left = position.left + 'px';
                        this.charm.style.top = position.top + 'px';
                        this.charm.style.right = 'auto';
                        this.charm.style.bottom = 'auto';
                    } catch (e) {
                        console.log('Failed to load charm position:', e);
                    }
                }
            }
        }

        // Initialize floating charm when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            window.floatingCharmInstance = new FloatingPhoneCharm();

            // Initialize charm visibility from localStorage
            const savedVisibility = localStorage.getItem('charmVisibility');
            const isVisible = savedVisibility !== 'false'; // Default to true

            // Check if function exists before calling
            if (typeof window.toggleCharmVisibility === 'function') {
                window.toggleCharmVisibility(isVisible);
            } else {
                console.error('DEBUG - toggleCharmVisibility function not found');
            }
        });

        // Load QZone settings on app start
        document.addEventListener('DOMContentLoaded', async function () {
            try {
                const qzoneSettings = await db.qzoneSettings.get('main');
                if (qzoneSettings) {
                    // Load nickname
                    if (qzoneSettings.nickname) {
                        const nicknameElement = document.getElementById('qzone-nickname');
                        if (nicknameElement) {
                            nicknameElement.textContent = qzoneSettings.nickname;
                        }
                    }

                    // Load status
                    if (qzoneSettings.status) {
                        const statusElement = document.getElementById('qzone-status');
                        if (statusElement) {
                            statusElement.textContent = qzoneSettings.status;
                        }
                    }
                }
            } catch (error) {
                console.error('Failed to load QZone settings:', error);
            }
        });
    </script>

    <!-- PWA Service Worker Registration -->
    <script>
        // Service Worker Registration (required for PWA)
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then((registration) => {
                        console.log('PWA: Service Worker registered successfully');
                    })
                    .catch((error) => {
                        console.error('PWA: Service Worker registration failed', error);
                    });
            });
        }
    </script>
</body>

</html>